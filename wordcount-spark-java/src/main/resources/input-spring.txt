1
00:00:00,719 --> 00:00:03,886
(light, upbeat music)

2
00:00:10,287 --> 00:00:11,770
- [Voiceover] Hello there and welcome to

3
00:00:11,770 --> 00:00:15,588
this Spring Framework
Fundamentals training course.

4
00:00:15,588 --> 00:00:17,519
I'm Richard Chesterwood.

5
00:00:17,519 --> 00:00:20,100
I'm a programmer from
the U.K., working for

6
00:00:20,100 --> 00:00:22,841
the Virtual Pair Programmers.

7
00:00:22,841 --> 00:00:25,956
In this opening chapter, I'll run through

8
00:00:25,956 --> 00:00:28,676
how the course works, and then I'll give a

9
00:00:28,676 --> 00:00:32,356
brief overview of Java EE and where Spring

10
00:00:32,356 --> 00:00:34,189
fits into all of this.

11
00:00:35,098 --> 00:00:37,434
This is the second edition of our

12
00:00:37,434 --> 00:00:40,218
Spring Framework course.

13
00:00:40,218 --> 00:00:44,224
The first edition was
written way back in 2009,

14
00:00:44,224 --> 00:00:47,190
and it was enormously successful.

15
00:00:47,190 --> 00:00:49,974
It helped developers all over the world

16
00:00:49,974 --> 00:00:53,451
get started with professional
Spring programming,

17
00:00:53,451 --> 00:00:57,110
and I hope this second edition
can do the same for you.

18
00:00:57,110 --> 00:00:59,158
We've released the second
edition to bring the

19
00:00:59,158 --> 00:01:03,606
course up to date with new
developments in Spring.

20
00:01:03,606 --> 00:01:06,552
But actually, one of the
great features of Spring is

21
00:01:06,552 --> 00:01:11,412
that over time, the fundamentals
don't change very much.

22
00:01:11,412 --> 00:01:14,079
It's quite a stable framework.

23
00:01:14,079 --> 00:01:15,818
And that's a good thing.

24
00:01:15,818 --> 00:01:17,877
On this course, we're
going to take you through

25
00:01:17,877 --> 00:01:20,170
all of the fundamental features of

26
00:01:20,170 --> 00:01:22,143
the Spring Framework.

27
00:01:22,143 --> 00:01:25,407
We will be looking at
dependency injection,

28
00:01:25,407 --> 00:01:29,240
how to wire applications,
and what that means.

29
00:01:31,198 --> 00:01:34,920
We'll see how to access a database.

30
00:01:34,920 --> 00:01:38,420
We'll also use Hybernate, JPA and MyBatis.

31
00:01:40,923 --> 00:01:44,009
We'll look at
aspects-oriented programming,

32
00:01:44,009 --> 00:01:46,759
and why Spring uses this feature.

33
00:01:47,945 --> 00:01:49,876
We'll also look at how to manage

34
00:01:49,876 --> 00:01:52,766
transactions in your application,

35
00:01:52,766 --> 00:01:55,599
and how to do integration testing.

36
00:01:56,543 --> 00:01:58,633
A new feature of this second edition

37
00:01:58,633 --> 00:02:01,883
is how to use annotations to do wiring.

38
00:02:03,041 --> 00:02:06,132
Now, this a controversial
feature of Spring

39
00:02:06,132 --> 00:02:09,390
that was added back in version 2.5,

40
00:02:09,390 --> 00:02:12,688
but has only become
popular since we recorded

41
00:02:12,688 --> 00:02:16,613
the last edition, so we'll
have a good look at that.

42
00:02:16,613 --> 00:02:18,501
The pattern of this
course is that you'll be

43
00:02:18,501 --> 00:02:22,544
listening to informal
sessions where I describe

44
00:02:22,544 --> 00:02:25,903
some fundamental concepts
about Spring using the

45
00:02:25,903 --> 00:02:29,093
combination of explanations,
which I'll try to

46
00:02:29,093 --> 00:02:32,261
keep as clear as possible,
but for most of the

47
00:02:32,261 --> 00:02:34,594
time, we'll be writing code.

48
00:02:35,973 --> 00:02:38,459
We've tried to make this
as close as possible

49
00:02:38,459 --> 00:02:42,235
to Virtual Pair Programming as we can.

50
00:02:42,235 --> 00:02:44,549
I want you to feel as
though you're sitting

51
00:02:44,549 --> 00:02:49,104
alongside a developer and
you're working together.

52
00:02:49,104 --> 00:02:52,315
We're going to be working
on two separate systems.

53
00:02:52,315 --> 00:02:56,293
I'm going to use this
bookstore application as

54
00:02:56,293 --> 00:03:00,944
a very basic example, just
to describe the concepts.

55
00:03:00,944 --> 00:03:03,877
When I'm working on the
bookstore, you have a choice.

56
00:03:03,877 --> 00:03:06,661
You can either follow along with me,

57
00:03:06,661 --> 00:03:08,953
I'll be providing you an exact copy

58
00:03:08,953 --> 00:03:11,446
of the code that I have on the video,

59
00:03:11,446 --> 00:03:14,454
or if you prefer, you can sit back and

60
00:03:14,454 --> 00:03:17,287
listen and enjoy the explanations.

61
00:03:18,826 --> 00:03:19,754
Books.

62
00:03:19,754 --> 00:03:23,395
There are going to be
regular, practical sessions

63
00:03:23,395 --> 00:03:26,395
where you build your own system.

64
00:03:26,395 --> 00:03:27,781
There's going to be eight sessions

65
00:03:27,781 --> 00:03:29,467
through the course, and these aren't

66
00:03:29,467 --> 00:03:31,334
going to be quick exercises.

67
00:03:31,334 --> 00:03:34,950
These will be proper
programming challenges.

68
00:03:34,950 --> 00:03:37,446
You will be writing
for yourself production

69
00:03:37,446 --> 00:03:41,126
quality code or as close
as we can get to it.

70
00:03:41,126 --> 00:03:44,742
And you'll be working almost from scratch.

71
00:03:44,742 --> 00:03:48,848
If you need help, we
provide full work solutions

72
00:03:48,848 --> 00:03:51,814
in the form of pre-prepared
code and we also

73
00:03:51,814 --> 00:03:54,131
have video demonstrations.

74
00:03:54,131 --> 00:03:57,534
So, you can't go far
wrong, but if you hit a

75
00:03:57,534 --> 00:04:00,520
problem that you're completely stuck with,

76
00:04:00,520 --> 00:04:03,134
then we have a support
system where one of our

77
00:04:03,134 --> 00:04:07,443
support team will help
you to get going again.

78
00:04:07,443 --> 00:04:09,459
We can't promise to be quick.

79
00:04:09,459 --> 00:04:12,990
We usually answer within
one or two business days,

80
00:04:12,990 --> 00:04:16,542
but we will help you get started again.

81
00:04:16,542 --> 00:04:19,571
When you finish, the
code will be, of course,

82
00:04:19,571 --> 00:04:22,238
yours to keep, and you'll
be able to extend it

83
00:04:22,238 --> 00:04:23,905
as much as you want.

84
00:04:25,621 --> 00:04:28,842
The only prerequisite,
or the previous knowledge

85
00:04:28,842 --> 00:04:31,146
that you need for this course is a

86
00:04:31,146 --> 00:04:35,615
reasonable, working
knowledge of standard Java.

87
00:04:35,615 --> 00:04:38,400
You'll need to be able
to write classes, and

88
00:04:38,400 --> 00:04:41,587
to create objects and
you'll also need to know

89
00:04:41,587 --> 00:04:43,254
what interfaces are.

90
00:04:44,232 --> 00:04:47,112
If you're quite new to
this, then you might

91
00:04:47,112 --> 00:04:50,045
find that this course is a great way of

92
00:04:50,045 --> 00:04:53,128
practicing the fundamentals,
but if you need

93
00:04:53,128 --> 00:04:55,016
help with any of this, then we have the

94
00:04:55,016 --> 00:04:58,429
Java Fundamentals course that will set you

95
00:04:58,429 --> 00:05:00,628
up well for this course.

96
00:05:00,628 --> 00:05:03,572
But apart from that, you'll be fine.

97
00:05:03,572 --> 00:05:06,078
Occasionally, I'll be
using some very simple

98
00:05:06,078 --> 00:05:10,100
UML, that's the Unified
Modeling Language, but

99
00:05:10,100 --> 00:05:13,897
really nothing more than
what you can see here.

100
00:05:13,897 --> 00:05:17,183
Boxes representing classes and lists

101
00:05:17,183 --> 00:05:19,337
of methods inside.

102
00:05:19,337 --> 00:05:21,449
Apart from a few of the
minor symbols, which

103
00:05:21,449 --> 00:05:23,849
I'll explain along the
way, that's about as

104
00:05:23,849 --> 00:05:25,940
complex as I get.

105
00:05:25,940 --> 00:05:29,844
For the course videos, I'm
going to be using Eclipse.

106
00:05:29,844 --> 00:05:32,265
Now, you can, technically, use any

107
00:05:32,265 --> 00:05:35,369
development environment
that you prefer, because

108
00:05:35,369 --> 00:05:38,399
we are only going to be
using a collection of

109
00:05:38,399 --> 00:05:40,652
jav files for Spring.

110
00:05:40,652 --> 00:05:44,214
However, I strongly recommend that you use

111
00:05:44,214 --> 00:05:47,094
Eclipse when you're working on the course,

112
00:05:47,094 --> 00:05:49,964
so that your screen matches what's on

113
00:05:49,964 --> 00:05:52,097
my video screen.

114
00:05:52,097 --> 00:05:55,474
That will make it far
easier to support you

115
00:05:55,474 --> 00:05:58,039
if you run into problems.

116
00:05:58,039 --> 00:05:59,884
You can always download Eclipse from

117
00:05:59,884 --> 00:06:03,159
Eclipse.org/downloads, and then when

118
00:06:03,159 --> 00:06:04,802
you've finished the course, you could

119
00:06:04,802 --> 00:06:07,095
move to a different
development environment,

120
00:06:07,095 --> 00:06:08,802
if you prefer.

121
00:06:08,802 --> 00:06:11,095
You can use any of the standard,

122
00:06:11,095 --> 00:06:13,676
or IDE for Java EE developers or the

123
00:06:13,676 --> 00:06:15,650
IDE for Java developers.

124
00:06:15,650 --> 00:06:17,582
It doesn't really matter.

125
00:06:17,582 --> 00:06:18,999
I think I'd probably recommend the

126
00:06:18,999 --> 00:06:22,167
IDE for Java developers if I had

127
00:06:22,167 --> 00:06:23,938
to select one.

128
00:06:23,938 --> 00:06:26,583
Now, we supply this course with a complete

129
00:06:26,583 --> 00:06:29,847
set of all the software
that you're going to need,

130
00:06:29,847 --> 00:06:33,164
apart from the development's
environment itself.

131
00:06:33,164 --> 00:06:36,674
So, if you've bought the course on a DVD,

132
00:06:36,674 --> 00:06:38,487
you'll find a file on the DVD called

133
00:06:38,487 --> 00:06:41,314
software.zip, or if you've bought from our

134
00:06:41,314 --> 00:06:43,916
website, there's a download.

135
00:06:43,916 --> 00:06:46,754
Follow the my courses link, and follow the

136
00:06:46,754 --> 00:06:50,124
link to Spring Framework
second edition, and

137
00:06:50,124 --> 00:06:53,303
then here's the full list of chapters, and

138
00:06:53,303 --> 00:06:54,988
we're going to be studying a lot of them

139
00:06:54,988 --> 00:06:56,087
on this course.

140
00:06:56,087 --> 00:06:58,423
Right at the very bottom
of the list, there,

141
00:06:58,423 --> 00:07:01,463
there should be one called
practicals and code.

142
00:07:01,463 --> 00:07:04,620
The file name is software.zip and if you

143
00:07:04,620 --> 00:07:07,522
download that, you will
have all the code you

144
00:07:07,522 --> 00:07:09,557
need for the course.

145
00:07:09,557 --> 00:07:12,395
Once you've downloaded
and unzipped that file,

146
00:07:12,395 --> 00:07:14,880
you'll find the following contents:

147
00:07:14,880 --> 00:07:17,013
First of all, there's a practical guide.

148
00:07:17,013 --> 00:07:19,285
Now it's a PDF document
that you won't need until

149
00:07:19,285 --> 00:07:23,125
you start with practicals
later on in the course.

150
00:07:23,125 --> 00:07:24,523
And then the three folders.

151
00:07:24,523 --> 00:07:27,509
We have a folder called additional code.

152
00:07:27,509 --> 00:07:29,792
You won't need these until much later.

153
00:07:29,792 --> 00:07:31,552
These are just files that I didn't

154
00:07:31,552 --> 00:07:34,848
include in your starting code.

155
00:07:34,848 --> 00:07:37,308
You'll need the MyBatis jav folder

156
00:07:37,308 --> 00:07:40,209
when you get to chapter 27, and you'll

157
00:07:40,209 --> 00:07:43,687
need the managing book's integration test

158
00:07:43,687 --> 00:07:45,937
when you get to chapter 29.

159
00:07:47,356 --> 00:07:49,895
So, we won't need those for now.

160
00:07:49,895 --> 00:07:51,996
And then, there's a folder called

161
00:07:51,996 --> 00:07:55,372
projects at the end of each chapter.

162
00:07:55,372 --> 00:07:56,997
Now, what I've done here is I've taken

163
00:07:56,997 --> 00:08:00,538
a snapshot of my coding environment

164
00:08:00,538 --> 00:08:04,183
that I used on the videos
at the end of each,

165
00:08:04,183 --> 00:08:07,127
or at least most of the chapters.

166
00:08:07,127 --> 00:08:10,604
So, for example, here in chapter six,

167
00:08:10,604 --> 00:08:12,844
if you got stuck on chapter six,

168
00:08:12,844 --> 00:08:16,887
we'll be working on a
bookstore in chapter six,

169
00:08:16,887 --> 00:08:18,839
so you can have a look inside there and

170
00:08:18,839 --> 00:08:22,753
you can find all the code
that was on the video screen.

171
00:08:22,753 --> 00:08:25,239
Sometimes, we'll be doing
some heavy typing on

172
00:08:25,239 --> 00:08:28,588
the course and you know,
this isn't a typing course,

173
00:08:28,588 --> 00:08:31,980
so, if you want to sneak
into there and do a bit

174
00:08:31,980 --> 00:08:33,911
of copying and pasting, that's fine,

175
00:08:33,911 --> 00:08:37,463
as long as you understand what's going on.

176
00:08:37,463 --> 00:08:39,745
You'll notice that on
some of the chapters,

177
00:08:39,745 --> 00:08:42,716
for example, in chapter
seven we don't do any

178
00:08:42,716 --> 00:08:45,243
particular coding, so I've combined those

179
00:08:45,243 --> 00:08:47,743
chapters into a single folder.

180
00:08:48,817 --> 00:08:50,662
Oh, and I should say before I leave this

181
00:08:50,662 --> 00:08:54,385
that if you look in any
of the lib directories,

182
00:08:54,385 --> 00:08:57,084
that's we normally store the jav files.

183
00:08:57,084 --> 00:08:59,676
I've removed all of the jav files from

184
00:08:59,676 --> 00:09:02,709
these snapshot folders
because it would have

185
00:09:02,709 --> 00:09:04,709
taken up too much space.

186
00:09:05,579 --> 00:09:08,543
You'll find the jav
files, and this gives me

187
00:09:08,543 --> 00:09:12,053
a chance to move to the
most important folder.

188
00:09:12,053 --> 00:09:15,647
This is the starting workspaces folder.

189
00:09:15,647 --> 00:09:18,207
Now, you have two of them, here.

190
00:09:18,207 --> 00:09:20,974
When we first begin the
course, in chapter two,

191
00:09:20,974 --> 00:09:24,590
we work on a very basic
system, and I've put that

192
00:09:24,590 --> 00:09:28,903
in this workspace called
workspace for coupling.

193
00:09:28,903 --> 00:09:31,346
If you're new to Eclipse,
then when you start up

194
00:09:31,346 --> 00:09:35,015
Eclipse, you'll want to
navigate to that folder

195
00:09:35,015 --> 00:09:39,159
in this dialogue box,
here, and then click on OK.

196
00:09:39,159 --> 00:09:41,089
But I'll be showing
you how to do that when

197
00:09:41,089 --> 00:09:42,711
we get there.

198
00:09:42,711 --> 00:09:45,110
But just to show you what's inside there,

199
00:09:45,110 --> 00:09:47,510
there's a project called coupling example,

200
00:09:47,510 --> 00:09:50,794
and in there, you have all
the source code that you

201
00:09:50,794 --> 00:09:54,763
need, and most importantly,
in the lib directory

202
00:09:54,763 --> 00:09:57,376
are any jav files that you need for that

203
00:09:57,376 --> 00:09:59,915
particular part of the course.

204
00:09:59,915 --> 00:10:02,016
While this is a very basic workspace,

205
00:10:02,016 --> 00:10:05,056
there's only a single
jav file for that one.

206
00:10:05,056 --> 00:10:07,392
But when you go to the next chapter, that

207
00:10:07,392 --> 00:10:10,524
will be chapter 3, we'll
open up this second

208
00:10:10,524 --> 00:10:14,474
workspace called the message
of the day workspace.

209
00:10:14,474 --> 00:10:16,095
Now, I didn't give this a very good name,

210
00:10:16,095 --> 00:10:17,311
to be honest.

211
00:10:17,311 --> 00:10:18,943
I thought this would just be a workspace

212
00:10:18,943 --> 00:10:21,300
for one particular
chapter, but then I went on

213
00:10:21,300 --> 00:10:24,404
and used it through
the rest of the course,

214
00:10:24,404 --> 00:10:26,879
so if you want to rename this to something

215
00:10:26,879 --> 00:10:30,538
like, I don't know,
training course workspace,

216
00:10:30,538 --> 00:10:31,999
then it might be a bit more obvious

217
00:10:31,999 --> 00:10:33,631
what's going on there.

218
00:10:33,631 --> 00:10:36,212
I can't rename it because I carried on

219
00:10:36,212 --> 00:10:39,764
recording with that workspace name.

220
00:10:39,764 --> 00:10:41,738
But in there are four different projects

221
00:10:41,738 --> 00:10:44,927
that we'll be building up
throughout this course.

222
00:10:44,927 --> 00:10:48,362
If we look in the bookstore
project, for example,

223
00:10:48,362 --> 00:10:51,956
I think, most importantly,
in the lib directory

224
00:10:51,956 --> 00:10:55,455
are all of the jav files
you need for the course.

225
00:10:55,455 --> 00:10:58,175
In particular, here are all of the,

226
00:10:58,175 --> 00:10:59,721
there's a lot of them, by the way.

227
00:10:59,721 --> 00:11:03,221
Here are all of the Spring Four jav files.

228
00:11:04,304 --> 00:11:05,478
And don't worry too much about the

229
00:11:05,478 --> 00:11:07,547
structure of this until we get into the

230
00:11:07,547 --> 00:11:09,382
next chapters.

231
00:11:09,382 --> 00:11:10,810
But, I just wanted you to know that those

232
00:11:10,810 --> 00:11:13,189
jav files are there.

233
00:11:13,189 --> 00:11:15,431
Now, you could have
downloaded those jav files

234
00:11:15,431 --> 00:11:19,450
for yourself from the
Spring Framework website.

235
00:11:19,450 --> 00:11:21,989
But I've done that for
you because they kind of

236
00:11:21,989 --> 00:11:24,485
hide away the downloads
now because they would

237
00:11:24,485 --> 00:11:27,781
rather that you used Maven to build your

238
00:11:27,781 --> 00:11:29,552
Spring system.

239
00:11:29,552 --> 00:11:34,006
Now, I agree that Maven
is probably the best way

240
00:11:34,006 --> 00:11:36,173
of managing your jav files

241
00:11:37,022 --> 00:11:40,190
or an alternative tool such as Gradle.

242
00:11:40,190 --> 00:11:43,418
Now, for this course we
don't want to be dealing

243
00:11:43,418 --> 00:11:46,202
with Maven and Gradle problems.

244
00:11:46,202 --> 00:11:48,356
So that's why we've given you a folder

245
00:11:48,356 --> 00:11:50,980
with all of the jav files you need.

246
00:11:50,980 --> 00:11:53,274
Please don't be tempted to start messing

247
00:11:53,274 --> 00:11:55,994
around with Maven and
those kinds of things

248
00:11:55,994 --> 00:11:58,596
while you're learning Spring.

249
00:11:58,596 --> 00:12:00,868
Of course, as soon as
you finish the course,

250
00:12:00,868 --> 00:12:02,906
you could then set up Maven.

251
00:12:02,906 --> 00:12:04,911
And if you want more information on how to

252
00:12:04,911 --> 00:12:07,396
use Maven, then we have
a full training course

253
00:12:07,396 --> 00:12:10,063
on that called Java Built Tools.

254
00:12:11,396 --> 00:12:13,446
But while I'm talking
about the Spring website,

255
00:12:13,446 --> 00:12:15,727
I think I'll introduce you to it.

256
00:12:15,727 --> 00:12:18,105
This site has gone through some various

257
00:12:18,105 --> 00:12:20,719
incarnations over the years.

258
00:12:20,719 --> 00:12:23,098
In fact, the original
name for this site was

259
00:12:23,098 --> 00:12:24,765
SpringFramework.org.

260
00:12:26,874 --> 00:12:29,828
If you go to SpringFramework.org
it will redirect

261
00:12:29,828 --> 00:12:33,745
here, which is their new
site called Spring.IO.

262
00:12:35,023 --> 00:12:37,444
Now, their intention is
that they're gathering

263
00:12:37,444 --> 00:12:41,647
together lots of projects
related to Spring, here,

264
00:12:41,647 --> 00:12:43,418
but at the time of this recording,

265
00:12:43,418 --> 00:12:46,298
if you follow the link to projects,

266
00:12:46,298 --> 00:12:48,719
you'll find quite a few projects on here

267
00:12:48,719 --> 00:12:52,302
that are kind of related
to Spring, such as

268
00:12:53,525 --> 00:12:55,765
Spring for Android, which we won't be

269
00:12:55,765 --> 00:12:57,429
covering on this course.

270
00:12:57,429 --> 00:12:59,701
We're concentrating on the core, which

271
00:12:59,701 --> 00:13:02,954
is this link here for Spring Framework.

272
00:13:02,954 --> 00:13:04,586
If you're following
this video and you find

273
00:13:04,586 --> 00:13:06,494
that their website's completely different,

274
00:13:06,494 --> 00:13:07,636
please don't panic.

275
00:13:07,636 --> 00:13:10,708
They seem to change it every few months,

276
00:13:10,708 --> 00:13:13,300
and we can't stop them
doing that, of course.

277
00:13:13,300 --> 00:13:15,785
But somewhere you will find a home for

278
00:13:15,785 --> 00:13:19,059
Spring Framework and we
are going to be using

279
00:13:19,059 --> 00:13:22,569
the documentation for Spring extensively

280
00:13:22,569 --> 00:13:24,116
through this course.

281
00:13:24,116 --> 00:13:26,676
And on this page, you
will find a link to the

282
00:13:26,676 --> 00:13:29,460
reference guide and the API.

283
00:13:29,460 --> 00:13:32,895
Believe me, you're going
to need it on the course.

284
00:13:32,895 --> 00:13:35,529
But, as I say, this is
where I was leading to.

285
00:13:35,529 --> 00:13:37,300
When you finish the course
and you want to move

286
00:13:37,300 --> 00:13:39,636
across to something like
Maven, then you will find

287
00:13:39,636 --> 00:13:42,336
all of the Maven
dependencies that you need

288
00:13:42,336 --> 00:13:44,669
here on their download page.

289
00:13:45,602 --> 00:13:47,713
But don't forget, you
can get started on this

290
00:13:47,713 --> 00:13:49,954
course without any of that because you've

291
00:13:49,954 --> 00:13:53,062
already got the jav files available.

292
00:13:53,062 --> 00:13:55,846
Just a few words on the
versions of Spring and

293
00:13:55,846 --> 00:13:58,342
this might be of interest to you if you've

294
00:13:58,342 --> 00:14:00,635
maybe done some work in Spring before.

295
00:14:00,635 --> 00:14:02,566
The original version
of Spring was released

296
00:14:02,566 --> 00:14:03,649
back in 2004.

297
00:14:04,603 --> 00:14:07,185
It really doesn't seem that long ago, but

298
00:14:07,185 --> 00:14:10,107
it was and one of the
amazing things for me

299
00:14:10,107 --> 00:14:13,607
is that even back in 2004, Spring featured

300
00:14:14,491 --> 00:14:18,840
pretty much all of the core
features from the start.

301
00:14:18,840 --> 00:14:20,983
Most of what we're going to cover on this

302
00:14:20,983 --> 00:14:23,639
course was present in Spring I,

303
00:14:23,639 --> 00:14:25,472
at least in some form.

304
00:14:26,498 --> 00:14:28,759
Some of the features were not particularly

305
00:14:28,759 --> 00:14:30,807
well-implemented at first,

306
00:14:30,807 --> 00:14:32,823
and they've massively improved,

307
00:14:32,823 --> 00:14:35,831
but most of them were there.

308
00:14:35,831 --> 00:14:37,634
So, I think that's great.

309
00:14:37,634 --> 00:14:40,130
As a Spring developer, we are able to

310
00:14:40,130 --> 00:14:42,594
learn the fundamentals and you don't

311
00:14:42,594 --> 00:14:45,090
have a certain new version coming out,

312
00:14:45,090 --> 00:14:47,085
meaning that you've got to re-learn

313
00:14:47,085 --> 00:14:49,197
everything from scratch.

314
00:14:49,197 --> 00:14:50,743
Really, all that's happened since then

315
00:14:50,743 --> 00:14:52,994
have a been a few relatively small changes

316
00:14:52,994 --> 00:14:57,161
to the fundamentals and lots
of new advanced features.

317
00:14:58,093 --> 00:15:01,173
In Spring 2, for example, AOP.

318
00:15:01,173 --> 00:15:02,799
If you don't know what that is we'll be

319
00:15:02,799 --> 00:15:05,487
studying it in detail on this course.

320
00:15:05,487 --> 00:15:08,903
The AOP was dramatically improved.

321
00:15:08,903 --> 00:15:10,855
And of course, that's the version of AOP

322
00:15:10,855 --> 00:15:14,322
that we'll be studying on the course.

323
00:15:14,322 --> 00:15:18,161
Spring 2.5 was 2007, and the really big

324
00:15:18,161 --> 00:15:22,031
change in there was annotation wiring.

325
00:15:22,031 --> 00:15:23,802
This is perhaps the most controversial

326
00:15:23,802 --> 00:15:25,349
change in Spring.

327
00:15:25,349 --> 00:15:29,266
We'll be covering this
in detail in chapter 22.

328
00:15:30,106 --> 00:15:31,611
That could have a big effect on the way

329
00:15:31,611 --> 00:15:33,595
you write your code.

330
00:15:33,595 --> 00:15:35,589
Spring 3, well, not really a lot

331
00:15:35,589 --> 00:15:37,562
changed in Spring 3.

332
00:15:37,562 --> 00:15:40,487
Lots of new features,
but really the only thing

333
00:15:40,487 --> 00:15:43,269
that affected the core
features was something

334
00:15:43,269 --> 00:15:46,436
called the JPATemplate was deprecated.

335
00:15:47,479 --> 00:15:49,568
If you already know
Spring and maybe you've

336
00:15:49,568 --> 00:15:51,713
studied the first
edition, then this will be

337
00:15:51,713 --> 00:15:53,632
a big change for you and we'll be covering

338
00:15:53,632 --> 00:15:57,465
the details of that when
we get to chapter 25,

339
00:15:58,785 --> 00:16:01,494
and I'll show you what you can do instead.

340
00:16:01,494 --> 00:16:04,214
And Spring 4 which is
current at the time of

341
00:16:04,214 --> 00:16:06,550
this recording, well,
do you know it's really

342
00:16:06,550 --> 00:16:10,507
quite hard to actually see
what's new in Spring 4?

343
00:16:10,507 --> 00:16:14,674
I would say it was largely a
tidy-up exercise, Spring 4.

344
00:16:15,851 --> 00:16:17,889
They've removed a lot of legacy support

345
00:16:17,889 --> 00:16:21,347
for things like old versions of Java.

346
00:16:21,347 --> 00:16:23,862
But if you're interested
in the exact changes,

347
00:16:23,862 --> 00:16:26,987
you can go to the Spring
site and check out

348
00:16:26,987 --> 00:16:29,185
whatever the latest
version of the reference

349
00:16:29,185 --> 00:16:32,312
manual is, and one of
the very early chapters

350
00:16:32,312 --> 00:16:36,426
there is what's new in
the Spring Framework and

351
00:16:36,426 --> 00:16:39,658
basically everything is listed there.

352
00:16:39,658 --> 00:16:43,050
So, there's a lot of
talk about that they've

353
00:16:43,050 --> 00:16:46,752
removed a lot of deprecated
packages and methods

354
00:16:46,752 --> 00:16:50,779
and now support Java Eight
and the key thing is,

355
00:16:50,779 --> 00:16:53,926
that really not much of this affects the

356
00:16:53,926 --> 00:16:56,955
core concepts that
we'll be following here.

357
00:16:56,955 --> 00:16:59,174
And I would very much hope that if you've

358
00:16:59,174 --> 00:17:03,089
come across this video and Spring 5 is the

359
00:17:03,089 --> 00:17:05,277
current latest version, I'm going to have

360
00:17:05,277 --> 00:17:09,266
a pretty big bet that everything or 90%

361
00:17:09,266 --> 00:17:12,564
of this course still
applies to whatever version

362
00:17:12,564 --> 00:17:16,019
of Spring is current at
the time you watch this.

363
00:17:16,019 --> 00:17:18,334
For the rest of this
chapter, I'm going to give

364
00:17:18,334 --> 00:17:20,745
a brief background of Spring.

365
00:17:20,745 --> 00:17:23,348
Where it came from,
it's history and how it

366
00:17:23,348 --> 00:17:27,636
compares with it's big
rival, which is called EJB.

367
00:17:27,636 --> 00:17:29,972
If you know all of this already, then you

368
00:17:29,972 --> 00:17:33,428
can move on to the next
chapter and get working.

369
00:17:33,428 --> 00:17:37,001
But, if you don't, this
is well worth watching.

370
00:17:37,001 --> 00:17:40,318
Okay, most of it is
ancient history, but it

371
00:17:40,318 --> 00:17:43,444
will help you to see how
the different competing

372
00:17:43,444 --> 00:17:45,444
frameworks fit together.

373
00:17:46,345 --> 00:17:47,701
I'll spend about 10 minutes on this.

374
00:17:47,701 --> 00:17:50,199
We won't need to do any code, but I think

375
00:17:50,199 --> 00:17:53,697
it will be useful in some technical areas.

376
00:17:53,697 --> 00:17:56,524
If I can sum up the Spring framework in a

377
00:17:56,524 --> 00:18:00,567
single sentence, I would
say that Spring aims

378
00:18:00,567 --> 00:18:03,900
to make Java server development simpler.

379
00:18:05,729 --> 00:18:07,895
Now, you might also hear the related term

380
00:18:07,895 --> 00:18:11,308
enterprise development,
which is a strange and

381
00:18:11,308 --> 00:18:14,709
vague word but for me, that really means

382
00:18:14,709 --> 00:18:18,139
applications that need to run on a server,

383
00:18:18,139 --> 00:18:19,972
rather than a desktop.

384
00:18:20,859 --> 00:18:23,558
Just in case you haven't
done any Java enterprise

385
00:18:23,558 --> 00:18:26,566
development before, and
in particular, I'm talking

386
00:18:26,566 --> 00:18:29,149
here about the Java EE library.

387
00:18:30,246 --> 00:18:33,968
Let's have a quick
overview of what that is.

388
00:18:33,968 --> 00:18:37,680
When you are developing
code to run on a server,

389
00:18:37,680 --> 00:18:39,763
We're dependent on tools.

390
00:18:40,731 --> 00:18:43,024
Just having a language like Java

391
00:18:43,024 --> 00:18:44,191
is not enough.

392
00:18:45,158 --> 00:18:48,144
We might need, for example,

393
00:18:48,144 --> 00:18:51,406
quite an obvious one, this, a database.

394
00:18:51,406 --> 00:18:53,454
Also, we're going to need a bridge to

395
00:18:53,454 --> 00:18:55,737
that database so that we can access

396
00:18:55,737 --> 00:18:57,987
the database from the code.

397
00:18:59,044 --> 00:19:01,891
Now, these things are
not part of the language.

398
00:19:01,891 --> 00:19:03,598
Not part of Java.

399
00:19:03,598 --> 00:19:07,758
They need to be supplied
by some kind of vendor.

400
00:19:07,758 --> 00:19:10,830
You might know that
Java has JDBC and that's

401
00:19:10,830 --> 00:19:14,041
been in Java almost from the start.

402
00:19:14,041 --> 00:19:17,468
But, that's sort of been
absorbed into the core language.

403
00:19:17,468 --> 00:19:19,131
I think it's important to remember that

404
00:19:19,131 --> 00:19:22,864
you're still relying on external support

405
00:19:22,864 --> 00:19:24,652
from some kind of a vendor.

406
00:19:24,652 --> 00:19:26,993
Someone had to write that database and

407
00:19:26,993 --> 00:19:29,062
someone had to write the bridge

408
00:19:29,062 --> 00:19:32,593
between the Java and the database.

409
00:19:32,593 --> 00:19:34,673
Now, on top of that,
for a web application,

410
00:19:34,673 --> 00:19:37,713
we will definitely need a web server.

411
00:19:37,713 --> 00:19:39,643
But we'll need a little more than that.

412
00:19:39,643 --> 00:19:43,686
We'll need a web server
that can run code, as well,

413
00:19:43,686 --> 00:19:45,841
because we're likely to want to generate

414
00:19:45,841 --> 00:19:47,857
dynamic web pages.

415
00:19:47,857 --> 00:19:51,003
So that's more software
support that we need.

416
00:19:51,003 --> 00:19:54,502
If you're writing
transactional applications,

417
00:19:54,502 --> 00:19:57,265
you might need a transaction manager.

418
00:19:57,265 --> 00:19:58,775
Now, if you don't know why a transaction

419
00:19:58,775 --> 00:20:00,887
manager is important, then that will be

420
00:20:00,887 --> 00:20:04,332
coming up in chapter 17 of the course.

421
00:20:04,332 --> 00:20:07,852
You might need a security system.

422
00:20:07,852 --> 00:20:10,636
You might need directory services so that

423
00:20:10,636 --> 00:20:12,748
you can publish objects across your

424
00:20:12,748 --> 00:20:14,839
entire application.

425
00:20:14,839 --> 00:20:17,463
I'm referring there to the JNDI library

426
00:20:17,463 --> 00:20:20,031
in Java, which we will be meeting later on

427
00:20:20,031 --> 00:20:22,239
in the course, but, you know as a Java

428
00:20:22,239 --> 00:20:24,759
developer, I often feel jealous of

429
00:20:24,759 --> 00:20:27,759
Microsoft developers, because in their

430
00:20:27,759 --> 00:20:30,565
environment, one
particular vendor, which is

431
00:20:30,565 --> 00:20:33,370
Microsoft, of course, have a very tight

432
00:20:33,370 --> 00:20:36,703
control of the entire stack of software.

433
00:20:38,106 --> 00:20:40,517
And so accessing all of these things that

434
00:20:40,517 --> 00:20:43,909
you can see here, in Microsoft is really

435
00:20:43,909 --> 00:20:47,973
tightly integrated into their languages.

436
00:20:47,973 --> 00:20:50,149
For instance, you can do a lot of these

437
00:20:50,149 --> 00:20:54,232
things in Visual Studio
using integrated wizards.

438
00:20:55,333 --> 00:20:58,032
In Java, we don't really
have that luxury because

439
00:20:58,032 --> 00:21:01,061
these tools are all
created by many different

440
00:21:01,061 --> 00:21:04,894
vendors, such as Oracle,
IBM, JBoss and so on.

441
00:21:07,621 --> 00:21:10,621
But for many years now,
the vendors have been

442
00:21:10,621 --> 00:21:14,498
providing these tools,
these software services,

443
00:21:14,498 --> 00:21:18,665
in single integrated packages
called application servers.

444
00:21:20,610 --> 00:21:22,626
So, an application server is really

445
00:21:22,626 --> 00:21:24,983
nothing more than software.

446
00:21:24,983 --> 00:21:28,055
It's software that provides server-side

447
00:21:28,055 --> 00:21:31,388
services in a single integrated package.

448
00:21:32,389 --> 00:21:35,746
Now, for a while, back
in about the late 1990's,

449
00:21:35,746 --> 00:21:38,115
I said this would be ancient history,

450
00:21:38,115 --> 00:21:40,195
we had a very unpleasant situation in the

451
00:21:40,195 --> 00:21:42,829
Java community and that's because if

452
00:21:42,829 --> 00:21:45,048
for instance, you had
written your software

453
00:21:45,048 --> 00:21:48,548
system using for example, IBM's Websphere,

454
00:21:50,469 --> 00:21:53,336
then, at that time your code would only

455
00:21:53,336 --> 00:21:56,239
run on IBM Websphere because you were

456
00:21:56,239 --> 00:21:59,989
using their API into
their software products.

457
00:22:01,122 --> 00:22:02,925
Now the vendors themselves were worried

458
00:22:02,925 --> 00:22:05,240
about this because without some kind of

459
00:22:05,240 --> 00:22:08,490
coordinated industry standard for Java,

460
00:22:09,411 --> 00:22:12,866
getting widespread developer acceptance

461
00:22:12,866 --> 00:22:14,936
would have been really difficult.

462
00:22:14,936 --> 00:22:18,979
So, in response to that,
the Java EE standard

463
00:22:18,979 --> 00:22:19,979
was created.

464
00:22:20,888 --> 00:22:23,491
Although you might
still see it referred to

465
00:22:23,491 --> 00:22:27,158
as J2EE, which was the
original name for it.

466
00:22:28,099 --> 00:22:31,331
It stood for Java 2 Enterprise Edition,

467
00:22:31,331 --> 00:22:34,498
but it has now been renamed to Java EE

468
00:22:35,589 --> 00:22:39,627
and you'll find that's
now the accepted term.

469
00:22:39,627 --> 00:22:41,901
Now I have to say the
term enterprise doesn't

470
00:22:41,901 --> 00:22:44,397
really mean anything here.

471
00:22:44,397 --> 00:22:46,552
Some people get confused
with this and think

472
00:22:46,552 --> 00:22:48,994
this is like an advanced version of Java

473
00:22:48,994 --> 00:22:51,565
that you have to pay
to download, but that's

474
00:22:51,565 --> 00:22:52,664
not the case at all.

475
00:22:52,664 --> 00:22:54,831
Java EE is a specification

476
00:22:56,339 --> 00:22:58,584
specifying the services

477
00:22:58,584 --> 00:23:02,584
that an application server
must support in Java.

478
00:23:03,549 --> 00:23:06,226
So, if you buy or obtain many of the more

479
00:23:06,226 --> 00:23:10,716
open source, the Java
EE application server,

480
00:23:10,716 --> 00:23:13,927
then you know that it
will feature a web server

481
00:23:13,927 --> 00:23:16,839
that can run Java, a transaction manager,

482
00:23:16,839 --> 00:23:19,964
security management and so on.

483
00:23:19,964 --> 00:23:22,706
Also, you know that the
API for calling these

484
00:23:22,706 --> 00:23:27,111
services is a standard,
so in theory, you can

485
00:23:27,111 --> 00:23:30,226
change the application
server you use without

486
00:23:30,226 --> 00:23:32,946
needing to port your code.

487
00:23:32,946 --> 00:23:35,346
So, really, Java EE is nothing more than a

488
00:23:35,346 --> 00:23:38,053
collection of libraries
that an application

489
00:23:38,053 --> 00:23:39,720
server must support.

490
00:23:41,050 --> 00:23:42,800
Actually, technically, it's a group of

491
00:23:42,800 --> 00:23:44,890
different libraries.

492
00:23:44,890 --> 00:23:48,528
For example, when using
an application server,

493
00:23:48,528 --> 00:23:50,757
you know that you have the standard

494
00:23:50,757 --> 00:23:54,757
RMI library to allow you
to call remote methods.

495
00:23:56,273 --> 00:23:57,605
Well, it's more than that, it's actually

496
00:23:57,605 --> 00:23:59,355
the RMI-IIOP library.

497
00:24:00,880 --> 00:24:03,301
That's an over-engineered
acronym, that one,

498
00:24:03,301 --> 00:24:06,329
but that means that
you can write Java code

499
00:24:06,329 --> 00:24:09,658
on server and call that Java code from

500
00:24:09,658 --> 00:24:11,804
non-Java clients.

501
00:24:11,804 --> 00:24:15,374
Maybe a Visual Basic client, for example.

502
00:24:15,374 --> 00:24:19,218
This uses the mechanism
called CORBA under the hood.

503
00:24:19,218 --> 00:24:21,372
It's a pretty complex
library, that, but it

504
00:24:21,372 --> 00:24:24,205
is built into application service.

505
00:24:25,168 --> 00:24:27,482
More on that in a moment.

506
00:24:27,482 --> 00:24:29,946
There's also a library called JTA

507
00:24:29,946 --> 00:24:32,419
built into application service and that

508
00:24:32,419 --> 00:24:35,835
allows you to write transactions.

509
00:24:35,835 --> 00:24:37,467
There are a lot of these.

510
00:24:37,467 --> 00:24:39,877
There's one called JNDI for naming and

511
00:24:39,877 --> 00:24:42,275
directory services.

512
00:24:42,275 --> 00:24:44,245
There's one called JDBC which you've

513
00:24:44,245 --> 00:24:45,314
probably come across.

514
00:24:45,314 --> 00:24:48,624
That's for managing databases and

515
00:24:48,624 --> 00:24:51,472
has now become part of
standard Java as well, but

516
00:24:51,472 --> 00:24:55,653
you know it will be in
the application server.

517
00:24:55,653 --> 00:24:57,986
There are servlets in JSP.

518
00:24:57,986 --> 00:25:01,292
That enables you to build webpages.

519
00:25:01,292 --> 00:25:03,020
And there's also the Java messaging

520
00:25:03,020 --> 00:25:04,770
service, or JMS.

521
00:25:04,770 --> 00:25:05,975
Now, I could go on.

522
00:25:05,975 --> 00:25:07,916
There's well over 20 of these libraries

523
00:25:07,916 --> 00:25:10,903
mandated by that standard.

524
00:25:10,903 --> 00:25:13,666
Now, the people who were creating Java EE

525
00:25:13,666 --> 00:25:16,108
were originally, and
I'm talking now back in

526
00:25:16,108 --> 00:25:19,457
about the early 2000's, long time ago now.

527
00:25:19,457 --> 00:25:21,591
They were really worried by this vast

528
00:25:21,591 --> 00:25:26,145
number of libraries that
application servers contain.

529
00:25:26,145 --> 00:25:27,468
They were worried that it would be too

530
00:25:27,468 --> 00:25:29,719
hard to learn and
understand so they came up

531
00:25:29,719 --> 00:25:33,219
with an idea, and the idea was called EJB.

532
00:25:35,041 --> 00:25:38,519
Now, EJB stands for Enterprise Java Bean,

533
00:25:38,519 --> 00:25:39,937
which I have to say isn't a very

534
00:25:39,937 --> 00:25:42,087
meaningful phrase.

535
00:25:42,087 --> 00:25:44,009
It was really just the label they

536
00:25:44,009 --> 00:25:48,101
gave this idea and if were
to convert this into English,

537
00:25:48,101 --> 00:25:51,751
I would say that an EJB was supposed to be

538
00:25:51,751 --> 00:25:54,918
an easy way to access those libraries.

539
00:25:56,071 --> 00:25:57,553
Let me explain.

540
00:25:57,553 --> 00:26:00,039
The rough idea behind an EJB would be

541
00:26:00,039 --> 00:26:02,823
that you would write a simple class.

542
00:26:02,823 --> 00:26:05,660
Now, I have here a regular Java class.

543
00:26:05,660 --> 00:26:08,175
It's called a bookservice and it's

544
00:26:08,175 --> 00:26:11,367
presumably a class involved in some kind

545
00:26:11,367 --> 00:26:14,599
of online book store, for example.

546
00:26:14,599 --> 00:26:16,637
Now, in EJB, this class would be

547
00:26:16,637 --> 00:26:18,387
largely regular Java.

548
00:26:19,357 --> 00:26:21,288
By that I mean you don't have to make

549
00:26:21,288 --> 00:26:23,805
any calls to the Java transaction API,

550
00:26:23,805 --> 00:26:26,386
or the Java remoting API.

551
00:26:26,386 --> 00:26:29,884
You don't have to worry
about any kind of security.

552
00:26:29,884 --> 00:26:32,520
You would, by and large, write a regular

553
00:26:32,520 --> 00:26:33,437
Java class.

554
00:26:34,631 --> 00:26:36,466
The idea then, is that you would obtain

555
00:26:36,466 --> 00:26:38,674
one of these application servers and then

556
00:26:38,674 --> 00:26:40,841
you would deploy the class

557
00:26:45,554 --> 00:26:47,033
to the application server.

558
00:26:47,033 --> 00:26:49,433
And by deploy, I mean some kind of upload

559
00:26:49,433 --> 00:26:52,046
process where you transfer the Java

560
00:26:52,046 --> 00:26:54,828
onto the application server.

561
00:26:54,828 --> 00:26:57,740
Now, and here was the
big feature of an EJB.

562
00:26:57,740 --> 00:27:00,620
Automatically, the
application server would

563
00:27:00,620 --> 00:27:02,787
add features to the class.

564
00:27:03,894 --> 00:27:06,777
All the methods would become remote.

565
00:27:06,777 --> 00:27:09,113
For example, which would
mean that if I were

566
00:27:09,113 --> 00:27:12,281
to write a client, it
could be a Java client,

567
00:27:12,281 --> 00:27:14,052
but it could be a Visual Basic client,

568
00:27:14,052 --> 00:27:16,569
it could be a C++ client.

569
00:27:16,569 --> 00:27:19,172
I would be able to call the methods

570
00:27:19,172 --> 00:27:21,379
on that server without me having to do

571
00:27:21,379 --> 00:27:23,296
any special extra work.

572
00:27:24,633 --> 00:27:28,003
All of the methods will
also become transactional.

573
00:27:28,003 --> 00:27:29,795
So, with very little
work, if something went

574
00:27:29,795 --> 00:27:32,400
wrong in any of the methods, all of the

575
00:27:32,400 --> 00:27:36,579
changes made to the database
would be rolled back.

576
00:27:36,579 --> 00:27:39,267
Now, I'm not sure if you're familiar with

577
00:27:39,267 --> 00:27:40,579
application transactions yet.

578
00:27:40,579 --> 00:27:42,617
We have a chapter coming up on the course.

579
00:27:42,617 --> 00:27:44,965
But, that's actually
quite a complex process

580
00:27:44,965 --> 00:27:46,565
to implement when you're working on

581
00:27:46,565 --> 00:27:49,482
object-oriented multi-tier systems.

582
00:27:50,384 --> 00:27:52,090
All of the features would also be

583
00:27:52,090 --> 00:27:54,917
secured, which means that if I wanted to,

584
00:27:54,917 --> 00:27:56,848
I could take some or all of the methods

585
00:27:56,848 --> 00:27:59,429
on that class and prevent them from being

586
00:27:59,429 --> 00:28:01,317
called by the clients unless

587
00:28:01,317 --> 00:28:04,240
the clients had logged in first.

588
00:28:04,240 --> 00:28:06,234
Now, that was the idea.

589
00:28:06,234 --> 00:28:08,677
Back in the early 2000's,
I don't know if you

590
00:28:08,677 --> 00:28:10,864
were working in Java then, but everybody

591
00:28:10,864 --> 00:28:12,697
was mad keen on EJB's.

592
00:28:13,573 --> 00:28:17,082
They were the coolest
thing to have on your CV.

593
00:28:17,082 --> 00:28:18,895
But it didn't work out like that.

594
00:28:18,895 --> 00:28:21,380
After about a year or so, people began

595
00:28:21,380 --> 00:28:24,196
to realize that EJB's were really

596
00:28:24,196 --> 00:28:26,113
complicated themselves.

597
00:28:27,204 --> 00:28:28,996
Now, I made it sound like it was an easy

598
00:28:28,996 --> 00:28:31,012
process of writing a simple class but

599
00:28:31,012 --> 00:28:32,996
believe me, it wasn't.

600
00:28:32,996 --> 00:28:35,257
They were really badly designed,

601
00:28:35,257 --> 00:28:37,935
difficult to use, really
difficult to write

602
00:28:37,935 --> 00:28:41,103
and a general nightmare to work with.

603
00:28:41,103 --> 00:28:42,511
On the first edition of this course,

604
00:28:42,511 --> 00:28:44,175
I went through the steps you had to follow

605
00:28:44,175 --> 00:28:45,999
to write an EJB.

606
00:28:45,999 --> 00:28:48,132
To be honest, now that's
too far in the past

607
00:28:48,132 --> 00:28:52,038
to repeat on this course,
but suffice to say

608
00:28:52,038 --> 00:28:54,256
they were difficult to work with.

609
00:28:54,256 --> 00:28:57,670
I started my career in
Java around the time

610
00:28:57,670 --> 00:28:59,462
that EJB was happening and it

611
00:28:59,462 --> 00:29:01,915
genuinely wasn't nice.

612
00:29:01,915 --> 00:29:04,006
Most of our development time in those days

613
00:29:04,006 --> 00:29:08,358
was wasted de-bugging
these horrible things.

614
00:29:08,358 --> 00:29:10,427
One of the main problems with EJB was that

615
00:29:10,427 --> 00:29:13,232
it was an all-or-nothing affair.

616
00:29:13,232 --> 00:29:15,444
If, for example, all
you were interested in

617
00:29:15,444 --> 00:29:19,077
were the transactional
aspects of EJB, I think

618
00:29:19,077 --> 00:29:20,933
basically the community threw everything

619
00:29:20,933 --> 00:29:24,368
they could think of
into the specification,

620
00:29:24,368 --> 00:29:26,149
because they didn't really know what

621
00:29:26,149 --> 00:29:29,281
developers ultimately were going to use.

622
00:29:29,281 --> 00:29:32,352
This business about all
the methods becoming

623
00:29:32,352 --> 00:29:35,104
remote and being able to be called from

624
00:29:35,104 --> 00:29:38,475
a Visual Basic client, back in the 2000's,

625
00:29:38,475 --> 00:29:40,587
that sounded like a great idea.

626
00:29:40,587 --> 00:29:42,613
But the committee hadn't seen that the

627
00:29:42,613 --> 00:29:45,280
web was growing really quickly and that

628
00:29:45,280 --> 00:29:47,211
most applications were going to become

629
00:29:47,211 --> 00:29:49,280
web applications and therefore, had

630
00:29:49,280 --> 00:29:51,780
absolutely no use for CORBA in

631
00:29:52,960 --> 00:29:56,469
Visual Basic clients' applications.

632
00:29:56,469 --> 00:29:58,848
It was hard-baked into the specifications,

633
00:29:58,848 --> 00:30:02,976
so you had to deal with it
even if you didn't want it.

634
00:30:02,976 --> 00:30:05,781
And by the, that was
true for many projects.

635
00:30:05,781 --> 00:30:09,397
Many projects want
transactions but nothing else.

636
00:30:09,397 --> 00:30:12,011
But with EJB in those days, you still

637
00:30:12,011 --> 00:30:14,112
had to deal with the complexity of the

638
00:30:14,112 --> 00:30:17,344
remoting features, the security features

639
00:30:17,344 --> 00:30:19,435
and lots of other features as well that

640
00:30:19,435 --> 00:30:22,048
you really didn't care about.

641
00:30:22,048 --> 00:30:23,531
But also for me, one of the biggest

642
00:30:23,531 --> 00:30:26,373
problems with EJB is that it would only

643
00:30:26,373 --> 00:30:29,093
run on an application server.

644
00:30:29,093 --> 00:30:32,556
Outside of the application
server they were useless.

645
00:30:32,556 --> 00:30:35,329
And this made them
difficult, very difficult

646
00:30:35,329 --> 00:30:37,662
to test or run in isolation.

647
00:30:39,020 --> 00:30:42,700
However, EJB was the official standard,

648
00:30:42,700 --> 00:30:46,380
and many projects felt
obliged to use them.

649
00:30:46,380 --> 00:30:50,113
Well, in 2002, a software developer called

650
00:30:50,113 --> 00:30:53,036
Rod Johnson, and this is the guy here,

651
00:30:53,036 --> 00:30:54,210
wrote a book called

652
00:30:54,210 --> 00:30:58,210
"Expert One-On-One J2EE
Design and Development".

653
00:30:59,266 --> 00:31:01,325
Now, this was a really brave book because

654
00:31:01,325 --> 00:31:04,610
it challenged the status quo in the Java

655
00:31:04,610 --> 00:31:06,935
industry and he asked the question,

656
00:31:06,935 --> 00:31:09,432
amongst other things, "Do we really need

657
00:31:09,432 --> 00:31:13,182
these EJB's to make Java
development simpler?

658
00:31:14,040 --> 00:31:16,098
Is there some kind of better way?"

659
00:31:16,098 --> 00:31:18,679
And the book tried to answer that question

660
00:31:18,679 --> 00:31:22,029
and it featured lots of coding examples,

661
00:31:22,029 --> 00:31:24,707
showing how really,
just simple fundamental

662
00:31:24,707 --> 00:31:28,045
Java, together with good
software engineering

663
00:31:28,045 --> 00:31:31,010
principles, could be used to simplify our

664
00:31:31,010 --> 00:31:34,669
development without the need for EJB's.

665
00:31:34,669 --> 00:31:37,858
We're still working with Java EE.

666
00:31:37,858 --> 00:31:40,194
We were still calling those libraries

667
00:31:40,194 --> 00:31:43,213
or transactions and all the rest of it,

668
00:31:43,213 --> 00:31:45,546
but without using the EJB's.

669
00:31:46,818 --> 00:31:48,216
Now the code that was contained

670
00:31:48,216 --> 00:31:49,634
in this book was made available

671
00:31:49,634 --> 00:31:51,992
for download on a website.

672
00:31:51,992 --> 00:31:54,957
Rod decided to open source that code.

673
00:31:54,957 --> 00:31:57,400
It was under the Apache license.

674
00:31:57,400 --> 00:31:59,128
And over time, the code was refined

675
00:31:59,128 --> 00:32:02,008
and expanded by both Rod and a group

676
00:32:02,008 --> 00:32:05,752
of other enthusiasts, and over time,

677
00:32:05,752 --> 00:32:08,386
it became a full-blown framework.

678
00:32:08,386 --> 00:32:10,765
And that, of course, eventually

679
00:32:10,765 --> 00:32:13,229
became the Spring Framework.

680
00:32:13,229 --> 00:32:15,725
So, we can use the code that Rod and

681
00:32:15,725 --> 00:32:19,388
his team supplied to do
the same thing as EJB.

682
00:32:19,388 --> 00:32:21,388
To access the services provided

683
00:32:21,388 --> 00:32:24,663
by Java EE, but by writing simple,

684
00:32:24,663 --> 00:32:27,692
plain, Java objects and critically,

685
00:32:27,692 --> 00:32:29,762
you choose what you need.

686
00:32:29,762 --> 00:32:32,684
If you're only interested
in, for instance,

687
00:32:32,684 --> 00:32:35,468
simplifying data access, then you can do

688
00:32:35,468 --> 00:32:38,455
that, and you only need to do that.

689
00:32:38,455 --> 00:32:40,247
If you want transaction management, you

690
00:32:40,247 --> 00:32:42,711
would write plain Java methods and you

691
00:32:42,711 --> 00:32:44,225
can make them transactional without

692
00:32:44,225 --> 00:32:46,892
affecting your code, and without the

693
00:32:46,892 --> 00:32:49,815
need to use anything else.

694
00:32:49,815 --> 00:32:51,650
And it even becomes the case when you're

695
00:32:51,650 --> 00:32:53,358
working with Spring and you might begin

696
00:32:53,358 --> 00:32:56,237
to realize that well,
we never really needed

697
00:32:56,237 --> 00:32:58,754
an application server anyway.

698
00:32:58,754 --> 00:33:01,645
With Spring and a few jav files,

699
00:33:01,645 --> 00:33:04,710
you can often replicate
the features that you

700
00:33:04,710 --> 00:33:06,843
would otherwise need a massive

701
00:33:06,843 --> 00:33:10,257
application service suite to achieve.

702
00:33:10,257 --> 00:33:11,558
Now, I find that working with Spring is a

703
00:33:11,558 --> 00:33:13,777
bit like choosing from a menu.

704
00:33:13,777 --> 00:33:15,643
You only need to learn about and

705
00:33:15,643 --> 00:33:17,755
use the features you need.

706
00:33:17,755 --> 00:33:19,323
Well, after that book, Rod went on

707
00:33:19,323 --> 00:33:21,030
a really amazing journey.

708
00:33:21,030 --> 00:33:23,864
He built up, from scratch a company

709
00:33:23,864 --> 00:33:26,489
which was originally called Interface 21

710
00:33:26,489 --> 00:33:29,945
but then they re-branded to Spring Source

711
00:33:29,945 --> 00:33:32,804
to promote and support Spring.

712
00:33:32,804 --> 00:33:34,574
But then the company got so big that

713
00:33:34,574 --> 00:33:37,764
in 2009, they were acquired by the

714
00:33:37,764 --> 00:33:41,742
giant VMware, and they got so big mainly

715
00:33:41,742 --> 00:33:45,145
because a lot of the Java industry went

716
00:33:45,145 --> 00:33:47,895
over to Spring instead of EJB and

717
00:33:49,038 --> 00:33:52,068
as Spring grew, Rod's company grew.

718
00:33:52,068 --> 00:33:54,525
So, that was a bit of a history lesson,

719
00:33:54,525 --> 00:33:56,103
and I'm sorry if I bored you there,

720
00:33:56,103 --> 00:33:58,278
but I think it's important to understand

721
00:33:58,278 --> 00:34:00,305
this history so that you can see how

722
00:34:00,305 --> 00:34:03,153
the different frameworks fit together.

723
00:34:03,153 --> 00:34:07,313
In the mid 2000's, let's say around 2004,

724
00:34:07,313 --> 00:34:09,692
most Java projects were struggling

725
00:34:09,692 --> 00:34:11,688
with this terrible, official Java

726
00:34:11,688 --> 00:34:15,574
standard, EJB, and then Spring came along

727
00:34:15,574 --> 00:34:18,400
to become an alternative cleaner and

728
00:34:18,400 --> 00:34:21,567
lighter de facto standard for Java EE.

729
00:34:23,318 --> 00:34:26,339
And what do I mean by a de facto standard?

730
00:34:26,339 --> 00:34:29,172
Well, EJB is an official standard.

731
00:34:30,361 --> 00:34:33,038
And it's defined by the JSR process, if

732
00:34:33,038 --> 00:34:34,499
you've come across that before, that's

733
00:34:34,499 --> 00:34:36,814
the process that standardizes

734
00:34:36,814 --> 00:34:38,981
all of the Java libraries.

735
00:34:39,950 --> 00:34:43,726
But Spring is so-called de facto standard.

736
00:34:43,726 --> 00:34:46,627
It's defined by a private group of people

737
00:34:46,627 --> 00:34:49,230
that was originally Rod and his team and

738
00:34:49,230 --> 00:34:53,063
now it's VMware, but
it's supported by a large

739
00:34:54,051 --> 00:34:57,721
number of people and it's used so commonly

740
00:34:57,721 --> 00:34:59,918
across the industry
that you could consider

741
00:34:59,918 --> 00:35:03,459
it a sort of, unofficial standard and they

742
00:35:03,459 --> 00:35:06,883
are often called de facto standards.

743
00:35:06,883 --> 00:35:09,283
And because Spring was so successful,

744
00:35:09,283 --> 00:35:11,321
lots of projects and developers moved

745
00:35:11,321 --> 00:35:14,563
away from EJB and over to Spring.

746
00:35:14,563 --> 00:35:16,067
I remember this time well.

747
00:35:16,067 --> 00:35:19,587
I met my first Spring project in 2005,

748
00:35:19,587 --> 00:35:21,497
and it was like a breath of fresh air,

749
00:35:21,497 --> 00:35:22,734
working on it.

750
00:35:22,734 --> 00:35:25,251
It was a really great time.

751
00:35:25,251 --> 00:35:28,643
But I need to complete
this history lesson.

752
00:35:28,643 --> 00:35:31,449
The EJB I've been describing so far was

753
00:35:31,449 --> 00:35:35,274
the original version of
EJB, versions one and two

754
00:35:35,274 --> 00:35:37,493
and that's before Spring came along.

755
00:35:37,493 --> 00:35:40,533
But then, the committee behind EJB created

756
00:35:40,533 --> 00:35:42,273
version three.

757
00:35:42,273 --> 00:35:45,106
Now, we do cover EJB on our JavaEE

758
00:35:46,198 --> 00:35:48,353
with Glassfish course.

759
00:35:48,353 --> 00:35:50,284
And it's really amazing how much this

760
00:35:50,284 --> 00:35:52,737
course and that course share in common.

761
00:35:52,737 --> 00:35:55,564
In other words, EJB and Spring today

762
00:35:55,564 --> 00:35:57,964
do pretty much the same things.

763
00:35:57,964 --> 00:36:00,973
Now, the thing about EJB3 is that EJB3

764
00:36:00,973 --> 00:36:02,556
is vastly improved.

765
00:36:03,597 --> 00:36:05,848
Now, that is thanks largely to the lead

766
00:36:05,848 --> 00:36:08,408
that Spring gave them but that doesn't

767
00:36:08,408 --> 00:36:09,241
really matter.

768
00:36:09,241 --> 00:36:13,528
The point is that today,
EJB's are themselves

769
00:36:13,528 --> 00:36:16,195
quite clean and easy to program.

770
00:36:17,229 --> 00:36:19,341
So, we've got an interesting situation

771
00:36:19,341 --> 00:36:20,867
in the Java industry.

772
00:36:20,867 --> 00:36:22,861
There are two camps, if you like.

773
00:36:22,861 --> 00:36:26,861
Some projects like official standards.

774
00:36:26,861 --> 00:36:29,603
That gives a sense of
safety and stability.

775
00:36:29,603 --> 00:36:33,848
These projects are likely
to prefer to use EJB.

776
00:36:33,848 --> 00:36:36,503
Other projects prefer to use Spring.

777
00:36:36,503 --> 00:36:38,124
Now, there are different reasons for this.

778
00:36:38,124 --> 00:36:40,162
Spring is more fast moving.

779
00:36:40,162 --> 00:36:42,434
It has more features than EJB, and

780
00:36:42,434 --> 00:36:46,380
in some places, it is better designed.

781
00:36:46,380 --> 00:36:49,303
But to be honest, many projects choose

782
00:36:49,303 --> 00:36:51,481
Spring because the project leader or

783
00:36:51,481 --> 00:36:55,385
the architech might have
used the old horrible EJB.

784
00:36:55,385 --> 00:36:57,519
They've decided never to go there again

785
00:36:57,519 --> 00:37:00,687
and they're sticking with
Spring through loyalty.

786
00:37:00,687 --> 00:37:01,807
And, you know what?

787
00:37:01,807 --> 00:37:03,737
That's fine as well.

788
00:37:03,737 --> 00:37:07,822
So, I'm often asked which
is best to use today?

789
00:37:07,822 --> 00:37:08,989
EJB or Spring?

790
00:37:09,828 --> 00:37:13,454
Now, I must admit, I have
to be impartial because

791
00:37:13,454 --> 00:37:17,208
I also train an EJB
course and we have a great

792
00:37:17,208 --> 00:37:20,195
time on that course as
well, but I admit that I

793
00:37:20,195 --> 00:37:24,366
still prefer Spring, but
only by a small margin.

794
00:37:24,366 --> 00:37:26,456
And the main reason is that it's easier

795
00:37:26,456 --> 00:37:28,717
to work in Spring, I think, because you

796
00:37:28,717 --> 00:37:31,032
don't need an application server.

797
00:37:31,032 --> 00:37:33,698
You can use one if you
want it, but if you don't

798
00:37:33,698 --> 00:37:37,026
want it, then you don't have to have it.

799
00:37:37,026 --> 00:37:38,850
That's why on this course, we're going

800
00:37:38,850 --> 00:37:41,613
to start with a very
simple application and

801
00:37:41,613 --> 00:37:43,938
build it up until it reaches the level of

802
00:37:43,938 --> 00:37:46,349
complexity that we need.

803
00:37:46,349 --> 00:37:47,693
As we go through the course,

804
00:37:47,693 --> 00:37:50,008
we'll add in transactions.

805
00:37:50,008 --> 00:37:52,141
We'll add in features such as

806
00:37:52,141 --> 00:37:54,296
aspect-oriented programming and

807
00:37:54,296 --> 00:37:56,226
we'll do all of this without

808
00:37:56,226 --> 00:37:58,029
an application server.

809
00:37:58,029 --> 00:38:00,312
But I'll also show you various

810
00:38:00,312 --> 00:38:02,711
places where you could integrate

811
00:38:02,711 --> 00:38:06,733
with an application
server if you wanted to.

812
00:38:06,733 --> 00:38:07,885
Now, the difference is if you're working

813
00:38:07,885 --> 00:38:11,053
in EJB, then your first job is always

814
00:38:11,053 --> 00:38:13,880
to install an application server.

815
00:38:13,880 --> 00:38:15,384
So, I like the general philosophy

816
00:38:15,384 --> 00:38:17,880
of Spring which is to keep things simple,

817
00:38:17,880 --> 00:38:19,778
until you need it.

818
00:38:19,778 --> 00:38:22,146
So, let's move on to the next chapter.

819
00:38:22,146 --> 00:38:23,917
Rod and his team when they were

820
00:38:23,917 --> 00:38:25,954
developing Spring realized that the

821
00:38:25,954 --> 00:38:28,365
dependency on the application server

822
00:38:28,365 --> 00:38:29,933
was a real problem.

823
00:38:29,933 --> 00:38:31,597
And they developed Spring to make

824
00:38:31,597 --> 00:38:33,912
sure that your application is not

825
00:38:33,912 --> 00:38:36,920
dependent on it's environment.

826
00:38:36,920 --> 00:38:38,200
So, they use a technique called

827
00:38:38,200 --> 00:38:40,920
dependency injection to help make

828
00:38:40,920 --> 00:38:43,138
your code independent of the

829
00:38:43,138 --> 00:38:45,048
server it's running on.

830
00:38:45,048 --> 00:38:46,573
So, in the following chapters,

831
00:38:46,573 --> 00:38:48,141
we're going to look at all of

832
00:38:48,141 --> 00:38:51,012
the major Spring core features.

833
00:38:51,012 --> 00:38:52,327
As we go along, we will build

834
00:38:52,327 --> 00:38:54,287
a full Spring application but we

835
00:38:54,287 --> 00:38:57,201
need to start with that
crucial fundamental

836
00:38:57,201 --> 00:39:00,144
concept called dependency injection.

837
00:39:00,144 --> 00:39:03,071
If you understand that,
then Spring is easy.

838
00:39:03,071 --> 00:39:05,307
So, rejoin me in chapter two for a full

839
00:39:05,307 --> 00:39:08,224
discussion of dependency injection.

840
00:39:09,074 --> 00:39:12,157
(light upbeat music)



1
00:00:00,000 --> 00:00:05,000
(electronic music)

2
00:00:09,978 --> 00:00:11,807
- [Voiceover] Welcome back to Chapter Two

3
00:00:11,807 --> 00:00:14,113
of the Spring Framework course.

4
00:00:14,113 --> 00:00:17,275
A fundamental principle
in Spring is called

5
00:00:17,275 --> 00:00:19,635
Dependency Injection.

6
00:00:19,635 --> 00:00:22,323
And in this chapter we'll be focusing on

7
00:00:22,323 --> 00:00:25,394
what that is and why it can help you build

8
00:00:25,394 --> 00:00:28,361
better software systems.

9
00:00:28,361 --> 00:00:30,752
We'll begin by looking at a problem

10
00:00:30,752 --> 00:00:33,618
that can affect your
software architecture.

11
00:00:33,618 --> 00:00:36,065
And that's called Coupling.

12
00:00:36,065 --> 00:00:37,972
Coupling is a bit scary

13
00:00:37,972 --> 00:00:40,717
in that you often allow it to creep

14
00:00:40,717 --> 00:00:44,149
into your system without realizing it.

15
00:00:44,149 --> 00:00:46,808
In this chapter I'm going to use

16
00:00:46,808 --> 00:00:49,827
a really simple example to illustrate

17
00:00:49,827 --> 00:00:51,766
what Coupling is.

18
00:00:51,766 --> 00:00:54,208
We will be working on much bigger

19
00:00:54,208 --> 00:00:57,035
examples in the rest of the course.

20
00:00:57,035 --> 00:00:59,698
Dependency Injection which is the most

21
00:00:59,698 --> 00:01:01,722
important concept in Spring,

22
00:01:01,722 --> 00:01:04,946
is designed to help with
the problem of Coupling.

23
00:01:04,946 --> 00:01:07,492
You might be surprised at how simple

24
00:01:07,492 --> 00:01:09,402
this really is.

25
00:01:09,402 --> 00:01:11,635
Most of it is just basic Java.

26
00:01:11,635 --> 00:01:13,677
At the end of the chapter,

27
00:01:13,677 --> 00:01:16,813
we'll meet the concept of a Container.

28
00:01:16,813 --> 00:01:20,721
Using a Container along
side Dependency Injection

29
00:01:20,721 --> 00:01:24,167
is a good solution to
the problem of Coupling.

30
00:01:24,167 --> 00:01:27,253
There won't be any Spring in this chapter,

31
00:01:27,253 --> 00:01:30,279
instead we're studying the concepts.

32
00:01:30,279 --> 00:01:32,687
But we'll see that Spring gives us one

33
00:01:32,687 --> 00:01:34,190
of these Containers,

34
00:01:34,190 --> 00:01:36,243
and that will set us up to use Spring

35
00:01:36,243 --> 00:01:39,380
for the first time in the next chapter.

36
00:01:42,040 --> 00:01:45,757
We're going to begin with
a very simple scenario.

37
00:01:45,757 --> 00:01:48,657
This is just going to be a small example

38
00:01:48,657 --> 00:01:51,712
to help me to explain about Coupling

39
00:01:51,712 --> 00:01:54,181
and Dependency Injection.

40
00:01:54,181 --> 00:01:56,999
We're not going to be
coding this application

41
00:01:56,999 --> 00:01:58,581
for the rest of the course,

42
00:01:58,581 --> 00:02:00,983
so there's no need to follow along yet.

43
00:02:00,983 --> 00:02:04,005
You can sit back and relax for a bit.

44
00:02:04,005 --> 00:02:07,150
We have an application
which is going to be

45
00:02:07,150 --> 00:02:10,359
managing invoices for a company.

46
00:02:10,359 --> 00:02:13,913
And the initial design
which I've sketched up here

47
00:02:13,913 --> 00:02:16,951
is just three classes.

48
00:02:16,951 --> 00:02:20,336
We're starting with the Client class,

49
00:02:20,336 --> 00:02:23,390
which for now will be just a stand alone

50
00:02:23,390 --> 00:02:25,983
Java console application.

51
00:02:25,983 --> 00:02:29,129
Eventually we'd probably make this into

52
00:02:29,129 --> 00:02:31,496
some kind of a webpage.

53
00:02:31,496 --> 00:02:36,303
But for now a text based
console application will do.

54
00:02:36,303 --> 00:02:40,519
We then, in the middle,
have a Service class.

55
00:02:40,519 --> 00:02:44,359
This is where the application
methods will appear.

56
00:02:44,359 --> 00:02:46,719
By application methods I mean

57
00:02:46,719 --> 00:02:50,204
the methods that the clients want to call.

58
00:02:50,204 --> 00:02:54,067
The application is
going to be storing data

59
00:02:54,067 --> 00:02:56,708
in a relational database.

60
00:02:56,708 --> 00:02:58,855
Following the normal Java

61
00:02:58,855 --> 00:03:02,078
or the normal software design pattern,

62
00:03:02,078 --> 00:03:06,036
we're using a D-A-O to hold

63
00:03:06,036 --> 00:03:08,710
the data access code.

64
00:03:08,710 --> 00:03:13,710
A D-A-O, or a DAO as
it's sometimes called,

65
00:03:14,369 --> 00:03:17,256
is a Data Access Object.

66
00:03:17,256 --> 00:03:19,441
The aim of this is to make sure

67
00:03:19,441 --> 00:03:22,479
that all of our database logic is stored

68
00:03:22,479 --> 00:03:24,272
in a single place.

69
00:03:24,272 --> 00:03:28,254
Let's say for example
that the save method here

70
00:03:28,254 --> 00:03:33,254
is going to be using
JDBC to persist the data.

71
00:03:33,820 --> 00:03:38,820
By the way, I don't know if
you're familiar with JDBC.

72
00:03:39,010 --> 00:03:42,542
That's quite a basic
library that we can use

73
00:03:42,542 --> 00:03:46,446
to access relational
databases from Java code.

74
00:03:46,446 --> 00:03:50,295
It's built in to the Java
library, which is good,

75
00:03:50,295 --> 00:03:53,859
but it is a bit of a pain to program.

76
00:03:53,859 --> 00:03:56,113
A simple design then.

77
00:03:56,113 --> 00:03:58,043
What we're going to do first

78
00:03:58,043 --> 00:04:01,916
is look at a naive way of implementing it.

79
00:04:01,916 --> 00:04:04,305
An obvious way of implementing it,

80
00:04:04,305 --> 00:04:07,375
but one which will cause some problems.

81
00:04:07,375 --> 00:04:10,041
We'll then have a look in detail

82
00:04:10,041 --> 00:04:12,542
at what those problems are

83
00:04:12,542 --> 00:04:14,884
and how we can do it better.

84
00:04:14,884 --> 00:04:17,933
Now because I'm just using Eclipse

85
00:04:17,933 --> 00:04:19,518
to show a concept here,

86
00:04:19,518 --> 00:04:22,929
you don't have to code
along with me right now.

87
00:04:22,929 --> 00:04:26,194
But, of course, you can if you want.

88
00:04:26,194 --> 00:04:28,045
So if you are following along with me,

89
00:04:28,045 --> 00:04:31,664
the easiest way is to fire up Eclipse,

90
00:04:31,664 --> 00:04:35,472
and when it asks for a workspace,

91
00:04:35,472 --> 00:04:37,254
the workspace you are looking for

92
00:04:37,254 --> 00:04:40,715
is the workspace for
Coupling that you will find

93
00:04:40,715 --> 00:04:44,631
in the Practicals and Code
folder for this course.

94
00:04:44,631 --> 00:04:49,631
Make sure you select the
workspace and not the project.

95
00:04:53,215 --> 00:04:55,656
But first you'll see
just an empty workspace,

96
00:04:55,656 --> 00:04:59,808
well I'll close the help tab first.

97
00:04:59,808 --> 00:05:02,703
Then you can go to File,

98
00:05:02,703 --> 00:05:04,465
select New,

99
00:05:04,465 --> 00:05:06,878
and then Java Project.

100
00:05:06,878 --> 00:05:08,899
On the dialog box here,

101
00:05:08,899 --> 00:05:12,838
type in the exact name
of the Project folder

102
00:05:12,838 --> 00:05:15,340
that's inside the workspace.

103
00:05:15,340 --> 00:05:20,308
And that happens to be Coupling Example.

104
00:05:20,308 --> 00:05:22,970
And be careful to include a capital C

105
00:05:22,970 --> 00:05:25,746
and a capital E.

106
00:05:25,746 --> 00:05:28,468
If you get this right
you'll see this text here

107
00:05:28,468 --> 00:05:32,858
indicates that the source for
the project already exists.

108
00:05:32,858 --> 00:05:35,652
Now if you don't see this message,

109
00:05:35,652 --> 00:05:38,712
check your spelling up here.

110
00:05:38,712 --> 00:05:42,062
If all is well, you can now click Finish.

111
00:05:43,272 --> 00:05:45,476
And you should now find source code

112
00:05:45,476 --> 00:05:48,846
in the Package Explorer.

113
00:05:48,846 --> 00:05:52,199
Now when we start writing
Spring code together,

114
00:05:52,199 --> 00:05:55,326
we'll usually be writing code from scratch

115
00:05:55,326 --> 00:05:57,005
here in Eclipse.

116
00:05:57,005 --> 00:06:00,569
But as in this chapter, I'm
just explaining the concept.

117
00:06:00,569 --> 00:06:02,706
I've already written some code

118
00:06:02,706 --> 00:06:04,970
before I started recording.

119
00:06:04,970 --> 00:06:08,096
We'll begin by looking at the domain class

120
00:06:08,096 --> 00:06:10,915
that we're working with
in this application,

121
00:06:10,915 --> 00:06:13,756
which was the Invoice class.

122
00:06:13,756 --> 00:06:18,511
I'll just close the task
list and the outline.

123
00:06:19,566 --> 00:06:21,305
Now this is our Invoice class

124
00:06:21,305 --> 00:06:25,334
and it's supposed to represent
an invoice for a customer.

125
00:06:25,334 --> 00:06:27,903
For the purposes of this simple exercise,

126
00:06:27,903 --> 00:06:31,073
I've made this classroom
very simple indeed.

127
00:06:31,073 --> 00:06:33,778
We have here just a few attributes,

128
00:06:33,778 --> 00:06:37,541
an invoice ID and a customer name.

129
00:06:37,541 --> 00:06:42,541
I also have a constructor, a
simple string implementation,

130
00:06:43,178 --> 00:06:47,039
and a couple of get methods.

131
00:06:47,039 --> 00:06:49,994
I'll be needing those in a few moments.

132
00:06:49,994 --> 00:06:52,925
And so very, very simple domain class.

133
00:06:52,925 --> 00:06:55,489
Now of course in a real application

134
00:06:55,489 --> 00:06:57,284
this would be much more involved

135
00:06:57,284 --> 00:06:59,233
and there would be quite a lot of

136
00:06:59,233 --> 00:07:01,465
business logic in there.

137
00:07:01,465 --> 00:07:05,345
Now let's switch across to the DAO,

138
00:07:05,345 --> 00:07:08,083
this is InvoicingDAO.

139
00:07:08,083 --> 00:07:10,738
For the purposes of this exercise,

140
00:07:10,738 --> 00:07:14,680
the implementation of this
class really doesn't matter,

141
00:07:14,680 --> 00:07:17,251
but what I did a few moments ago,

142
00:07:17,251 --> 00:07:19,439
was I threw together a very simple,

143
00:07:19,439 --> 00:07:22,504
quick and dirty implementation of a

144
00:07:22,504 --> 00:07:26,155
JDBC data access object.

145
00:07:26,155 --> 00:07:30,047
I'm just loading the driver
here in the constructor.

146
00:07:30,047 --> 00:07:34,878
And then in this Save method down here,

147
00:07:34,878 --> 00:07:37,139
I take in an instance of an invoice

148
00:07:37,139 --> 00:07:42,107
and then use the very ugly JDBC API

149
00:07:42,107 --> 00:07:45,798
to save that row into a database.

150
00:07:46,655 --> 00:07:49,567
Now please don't send in any messages

151
00:07:49,567 --> 00:07:52,959
complaining about our
implementation of this DAO.

152
00:07:52,959 --> 00:07:54,783
It's certainly not clean.

153
00:07:54,783 --> 00:07:56,637
It's certainly not perfect,

154
00:07:56,637 --> 00:07:58,413
but it should work.

155
00:07:58,413 --> 00:08:00,459
Now in this application,

156
00:08:00,459 --> 00:08:05,459
I have decided to use a
database called HSQLDB.

157
00:08:05,715 --> 00:08:10,202
You'll find a jar file for
that in the lib directory.

158
00:08:10,202 --> 00:08:14,653
And the reason I've used
HSQLDB is that it can

159
00:08:14,653 --> 00:08:18,477
create a database on the fly in memory

160
00:08:18,477 --> 00:08:20,546
and then at the end of program,

161
00:08:20,546 --> 00:08:23,633
the database is written to a file.

162
00:08:23,633 --> 00:08:28,633
You can run HSQLDB as a traditional server

163
00:08:29,115 --> 00:08:31,149
based database which is fine,

164
00:08:31,149 --> 00:08:34,788
but I like the idea of
an in-memory database

165
00:08:34,788 --> 00:08:38,311
for the course because
that means you don't

166
00:08:38,311 --> 00:08:40,957
have to worry about installing a database,

167
00:08:40,957 --> 00:08:44,400
configuring it and all the rest of it.

168
00:08:44,400 --> 00:08:47,536
If you want to use a database like Oracle

169
00:08:47,536 --> 00:08:52,293
or MySQL, you just go in
here and change the driver

170
00:08:52,293 --> 00:08:55,895
and the URL of the database.

171
00:08:55,895 --> 00:08:58,108
And everything else should still work.

172
00:08:58,108 --> 00:09:01,098
Feel free to do that if
you really want to do that.

173
00:09:01,098 --> 00:09:04,448
But I won't be able to give
you any support on that.

174
00:09:04,448 --> 00:09:06,653
The beauty of this workspace is that

175
00:09:06,653 --> 00:09:08,951
everything should run without needing any

176
00:09:08,951 --> 00:09:11,413
external dependencies.

177
00:09:11,413 --> 00:09:14,936
So, that's the DAO and the Invoice.

178
00:09:14,936 --> 00:09:17,089
Now let's look at the rest of the code.

179
00:09:17,089 --> 00:09:19,585
If you recall from the design,

180
00:09:19,585 --> 00:09:22,077
the design said that the clients are not

181
00:09:22,077 --> 00:09:25,149
going to call the DAO directly.

182
00:09:25,149 --> 00:09:26,893
Now that's good design.

183
00:09:26,893 --> 00:09:29,888
We wouldn't want the clients to be Coupled

184
00:09:29,888 --> 00:09:32,913
directly to the data access objects

185
00:09:32,913 --> 00:09:35,500
because if we wanted to change the data

186
00:09:35,500 --> 00:09:37,259
access strategy later on,

187
00:09:37,259 --> 00:09:40,947
maybe we might want to use
Hibernate in the future,

188
00:09:40,947 --> 00:09:44,747
then we'd have to go and
change all of the clients.

189
00:09:44,747 --> 00:09:48,660
It's good practice to have
an intermediate object

190
00:09:48,660 --> 00:09:53,660
and that's what we're calling
the Service Object right here.

191
00:09:54,740 --> 00:09:57,061
As you can see the implementation

192
00:09:57,061 --> 00:10:01,038
of the raise invoice method
is very simple indeed.

193
00:10:01,038 --> 00:10:04,655
We're just creating a
new instance of the DAO

194
00:10:04,655 --> 00:10:08,736
and then we're calling Save.

195
00:10:08,736 --> 00:10:11,046
However, going forward with this design,

196
00:10:11,046 --> 00:10:15,942
we may introduce some kind
of logic into this class,

197
00:10:15,942 --> 00:10:17,834
but this will do for now.

198
00:10:18,719 --> 00:10:22,373
Finally, we have the client
side of the application.

199
00:10:22,373 --> 00:10:25,742
Which, again, very simple indeed.

200
00:10:25,742 --> 00:10:29,382
I create a new instance
of the invoice service.

201
00:10:29,382 --> 00:10:34,177
Step two, I'm just creating
a test invoice here

202
00:10:34,177 --> 00:10:38,755
with the attributes
11075 for the invoice ID.

203
00:10:38,755 --> 00:10:41,953
And some customer name
for the second attributes.

204
00:10:41,953 --> 00:10:46,557
And then I'm passing that
on to the Service object.

205
00:10:46,557 --> 00:10:49,940
We have what looks on the face of it,

206
00:10:49,940 --> 00:10:53,499
fairly simple workable architecture.

207
00:10:53,499 --> 00:10:55,129
The zero?

208
00:10:55,129 --> 00:10:57,127
Well, we need to check that.

209
00:10:57,127 --> 00:10:59,003
So I'm going to run the application.

210
00:10:59,003 --> 00:11:00,446
Right click on the client,

211
00:11:00,446 --> 00:11:02,113
Run As

212
00:11:02,113 --> 00:11:04,621
and Java application.

213
00:11:06,681 --> 00:11:09,967
Now on some versions of
Eclipse there's a bit of a bug

214
00:11:09,967 --> 00:11:13,330
and it seems to have affected
my version of Eclipse.

215
00:11:13,330 --> 00:11:14,811
I did run the application,

216
00:11:14,811 --> 00:11:16,775
but nothing seems to have happened.

217
00:11:16,775 --> 00:11:20,457
But if I go to the Window, Show View,

218
00:11:20,457 --> 00:11:23,406
and I'm looking for Console,

219
00:11:23,406 --> 00:11:26,818
this line here is telling me that actually

220
00:11:26,818 --> 00:11:29,354
the program did run and it terminated

221
00:11:29,354 --> 00:11:31,093
without any errors.

222
00:11:31,093 --> 00:11:34,107
Now I want to check the database.

223
00:11:34,107 --> 00:11:37,736
As I mentioned, we're using HSQLDB here,

224
00:11:37,736 --> 00:11:39,902
which runs in memory.

225
00:11:39,902 --> 00:11:42,392
There's no need to run
any separate database.

226
00:11:42,392 --> 00:11:45,496
And what it will do at the
end of a successful run

227
00:11:45,496 --> 00:11:49,147
is it will write all of
the data into a file,

228
00:11:49,147 --> 00:11:53,023
and that file will be picked
up on subsequent runs.

229
00:11:53,023 --> 00:11:56,717
To see the database, click on the project

230
00:11:56,717 --> 00:11:58,601
and either click F5

231
00:11:58,601 --> 00:12:02,504
or right click and select Refresh.

232
00:12:03,917 --> 00:12:07,080
And you can see here that two new files

233
00:12:07,080 --> 00:12:08,774
have been created.

234
00:12:08,774 --> 00:12:12,351
The properties file
isn't very interesting.

235
00:12:12,351 --> 00:12:13,815
You could look at it if you want,

236
00:12:13,815 --> 00:12:16,518
but there's nothing of great use in there.

237
00:12:16,518 --> 00:12:18,888
But inside the script file...

238
00:12:18,888 --> 00:12:22,358
well actually this is
opening up in Notepad.

239
00:12:22,358 --> 00:12:24,767
If I want it to open up in Eclipse,

240
00:12:24,767 --> 00:12:26,615
I'll need to select Open With

241
00:12:26,615 --> 00:12:30,486
and I think it's Text Editor...

242
00:12:30,486 --> 00:12:32,861
yeah, that's now opening up in Eclipse.

243
00:12:32,861 --> 00:12:36,092
And you can see here there
is an insert statement

244
00:12:36,092 --> 00:12:39,170
with exactly the data
that we've just inserted

245
00:12:39,170 --> 00:12:41,203
from our previous run.

246
00:12:41,203 --> 00:12:43,648
Now what happens is when
we run this program again,

247
00:12:43,648 --> 00:12:46,692
HSQLDB will pass this script

248
00:12:46,692 --> 00:12:51,448
and it will use this to
regenerate the database.

249
00:12:51,448 --> 00:12:54,416
So, it certainly looks
like the program ran

250
00:12:54,416 --> 00:12:58,980
and we successfully got
data into our database.

251
00:12:58,980 --> 00:13:03,980
Okay, but I can think
of two serious problems

252
00:13:04,273 --> 00:13:06,980
with this naive way of working.

253
00:13:06,980 --> 00:13:09,620
One, we've got a really small program.

254
00:13:09,620 --> 00:13:12,880
It might not be obvious that
there is something wrong.

255
00:13:12,880 --> 00:13:16,883
But of course, over time,
this application is going

256
00:13:16,883 --> 00:13:20,336
to get bigger with many more classes added

257
00:13:20,336 --> 00:13:24,167
and I'm afraid that if we
continue working like this

258
00:13:24,167 --> 00:13:27,843
we're soon going to start
hitting some problems.

259
00:13:27,843 --> 00:13:31,970
The first problem is
that if our application

260
00:13:31,970 --> 00:13:35,305
continues to grow then changes are going

261
00:13:35,305 --> 00:13:37,270
to be difficult to make.

262
00:13:37,270 --> 00:13:40,342
Let's consider our DAO.

263
00:13:40,342 --> 00:13:43,770
Now, I deliberately set that this DAO

264
00:13:43,770 --> 00:13:47,195
is not a particularly good DAO.

265
00:13:47,195 --> 00:13:50,149
There's a lot of hard coding inside here,

266
00:13:50,149 --> 00:13:52,770
the SQL statements...

267
00:13:52,770 --> 00:13:55,976
the driver name and so on.

268
00:13:55,976 --> 00:13:58,749
Now, this is a really poor strategy

269
00:13:58,749 --> 00:14:01,652
for acquiring database connections.

270
00:14:01,652 --> 00:14:04,402
In a true Java application,

271
00:14:04,402 --> 00:14:07,165
we'd want to use a more sophisticated way

272
00:14:07,165 --> 00:14:09,152
of handling database connections,

273
00:14:09,152 --> 00:14:11,346
such as a connection port.

274
00:14:11,346 --> 00:14:13,707
Now, if you don't know
what one of those is,

275
00:14:13,707 --> 00:14:15,625
don't worry because we're going to be

276
00:14:15,625 --> 00:14:19,306
talking about that in
detail later in the course.

277
00:14:19,306 --> 00:14:21,697
But the point is I'm almost certain

278
00:14:21,697 --> 00:14:24,600
to need to change the code in this class.

279
00:14:24,600 --> 00:14:27,200
In fact, it's more than that.

280
00:14:27,200 --> 00:14:29,686
I probably would want to get rid of the

281
00:14:29,686 --> 00:14:33,710
entire class and start again from scratch.

282
00:14:33,710 --> 00:14:38,470
Let's say we decide to use
a better database strategy

283
00:14:38,470 --> 00:14:42,761
to use, maybe, hibernate
later in the future.

284
00:14:42,761 --> 00:14:44,692
Now in that case,

285
00:14:44,692 --> 00:14:46,261
rather than going into this class

286
00:14:46,261 --> 00:14:47,525
and changing things,

287
00:14:47,525 --> 00:14:51,957
we might decide to write a brand new DAO,

288
00:14:51,957 --> 00:14:54,318
called Hibernate DAO.

289
00:14:54,318 --> 00:14:56,906
Now, I'm just going to
do this for illustration,

290
00:14:56,906 --> 00:14:58,764
you don't need to follow along

291
00:14:58,764 --> 00:15:01,700
with this part of the course.

292
00:15:01,700 --> 00:15:06,699
So, I'm going to call this HibernateDAO.

293
00:15:06,699 --> 00:15:08,004
Now, although this class is going to be

294
00:15:08,004 --> 00:15:09,407
implemented differently,

295
00:15:09,407 --> 00:15:14,083
it will have the same
method as our previous DAO,

296
00:15:14,083 --> 00:15:16,462
which is going to be
the method called Save

297
00:15:16,462 --> 00:15:21,462
taking in an invoice which
I'm calling New Invoice.

298
00:15:22,066 --> 00:15:26,478
Now, I'm just going to
put a stub implementation

299
00:15:26,478 --> 00:15:29,180
in here just because for
now the implementation

300
00:15:29,180 --> 00:15:30,705
isn't important.

301
00:15:30,705 --> 00:15:31,823
But I'll just put in there,

302
00:15:31,823 --> 00:15:35,353
saving an invoice using Hibernate.

303
00:15:35,353 --> 00:15:37,829
In real life there would
be lots of Hibernate

304
00:15:37,829 --> 00:15:39,656
code appearing here.

305
00:15:39,656 --> 00:15:44,656
So we now have a brand new
way of saving invoices.

306
00:15:45,267 --> 00:15:47,043
Now the huge problem is that

307
00:15:47,043 --> 00:15:48,904
in order to make this change

308
00:15:48,904 --> 00:15:50,598
become part of the system,

309
00:15:50,598 --> 00:15:55,455
I now have to go across to
the invoice Service class

310
00:15:55,455 --> 00:15:58,547
and I need to make changes.

311
00:15:58,547 --> 00:16:01,327
And the changes I would need to make...

312
00:16:01,327 --> 00:16:03,511
I would need to change the class name here

313
00:16:03,511 --> 00:16:06,810
to HibernateDAO,

314
00:16:08,260 --> 00:16:10,257
and I would have to change the class name

315
00:16:10,257 --> 00:16:14,797
here as well to HibernateDAO.

316
00:16:14,797 --> 00:16:16,482
And now I would have to recompile

317
00:16:16,482 --> 00:16:18,953
and test my changes.

318
00:16:18,953 --> 00:16:21,470
Now of course this looks very simple here,

319
00:16:21,470 --> 00:16:23,729
but that's because we've only just started

320
00:16:23,729 --> 00:16:25,248
with this application.

321
00:16:25,248 --> 00:16:28,682
Consider that change in
a full blown application

322
00:16:28,682 --> 00:16:32,483
where we might well be
calling the DAO from dozens,

323
00:16:32,483 --> 00:16:36,426
or possibly even hundreds of classes.

324
00:16:36,426 --> 00:16:39,156
Certainly, hundreds of methods.

325
00:16:39,156 --> 00:16:42,152
This would be a really
painful change to make.

326
00:16:42,152 --> 00:16:44,819
And the reason that this change is painful

327
00:16:44,819 --> 00:16:47,984
is because we've hard coded the specific

328
00:16:47,984 --> 00:16:51,878
implementation classes here into the code.

329
00:16:51,878 --> 00:16:56,344
Now, for large scale projects,
this is not desirable.

330
00:16:56,344 --> 00:16:58,961
The next problem with this architecture

331
00:16:58,961 --> 00:17:03,208
is that it's likely to
be difficult to unit test

332
00:17:03,208 --> 00:17:05,428
any of our service classes.

333
00:17:05,428 --> 00:17:09,094
With unit tests we need to be able to test

334
00:17:09,094 --> 00:17:13,684
in isolation one object at a time.

335
00:17:13,684 --> 00:17:16,422
So, in the case of the invoice service,

336
00:17:16,422 --> 00:17:20,060
all I want to do is test this one class

337
00:17:20,060 --> 00:17:24,779
and have no dependences on
the external environment.

338
00:17:24,779 --> 00:17:27,486
Now, at the moment there
isn't any interesting

339
00:17:27,486 --> 00:17:29,504
logic in this service class,

340
00:17:29,504 --> 00:17:32,385
so really there's nothing to test.

341
00:17:32,385 --> 00:17:34,493
But I'd just like you
to imagine that possibly

342
00:17:34,493 --> 00:17:37,683
after calling this Save Method,

343
00:17:37,683 --> 00:17:42,683
we might apply some logic to the invoice

344
00:17:42,755 --> 00:17:45,422
and, I don't know,

345
00:17:45,422 --> 00:17:46,346
it could be something like,

346
00:17:46,346 --> 00:17:50,039
if the invoice is in an invalid state

347
00:17:50,039 --> 00:17:53,666
a not-valid state after it's been saved,

348
00:17:53,666 --> 00:17:56,887
then we might throw an
exception back to the client.

349
00:17:56,887 --> 00:17:59,436
Now that is definite logic.

350
00:17:59,436 --> 00:18:01,213
And I would want to be able to test

351
00:18:01,213 --> 00:18:03,747
that that works correctly.

352
00:18:03,747 --> 00:18:07,180
Now, I'm assuming that
you're reasonably familiar

353
00:18:07,180 --> 00:18:11,068
already with the concepts of unit testing.

354
00:18:11,068 --> 00:18:15,452
If not, we do cover it in
our Java fundamentals course.

355
00:18:15,452 --> 00:18:17,704
I'll go very quickly through the basics

356
00:18:17,704 --> 00:18:20,412
of the kind of thing you might do.

357
00:18:20,412 --> 00:18:24,595
We would Create a new class
specifically for testing.

358
00:18:24,595 --> 00:18:26,574
And this is built in to Eclipse.

359
00:18:26,574 --> 00:18:29,695
We can select JUnit Test Case.

360
00:18:31,225 --> 00:18:33,980
I'm going to go for a JUnit 4 Test

361
00:18:33,980 --> 00:18:35,915
and it's automatically called the

362
00:18:35,915 --> 00:18:39,367
Class Invoice Service Test.

363
00:18:39,367 --> 00:18:41,335
I'll just click Finish there.

364
00:18:41,335 --> 00:18:43,447
And because this is the first time

365
00:18:43,447 --> 00:18:45,855
I've created a JUnit Test,

366
00:18:45,855 --> 00:18:47,793
it's asking me if I want to add

367
00:18:47,793 --> 00:18:49,602
JUnit to the build path.

368
00:18:49,602 --> 00:18:52,430
I do, so I will click Okay.

369
00:18:52,430 --> 00:18:55,765
Now, in a real project we'd definitely

370
00:18:55,765 --> 00:18:58,117
have these tests in a separate package,

371
00:18:58,117 --> 00:19:01,101
but for this example it should be okay.

372
00:19:01,101 --> 00:19:04,336
Now we write a test method for every piece

373
00:19:04,336 --> 00:19:07,495
of interesting functionality in the object

374
00:19:07,495 --> 00:19:09,158
we're trying to test.

375
00:19:09,158 --> 00:19:12,117
So, for example I might be doing something

376
00:19:12,117 --> 00:19:17,117
like test that's sending
an invalid invoice

377
00:19:17,516 --> 00:19:22,363
will throw an exception.

378
00:19:22,363 --> 00:19:25,517
Unit tests have quite long
names for these tests.

379
00:19:25,517 --> 00:19:27,694
And the general idea
inside each test method

380
00:19:27,694 --> 00:19:31,101
is we would create a new instance

381
00:19:32,031 --> 00:19:34,121
of the class that we're trying to test.

382
00:19:34,121 --> 00:19:36,799
So in this case it's the service...

383
00:19:40,514 --> 00:19:44,023
if I can spell invoice service correct,

384
00:19:44,023 --> 00:19:46,985
and then I'll need to
create some test dates.

385
00:19:46,985 --> 00:19:49,128
And so I'm going to create an invoice

386
00:19:49,128 --> 00:19:51,070
and this is going to be deliberately

387
00:19:51,070 --> 00:19:53,953
an invalid invoice.

388
00:19:54,873 --> 00:19:58,124
Now, because we're not
really writing this system,

389
00:19:58,124 --> 00:20:00,531
I don't know what makes
an invalid invoice.

390
00:20:00,531 --> 00:20:03,101
But, let's say, for example,

391
00:20:03,101 --> 00:20:06,672
that an invoice ID should be a number.

392
00:20:06,672 --> 00:20:10,020
But in this case we've added a letter

393
00:20:10,020 --> 00:20:12,200
to the end of the invoice ID.

394
00:20:12,200 --> 00:20:14,683
I think we also need to supply a name

395
00:20:14,683 --> 00:20:16,593
in the constructor there.

396
00:20:16,593 --> 00:20:19,425
So what should happen now

397
00:20:19,425 --> 00:20:23,410
is if I called the service's
raise invoice method,

398
00:20:23,410 --> 00:20:26,133
passing in this invalid invoice,

399
00:20:26,133 --> 00:20:28,787
we should get an exception.

400
00:20:28,787 --> 00:20:31,412
And I won't go into
details on how to do this,

401
00:20:31,412 --> 00:20:36,412
but we could test here that
an exception is thrown.

402
00:20:37,919 --> 00:20:41,429
Now this doesn't really
work as a unit test at all.

403
00:20:41,429 --> 00:20:44,811
And it doesn't work because
by running the test,

404
00:20:44,811 --> 00:20:49,070
we will be unavoidably
accessing the environment.

405
00:20:49,070 --> 00:20:53,461
In this case we will be
writing data to the database.

406
00:20:53,461 --> 00:20:55,602
Let me illustrate that by,

407
00:20:55,602 --> 00:20:58,317
if I just go back into my invoice service.

408
00:20:58,317 --> 00:21:01,113
At the moment I'm using this HibernateDAO,

409
00:21:01,113 --> 00:21:02,730
but I'm going to change it back

410
00:21:02,730 --> 00:21:07,008
to our original invoicingDAO.

411
00:21:07,008 --> 00:21:09,854
Which you'll remember really does write

412
00:21:09,854 --> 00:21:12,393
to the database.

413
00:21:14,032 --> 00:21:16,954
Now, if I run this test,

414
00:21:16,954 --> 00:21:19,206
and I can do that just by Right clicking

415
00:21:19,206 --> 00:21:22,696
and Run As JUnit Test.

416
00:21:24,678 --> 00:21:26,337
Now, the test is run;

417
00:21:26,337 --> 00:21:28,425
and it's passing just
because we're not doing

418
00:21:28,425 --> 00:21:30,346
anything that might fail at the minute.

419
00:21:30,346 --> 00:21:33,112
The test ran but the problem is,

420
00:21:33,112 --> 00:21:36,093
of course if we look at
the database script now,

421
00:21:36,093 --> 00:21:38,806
we've written some data there.

422
00:21:38,806 --> 00:21:41,717
There's Jack Jones
written into the database.

423
00:21:41,717 --> 00:21:45,520
Now, consider that this could
be a production database,

424
00:21:45,520 --> 00:21:49,378
we've just now polluted the
database with test data.

425
00:21:49,378 --> 00:21:54,311
The other thing is tests, of
course, tend to run often.

426
00:21:54,311 --> 00:21:57,496
Every time I make a minor
change to the application,

427
00:21:57,496 --> 00:22:00,403
I'm likely to want to run the test again.

428
00:22:00,403 --> 00:22:05,403
So, I'll just simulate
that by running the test

429
00:22:05,544 --> 00:22:09,784
a few times which we
certainly expect to happen

430
00:22:09,784 --> 00:22:11,515
while we're developing.

431
00:22:11,515 --> 00:22:13,554
I think you can guess what's happened now

432
00:22:13,554 --> 00:22:15,244
if we go across to the database

433
00:22:15,244 --> 00:22:17,266
and look in the script again,

434
00:22:17,266 --> 00:22:19,754
I really have polluted the database

435
00:22:19,754 --> 00:22:22,044
with lots of test data.

436
00:22:22,044 --> 00:22:24,208
This is not good at all.

437
00:22:24,208 --> 00:22:28,171
Now, I could go back to the code,

438
00:22:28,171 --> 00:22:30,063
back to the test

439
00:22:30,063 --> 00:22:34,154
and I could, in the
test, do something like

440
00:22:34,154 --> 00:22:37,128
go to the database and delete the rows

441
00:22:37,128 --> 00:22:39,788
that I put in when the test is finished.

442
00:22:39,788 --> 00:22:41,816
But that would get really messy

443
00:22:41,816 --> 00:22:43,770
and would still be dangerous,

444
00:22:43,770 --> 00:22:47,579
especially if we're working
with a production database.

445
00:22:47,579 --> 00:22:50,141
A more subtle problem with this

446
00:22:50,141 --> 00:22:54,206
is that Unit tests need
to run as fast as possible

447
00:22:54,206 --> 00:22:57,446
because we're going to
be running them often.

448
00:22:57,446 --> 00:23:01,770
Because our Unit test is
now writing to a database,

449
00:23:01,770 --> 00:23:05,317
this Unit test is going
to run really slowly.

450
00:23:05,317 --> 00:23:10,317
Well, okay, it maybe doesn't
look that slow right now.

451
00:23:12,859 --> 00:23:15,713
I don't know if you think
that was fast or not,

452
00:23:15,713 --> 00:23:17,739
but with a few more tests in place,

453
00:23:17,739 --> 00:23:19,981
we're going to start to feel the overhead

454
00:23:19,981 --> 00:23:23,151
of these unnecessary
trips to the database.

455
00:23:23,151 --> 00:23:27,183
And it is quite a common
complaint on real world projects

456
00:23:27,183 --> 00:23:30,324
that "Oh, we've stopped
running our Unit tests

457
00:23:30,324 --> 00:23:33,555
"because they take an hour to run."

458
00:23:33,555 --> 00:23:36,461
And often the reason that's happened

459
00:23:36,461 --> 00:23:40,933
is because their Unit tests
aren't really unit tests.

460
00:23:40,933 --> 00:23:44,139
They've started accessing
external resources like

461
00:23:44,139 --> 00:23:49,053
files and databases so they're
naturally running slowly.

462
00:23:49,053 --> 00:23:53,683
So, I've talked about two
problems with the architecture,

463
00:23:53,683 --> 00:23:57,181
but really the two problems
are the same problem,

464
00:23:57,181 --> 00:23:59,668
the same fundamental problem;

465
00:23:59,668 --> 00:24:04,291
and this fundamental problem is Coupling.

466
00:24:04,291 --> 00:24:06,507
Now Coupling is when two classes

467
00:24:06,507 --> 00:24:10,116
are dependent upon each other.

468
00:24:10,116 --> 00:24:14,142
And put simply, if you
need to change one class,

469
00:24:14,142 --> 00:24:18,299
then you might need to
change the other class.

470
00:24:18,299 --> 00:24:22,626
Now, we need Coupling in any application.

471
00:24:22,626 --> 00:24:25,973
Otherwise all of your
classes would be disconnected

472
00:24:25,973 --> 00:24:27,572
from all of the other classes.

473
00:24:27,572 --> 00:24:29,517
And without talking to each other,

474
00:24:29,517 --> 00:24:33,433
the classes aren't going
to be very effective.

475
00:24:33,433 --> 00:24:35,360
We need some Coupling.

476
00:24:35,360 --> 00:24:38,723
But the trick is to reduce
Coupling as much as possible.

477
00:24:38,723 --> 00:24:43,613
It's unnecessary Coupling
that's a bad thing.

478
00:24:43,613 --> 00:24:45,216
Why?

479
00:24:45,216 --> 00:24:47,863
Well, systems with a lot of Coupling

480
00:24:47,863 --> 00:24:50,239
tend to be brittle.

481
00:24:50,239 --> 00:24:53,772
Changes tend to ripple across the design,

482
00:24:53,772 --> 00:24:55,657
and I think we've all been there.

483
00:24:55,657 --> 00:24:57,536
You know when you change one class

484
00:24:57,536 --> 00:24:59,772
and you end up having to change lots

485
00:24:59,772 --> 00:25:01,582
of other classes that you didn't think

486
00:25:01,582 --> 00:25:04,357
you should've affected.

487
00:25:04,357 --> 00:25:09,357
Now, as we've seen, Coupled
systems get hard to test.

488
00:25:09,925 --> 00:25:11,904
Because when you're testing,

489
00:25:11,904 --> 00:25:13,217
one thing you really want to do

490
00:25:13,217 --> 00:25:17,591
is to be able to look at one
single class in isolation.

491
00:25:17,591 --> 00:25:20,416
If the classes are coupled together,

492
00:25:20,416 --> 00:25:24,973
then it's very difficult
to tease them apart.

493
00:25:24,973 --> 00:25:28,203
Now, it's important to
mention that Coupling

494
00:25:28,203 --> 00:25:30,642
can't be eradicated completely.

495
00:25:30,642 --> 00:25:35,187
We do need some degree of
Coupling in any system.

496
00:25:35,187 --> 00:25:38,600
For example, the following code,

497
00:25:38,600 --> 00:25:42,565
perfectly normal, straight forward Java,

498
00:25:42,565 --> 00:25:44,913
but there's Coupling here.

499
00:25:44,913 --> 00:25:49,913
Here, we've coupled our code
to the Java string class.

500
00:25:50,635 --> 00:25:54,663
Now as you know of course this
is part of the Java library.

501
00:25:54,663 --> 00:25:58,612
And this class is outside of our control.

502
00:25:58,612 --> 00:26:00,386
Now, this is coupling,

503
00:26:00,386 --> 00:26:04,788
because if the string
class were ever modified,

504
00:26:04,788 --> 00:26:07,204
let's say someone in charge of Java

505
00:26:07,204 --> 00:26:10,889
removes one of the methods
from the string class.

506
00:26:10,889 --> 00:26:14,043
Then, our code might break.

507
00:26:14,043 --> 00:26:15,879
However, do you care?

508
00:26:15,879 --> 00:26:17,812
No, probably not.

509
00:26:17,812 --> 00:26:20,807
We can almost always accept this.

510
00:26:20,807 --> 00:26:24,016
The string class is unlikely to vary.

511
00:26:24,016 --> 00:26:27,282
The Java people at Oracle would never dare

512
00:26:27,282 --> 00:26:31,057
mess around with the string class.

513
00:26:31,057 --> 00:26:35,232
But anyway, we generally
accept that the string class

514
00:26:35,232 --> 00:26:36,995
is what we need here.

515
00:26:36,995 --> 00:26:39,193
Some classes just live together

516
00:26:39,193 --> 00:26:42,217
and their coupled together
by their very nature.

517
00:26:42,217 --> 00:26:44,931
For example, in this domain model,

518
00:26:44,931 --> 00:26:47,749
we might have a customer class

519
00:26:47,749 --> 00:26:49,867
and an order class.

520
00:26:49,867 --> 00:26:54,695
Now, as we know, customers raise orders.

521
00:26:54,695 --> 00:26:58,452
It's a natural real world relationship.

522
00:26:58,452 --> 00:27:02,084
So therefore I think it's only natural

523
00:27:02,084 --> 00:27:05,896
that these classes should be coupled

524
00:27:05,896 --> 00:27:08,007
together in the code.

525
00:27:08,007 --> 00:27:10,043
And as you can see here,

526
00:27:10,043 --> 00:27:13,851
the Customer class is
creating new instances

527
00:27:13,851 --> 00:27:17,937
of the Order class on the
line I'm highlighting here.

528
00:27:17,937 --> 00:27:20,411
And I think that's absolutely fine.

529
00:27:20,411 --> 00:27:23,913
It is coupling, but we accept it.

530
00:27:23,913 --> 00:27:27,008
Now, what we're really
interested in for this course

531
00:27:27,008 --> 00:27:28,798
is what I'm going to call,

532
00:27:28,798 --> 00:27:32,145
The Architectural Coupling.

533
00:27:32,145 --> 00:27:35,772
That's the coupling between
the tiers of our application.

534
00:27:35,772 --> 00:27:38,175
Such as, for in our example,

535
00:27:38,175 --> 00:27:42,370
the Service tier and the DAO tier.

536
00:27:42,370 --> 00:27:46,947
It's almost always
desirable to decouple here,

537
00:27:46,947 --> 00:27:49,311
because we probably want to be able

538
00:27:49,311 --> 00:27:51,346
to change things around.

539
00:27:51,346 --> 00:27:53,013
We want to change one tier

540
00:27:53,013 --> 00:27:56,298
without affecting the other tiers.

541
00:27:56,298 --> 00:27:58,606
Now in our example system we've already

542
00:27:58,606 --> 00:28:01,881
identified that there
are at least two reasons

543
00:28:01,881 --> 00:28:05,976
why this DAO class, this dependent class,

544
00:28:05,976 --> 00:28:08,108
might need to change.

545
00:28:08,108 --> 00:28:10,100
Just to remind you, first of all,

546
00:28:10,100 --> 00:28:12,623
we might want to change the strategy

547
00:28:12,623 --> 00:28:17,171
that this DAO object uses
to access the database.

548
00:28:17,171 --> 00:28:21,071
Secondly, we might need
to test the service class

549
00:28:21,071 --> 00:28:24,122
without the DAO being present.

550
00:28:24,122 --> 00:28:26,401
But we can't make these changes

551
00:28:26,401 --> 00:28:30,488
because we've coupled the
two classes together hard.

552
00:28:30,488 --> 00:28:34,560
The line of code here, with a new keyword,

553
00:28:34,560 --> 00:28:37,218
is almost like we're
taking these two classes

554
00:28:37,218 --> 00:28:40,248
and we're fusing them together.

555
00:28:40,248 --> 00:28:42,937
We need more flexibility here.

556
00:28:42,937 --> 00:28:45,758
So how can we reduce coupling?

557
00:28:45,758 --> 00:28:49,339
Well, there are three steps we can apply.

558
00:28:49,339 --> 00:28:51,634
And over the next few moments

559
00:28:51,634 --> 00:28:54,252
we're going to look at each step in turn.

560
00:28:54,252 --> 00:28:57,933
Now, I should stress that
each of the three steps

561
00:28:57,933 --> 00:29:00,834
on their own is not enough.

562
00:29:00,834 --> 00:29:05,070
We're going to need to do
all three steps together.

563
00:29:05,070 --> 00:29:07,769
Step one, is going to be

564
00:29:07,769 --> 00:29:12,008
we're going to program to interfaces.

565
00:29:12,008 --> 00:29:17,008
Step two, is going to
be dependency injection.

566
00:29:18,780 --> 00:29:20,533
And step three,

567
00:29:20,533 --> 00:29:22,545
and this is where Spring is going to help,

568
00:29:22,545 --> 00:29:26,887
is to centralize the
configuration of our application.

569
00:29:26,887 --> 00:29:29,168
Now let's have a look at each of

570
00:29:29,168 --> 00:29:31,354
these three steps in turn.

571
00:29:31,354 --> 00:29:35,634
Step one then is
programming to an interface.

572
00:29:35,634 --> 00:29:39,248
Now this is actually just standard Java.

573
00:29:39,248 --> 00:29:42,689
So I'll assume you know
most of this already.

574
00:29:42,689 --> 00:29:46,417
We do cover this in our
Java fundamentals course.

575
00:29:46,417 --> 00:29:49,703
An interface in Java allows us to define

576
00:29:49,703 --> 00:29:53,211
just the specifications of the class

577
00:29:53,211 --> 00:29:56,227
without providing an implementation.

578
00:29:56,227 --> 00:29:59,738
It's almost like making
a design of the class,

579
00:29:59,738 --> 00:30:02,055
but putting that design into the Java.

580
00:30:02,055 --> 00:30:05,616
For example, here I've
written an interface

581
00:30:05,616 --> 00:30:08,052
describing what I would like an invoice

582
00:30:08,052 --> 00:30:10,605
data access object to look like.

583
00:30:10,605 --> 00:30:13,199
I'd like it to have a method called save,

584
00:30:13,199 --> 00:30:14,746
a method called delete,

585
00:30:14,746 --> 00:30:16,903
and a method called update.

586
00:30:16,903 --> 00:30:20,598
Then, what I would
typically do is to create

587
00:30:20,598 --> 00:30:23,175
implementations, one or more of them,

588
00:30:23,175 --> 00:30:25,414
of this interface.

589
00:30:25,414 --> 00:30:28,061
Then I can create as many as I like.

590
00:30:28,061 --> 00:30:31,643
Then by referring to just the interface

591
00:30:31,643 --> 00:30:33,898
wherever possible through the code,

592
00:30:33,898 --> 00:30:36,649
we can then switch the implementations

593
00:30:36,649 --> 00:30:40,346
around at run time to suit our needs.

594
00:30:40,346 --> 00:30:42,483
So let's have a look in Eclipse.

595
00:30:42,483 --> 00:30:46,018
Here, I've created my interface

596
00:30:46,018 --> 00:30:48,344
and I did this off camera so you wouldn't

597
00:30:48,344 --> 00:30:50,582
get bored watching me typing.

598
00:30:50,582 --> 00:30:53,353
If you're following along
then you can do the same,

599
00:30:53,353 --> 00:30:55,642
or you can find it from
the complete version

600
00:30:55,642 --> 00:30:59,271
of this project in the
practicals and code folder.

601
00:30:59,271 --> 00:31:02,008
It's exactly the same as you saw

602
00:31:02,008 --> 00:31:04,990
on the screen shot before.

603
00:31:04,990 --> 00:31:07,316
The key thing is now
when I come to implement

604
00:31:07,316 --> 00:31:09,969
the data access objects,

605
00:31:09,969 --> 00:31:14,041
for instance my JDBC version here...

606
00:31:14,041 --> 00:31:16,547
Oh, and by the way, I've also off camera,

607
00:31:16,547 --> 00:31:21,547
renamed this class to
make it more meaningful.

608
00:31:21,733 --> 00:31:26,017
I'm saying that this is
the JDBC implementation

609
00:31:26,017 --> 00:31:28,721
of the Invoicing DAO.

610
00:31:28,721 --> 00:31:30,201
If you need to do that,

611
00:31:30,201 --> 00:31:31,742
you can right click on any class,

612
00:31:31,742 --> 00:31:36,334
select Refactor and Rename.

613
00:31:37,198 --> 00:31:39,521
And what I would do now is you use the

614
00:31:39,521 --> 00:31:42,058
implements keyword to tell Java

615
00:31:42,058 --> 00:31:44,153
that this is implementing

616
00:31:44,153 --> 00:31:48,594
the invoicing DAO interface.

617
00:31:49,458 --> 00:31:51,295
Now, though I haven't mentioned it before,

618
00:31:51,295 --> 00:31:53,451
if I go down in this class,

619
00:31:53,451 --> 00:31:56,294
you'll see that there are implementations

620
00:31:56,294 --> 00:31:59,210
of the Delete and Update methods

621
00:31:59,210 --> 00:32:02,675
although they don't do
anything useful just yet.

622
00:32:02,675 --> 00:32:06,755
Now if we go across to our Hibernate DAO,

623
00:32:06,755 --> 00:32:09,755
remember this is the
alternative implementation

624
00:32:09,755 --> 00:32:12,409
that we have of a data access object.

625
00:32:12,409 --> 00:32:15,035
I would do exactly the same thing here,

626
00:32:15,035 --> 00:32:17,504
in that this is also going to implement

627
00:32:17,504 --> 00:32:22,170
the invoicing DAO interface.

628
00:32:22,170 --> 00:32:26,865
Now at the moment, I have
an error in my code here

629
00:32:26,865 --> 00:32:29,247
and that's because I haven't included

630
00:32:29,247 --> 00:32:32,947
the delete method and the update method.

631
00:32:32,947 --> 00:32:35,542
The great thing is I can use Eclipse

632
00:32:35,542 --> 00:32:37,990
to automatically fix this problem.

633
00:32:37,990 --> 00:32:40,912
I've just hovered over the red line there,

634
00:32:40,912 --> 00:32:43,094
and it's given me a quick fix

635
00:32:43,094 --> 00:32:47,069
of adding the unimplemented methods.

636
00:32:47,069 --> 00:32:50,262
And it automatically fills
in the implementation.

637
00:32:50,262 --> 00:32:53,770
Now, just for the purposes
of this demonstration

638
00:32:53,770 --> 00:32:55,891
I'm going to leave these two methods

639
00:32:55,891 --> 00:32:59,244
as stubs with nothing in them,

640
00:32:59,244 --> 00:33:02,041
but the key point is I was forced

641
00:33:02,041 --> 00:33:04,840
to implement them by Java.

642
00:33:04,840 --> 00:33:08,083
Now, switching across
to the invoice service

643
00:33:08,083 --> 00:33:11,420
where we're actually using the DAO,

644
00:33:11,420 --> 00:33:15,942
notice that the moment I'm hard coding

645
00:33:15,942 --> 00:33:20,942
the specific concrete class
name that I want to use.

646
00:33:21,408 --> 00:33:23,792
Now we know now that's coupling

647
00:33:23,792 --> 00:33:25,645
and it's not good.

648
00:33:25,645 --> 00:33:28,667
So instead, I'm going
to follow the principle

649
00:33:28,667 --> 00:33:31,508
of programming to an interface.

650
00:33:31,508 --> 00:33:34,525
And all that means is I'm going to refer

651
00:33:34,525 --> 00:33:37,465
where possible to the interface

652
00:33:37,465 --> 00:33:39,868
rather than the implementation.

653
00:33:39,868 --> 00:33:42,774
I can do that here on the left hand side

654
00:33:42,774 --> 00:33:46,242
by making that now be just a reference

655
00:33:46,242 --> 00:33:48,540
to the invoicing DAO.

656
00:33:48,540 --> 00:33:51,282
Notice the code still compiles.

657
00:33:51,282 --> 00:33:56,120
Now this is our first
loosening of the coupling.

658
00:33:56,120 --> 00:33:59,857
I'm trying to say here that I don't care

659
00:33:59,857 --> 00:34:03,113
about the specific implementation class

660
00:34:03,113 --> 00:34:04,832
that's being used.

661
00:34:04,832 --> 00:34:08,110
That's not enough on its own.

662
00:34:08,110 --> 00:34:10,955
Notice we are still referring to the

663
00:34:10,955 --> 00:34:13,667
concrete class name here.

664
00:34:13,667 --> 00:34:17,464
At some point we have
to create the objects.

665
00:34:17,464 --> 00:34:20,682
Have a look there at the new keyword.

666
00:34:20,682 --> 00:34:24,433
Now the new keyword is
always a sign of coupling.

667
00:34:24,433 --> 00:34:27,613
Without recompiling this code,

668
00:34:27,613 --> 00:34:29,366
there would be no way of changing

669
00:34:29,366 --> 00:34:31,679
that implementing class.

670
00:34:31,679 --> 00:34:34,125
So that means we still have coupling here.

671
00:34:34,125 --> 00:34:36,418
So step one was necessary,

672
00:34:36,418 --> 00:34:39,016
but it's only one step.

673
00:34:39,016 --> 00:34:41,487
This is going to lead us to step two,

674
00:34:41,487 --> 00:34:44,867
which is called Dependency Injection.

675
00:34:44,867 --> 00:34:48,088
Dependency Injection is nothing more

676
00:34:48,088 --> 00:34:51,950
than a fancy term that means to pass in

677
00:34:51,950 --> 00:34:55,905
the collaborating objects as parameters

678
00:34:55,905 --> 00:34:58,973
rather than hard coding them.

679
00:34:58,973 --> 00:35:02,163
Although Dependency Injection sounds like

680
00:35:02,163 --> 00:35:05,221
a really big and fancy term,

681
00:35:05,221 --> 00:35:08,284
it's actually really simple Java.

682
00:35:08,284 --> 00:35:10,062
Let's switch across to Eclipse

683
00:35:10,062 --> 00:35:12,111
and see how it works.

684
00:35:12,111 --> 00:35:14,406
So back to our service.

685
00:35:14,406 --> 00:35:16,991
One thing that's odd in here at the moment

686
00:35:16,991 --> 00:35:19,109
is that if we have more than one method

687
00:35:19,109 --> 00:35:20,891
and of course we probably will.

688
00:35:20,891 --> 00:35:22,858
Let's say there was also in here

689
00:35:22,858 --> 00:35:27,027
a void method called update invoice.

690
00:35:27,027 --> 00:35:32,027
And maybe this takes an updated invoice.

691
00:35:32,417 --> 00:35:36,710
Now we would need a DAO in here as well.

692
00:35:36,710 --> 00:35:40,038
So we could copy and paste the code here,

693
00:35:40,038 --> 00:35:43,927
add it to here and maybe go ahead

694
00:35:43,927 --> 00:35:48,774
and call the method on the DAO.

695
00:35:49,672 --> 00:35:52,698
But that's just repetition.

696
00:35:52,698 --> 00:35:55,436
So, what I'll do to tidy this code up

697
00:35:55,436 --> 00:35:59,784
is to make the DAO become
an attribute of the class

698
00:35:59,784 --> 00:36:03,947
because it's silly, really,
creating this DAO twice.

699
00:36:03,947 --> 00:36:06,180
So I'll make it an attribute,

700
00:36:06,180 --> 00:36:10,838
type being invoice DAO that's programming

701
00:36:10,838 --> 00:36:12,470
to an interface again.

702
00:36:12,470 --> 00:36:15,611
And I'll call the attribute DAO...

703
00:36:15,611 --> 00:36:20,307
sorry, that's called invoicing DAO.

704
00:36:21,327 --> 00:36:23,309
And then I don't need this line of code

705
00:36:23,309 --> 00:36:26,139
here or here.

706
00:36:26,139 --> 00:36:28,828
So that's a bit tidier.

707
00:36:28,828 --> 00:36:31,330
Now of course I'm going to have to create

708
00:36:31,330 --> 00:36:34,084
the invoicing DAO objects.

709
00:36:34,084 --> 00:36:36,430
So I could instantiate it here

710
00:36:36,430 --> 00:36:39,467
and as before, we'd have to choose

711
00:36:39,467 --> 00:36:42,803
which implementation we want to work with.

712
00:36:42,803 --> 00:36:47,187
So I'm going to go for
the JDBC version here.

713
00:36:47,187 --> 00:36:51,420
Remember though that it's
this new keyword here

714
00:36:51,420 --> 00:36:53,795
that's the statements of concern.

715
00:36:53,795 --> 00:36:56,995
This is where the coupling comes in.

716
00:36:56,995 --> 00:37:01,204
Now, all I'm suggesting
with dependency injection

717
00:37:01,204 --> 00:37:05,842
is that we're going to
stop creating the objects,

718
00:37:05,842 --> 00:37:08,131
the DAO in this class.

719
00:37:08,131 --> 00:37:10,336
I'll remove that.

720
00:37:10,336 --> 00:37:14,638
And instead, we're going
to provide a method

721
00:37:14,638 --> 00:37:16,457
a public void method,

722
00:37:16,457 --> 00:37:21,457
which by convention
we're going to call Set,

723
00:37:21,564 --> 00:37:24,669
followed by the name of the...

724
00:37:24,669 --> 00:37:27,438
well I suppose now this
is a property if you like,

725
00:37:27,438 --> 00:37:29,512
that we're trying to configure.

726
00:37:29,512 --> 00:37:34,284
So, for us it's the DAO
that we're trying to set.

727
00:37:34,284 --> 00:37:38,317
And the method will
have a single parameter,

728
00:37:38,317 --> 00:37:41,235
and we're going to insist that we pass in

729
00:37:41,235 --> 00:37:45,337
an instance of the invoicing DAO.

730
00:37:45,337 --> 00:37:49,604
And I think I happened to have used

731
00:37:49,604 --> 00:37:53,277
a capital A and a capital
O on that class name.

732
00:37:53,277 --> 00:37:54,492
That's now right.

733
00:37:54,492 --> 00:37:56,951
Now the implementation of a set method

734
00:37:56,951 --> 00:38:01,483
is usually just a trivial save the object.

735
00:38:01,483 --> 00:38:05,417
So here I would say the
attributes called DAO

736
00:38:05,417 --> 00:38:09,698
will be set to whichever
value is being passed in.

737
00:38:09,698 --> 00:38:13,374
Now this simple change
that we just made here

738
00:38:13,374 --> 00:38:16,994
is called dependency injection.

739
00:38:16,994 --> 00:38:21,994
Rather than creating the
object directly inside here,

740
00:38:22,168 --> 00:38:26,268
we're going to allow it
to be created externally.

741
00:38:26,268 --> 00:38:29,160
It might not look like a big improvement,

742
00:38:29,160 --> 00:38:32,621
but we've now got a lot more flexibility,

743
00:38:32,621 --> 00:38:36,044
as we can now use this
class in more than one way.

744
00:38:36,044 --> 00:38:38,449
We could instantiate the service

745
00:38:38,449 --> 00:38:42,098
and pass in a JDBC DAO,

746
00:38:42,098 --> 00:38:45,084
or we could pass in a Hibernate DAO,

747
00:38:45,084 --> 00:38:48,827
or we could pass it a testing DAO.

748
00:38:48,827 --> 00:38:50,929
We haven't seen a testing DAO yet,

749
00:38:50,929 --> 00:38:52,542
but we could write one.

750
00:38:52,542 --> 00:38:56,970
So a small change, but
we've added just that little

751
00:38:56,970 --> 00:39:00,127
bit more flexibility in the connection

752
00:39:00,127 --> 00:39:02,519
between this class and the DAO.

753
00:39:02,519 --> 00:39:04,865
Let's go back to the client.

754
00:39:04,865 --> 00:39:06,857
Now remember what we're doing in the

755
00:39:06,857 --> 00:39:09,509
client is we're creating
the invoice service

756
00:39:09,509 --> 00:39:12,469
and then we're passing
in an invoice for it

757
00:39:12,469 --> 00:39:14,601
to save in the database.

758
00:39:14,601 --> 00:39:17,874
Because we've now decoupled the service

759
00:39:17,874 --> 00:39:21,929
and the DAO we can, in
here, in the client,

760
00:39:21,929 --> 00:39:25,500
create an instance of the DAO.

761
00:39:25,500 --> 00:39:28,009
So I'm going to create

762
00:39:28,009 --> 00:39:31,666
invoicing DAO instance,

763
00:39:31,666 --> 00:39:33,642
which I'll call DAO.

764
00:39:33,642 --> 00:39:38,642
I will instantiate this
as an invoicing DAO

765
00:39:39,575 --> 00:39:43,171
JDBC implementation.

766
00:39:43,171 --> 00:39:47,671
I could have chosen the
Hibernate version if I preferred.

767
00:39:47,671 --> 00:39:50,747
And now we can tie the two together

768
00:39:50,747 --> 00:39:55,747
by calling invoices.setDAO,

769
00:39:59,574 --> 00:40:02,925
passing in our DAO objects.

770
00:40:02,925 --> 00:40:04,879
So we now have the freedom and flexibility

771
00:40:04,879 --> 00:40:07,482
to change this DAO around.

772
00:40:07,482 --> 00:40:10,974
It's all compiling and it should run fine.

773
00:40:10,974 --> 00:40:12,821
Let's test this.

774
00:40:12,821 --> 00:40:16,045
And if we look in database...

775
00:40:16,045 --> 00:40:18,491
yeah, we've now got a new instance

776
00:40:18,491 --> 00:40:22,396
of this 11075 at the bottom of the list.

777
00:40:22,396 --> 00:40:24,439
I could double check that by changing

778
00:40:24,439 --> 00:40:28,880
this ID to 11080...

779
00:40:28,880 --> 00:40:32,606
and yeah, if we check in the script,

780
00:40:32,606 --> 00:40:34,684
there it is at the bottom.

781
00:40:34,684 --> 00:40:37,665
Now if at a later date we decide that we

782
00:40:37,665 --> 00:40:40,533
don't want this JDBC
implementation anymore;

783
00:40:40,533 --> 00:40:43,537
let's say we want to use
the Hibernate version,

784
00:40:43,537 --> 00:40:47,472
it's a minor change here to switch

785
00:40:47,472 --> 00:40:49,685
the implementation around.

786
00:40:49,685 --> 00:40:52,368
Let's try that and...

787
00:40:52,368 --> 00:40:54,699
my naming is a bit inconsistent.

788
00:40:54,699 --> 00:40:58,042
I think I called this one HibernateDAO.

789
00:40:58,042 --> 00:40:59,148
It's compiling,

790
00:40:59,148 --> 00:41:00,459
and because we've only referred to

791
00:41:00,459 --> 00:41:03,581
interfaces inside this set method,

792
00:41:03,581 --> 00:41:07,224
it's fine to pass this in as an instance.

793
00:41:07,224 --> 00:41:09,080
Now if I run the code,

794
00:41:09,080 --> 00:41:11,338
as you can see we're now using the

795
00:41:11,338 --> 00:41:13,683
Hibernate version and I didn't have to go

796
00:41:13,683 --> 00:41:17,233
into the service and make
any changes in there.

797
00:41:17,233 --> 00:41:19,569
Now I think we've gained some flexibility,

798
00:41:19,569 --> 00:41:21,412
but I hope at this point you're feeling

799
00:41:21,412 --> 00:41:25,725
quite uncomfortable because this way

800
00:41:25,725 --> 00:41:28,836
of working isn't very pleasant either.

801
00:41:28,836 --> 00:41:32,663
Because every time I want
to use this service class,

802
00:41:32,663 --> 00:41:36,452
now I have to manually pass in all of its

803
00:41:36,452 --> 00:41:38,077
dependent objects.

804
00:41:38,077 --> 00:41:42,734
It's really made using this
service class a real burden.

805
00:41:42,734 --> 00:41:45,402
And of course if we forget to do this

806
00:41:45,402 --> 00:41:46,953
dependency injection,

807
00:41:46,953 --> 00:41:50,730
let's say we forgot to do this set DAO.

808
00:41:50,730 --> 00:41:54,163
Maybe we've even forgotten
to create the DAO.

809
00:41:54,163 --> 00:41:57,513
The client is now really as it was before.

810
00:41:57,513 --> 00:42:00,730
You can guess what will happen
if I run the client now?

811
00:42:00,730 --> 00:42:03,871
We get a no points of exception

812
00:42:03,871 --> 00:42:06,205
because this invoice service

813
00:42:06,205 --> 00:42:08,946
has not been correctly configured.

814
00:42:08,946 --> 00:42:11,465
So if I just undo that change,

815
00:42:11,465 --> 00:42:15,386
this kind of assembling the service object

816
00:42:15,386 --> 00:42:20,046
every time we use it would not
be viable in a real system.

817
00:42:20,046 --> 00:42:23,438
So this is where step three comes in.

818
00:42:23,438 --> 00:42:26,733
And this is where the whole
process comes together.

819
00:42:26,733 --> 00:42:28,990
And by the way, this is where Spring

820
00:42:28,990 --> 00:42:31,113
is going to help as well.

821
00:42:31,113 --> 00:42:34,396
The dependencies between our architectural

822
00:42:34,396 --> 00:42:37,684
objects such as our services and our DAOs

823
00:42:37,684 --> 00:42:42,684
could be captured all in one single place.

824
00:42:42,722 --> 00:42:46,366
We're going to centralize
this configuration.

825
00:42:46,366 --> 00:42:49,174
Now this is good software practice.

826
00:42:49,174 --> 00:42:51,479
If something is likely to vary,

827
00:42:51,479 --> 00:42:54,581
we should encaptulate
it and hold that thing

828
00:42:54,581 --> 00:42:56,991
all in one place.

829
00:42:56,991 --> 00:42:59,020
Then when changes do need to be made,

830
00:42:59,020 --> 00:43:01,970
we know that we only need to make

831
00:43:01,970 --> 00:43:04,908
the changes in one place.

832
00:43:04,908 --> 00:43:07,951
And we're going to
capture these dependencies

833
00:43:07,951 --> 00:43:10,354
all in a single place.

834
00:43:10,354 --> 00:43:12,596
And what we could do is we could write

835
00:43:12,596 --> 00:43:16,037
a special class whose responsibility is

836
00:43:16,037 --> 00:43:20,612
to configure or rather
to create and configure

837
00:43:20,612 --> 00:43:22,571
the objects that we need.

838
00:43:22,571 --> 00:43:24,839
Now, you could almost think of this class

839
00:43:24,839 --> 00:43:28,985
as being almost like
a system configurator.

840
00:43:28,985 --> 00:43:31,648
Now, that's not a term that's used

841
00:43:31,648 --> 00:43:33,768
in the industry as far as I know.

842
00:43:33,768 --> 00:43:38,768
The industry calls this class a container.

843
00:43:39,009 --> 00:43:42,523
Now writing a container
isn't very difficult.

844
00:43:42,523 --> 00:43:46,107
What I've done here is
I've written a very crude,

845
00:43:46,107 --> 00:43:50,433
very basic implementation of a container.

846
00:43:50,433 --> 00:43:52,402
Now, as I've mentioned
here in the comment,

847
00:43:52,402 --> 00:43:54,784
don't worry we'll be using a real one

848
00:43:54,784 --> 00:43:56,703
in the next chapter.

849
00:43:56,703 --> 00:43:59,189
And you'll see the real ones are very

850
00:43:59,189 --> 00:44:00,856
much more sophisticated than this.

851
00:44:00,856 --> 00:44:04,242
But, I hope this will at
least get the idea across.

852
00:44:04,242 --> 00:44:05,858
So what I did off camera was,

853
00:44:05,858 --> 00:44:08,181
and again, I'll just save you the tedium

854
00:44:08,181 --> 00:44:11,312
of having to watch me type this in,

855
00:44:11,312 --> 00:44:14,740
but you will find this class
in practicals and code.

856
00:44:14,740 --> 00:44:18,608
And what I've got here is
a method inside this class

857
00:44:18,608 --> 00:44:20,864
and I've made it a static method

858
00:44:20,864 --> 00:44:23,166
so it's easy to call.

859
00:44:23,166 --> 00:44:27,934
And the method's called
get invoice service.

860
00:44:27,934 --> 00:44:30,701
And it's going to return an instance

861
00:44:30,701 --> 00:44:33,263
of the invoice service.

862
00:44:33,263 --> 00:44:37,324
Now, what it's doing inside
here is it's creating

863
00:44:37,324 --> 00:44:42,324
all of the objects for us
that the service depends upon.

864
00:44:42,655 --> 00:44:47,228
In our case it's only
one dependency, this DAO,

865
00:44:47,228 --> 00:44:51,223
but in real life there
could be more dependencies.

866
00:44:51,223 --> 00:44:53,404
So, it's creating the DAO,

867
00:44:53,404 --> 00:44:58,397
it's creating the service and
perhaps most interestingly,

868
00:44:58,397 --> 00:45:02,527
it's connecting the two objects together.

869
00:45:02,527 --> 00:45:05,357
And the beauty of this now,

870
00:45:05,357 --> 00:45:07,767
is if I go back to my client,

871
00:45:07,767 --> 00:45:10,658
instead of the client creating

872
00:45:10,658 --> 00:45:14,034
the invoice service directly,

873
00:45:14,034 --> 00:45:16,952
what we will do instead is we will ask

874
00:45:16,952 --> 00:45:20,863
the container to do the work for us.

875
00:45:21,843 --> 00:45:26,843
So, I can just say
crudecontainer.getinvoiceservice.

876
00:45:28,090 --> 00:45:30,346
And then with just this single line,

877
00:45:30,346 --> 00:45:33,254
the client will have a fully instantiated

878
00:45:33,254 --> 00:45:37,008
and ready to use invoice service.

879
00:45:37,008 --> 00:45:40,516
My client code doesn't now have to bother

880
00:45:40,516 --> 00:45:44,465
creating the DAO and
connecting them together.

881
00:45:44,465 --> 00:45:47,075
So, I can remove these two lines.

882
00:45:47,075 --> 00:45:49,763
Let's just check that it works.

883
00:45:52,723 --> 00:45:54,949
Now, I think we have some big wins here.

884
00:45:54,949 --> 00:45:58,795
The client is relatively small and clean.

885
00:45:58,795 --> 00:46:00,604
The client doesn't want to worry about

886
00:46:00,604 --> 00:46:04,011
how to construct an invoice service,

887
00:46:04,011 --> 00:46:08,003
so it just asks the container
to do the job instead.

888
00:46:08,003 --> 00:46:10,636
And then the client gets on with its work.

889
00:46:10,636 --> 00:46:14,422
And our invoice service is clean as well

890
00:46:14,422 --> 00:46:16,948
because it doesn't refer specifically

891
00:46:16,948 --> 00:46:21,474
to any particular
implementation of that DAO.

892
00:46:21,474 --> 00:46:23,937
So we've got the flexibility here.

893
00:46:23,937 --> 00:46:26,488
Now the trouble is this container is

894
00:46:26,488 --> 00:46:29,110
a very crude container.

895
00:46:29,110 --> 00:46:32,328
Now, let's say that our
project leader decides

896
00:46:32,328 --> 00:46:36,303
that we're not going to use JDBC anymore.

897
00:46:36,303 --> 00:46:39,472
We want to switch to Hibernate instead.

898
00:46:39,472 --> 00:46:42,811
Now, we've already written
the Hibernate DAOs,

899
00:46:42,811 --> 00:46:45,684
and we've got the big win really,

900
00:46:45,684 --> 00:46:47,484
in that we know that to make that change,

901
00:46:47,484 --> 00:46:50,669
we'll find all of the references to the

902
00:46:50,669 --> 00:46:55,503
DAO implementation in this
single container class.

903
00:46:55,503 --> 00:46:57,244
You can imagine this container class

904
00:46:57,244 --> 00:46:59,441
will be pretty big on a real project.

905
00:46:59,441 --> 00:47:01,008
It's quite small for us,

906
00:47:01,008 --> 00:47:04,716
but at least all the references
would be in one place.

907
00:47:04,716 --> 00:47:08,674
So, I would just fine
this JDBC reference here,

908
00:47:08,674 --> 00:47:11,434
change it to the Hibernate DAO.

909
00:47:11,434 --> 00:47:14,535
That one change in this one class

910
00:47:14,535 --> 00:47:17,378
now means if I run the application,

911
00:47:17,378 --> 00:47:20,478
it's now using Hibernate instead.

912
00:47:20,478 --> 00:47:23,864
But let's be honest, it's still not great

913
00:47:23,864 --> 00:47:27,041
because I've got to find this class.

914
00:47:27,041 --> 00:47:28,372
This class, by the way,

915
00:47:28,372 --> 00:47:32,117
would get really big on a real project.

916
00:47:32,117 --> 00:47:34,181
And I've still got to change Java

917
00:47:34,181 --> 00:47:37,486
and I've still got to recompile.

918
00:47:37,486 --> 00:47:41,614
A much better container would rather them

919
00:47:41,614 --> 00:47:45,762
working hard coded
dependencies here in the Java,

920
00:47:45,762 --> 00:47:48,571
would read from a file instead.

921
00:47:48,571 --> 00:47:51,205
And it would be great if we could somehow

922
00:47:51,205 --> 00:47:54,792
put in that file the
dependencies that we have.

923
00:47:54,792 --> 00:47:58,539
Then, we would be able to switch from JDBC

924
00:47:58,539 --> 00:48:02,989
to Hibernate by just
changing that config file.

925
00:48:02,989 --> 00:48:05,129
We really would have complete freedom

926
00:48:05,129 --> 00:48:10,012
and flexibility to change our
architectural tiers around.

927
00:48:10,012 --> 00:48:14,279
However, writing a sophisticated container

928
00:48:14,279 --> 00:48:17,470
that's going to be able to
read configuration files

929
00:48:17,470 --> 00:48:21,298
and pass them and
presumably do error checking

930
00:48:21,298 --> 00:48:25,247
and things like that
sounds like very tedius

931
00:48:25,247 --> 00:48:27,412
and time consuming work.

932
00:48:27,412 --> 00:48:30,234
It would probably take months to implement

933
00:48:30,234 --> 00:48:32,837
as sophisticated container.

934
00:48:32,837 --> 00:48:35,609
Luckily, in the past few years,

935
00:48:35,609 --> 00:48:38,513
some open source projects have already

936
00:48:38,513 --> 00:48:42,761
implemented dependency
injection containers for us.

937
00:48:42,761 --> 00:48:45,861
And one project called PicoContainer,

938
00:48:45,861 --> 00:48:48,431
at the address you can see here,

939
00:48:48,431 --> 00:48:51,347
have implemented exactly that.

940
00:48:51,347 --> 00:48:56,347
A container that honors the
dependency injection pattern.

941
00:48:56,914 --> 00:49:00,366
In other words, the software
that you can download here

942
00:49:00,366 --> 00:49:03,614
will provide a really
sophisticated implementation

943
00:49:03,614 --> 00:49:07,423
for step three of our plan.

944
00:49:07,423 --> 00:49:08,856
Now, as you can see here,

945
00:49:08,856 --> 00:49:12,847
this project has been running since 2003.

946
00:49:12,847 --> 00:49:16,624
In the first edition of
the Spring framework course

947
00:49:16,624 --> 00:49:19,454
which we recorded back in 2008,

948
00:49:19,454 --> 00:49:23,899
we mentioned that PicoContainer
was a leading container.

949
00:49:23,899 --> 00:49:26,750
And, I must say though that by the time

950
00:49:26,750 --> 00:49:29,716
of this recording in 2013,

951
00:49:29,716 --> 00:49:33,058
PicoContainer seems to be not used

952
00:49:33,058 --> 00:49:35,187
so much these days.

953
00:49:35,187 --> 00:49:38,209
But it's a good example of how you can get

954
00:49:38,209 --> 00:49:41,487
pre-written containers to really make

955
00:49:41,487 --> 00:49:44,275
step three much easier to work with.

956
00:49:44,275 --> 00:49:47,410
Now back on that first
edition of our spring course,

957
00:49:47,410 --> 00:49:50,255
Google had decided that they liked

958
00:49:50,255 --> 00:49:53,251
dependency injection as well so they got

959
00:49:53,251 --> 00:49:55,637
in the act and they began a project called

960
00:49:55,637 --> 00:49:58,364
Google-guice.

961
00:49:58,364 --> 00:50:00,907
Which they describe as a light weight

962
00:50:00,907 --> 00:50:03,966
dependency injection framework.

963
00:50:03,966 --> 00:50:06,386
And this is a very similar idea.

964
00:50:06,386 --> 00:50:08,634
When you download google-guice,

965
00:50:08,634 --> 00:50:12,832
you effectively get a
pre-written container.

966
00:50:12,832 --> 00:50:16,886
You'll find this at code.google.com

967
00:50:16,886 --> 00:50:20,368
and as of this recording in 2013,

968
00:50:20,368 --> 00:50:24,344
guice has been really successful.

969
00:50:24,344 --> 00:50:28,749
You're going to find it's
used on a lot of projects.

970
00:50:28,749 --> 00:50:31,344
Now there are some other implementations

971
00:50:31,344 --> 00:50:33,722
of containers out there as well,

972
00:50:33,722 --> 00:50:38,722
but of course this is a Spring course.

973
00:50:38,953 --> 00:50:41,306
And the point of this chapter

974
00:50:41,306 --> 00:50:44,846
is that Spring features at its core

975
00:50:44,846 --> 00:50:48,692
a dependency injection container.

976
00:50:48,692 --> 00:50:51,446
Now, here I am at the Spring website.

977
00:50:51,446 --> 00:50:54,579
We'll be using this website
a lot through this course.

978
00:50:54,579 --> 00:50:57,035
And if we just have a look
at their introduction here,

979
00:50:57,035 --> 00:50:59,604
you'll see really their number one feature

980
00:50:59,604 --> 00:51:02,551
is dependency injection.

981
00:51:02,551 --> 00:51:03,974
And to make that work,

982
00:51:03,974 --> 00:51:07,465
they provide you with
a very sophisticated,

983
00:51:07,465 --> 00:51:10,651
fully operational container.

984
00:51:10,651 --> 00:51:12,628
And we're going to be using that container

985
00:51:12,628 --> 00:51:14,819
in the next chapter.

986
00:51:14,819 --> 00:51:16,641
And through subsequent chapters,

987
00:51:16,641 --> 00:51:18,975
we'll be going further
with the Spring framework

988
00:51:18,975 --> 00:51:21,465
and we'll be seeing that this container

989
00:51:21,465 --> 00:51:24,580
provides additional features such as,

990
00:51:24,580 --> 00:51:28,235
transaction management, security,

991
00:51:28,235 --> 00:51:31,043
database access and so on.

992
00:51:31,043 --> 00:51:32,887
And the point of this course is to

993
00:51:32,887 --> 00:51:35,405
show you how all of this works.

994
00:51:38,515 --> 00:51:40,328
So I hope that was all okay.

995
00:51:40,328 --> 00:51:41,738
I've tried to make the example

996
00:51:41,738 --> 00:51:44,991
as simple as possible really to show

997
00:51:44,991 --> 00:51:46,550
that the problem of coupling

998
00:51:46,550 --> 00:51:49,331
might not be immediately obvious.

999
00:51:49,331 --> 00:51:52,040
But as your system gets bigger and bigger,

1000
00:51:52,040 --> 00:51:54,712
coupling really can leave you in a state

1001
00:51:54,712 --> 00:51:56,992
where your application is brittle,

1002
00:51:56,992 --> 00:51:59,411
the layers are difficult to change,

1003
00:51:59,411 --> 00:52:01,866
and difficult to test.

1004
00:52:01,866 --> 00:52:05,795
Dependency injection is just basic Java,

1005
00:52:05,795 --> 00:52:09,788
and you might be surprised
at how simple it is.

1006
00:52:09,788 --> 00:52:13,109
It really is just a case
providing the set method

1007
00:52:13,109 --> 00:52:16,524
to allow dependencies to be injected.

1008
00:52:16,524 --> 00:52:19,909
But you will need a
container if you don't want

1009
00:52:19,909 --> 00:52:22,697
to write one yourself
then you need to get one.

1010
00:52:22,697 --> 00:52:25,726
Spring features one of these containers.

1011
00:52:25,726 --> 00:52:28,822
So in the next chapter
we'll be using Spring

1012
00:52:28,822 --> 00:52:31,111
for the first time and
we'll be concentrating

1013
00:52:31,111 --> 00:52:33,676
on how to use that container.

1014
00:52:33,676 --> 00:52:36,774
So I'll see you in chapter three.

1
00:00:00,000 --> 00:00:04,460
(soft music)

2
00:00:10,450 --> 00:00:11,210
- [Voiceover] Welcome back,

3
00:00:11,210 --> 00:00:12,750
and in chapter three we're going

4
00:00:12,750 --> 00:00:16,930
to use the Spring Container
for the first time.

5
00:00:16,930 --> 00:00:18,450
In this chapter we will write

6
00:00:18,450 --> 00:00:21,430
a basic Hello World application

7
00:00:21,430 --> 00:00:23,510
just to keep things simple.

8
00:00:23,510 --> 00:00:26,870
We'll get our first
experience of using XML

9
00:00:26,870 --> 00:00:29,850
to configure a container.

10
00:00:29,850 --> 00:00:31,030
One of the great freedoms

11
00:00:31,030 --> 00:00:33,570
that using the container gives us

12
00:00:33,570 --> 00:00:37,250
is the ability to switch
the implementation classes

13
00:00:37,250 --> 00:00:39,790
with no changes to the code.

14
00:00:39,790 --> 00:00:42,750
Just the XML firewall change

15
00:00:42,750 --> 00:00:45,740
and I'll be demonstrating that.

16
00:00:48,510 --> 00:00:50,970
Well for the first use of Spring,

17
00:00:50,970 --> 00:00:53,130
we're going to bow to tradition

18
00:00:53,130 --> 00:00:56,790
and use a classic Hello World example.

19
00:00:56,790 --> 00:00:59,330
Well this example is
very similar to the one

20
00:00:59,330 --> 00:01:01,870
on the Spring framework website.

21
00:01:01,870 --> 00:01:04,390
I promise I haven't copied it from them.

22
00:01:04,390 --> 00:01:07,730
It's just that this is
really the easiest program

23
00:01:07,730 --> 00:01:09,990
you can write with Spring.

24
00:01:09,990 --> 00:01:12,490
Before I start, I must
say that this example

25
00:01:12,490 --> 00:01:15,970
will only be a small
one to get us started.

26
00:01:15,970 --> 00:01:20,030
You wouldn't really use Spring
for a program of this size.

27
00:01:20,030 --> 00:01:24,130
It's too big a tool for
too small a problem,

28
00:01:24,130 --> 00:01:27,330
but once you learn the
basics in this chapter,

29
00:01:27,330 --> 00:01:29,610
we'll move on and build something

30
00:01:29,610 --> 00:01:33,030
more substantial in the future chapters.

31
00:01:33,030 --> 00:01:35,130
The requirement that I have

32
00:01:35,130 --> 00:01:39,210
is that we have a client
of some description.

33
00:01:39,210 --> 00:01:40,850
This could be a webpage

34
00:01:40,850 --> 00:01:42,450
it could be anything we like.

35
00:01:42,450 --> 00:01:44,930
It doesn't really matter
for this exercise.

36
00:01:44,930 --> 00:01:48,090
We're going to make it just a Java class

37
00:01:48,090 --> 00:01:50,630
with a main method.

38
00:01:50,630 --> 00:01:53,210
The client is going to, each day,

39
00:01:53,210 --> 00:01:56,890
call a job or class that
we're going to write called,

40
00:01:56,890 --> 00:01:59,310
MessageOfTheDayService

41
00:01:59,310 --> 00:02:02,730
and the deal behind this
MessageOfTheDayService

42
00:02:02,730 --> 00:02:05,270
is it will, unless the class says,

43
00:02:05,270 --> 00:02:07,970
return a message of the day.

44
00:02:07,970 --> 00:02:10,770
Now we don't yet know
what the requirements

45
00:02:10,770 --> 00:02:13,450
for this class are in detail.

46
00:02:13,450 --> 00:02:17,070
It could be that we get
the same message each day,

47
00:02:17,070 --> 00:02:18,710
Hello World, for example,

48
00:02:18,710 --> 00:02:22,910
or it could be that the
message is different each day.

49
00:02:22,910 --> 00:02:25,650
Perhaps there is a random message,

50
00:02:25,650 --> 00:02:29,190
perhaps there are messages
stored in relational databases

51
00:02:29,190 --> 00:02:31,270
we don't yet know.

52
00:02:31,270 --> 00:02:34,390
What we do know is that we're going to

53
00:02:34,390 --> 00:02:39,140
need a method in there
called, getTodaysMessage.

54
00:02:40,190 --> 00:02:43,330
So following good regular Java practice,

55
00:02:43,330 --> 00:02:46,390
we're going to write an interface

56
00:02:46,390 --> 00:02:49,650
before we write an implementation class,

57
00:02:49,650 --> 00:02:51,830
and here is the interface

58
00:02:51,830 --> 00:02:54,930
that we're going to write
in Eclipse in a moment.

59
00:02:54,930 --> 00:02:57,590
I hope you can see this is just a simple,

60
00:02:57,590 --> 00:03:01,250
plain, regular Java interface.

61
00:03:01,250 --> 00:03:03,210
The only thing that will be different

62
00:03:03,210 --> 00:03:05,390
when I do this in Eclipse

63
00:03:05,390 --> 00:03:08,250
is I will put this in a package.

64
00:03:08,250 --> 00:03:13,250
For the implementation, this
is a very basic implementation,

65
00:03:13,470 --> 00:03:16,990
and I've reflected that in the class name.

66
00:03:16,990 --> 00:03:21,870
I've called the class
MessageOfTheDayBasicImpl.

67
00:03:21,870 --> 00:03:25,450
You'll see that quite often in Java

68
00:03:25,450 --> 00:03:30,450
where an implementing class
ends with the letters Impl.

69
00:03:30,890 --> 00:03:35,295
All I'm doing is, I'm
holding a single message

70
00:03:35,295 --> 00:03:37,515
here in a private attribute.

71
00:03:37,515 --> 00:03:39,715
I have a constructor,

72
00:03:39,715 --> 00:03:43,215
I didn't really need to
construct in this case,

73
00:03:43,215 --> 00:03:45,915
but I just wanted to
remind you that you can

74
00:03:45,915 --> 00:03:49,275
have a constructor if you want.

75
00:03:49,275 --> 00:03:53,955
Maybe we could put in
there a default message.

76
00:03:53,955 --> 00:03:57,635
And now the set message method.

77
00:03:57,635 --> 00:04:01,423
This is where I'm going to use
Spring's dependency injection

78
00:04:01,423 --> 00:04:03,843
to allow me to configure this message,

79
00:04:03,843 --> 00:04:08,734
this dependency in an external XML file

80
00:04:08,734 --> 00:04:11,454
rather than in the code itself.

81
00:04:11,454 --> 00:04:16,274
And finally it's the
getTodaysMessage method.

82
00:04:16,274 --> 00:04:19,674
That's the method that we
defined in the interface

83
00:04:19,674 --> 00:04:21,714
so it needs to be there.

84
00:04:21,714 --> 00:04:24,634
Now notice that the setMessage method

85
00:04:24,634 --> 00:04:29,234
does not appear in the
interface for this class.

86
00:04:29,234 --> 00:04:32,654
Now I'm not going to tell you
why that's the case just yet

87
00:04:32,654 --> 00:04:35,434
but maybe you want to
start having to think about

88
00:04:35,434 --> 00:04:37,354
why that's the case now.

89
00:04:37,354 --> 00:04:40,454
I'll come back to that towards
the end of this chapter.

90
00:04:40,454 --> 00:04:44,034
So what we'll do now is we'll
switch across to Eclipse,

91
00:04:44,034 --> 00:04:46,214
we'll start a brand new workspace,

92
00:04:46,214 --> 00:04:49,354
and just make sure these
two classes compile

93
00:04:49,354 --> 00:04:53,354
before we bring Spring into the mix.

94
00:04:53,354 --> 00:04:55,814
As I mentioned in the opening chapter,

95
00:04:55,814 --> 00:04:58,034
we supplied you with a set of files

96
00:04:58,034 --> 00:05:01,054
that you will need for the exercises.

97
00:05:01,054 --> 00:05:02,614
And what we've usually done is

98
00:05:02,614 --> 00:05:04,674
we've given you all of the files

99
00:05:04,674 --> 00:05:08,214
that are boring and tedious
to create for yourself.

100
00:05:08,214 --> 00:05:11,774
Of course, you'll be adding
a lot of your own work

101
00:05:11,774 --> 00:05:13,854
on top of these files.

102
00:05:13,854 --> 00:05:18,314
So for example, look in the
starting workspaces folder,

103
00:05:18,314 --> 00:05:21,114
then in message of the day,

104
00:05:21,114 --> 00:05:22,534
and you'll find in there

105
00:05:22,534 --> 00:05:26,794
a folder called MessageProject.

106
00:05:26,794 --> 00:05:30,394
Inside there there's an SRC folder.

107
00:05:30,394 --> 00:05:33,094
And that will contain any source code

108
00:05:33,094 --> 00:05:36,534
that we're pre-splaying for you.

109
00:05:36,534 --> 00:05:39,262
Now in this example, we're just giving you

110
00:05:39,262 --> 00:05:42,402
a skeleton version of the XML file

111
00:05:42,402 --> 00:05:44,382
you'll be seeing in a moment.

112
00:05:44,382 --> 00:05:46,282
We'll have a look at that very shortly.

113
00:05:46,282 --> 00:05:49,142
The BIN directory, of course,

114
00:05:49,142 --> 00:05:51,622
will be where the Java binary lives,

115
00:05:51,622 --> 00:05:55,922
and the LIB directory
contains the JAF files

116
00:05:55,922 --> 00:05:58,982
that we looked at in the opening chapter.

117
00:05:58,982 --> 00:06:02,662
Now for this exercise I've
assembled the JAF files

118
00:06:02,662 --> 00:06:06,282
that you're going to need
for the Hello World example.

119
00:06:06,282 --> 00:06:09,262
You'll see that it's not the full set of

120
00:06:09,262 --> 00:06:11,362
Spring JAF files.

121
00:06:11,362 --> 00:06:13,922
We just have four of them here.

122
00:06:13,922 --> 00:06:16,802
Together with commons logging.

123
00:06:16,802 --> 00:06:19,342
These are just the basic JAF files.

124
00:06:19,342 --> 00:06:22,202
In later projects, later chapters,

125
00:06:22,202 --> 00:06:25,622
we'll need a lot more JAF files than this.

126
00:06:25,622 --> 00:06:29,832
So open up your Message
of the Day workspace,

127
00:06:31,702 --> 00:06:34,342
and depending on your version of Eclipse,

128
00:06:34,342 --> 00:06:36,542
you might see slightly different screens

129
00:06:36,542 --> 00:06:38,082
than the one I have here,

130
00:06:38,082 --> 00:06:40,962
but usually you get some
kind of welcome screen,

131
00:06:40,962 --> 00:06:43,782
which we can immediately close,

132
00:06:43,782 --> 00:06:46,682
and although we do have a
project in the workspace,

133
00:06:46,682 --> 00:06:50,762
by default Eclipse won't
recognize that project.

134
00:06:50,762 --> 00:06:53,842
To bring the project
into the package explorer

135
00:06:53,842 --> 00:06:55,842
there are a few different
way you could do this,

136
00:06:55,842 --> 00:06:59,182
but my preferred way is
to go to the File menu,

137
00:06:59,182 --> 00:07:01,682
select New,

138
00:07:01,682 --> 00:07:03,382
and Java Project,

139
00:07:03,382 --> 00:07:06,782
and be sure to select Java project here.

140
00:07:06,782 --> 00:07:08,362
And then for the Project name

141
00:07:08,362 --> 00:07:11,322
we need to type in exactly the same name

142
00:07:11,322 --> 00:07:15,322
as the folder in which our project lives.

143
00:07:15,322 --> 00:07:19,222
And that folder is called MessageProject,

144
00:07:19,222 --> 00:07:22,562
with a capital M and a capital P.

145
00:07:22,562 --> 00:07:26,662
So if we type that into
the Project name field

146
00:07:26,662 --> 00:07:28,262
if you watch what happens

147
00:07:28,262 --> 00:07:31,262
as soon as I press the
last character here.

148
00:07:31,262 --> 00:07:34,342
A little info box has
popped up at the bottom

149
00:07:34,342 --> 00:07:36,902
saying the wizard will
automatically configure

150
00:07:36,902 --> 00:07:40,082
the environment based
on the existing source.

151
00:07:40,082 --> 00:07:42,302
If you don't see that info message,

152
00:07:42,302 --> 00:07:46,322
be sure to check your spelling here.

153
00:07:46,322 --> 00:07:48,362
And if that spelling is correct,

154
00:07:48,362 --> 00:07:52,282
then make sure you've opened
up the correct workspace.

155
00:07:52,282 --> 00:07:55,022
All being well, we can now click finish,

156
00:07:55,022 --> 00:07:58,302
and I can open up the project,

157
00:07:58,302 --> 00:08:00,522
and I can look inside the SRC folder,

158
00:08:00,522 --> 00:08:03,402
as I said, the only file we have so far

159
00:08:03,402 --> 00:08:06,662
is this file called application.xml

160
00:08:06,662 --> 00:08:10,122
and I'll be describing what's inside there

161
00:08:10,122 --> 00:08:12,602
in just a few moments.

162
00:08:12,602 --> 00:08:14,882
So let's leave that for now.

163
00:08:14,882 --> 00:08:18,602
Our first job is to write
the interface class,

164
00:08:18,602 --> 00:08:19,942
and just to remind you,

165
00:08:19,942 --> 00:08:23,842
that's what the interface
needs to end up looking like.

166
00:08:23,842 --> 00:08:25,982
Now I need to start doing this code

167
00:08:25,982 --> 00:08:27,402
a bit more professionally now,

168
00:08:27,402 --> 00:08:30,282
so I'm going to start
using proper packages.

169
00:08:30,282 --> 00:08:32,362
So we'll go to File,

170
00:08:32,362 --> 00:08:33,962
select New,

171
00:08:33,962 --> 00:08:37,462
and Interface.

172
00:08:37,462 --> 00:08:40,822
The packages I'll use
on the videos will be

173
00:08:40,822 --> 00:08:45,602
com.virtualpairprogrammers

174
00:08:45,602 --> 00:08:48,242
and use your own, if you prefer,

175
00:08:48,242 --> 00:08:52,152
and I'll put in a
sub-package here called motd

176
00:08:52,152 --> 00:08:54,402
for Message of the Day.

177
00:08:54,402 --> 00:08:59,174
And the interface name is
MessageOfTheDayService.

178
00:09:02,824 --> 00:09:06,444
And my single business
method in here is called

179
00:09:06,444 --> 00:09:09,204
getTodaysMessage.

180
00:09:10,504 --> 00:09:14,404
It takes no parameters,
but returns string.

181
00:09:14,404 --> 00:09:17,224
So just normal Java and that's compiling.

182
00:09:17,224 --> 00:09:19,384
I have no problems here.

183
00:09:19,384 --> 00:09:23,714
And next I'll create my
basic implementation.

184
00:09:24,664 --> 00:09:27,044
So we'll go for a new Java class.

185
00:09:27,044 --> 00:09:28,444
And I suggested on the caption

186
00:09:28,444 --> 00:09:33,354
that we call this MesageOfTheDayBasicImpl.

187
00:09:34,564 --> 00:09:39,084
Now to save time, I can
add into the interface list

188
00:09:39,084 --> 00:09:41,904
the Message of the Day.

189
00:09:41,904 --> 00:09:44,844
If fact if I just type
messageofthe it comes up

190
00:09:44,844 --> 00:09:47,184
as the only matching option.

191
00:09:47,184 --> 00:09:48,784
And the good thing about that is

192
00:09:48,784 --> 00:09:53,244
as long as I have this
tick box checked here,

193
00:09:53,244 --> 00:09:56,734
then when I click finish,

194
00:09:56,734 --> 00:09:59,544
it will automatically
build a skeleton version

195
00:09:59,544 --> 00:10:01,564
of this class.

196
00:10:01,564 --> 00:10:05,484
Rather curiously I have an error in there.

197
00:10:05,484 --> 00:10:08,064
I just hover over that.

198
00:10:08,064 --> 00:10:10,544
It's complaining that this method

199
00:10:10,544 --> 00:10:15,504
isn't correctly overriding
a super tight method.

200
00:10:15,504 --> 00:10:17,864
In other words, it thinks that this method

201
00:10:17,864 --> 00:10:21,144
doesn't appear in the interface.

202
00:10:21,144 --> 00:10:24,644
Well public string getTodaysMessage

203
00:10:24,644 --> 00:10:26,344
public sting getTodaysMessage.

204
00:10:26,344 --> 00:10:28,364
Well that looks correct.

205
00:10:28,364 --> 00:10:31,144
I think it's just because I
haven't saved this interface,

206
00:10:31,144 --> 00:10:33,744
there's an asterisk there by the file.

207
00:10:33,744 --> 00:10:35,524
So if I just save that,

208
00:10:35,524 --> 00:10:37,684
yeah the error's gone away

209
00:10:37,684 --> 00:10:39,644
in the implementation.

210
00:10:39,644 --> 00:10:42,244
Now you can forward wind
the video a few minutes

211
00:10:42,244 --> 00:10:43,624
if you find this boring,

212
00:10:43,624 --> 00:10:46,044
but I'm going to implement
the rest of the class

213
00:10:46,044 --> 00:10:47,404
as on the captions.

214
00:10:47,404 --> 00:10:49,644
So first of all, we
have a private attribute

215
00:10:49,644 --> 00:10:52,324
which is going to be holding the message,

216
00:10:52,324 --> 00:10:55,184
just a single message in this class.

217
00:10:55,184 --> 00:10:57,324
I had a constructor on the caption,

218
00:10:57,324 --> 00:11:00,044
but as I'm not really using it,

219
00:11:00,044 --> 00:11:02,364
I'm going to not bother with that,

220
00:11:02,364 --> 00:11:04,964
and we'll just rely on
the default constructor,

221
00:11:04,964 --> 00:11:06,564
that's fine for now.

222
00:11:06,564 --> 00:11:11,414
And we need to supply
the set message method

223
00:11:16,224 --> 00:11:19,144
and the implementation

224
00:11:19,144 --> 00:11:23,184
of that is just a trivial
save the parameter

225
00:11:23,184 --> 00:11:25,804
into the attribute.

226
00:11:25,804 --> 00:11:29,464
Oh and of course, I need to
put a reasonable implementation

227
00:11:29,464 --> 00:11:33,304
inside this getTodaysMessage method.

228
00:11:33,304 --> 00:11:36,264
Well for this very basic implementation

229
00:11:36,264 --> 00:11:40,554
we are just going to return the message.

230
00:11:41,804 --> 00:11:43,864
Now I promise I'll get a
little more sophisticated

231
00:11:43,864 --> 00:11:46,284
than that later on.

232
00:11:46,284 --> 00:11:48,844
Great so both classes are now compiling,

233
00:11:48,844 --> 00:11:50,584
and at this point in real life

234
00:11:50,584 --> 00:11:53,224
we could write a unit test to make sure

235
00:11:53,224 --> 00:11:55,364
the class is working ok.

236
00:11:55,364 --> 00:11:57,384
Now we won't do that because this isn't

237
00:11:57,384 --> 00:11:59,104
a unit test course,

238
00:11:59,104 --> 00:12:01,264
and also there isn't really

239
00:12:01,264 --> 00:12:06,264
enough business logic in here to test.

240
00:12:06,753 --> 00:12:09,662
What we'll do now is we'll
write the client's part

241
00:12:09,662 --> 00:12:11,542
of the application.

242
00:12:11,542 --> 00:12:15,002
Now ordinarily in a basic Java program

243
00:12:15,002 --> 00:12:18,362
the Client would probably
just create a new instance

244
00:12:18,362 --> 00:12:20,202
of the service object,

245
00:12:20,202 --> 00:12:22,202
and call it method.

246
00:12:22,202 --> 00:12:24,143
Now we saw in our earlier discussion

247
00:12:24,143 --> 00:12:25,782
about dependency injection

248
00:12:25,782 --> 00:12:28,292
that we could use instead

249
00:12:28,292 --> 00:12:32,442
a container to sort of prepare the object

250
00:12:32,442 --> 00:12:35,842
to filling all of its dependent objects,

251
00:12:35,842 --> 00:12:39,542
in this case the
dependency is that message.

252
00:12:39,542 --> 00:12:41,122
So on this picture,

253
00:12:41,122 --> 00:12:43,302
I'm just showing you the general pattern

254
00:12:43,302 --> 00:12:45,822
of how we're going to work with Spring,

255
00:12:45,822 --> 00:12:47,802
and then we'll switch back to the code.

256
00:12:47,802 --> 00:12:49,522
So the client,

257
00:12:49,522 --> 00:12:53,662
instead of creating the
MessageOfTheDayService itself

258
00:12:53,662 --> 00:12:58,662
is going to get the object
from the Spring Container.

259
00:12:59,122 --> 00:13:03,912
Now Spring, by the way,
calls objects beans.

260
00:13:05,202 --> 00:13:07,742
I'll stick with that
teminology from now on

261
00:13:07,742 --> 00:13:10,282
but please don't worry about that term.

262
00:13:10,282 --> 00:13:13,722
A bean is just an object.

263
00:13:13,722 --> 00:13:18,322
So how does Spring create
this service object?

264
00:13:18,322 --> 00:13:22,022
Well it's going to work
from a config file.

265
00:13:22,022 --> 00:13:26,742
Now traditionally these config
files are written in XML.

266
00:13:26,742 --> 00:13:29,522
Now there are other ways of
configuring the container,

267
00:13:29,522 --> 00:13:32,262
and we will see those
ways later in the course,

268
00:13:32,262 --> 00:13:35,502
but for now we'll go
with the traditional way,

269
00:13:35,502 --> 00:13:37,662
which is XML.

270
00:13:37,662 --> 00:13:41,122
So the Spring Container will
look at this config file,

271
00:13:41,122 --> 00:13:43,602
and based on what it finds in there

272
00:13:43,602 --> 00:13:48,592
it will create an instance
of MessageOfTheDaySerivce.

273
00:13:50,082 --> 00:13:53,362
The main thing that will
be in this config file

274
00:13:53,362 --> 00:13:58,322
is which implementation class
we want Spring to work with.

275
00:13:58,322 --> 00:14:00,702
Now we only have one so far,

276
00:14:00,702 --> 00:14:02,522
this basic input,

277
00:14:02,522 --> 00:14:06,422
but later on we might have
other implementations.

278
00:14:06,422 --> 00:14:09,502
So we put that in the config file.

279
00:14:09,502 --> 00:14:11,822
Now the other thing that's in the config

280
00:14:11,822 --> 00:14:15,702
are all of the properties for the objects,

281
00:14:15,702 --> 00:14:18,862
We've seen that our class
has a single property,

282
00:14:18,862 --> 00:14:21,322
a single attribute if you prefer,

283
00:14:21,322 --> 00:14:24,102
called Message.

284
00:14:24,102 --> 00:14:26,002
Now that message can vary.

285
00:14:26,002 --> 00:14:30,302
It's a dependency on the
MessageOfTheDayService,

286
00:14:30,302 --> 00:14:32,042
and we want that message to be able

287
00:14:32,042 --> 00:14:34,302
to be set by a system administrator

288
00:14:34,302 --> 00:14:38,842
so we're going to put that
message in the config file.

289
00:14:38,842 --> 00:14:41,522
So the next thing that Spring will do,

290
00:14:41,522 --> 00:14:44,962
I'm calling this step 2.1 here,

291
00:14:44,962 --> 00:14:49,562
is that Spring will call
the setMessage method

292
00:14:49,562 --> 00:14:51,882
and it will pass through whatever data

293
00:14:51,882 --> 00:14:54,022
was in that configuration file

294
00:14:54,022 --> 00:14:55,982
into the objects.

295
00:14:55,982 --> 00:15:00,922
So the client hasn't directly instantiated

296
00:15:00,922 --> 00:15:03,463
the MessageOfTheDayService.

297
00:15:03,463 --> 00:15:06,023
Spring has done it instead.

298
00:15:06,023 --> 00:15:08,783
And all of the runtime dependencies

299
00:15:08,783 --> 00:15:11,063
have all been managed from the container,

300
00:15:11,063 --> 00:15:13,723
and from the config file.

301
00:15:13,723 --> 00:15:15,703
The situation that we're in now,

302
00:15:15,703 --> 00:15:18,643
is that this client will
now have been handed

303
00:15:18,643 --> 00:15:23,503
a direct reference to the
MessageOfTheDayService,

304
00:15:23,503 --> 00:15:27,783
and from here on everything
is very simple now,

305
00:15:27,783 --> 00:15:31,773
because, in fact, the
container is no longer needed

306
00:15:31,773 --> 00:15:34,723
at least for this example.

307
00:15:34,723 --> 00:15:37,843
The client has a reference
to the MessageOfTheDayService

308
00:15:37,843 --> 00:15:42,823
and therefore the client can
now call the method it needs.

309
00:15:42,823 --> 00:15:44,483
And just one last time, I'll remind you

310
00:15:44,483 --> 00:15:47,683
that this might sound like
quite a long winded solution

311
00:15:47,683 --> 00:15:49,343
to a small problem,

312
00:15:49,343 --> 00:15:52,403
and it's true that we
probably wouldn't use Spring

313
00:15:52,403 --> 00:15:54,243
for something as simple as

314
00:15:54,243 --> 00:15:55,803
a MessageOfTheDayService,

315
00:15:55,803 --> 00:15:58,583
but once you understand this process,

316
00:15:58,583 --> 00:16:02,143
it's not much work to
start configuring services,

317
00:16:02,143 --> 00:16:04,063
data access objects,

318
00:16:04,063 --> 00:16:05,423
connection pools,

319
00:16:05,423 --> 00:16:06,903
transaction managers,

320
00:16:06,903 --> 00:16:09,323
and all types of complex objects.

321
00:16:09,323 --> 00:16:11,363
And we'll be doing that
through the course,

322
00:16:11,363 --> 00:16:13,583
and the underlying process

323
00:16:13,583 --> 00:16:16,543
is as simple as this.

324
00:16:16,543 --> 00:16:18,423
Well as we saw from the picture,

325
00:16:18,423 --> 00:16:20,883
Spring needs a configuration file

326
00:16:20,883 --> 00:16:23,343
so that it knows two things.

327
00:16:23,343 --> 00:16:27,343
Firstly, which specific
implementation of the class

328
00:16:27,343 --> 00:16:29,663
does it need to create,

329
00:16:29,663 --> 00:16:33,963
and secondly, what properties
will the object need

330
00:16:33,963 --> 00:16:36,543
once it's been instantiated.

331
00:16:36,543 --> 00:16:38,383
Now there are two main ways of doing this,

332
00:16:38,383 --> 00:16:40,543
one is to use annotations,

333
00:16:40,543 --> 00:16:42,823
which we will work on later,

334
00:16:42,823 --> 00:16:46,083
but first we'll look at the XML way.

335
00:16:46,083 --> 00:16:49,503
This method has been in
Spring since the start,

336
00:16:49,503 --> 00:16:53,623
and I think of it as the
traditional way of working.

337
00:16:53,623 --> 00:16:57,103
There are pros and cons
to annotations and XML,

338
00:16:57,103 --> 00:16:59,083
but we'll talk about that later.

339
00:16:59,083 --> 00:17:01,983
For now, let's look at the
file outside of Eclipse

340
00:17:01,983 --> 00:17:03,583
so we have a full understanding

341
00:17:03,583 --> 00:17:06,243
of this file before we start coding.

342
00:17:06,243 --> 00:17:10,903
The outer tag of any Spring
XML configuration file

343
00:17:10,903 --> 00:17:14,863
is this beans tag here.

344
00:17:14,863 --> 00:17:18,323
And the idea is this tag
encloses the definition

345
00:17:18,323 --> 00:17:20,763
of all of the beans,

346
00:17:20,763 --> 00:17:23,043
that's all of the objects,

347
00:17:23,043 --> 00:17:25,743
that you want Spring to configure.

348
00:17:25,743 --> 00:17:28,583
Inside the beans tag will be a series

349
00:17:28,583 --> 00:17:32,063
of bean definitions.

350
00:17:32,063 --> 00:17:34,583
Now we have just one here,

351
00:17:34,583 --> 00:17:38,183
and the first thing to notice about a bean

352
00:17:38,183 --> 00:17:41,703
is that we must give each bean a name,

353
00:17:41,703 --> 00:17:43,923
or an ID.

354
00:17:43,923 --> 00:17:47,403
You'll see the significance of this ID

355
00:17:47,403 --> 00:17:49,043
in a few moments when we look

356
00:17:49,043 --> 00:17:52,063
at the client side of the application.

357
00:17:52,063 --> 00:17:56,563
Now I've decided to call
this bean motdService.

358
00:17:56,563 --> 00:17:59,023
You can call it anything you like,

359
00:17:59,023 --> 00:18:00,983
it's just a string.

360
00:18:00,983 --> 00:18:04,583
Now the second thing we
need to add to this tag

361
00:18:04,583 --> 00:18:07,983
is a declaration of the class

362
00:18:07,983 --> 00:18:11,563
that this bean is going to come from.

363
00:18:11,563 --> 00:18:15,183
So for you, it would be
whatever your package is called

364
00:18:15,183 --> 00:18:18,563
followed by the concrete specific class

365
00:18:18,563 --> 00:18:21,283
that you want Spring to instantiate.

366
00:18:21,283 --> 00:18:23,023
That's not the interface,

367
00:18:23,023 --> 00:18:26,923
this is the specific
class that you want Spring

368
00:18:26,923 --> 00:18:29,883
to create an instance of.

369
00:18:29,883 --> 00:18:34,883
Inside the bean tag is a
series of optional properties.

370
00:18:35,383 --> 00:18:38,323
Now we know that our
MessageOfTheDayService

371
00:18:38,323 --> 00:18:42,203
needs a message, a single message.

372
00:18:42,203 --> 00:18:46,143
And we need to inject
that into the object.

373
00:18:46,143 --> 00:18:48,583
So the scheme for doing this is the

374
00:18:48,583 --> 00:18:50,283
property tag

375
00:18:50,283 --> 00:18:54,003
followed by the name of the set method

376
00:18:54,003 --> 00:18:56,843
that we want Spring to call.

377
00:18:56,843 --> 00:18:59,863
Now what's happening here is we're seeing

378
00:18:59,863 --> 00:19:04,763
the standard Java bean naming convention.

379
00:19:04,763 --> 00:19:08,303
You might not have seen
this convention before.

380
00:19:08,303 --> 00:19:10,963
What will happen here is Spring sees

381
00:19:10,963 --> 00:19:12,903
that the name of the prooerty

382
00:19:12,903 --> 00:19:15,283
is message.

383
00:19:15,283 --> 00:19:18,223
Notice, with a lowercase m.

384
00:19:18,223 --> 00:19:20,543
Spring will therefore know,

385
00:19:20,543 --> 00:19:24,823
that it needs to look for a method called

386
00:19:24,823 --> 00:19:28,123
setMessage,

387
00:19:28,123 --> 00:19:32,063
but with a capital M.

388
00:19:32,063 --> 00:19:35,103
It will turn what I've written

389
00:19:35,103 --> 00:19:36,783
in my XML,

390
00:19:36,783 --> 00:19:39,643
the lowercase message,

391
00:19:39,643 --> 00:19:44,643
into a CamelCase Java method name.

392
00:19:45,078 --> 00:19:47,208
The idea of this is it just means that

393
00:19:47,208 --> 00:19:48,958
we can aviod having to write

394
00:19:48,958 --> 00:19:51,878
ugly and clunky method names

395
00:19:51,878 --> 00:19:54,858
in the configuration file.

396
00:19:54,858 --> 00:19:56,998
As the value for this message is

397
00:19:56,998 --> 00:19:59,638
just a simple string property

398
00:19:59,638 --> 00:20:04,638
all I need to do is directly
specify the property value,

399
00:20:04,738 --> 00:20:07,238
which in this case is going
to be some kind of standard

400
00:20:07,238 --> 00:20:09,878
stock message.

401
00:20:09,878 --> 00:20:12,658
If you have more properties in here

402
00:20:12,658 --> 00:20:15,758
you can go ahead and
list those properties,

403
00:20:15,758 --> 00:20:18,698
and similarly, if you have
more beans to configure

404
00:20:18,698 --> 00:20:20,918
in your application you'd go on

405
00:20:20,918 --> 00:20:23,358
and list those as well.

406
00:20:23,358 --> 00:20:24,618
And finally we're looking now

407
00:20:24,618 --> 00:20:26,878
at the client application.

408
00:20:26,878 --> 00:20:30,818
The first three lines of code
in this client application

409
00:20:30,818 --> 00:20:32,658
are pretty much

410
00:20:32,658 --> 00:20:35,718
as I described on the animation before.

411
00:20:35,718 --> 00:20:40,218
Rather than creating the
MessageOfTheDayService directly,

412
00:20:40,218 --> 00:20:43,058
we're going to ask the Spring container

413
00:20:43,058 --> 00:20:45,238
to configure it for us.

414
00:20:45,238 --> 00:20:47,838
That'll give us a reference to it.

415
00:20:47,838 --> 00:20:50,638
Now the first line of code here

416
00:20:50,638 --> 00:20:54,618
is where we're creating
the Spring container.

417
00:20:54,618 --> 00:20:59,618
Now notice the big ugly class name here.

418
00:20:59,818 --> 00:21:04,458
ClassPathXmlApplicationContext

419
00:21:04,458 --> 00:21:06,918
I'm afraid the class names in Spring

420
00:21:06,918 --> 00:21:10,138
can be a little bit, well, long.

421
00:21:10,138 --> 00:21:15,138
Really that class name
translates as container.

422
00:21:15,738 --> 00:21:16,518
If you want to think of

423
00:21:16,518 --> 00:21:21,018
ClassPathXmlApplicationContext
as being container

424
00:21:21,018 --> 00:21:23,658
you won't be far wrong.

425
00:21:23,658 --> 00:21:27,798
And notice, in fact, that I'm
calling the resulting object

426
00:21:27,798 --> 00:21:31,178
just container.

427
00:21:31,178 --> 00:21:34,158
Now although in the
Spring reference manual

428
00:21:34,158 --> 00:21:37,858
they talk a lot about containers.

429
00:21:37,858 --> 00:21:40,698
in the Java they use the term

430
00:21:40,698 --> 00:21:44,318
Application Context for container,

431
00:21:44,318 --> 00:21:46,158
which is a bit confusing,

432
00:21:46,158 --> 00:21:49,198
but I hope that later on in this chapter

433
00:21:49,198 --> 00:21:53,978
I'll try to explain
why Application Context

434
00:21:53,978 --> 00:21:56,918
is a term that does make some sense.

435
00:21:56,918 --> 00:21:59,098
It's a bit jargony,

436
00:21:59,098 --> 00:22:02,138
but for now just think
of it as a container.

437
00:22:02,138 --> 00:22:05,738
Anyway, we're going to be
configuring this container,

438
00:22:05,738 --> 00:22:09,018
or if you prefer, Application Context

439
00:22:09,018 --> 00:22:11,678
using an XML file.

440
00:22:11,678 --> 00:22:14,158
And that XML file is going to be

441
00:22:14,158 --> 00:22:16,938
somewhere on our class path.

442
00:22:16,938 --> 00:22:20,538
Hence the first part of the class name.

443
00:22:20,538 --> 00:22:23,958
By that I just mean that the XML file

444
00:22:23,958 --> 00:22:27,158
is going to be in our SRC folder.

445
00:22:27,158 --> 00:22:30,418
It's going to be in our Java source code.

446
00:22:30,418 --> 00:22:31,658
Now I didn't mention this,

447
00:22:31,658 --> 00:22:33,398
but we're going to call the file

448
00:22:33,398 --> 00:22:36,218
application.xml

449
00:22:36,218 --> 00:22:39,418
You can call this file anything you wish

450
00:22:39,418 --> 00:22:42,858
but I usually go for application.xml

451
00:22:42,858 --> 00:22:44,998
because really with this file

452
00:22:44,998 --> 00:22:48,118
you're configuring the set up

453
00:22:48,118 --> 00:22:51,878
of your entire application.

454
00:22:51,878 --> 00:22:55,358
Well, line one was an ugly line of code,

455
00:22:55,358 --> 00:22:57,558
but once it's done we've now

456
00:22:57,558 --> 00:22:59,998
got the container up and running.

457
00:22:59,998 --> 00:23:03,058
The main thing that we want
to do with this container

458
00:23:03,058 --> 00:23:06,018
is to access the beans
that we've configured,

459
00:23:06,018 --> 00:23:07,958
and the way that we access the beans

460
00:23:07,958 --> 00:23:11,358
and this is where that ID comes into play.

461
00:23:11,358 --> 00:23:15,138
You'll recall that we gave
our MessageOfTheDayService

462
00:23:15,138 --> 00:23:18,908
an ID of motdService.

463
00:23:19,758 --> 00:23:21,478
Now the way that we access the bean

464
00:23:21,478 --> 00:23:22,958
from the container

465
00:23:22,958 --> 00:23:26,978
is to call the getBean method.

466
00:23:26,978 --> 00:23:30,558
I'd say the getBean method
is the most important method

467
00:23:30,558 --> 00:23:33,598
probably in the whole of Spring.

468
00:23:33,598 --> 00:23:35,658
As you can see here,

469
00:23:35,658 --> 00:23:39,218
in the parameters we are
firstly specifying the ID

470
00:23:39,218 --> 00:23:41,878
of the bean that we want.

471
00:23:41,878 --> 00:23:43,978
Oh, in the getBean method we also

472
00:23:43,978 --> 00:23:48,378
need to specify what the
type of the object is.

473
00:23:48,378 --> 00:23:52,438
Now this is just so that Java
can maintain its type safety.

474
00:23:52,438 --> 00:23:55,378
There are a few options here

475
00:23:55,378 --> 00:23:58,038
and I think I'll wait
until we get into Eclipse

476
00:23:58,038 --> 00:24:00,238
to show you those options.

477
00:24:00,238 --> 00:24:02,298
If you know about Java generics

478
00:24:02,298 --> 00:24:06,178
and Java types you'll know
what's going on there.

479
00:24:06,178 --> 00:24:09,398
Now once we've completed those two steps

480
00:24:09,398 --> 00:24:13,458
we're back now into standard Java.

481
00:24:13,458 --> 00:24:16,858
All we have to do now is
call the business method

482
00:24:16,858 --> 00:24:18,658
that we want,

483
00:24:18,658 --> 00:24:22,348
and in our case it's
called getTodaysMessage.

484
00:24:23,278 --> 00:24:25,358
Now there is one final line of code,

485
00:24:25,358 --> 00:24:27,658
and you might not always see this

486
00:24:27,658 --> 00:24:29,118
in a Spring application.

487
00:24:29,118 --> 00:24:31,698
In fact, on the first
edition of this course

488
00:24:31,698 --> 00:24:33,978
I didn't bother calling this method

489
00:24:33,978 --> 00:24:37,078
because it's technically not needed.

490
00:24:37,078 --> 00:24:40,518
This close method is telling the container

491
00:24:40,518 --> 00:24:43,298
to close at the end of the program.

492
00:24:43,298 --> 00:24:45,138
Now this will give the container a chance

493
00:24:45,138 --> 00:24:48,298
to do any work that needs to be done

494
00:24:48,298 --> 00:24:52,058
before the objects in the
container are destroyed.

495
00:24:52,058 --> 00:24:54,418
And we really don't need this here

496
00:24:54,418 --> 00:24:57,418
because they're just basic Java objects.

497
00:24:57,418 --> 00:24:59,858
But before long we'll
be writing applications

498
00:24:59,858 --> 00:25:03,178
that open database connections,

499
00:25:03,178 --> 00:25:06,738
and maybe open files,

500
00:25:06,738 --> 00:25:08,758
or other kinds of resources.

501
00:25:08,758 --> 00:25:11,638
So it will be through this close method

502
00:25:11,638 --> 00:25:13,478
that the container,

503
00:25:13,478 --> 00:25:16,958
that Spring will know it
needs to close connections,

504
00:25:16,958 --> 00:25:18,858
clean up resources, and so on.

505
00:25:18,858 --> 00:25:20,518
So for this edition of the course

506
00:25:20,518 --> 00:25:23,558
I've decided to always call close

507
00:25:23,558 --> 00:25:27,358
just because I think it's
good engineering practice.

508
00:25:27,358 --> 00:25:28,918
So that's a lot of talk,

509
00:25:28,918 --> 00:25:29,878
what we'll do now then

510
00:25:29,878 --> 00:25:31,278
is switch across to Eclipse

511
00:25:31,278 --> 00:25:33,538
and see if this all works.

512
00:25:33,538 --> 00:25:36,998
So I've already transferred across the XML

513
00:25:36,998 --> 00:25:39,418
and there's nothing of
difference between this

514
00:25:39,418 --> 00:25:42,858
and what you saw on the
caption a few moments ago.

515
00:25:42,858 --> 00:25:45,518
So you can either pause the video here

516
00:25:45,518 --> 00:25:47,278
and type in for yourself,

517
00:25:47,278 --> 00:25:50,258
or if you prefer, as always,

518
00:25:50,258 --> 00:25:52,758
all of the completed files are available

519
00:25:52,758 --> 00:25:54,878
in the final code folder

520
00:25:54,878 --> 00:25:57,678
in your practicals and code download.

521
00:25:57,678 --> 00:26:01,298
So just make that change
and save the file.

522
00:26:01,298 --> 00:26:02,878
And I've also created the

523
00:26:02,878 --> 00:26:06,898
client application as well,

524
00:26:06,898 --> 00:26:08,758
and nothing has really changed

525
00:26:08,758 --> 00:26:10,038
from what you saw before

526
00:26:10,038 --> 00:26:14,098
except I decided to put this
class into a package of its own

527
00:26:14,098 --> 00:26:17,758
and I've created a package
here called Client.

528
00:26:17,758 --> 00:26:20,778
You can do the same if you wish.

529
00:26:20,778 --> 00:26:24,558
Now as you can see, I am
getting several compile errors.

530
00:26:24,558 --> 00:26:28,478
Now these compile errors,
as you can probably guess,

531
00:26:28,478 --> 00:26:32,318
is because I'm missing some imports.

532
00:26:32,318 --> 00:26:33,738
Now the imports I'm missing,

533
00:26:33,738 --> 00:26:35,998
let's have a look at the easy ones.

534
00:26:35,998 --> 00:26:38,598
The MessageOfTheDayService here,

535
00:26:38,598 --> 00:26:41,598
well that's the interface that I wrote,

536
00:26:41,598 --> 00:26:43,198
but it's just in a different package

537
00:26:43,198 --> 00:26:44,718
than the one I'm in here.

538
00:26:44,718 --> 00:26:47,578
So that's an easy fix.

539
00:26:47,578 --> 00:26:50,998
The other compile error
is because, of course,

540
00:26:50,998 --> 00:26:53,418
this class path XML application context

541
00:26:53,418 --> 00:26:55,378
is a Spring class,

542
00:26:55,378 --> 00:26:58,098
and therefore will be in its own package.

543
00:26:58,098 --> 00:26:59,778
So as a shortcut,

544
00:26:59,778 --> 00:27:02,518
and I'm going to do this
a lot on this course,

545
00:27:02,518 --> 00:27:06,598
is I'm going to press Ctrl+Shift+O

546
00:27:06,598 --> 00:27:08,718
because I'm recording on a PC.

547
00:27:08,718 --> 00:27:10,618
If you're on a Macintosh then the shortcut

548
00:27:10,618 --> 00:27:14,298
is the Cmd+Shift+O keys.

549
00:27:14,298 --> 00:27:17,178
And that will organize the imports.

550
00:27:17,178 --> 00:27:18,938
And just with that single key press

551
00:27:18,938 --> 00:27:22,358
I've now got the two
imports automatically added.

552
00:27:22,358 --> 00:27:27,358
Now if for some reason you
don't see the Spring import,

553
00:27:28,578 --> 00:27:32,638
then it may be because your
build path isn't correctly set.

554
00:27:32,638 --> 00:27:35,658
You should see, under reference libraries,

555
00:27:35,658 --> 00:27:39,098
the five JAF files that I gave you.

556
00:27:39,098 --> 00:27:40,798
If you're not seeing that,

557
00:27:40,798 --> 00:27:43,858
then drop down the lib folder,

558
00:27:43,858 --> 00:27:45,918
select all of the JAFs in there,

559
00:27:45,918 --> 00:27:47,898
right click,

560
00:27:47,898 --> 00:27:49,998
select build path,

561
00:27:49,998 --> 00:27:53,038
and you'll select add to
build path from here now.

562
00:27:53,038 --> 00:27:54,178
It's not available for me

563
00:27:54,178 --> 00:27:56,538
because they're already on the build path.

564
00:27:56,538 --> 00:28:00,638
Ctrl+Shift+O should add in those inputs.

565
00:28:00,638 --> 00:28:02,258
Now I'm still seeing errors here,

566
00:28:02,258 --> 00:28:06,018
but I think that's just because
I haven't saved the file.

567
00:28:06,018 --> 00:28:08,558
And there we are now, a clean compile.

568
00:28:08,558 --> 00:28:11,458
So, I think, we are now ready for a run.

569
00:28:11,458 --> 00:28:12,318
Hold your breath,

570
00:28:12,318 --> 00:28:16,178
this is our first Spring application run.

571
00:28:16,178 --> 00:28:18,398
We will right click on
the client application,

572
00:28:18,398 --> 00:28:19,678
and run as,

573
00:28:19,678 --> 00:28:22,278
and Java application.

574
00:28:22,278 --> 00:28:23,658
Let's just maximize the console

575
00:28:23,658 --> 00:28:25,098
so we can see what's going on here.

576
00:28:25,098 --> 00:28:27,618
Well we do have some red text here

577
00:28:27,618 --> 00:28:29,778
which may seem a little alarming,

578
00:28:29,778 --> 00:28:32,918
but if you have a look in
detail at that red text

579
00:28:32,918 --> 00:28:37,058
you'll see that it really is
just some kind of logging.

580
00:28:37,058 --> 00:28:39,058
Some information logging

581
00:28:39,058 --> 00:28:41,318
coming from the Spring framework.

582
00:28:41,318 --> 00:28:45,578
And really, there's nothing
of interest in there at all.

583
00:28:45,578 --> 00:28:48,438
It's really quite internal to Spring.

584
00:28:48,438 --> 00:28:50,738
Now we could configure that away,

585
00:28:50,738 --> 00:28:53,098
but, well it really
doesn't matter for now.

586
00:28:53,098 --> 00:28:56,158
What does matter is that
we've got the output here

587
00:28:56,158 --> 00:28:58,418
of Well Hello There.

588
00:28:58,418 --> 00:29:01,818
Well, of course that was a lot of work

589
00:29:01,818 --> 00:29:04,558
for a fairly simple result,

590
00:29:04,558 --> 00:29:06,758
but what I hope to demonstrate now

591
00:29:06,758 --> 00:29:07,858
for the next few minutes

592
00:29:07,858 --> 00:29:11,798
is just how flexible this solution now is.

593
00:29:11,798 --> 00:29:15,078
Now the most obvious piece
of functionality I guess

594
00:29:15,078 --> 00:29:18,658
is the message of the day
can now be easily changed

595
00:29:18,658 --> 00:29:21,278
by the system administrator
without the need

596
00:29:21,278 --> 00:29:24,018
to recompile any Java code.

597
00:29:24,018 --> 00:29:25,798
All we would need to go do

598
00:29:25,798 --> 00:29:28,678
is to go into the XML file

599
00:29:28,678 --> 00:29:31,158
and let's say a particular customer

600
00:29:31,158 --> 00:29:34,498
is not happy with this message of the day,

601
00:29:34,498 --> 00:29:37,578
I don't know, because it
doesn't translate well

602
00:29:37,578 --> 00:29:40,738
in the particular country
their system running in.

603
00:29:40,738 --> 00:29:42,698
And they want a completely
different message

604
00:29:42,698 --> 00:29:46,618
all they would have to do
is make the change here,

605
00:29:46,618 --> 00:29:48,458
save the XML file,

606
00:29:48,458 --> 00:29:51,398
and then we run the application again,

607
00:29:51,398 --> 00:29:52,398
and as you can see here,

608
00:29:52,398 --> 00:29:54,558
we have a different message.

609
00:29:54,558 --> 00:29:57,138
By the way, you may sometimes see the

610
00:29:57,138 --> 00:30:01,378
message output in the
middle of the red text.

611
00:30:01,378 --> 00:30:03,598
As you can see here.

612
00:30:03,598 --> 00:30:04,758
Now the reason for that is because

613
00:30:04,758 --> 00:30:08,858
the red text is the error stream in Java,

614
00:30:08,858 --> 00:30:11,598
and the error stream is not buffered.

615
00:30:11,598 --> 00:30:12,898
I think the reasoning is

616
00:30:12,898 --> 00:30:16,398
perhaps with errors you want
to see them immediately.

617
00:30:16,398 --> 00:30:20,898
Whereas anything written
to system.out is buffered,

618
00:30:20,898 --> 00:30:24,238
and sometimes appears at a
completely different time.

619
00:30:24,238 --> 00:30:25,698
I don't really understand that,

620
00:30:25,698 --> 00:30:28,618
but the point is this can
be a little bit random.

621
00:30:28,618 --> 00:30:31,178
If I run it a few more times.

622
00:30:33,298 --> 00:30:35,548
There, yeah you can see.

623
00:30:36,718 --> 00:30:39,258
Sometimes it's in a different order.

624
00:30:39,258 --> 00:30:42,018
So okay, that's the
first bit of flexibility,

625
00:30:42,018 --> 00:30:44,178
but that's a bit boring really.

626
00:30:44,178 --> 00:30:45,558
We could have got the same result

627
00:30:45,558 --> 00:30:47,638
from a properties file.

628
00:30:47,638 --> 00:30:50,218
The real flexibility in Spring

629
00:30:50,218 --> 00:30:55,018
is that we can now change
this implementation class

630
00:30:55,018 --> 00:30:59,041
without affecting any
of the rest of the code.

631
00:30:59,041 --> 00:31:00,881
Let's demonstrate.

632
00:31:00,881 --> 00:31:02,801
Let's say that we've got many customers

633
00:31:02,801 --> 00:31:04,541
of our new application,

634
00:31:04,541 --> 00:31:07,421
and lot's of them are really happy

635
00:31:07,421 --> 00:31:10,421
with our boring message of the day.

636
00:31:10,421 --> 00:31:12,821
Their message of the day never changes,

637
00:31:12,821 --> 00:31:15,541
unless the system
administrator can be bothered

638
00:31:15,541 --> 00:31:17,261
to change the XML,

639
00:31:17,261 --> 00:31:18,961
but most customers are happy,

640
00:31:18,961 --> 00:31:21,481
but a few customers are
starting to complain.

641
00:31:21,481 --> 00:31:24,101
They'd like to see a more dynamic version

642
00:31:24,101 --> 00:31:27,261
of this message of the day service.

643
00:31:27,261 --> 00:31:30,861
They'd like to see a
different message everyday.

644
00:31:30,861 --> 00:31:33,341
Depending on the day of the week.

645
00:31:33,341 --> 00:31:36,201
We want to be able to
accommodate those customers,

646
00:31:36,201 --> 00:31:39,301
but we don't want to upset the customers

647
00:31:39,301 --> 00:31:41,661
who are currently happy

648
00:31:41,661 --> 00:31:44,161
with their static implementation.

649
00:31:44,161 --> 00:31:46,341
So in other words,

650
00:31:46,341 --> 00:31:48,661
I can't just go into here

651
00:31:48,661 --> 00:31:50,941
and start adding the new functionality

652
00:31:50,941 --> 00:31:55,941
because we need to leave
this class as it stands.

653
00:31:56,241 --> 00:32:00,781
So I really need to provide
an alternative implementation.

654
00:32:00,781 --> 00:32:04,061
Now if I look across at my interface,

655
00:32:04,061 --> 00:32:06,881
the MessageOfTheDayService interface,

656
00:32:06,881 --> 00:32:09,461
I guess what I really need to do now

657
00:32:09,461 --> 00:32:12,321
is create a second implementation

658
00:32:12,321 --> 00:32:15,441
of this same interface.

659
00:32:15,441 --> 00:32:17,601
So let's do just that.

660
00:32:17,601 --> 00:32:19,921
Now the difficult thing is,

661
00:32:20,821 --> 00:32:23,281
because I've already got
one implementation of this

662
00:32:23,281 --> 00:32:27,901
is coming up with a
reasonable name for it.

663
00:32:27,901 --> 00:32:30,701
You'll find that sometimes these
class names get quite long.

664
00:32:30,701 --> 00:32:35,671
I'm going for
MessageOfTheDayDailyDynamicImpl

665
00:32:39,441 --> 00:32:43,761
and I'll just use Impl for implementation.

666
00:32:43,761 --> 00:32:46,381
Well it's not a very pretty class name,

667
00:32:46,381 --> 00:32:47,981
but it will do for now,

668
00:32:47,981 --> 00:32:50,541
and I'll come back later
and talk a little bit

669
00:32:50,541 --> 00:32:51,941
about these class names

670
00:32:51,941 --> 00:32:53,781
and why it doesn't necessarily matter

671
00:32:53,781 --> 00:32:56,181
if the classes are a little bit ugly.

672
00:32:56,181 --> 00:33:00,061
So I want this class to
implement the same interface

673
00:33:00,061 --> 00:33:02,701
as the previous implementation,

674
00:33:02,701 --> 00:33:07,231
so it's already giving me
MessageOfTheDayService there,

675
00:33:07,231 --> 00:33:10,281
but I could have typed messageof in here

676
00:33:10,281 --> 00:33:13,501
it would have given me
that as a suggestion.

677
00:33:13,501 --> 00:33:15,441
If I click on finish,

678
00:33:15,441 --> 00:33:19,961
as before, I'm already getting
a basic stub implementation

679
00:33:19,961 --> 00:33:22,061
of this class.

680
00:33:22,061 --> 00:33:26,101
So I'm now free to come
up with any implementation

681
00:33:26,101 --> 00:33:28,021
that I like.

682
00:33:28,021 --> 00:33:30,681
Now as this is just standard Java,

683
00:33:30,681 --> 00:33:34,261
I've already written an
implementation off camera.

684
00:33:34,261 --> 00:33:37,021
Now you can get this
from the finished version

685
00:33:37,021 --> 00:33:41,041
of this system in the
practicals and code folder.

686
00:33:41,041 --> 00:33:44,121
I'm not going to bore
you by typing it in here.

687
00:33:44,121 --> 00:33:45,661
I'm going to save some time here

688
00:33:45,661 --> 00:33:49,541
by fading to the code
that I prepared earlier.

689
00:33:49,541 --> 00:33:53,221
Well here is the class that I
implemented off camera then.

690
00:33:53,221 --> 00:33:57,561
I don't think this is going
to win any Java coding awards,

691
00:33:57,561 --> 00:34:01,301
but at least it's richer than
my previous implementation.

692
00:34:01,301 --> 00:34:02,741
So let's go through it.

693
00:34:02,741 --> 00:34:04,661
First of all, I have a class here

694
00:34:04,661 --> 00:34:07,621
with that big long ugly class name.

695
00:34:07,621 --> 00:34:10,601
But it's implementing the same interface

696
00:34:10,601 --> 00:34:13,361
as our previous implementation.

697
00:34:13,361 --> 00:34:17,441
This time around, instead
of injecting the messages

698
00:34:17,441 --> 00:34:19,641
I've just hard coded them in

699
00:34:19,641 --> 00:34:23,101
straight into a Java
array called messages.

700
00:34:23,101 --> 00:34:25,181
Now that's not very sophisticated,

701
00:34:25,181 --> 00:34:27,461
but I'll return to that shortly.

702
00:34:27,461 --> 00:34:32,461
The implementation of the
getTodaysMessage method,

703
00:34:33,141 --> 00:34:35,401
instead of just returning the message,

704
00:34:35,401 --> 00:34:37,161
this time it's a bit more sophisticated.

705
00:34:37,161 --> 00:34:40,961
It's using the Java
Gregorian Calendar class

706
00:34:40,961 --> 00:34:44,741
to work out what day of the week it is.

707
00:34:44,741 --> 00:34:48,721
And then it looks in its array of messages

708
00:34:48,721 --> 00:34:51,781
and it returns back
the appropriate message

709
00:34:51,781 --> 00:34:54,621
personalized for the day of the weeks.

710
00:34:54,621 --> 00:34:58,041
So okay, it's not amazing implementation,

711
00:34:58,041 --> 00:35:00,941
but a bit more interesting than before.

712
00:35:00,941 --> 00:35:02,381
So the big question is,

713
00:35:02,381 --> 00:35:05,241
how do I make Spring
use this implementation

714
00:35:05,241 --> 00:35:09,301
instead of the previous implementation?

715
00:35:09,301 --> 00:35:13,241
Well the answer is going to be in the XML.

716
00:35:13,241 --> 00:35:14,441
Let's have a look then,

717
00:35:14,441 --> 00:35:16,761
and have a look at what we need to change.

718
00:35:16,761 --> 00:35:18,481
The only real change,

719
00:35:18,481 --> 00:35:20,641
there will be a couple of changes,

720
00:35:20,641 --> 00:35:23,341
but the big change is
we just need to change

721
00:35:23,341 --> 00:35:27,061
the implementing class name here.

722
00:35:27,061 --> 00:35:29,921
This is the basic implementation.

723
00:35:29,921 --> 00:35:31,661
All I need to do is replace that

724
00:35:31,661 --> 00:35:34,161
with the class name
that I came with before

725
00:35:34,161 --> 00:35:39,161
it's going to be the DailyDynamicImpl

726
00:35:41,002 --> 00:35:43,062
and that's just telling
Spring to use a different

727
00:35:43,062 --> 00:35:44,662
implementing class now.

728
00:35:44,662 --> 00:35:46,462
Before I see if this runs,

729
00:35:46,462 --> 00:35:48,262
I've got a big question for you.

730
00:35:48,262 --> 00:35:51,902
I'm going to switch across
to the client application

731
00:35:51,902 --> 00:35:55,822
and have a good hard look
at this client application,

732
00:35:55,822 --> 00:35:59,282
and the question is,
what do I need to change

733
00:35:59,282 --> 00:36:01,502
in this client application?

734
00:36:01,502 --> 00:36:03,342
Well the answer is,

735
00:36:03,342 --> 00:36:05,502
and well done if you
came up with that answer,

736
00:36:05,502 --> 00:36:09,122
is we would have to
change absolutely nothing,

737
00:36:09,122 --> 00:36:11,662
nothing in this class would change.

738
00:36:11,662 --> 00:36:13,702
Although we have a new implementation

739
00:36:13,702 --> 00:36:16,302
of the interface, because I followed

740
00:36:16,302 --> 00:36:20,702
the principle of programming
only to an interface

741
00:36:20,702 --> 00:36:22,722
these two references here

742
00:36:22,722 --> 00:36:25,002
are just the interfaces

743
00:36:25,002 --> 00:36:28,842
rather than the concrete classes.

744
00:36:28,842 --> 00:36:31,202
Therefore, I've now brought in

745
00:36:31,202 --> 00:36:34,002
a new concrete class into the system,

746
00:36:34,002 --> 00:36:36,322
but because Spring is dealing with that,

747
00:36:36,322 --> 00:36:38,502
once we change the XML,

748
00:36:38,502 --> 00:36:40,662
then Spring will pass it back to us

749
00:36:40,662 --> 00:36:43,322
and we don't have to
make any further changes

750
00:36:43,322 --> 00:36:46,002
in our client code.

751
00:36:46,002 --> 00:36:49,422
So effectively, as long
as this client side

752
00:36:49,422 --> 00:36:53,022
gets back an object
that has a method in it

753
00:36:53,022 --> 00:36:55,262
called getTodaysMessage,

754
00:36:55,262 --> 00:36:56,582
then it's happy.

755
00:36:56,582 --> 00:36:58,762
It doesn't know or care what

756
00:36:58,762 --> 00:37:01,862
the actual implementing class is.

757
00:37:01,862 --> 00:37:05,022
Now when we start to build bigger programs

758
00:37:05,022 --> 00:37:10,022
this ability to kind of plug
in alternative implementations

759
00:37:10,202 --> 00:37:13,082
without changing any of the code

760
00:37:13,082 --> 00:37:16,362
is going to be a big improvement
to our architectures,

761
00:37:16,362 --> 00:37:20,202
and then we could change
entire paths of our application

762
00:37:20,202 --> 00:37:23,402
with just a little bit of XML config.

763
00:37:23,402 --> 00:37:26,692
Well let's see if this runs,

764
00:37:27,642 --> 00:37:28,922
and I'll maximize the console,

765
00:37:28,922 --> 00:37:31,122
and we have a big error,

766
00:37:31,122 --> 00:37:34,682
and it is a common feeling

767
00:37:34,682 --> 00:37:37,442
with many Spring programmers

768
00:37:37,442 --> 00:37:39,842
that these call chains that you get

769
00:37:39,842 --> 00:37:43,182
when Spring crashes can
be quite intimidating,

770
00:37:43,182 --> 00:37:45,562
but if you look through the exception

771
00:37:45,562 --> 00:37:48,862
you can probably ignore most of it.

772
00:37:48,862 --> 00:37:50,562
Most of it is just a call chain.

773
00:37:50,562 --> 00:37:53,922
If you look towards here,

774
00:37:53,922 --> 00:37:55,562
I'll just put a highlighter on that,

775
00:37:55,562 --> 00:38:00,472
it's saying invalid property
message of bean class.

776
00:38:02,082 --> 00:38:05,082
And I think if you go a
little further forward

777
00:38:05,082 --> 00:38:09,922
it's saying bean property
message is not writable.

778
00:38:09,922 --> 00:38:14,752
Let's go back to our original
basic implementation.

779
00:38:15,962 --> 00:38:18,322
Now that has the
getTodaysMessage method in,

780
00:38:18,322 --> 00:38:20,642
which it must have,

781
00:38:20,642 --> 00:38:25,362
but it also required a set message method.

782
00:38:25,362 --> 00:38:27,342
Now we needed that because we wanted

783
00:38:27,342 --> 00:38:29,762
to inject the message

784
00:38:29,762 --> 00:38:32,082
into this implementation.

785
00:38:32,082 --> 00:38:33,262
The thing is though,

786
00:38:33,262 --> 00:38:37,162
for this new DailyDynamicImpl

787
00:38:37,162 --> 00:38:39,002
we don't need that anymore

788
00:38:39,002 --> 00:38:42,882
because the messages are now
hard coded into the Java.

789
00:38:42,882 --> 00:38:46,822
So it's now a redundant property.

790
00:38:46,822 --> 00:38:51,622
So the error really is in
the XML, not in the code.

791
00:38:51,622 --> 00:38:53,622
If we look in the XML we can see

792
00:38:53,622 --> 00:38:57,972
that we are still trying to
configure the message property

793
00:38:57,972 --> 00:38:59,982
with this value of Howdy,

794
00:38:59,982 --> 00:39:02,142
and we simply don't need it.

795
00:39:02,142 --> 00:39:03,682
We can get rid of it.

796
00:39:03,682 --> 00:39:05,882
So you'll see now that this XML file

797
00:39:05,882 --> 00:39:08,762
is completely different when we want

798
00:39:08,762 --> 00:39:11,762
to run with the DailyDynamicImpl

799
00:39:11,762 --> 00:39:15,322
from how it looked when we ran
with the basic implementation

800
00:39:15,322 --> 00:39:17,542
So what we have really,

801
00:39:17,542 --> 00:39:22,512
are different XML files
for different contexts.

802
00:39:23,682 --> 00:39:25,982
In my requirement, different customers

803
00:39:25,982 --> 00:39:29,222
wanted different
implementations of this service.

804
00:39:29,222 --> 00:39:32,522
So you would simply give
each different customer

805
00:39:32,522 --> 00:39:35,422
their own tailored XML file.

806
00:39:35,422 --> 00:39:38,522
The XML is describing how we want

807
00:39:38,522 --> 00:39:40,442
the application to be configured

808
00:39:40,442 --> 00:39:43,282
based on some context,

809
00:39:43,282 --> 00:39:47,782
which is why Spring uses
this rather jargon term

810
00:39:47,782 --> 00:39:51,042
of application context.

811
00:39:51,042 --> 00:39:52,722
I just want to reemphasize though,

812
00:39:52,722 --> 00:39:54,762
that the most important message

813
00:39:54,762 --> 00:39:56,442
from this entire session is that

814
00:39:56,442 --> 00:40:00,102
the client application
is completely unchanged.

815
00:40:00,102 --> 00:40:02,082
I didn't need to do any recompiling,

816
00:40:02,082 --> 00:40:04,882
or any serious rebuilding of my app.

817
00:40:04,882 --> 00:40:05,962
So let's make sure it runs and

818
00:40:05,962 --> 00:40:08,742
by the way, before I run this,

819
00:40:08,742 --> 00:40:10,542
I'll tell you we are
recording this session

820
00:40:10,542 --> 00:40:13,022
on a Friday evening.

821
00:40:13,022 --> 00:40:18,022
So let's see if my,

822
00:40:18,062 --> 00:40:19,502
yeah, well the message appears

823
00:40:19,502 --> 00:40:21,142
to mention the word Friday

824
00:40:21,142 --> 00:40:24,482
so I think that looks okay.

825
00:40:24,482 --> 00:40:26,602
To be honest, I would probably,

826
00:40:26,602 --> 00:40:29,142
for the dynamic implementation,

827
00:40:29,142 --> 00:40:31,962
I would probably want a
decent unit test on that

828
00:40:31,962 --> 00:40:33,442
because I have no idea

829
00:40:33,442 --> 00:40:37,042
if my use of Gregorian
Calendar is robust or not.

830
00:40:37,042 --> 00:40:40,062
I hate the Gregorian Calendar class,

831
00:40:40,062 --> 00:40:42,482
but it is certainly working today.

832
00:40:42,482 --> 00:40:43,742
Now before we finish this chapter

833
00:40:43,742 --> 00:40:45,242
there is one thing that
has been bothering me

834
00:40:45,242 --> 00:40:48,382
about this DailyDynamicImpl
and that is, of course

835
00:40:48,382 --> 00:40:51,322
we're hard coding the
messages into the class,

836
00:40:51,322 --> 00:40:54,082
which isn't very clever at all.

837
00:40:54,082 --> 00:40:56,562
I would much rather that these messages

838
00:40:56,562 --> 00:41:00,102
be injected as a dependency

839
00:41:00,102 --> 00:41:02,122
instead of them being hard coded.

840
00:41:02,122 --> 00:41:03,462
So I'm going to change that,

841
00:41:03,462 --> 00:41:06,282
but I'm conscious that I want this class

842
00:41:06,282 --> 00:41:08,742
to be in the final code

843
00:41:08,742 --> 00:41:11,442
so that you have a copy
of this class for yourself

844
00:41:11,442 --> 00:41:13,542
if you need it.

845
00:41:13,542 --> 00:41:16,492
So of course what I can do
instead of changing this

846
00:41:16,492 --> 00:41:21,492
is I can now create a third
implementation of the interface.

847
00:41:23,032 --> 00:41:24,652
I'm going to call this one

848
00:41:24,652 --> 00:41:29,652
MessageOfTheDayDynamicConfigurableImpl.

849
00:41:33,832 --> 00:41:35,232
These are getting a bit silly now,

850
00:41:35,232 --> 00:41:36,212
these class names,

851
00:41:36,212 --> 00:41:38,252
but I hope you get the idea.

852
00:41:38,252 --> 00:41:41,692
It's going to implement the
same interface as before

853
00:41:41,692 --> 00:41:43,512
the MessageOfTheDayService.

854
00:41:43,512 --> 00:41:45,432
The difference this time is

855
00:41:45,432 --> 00:41:48,932
the property holding the messages

856
00:41:48,932 --> 00:41:50,972
I'm not going to configure in here.

857
00:41:50,972 --> 00:41:54,312
I'm going to inject the
values using Spring.

858
00:41:54,312 --> 00:41:56,812
Now, in fact, just to be absolutely clear

859
00:41:56,812 --> 00:42:00,112
I'm going to call this
property messageList

860
00:42:00,112 --> 00:42:03,752
just to emphasize that
it's more than one message.

861
00:42:03,752 --> 00:42:06,432
I'm not going to
configure that value here.

862
00:42:06,432 --> 00:42:10,532
Instead, I'm going to let
Spring inject the values

863
00:42:10,532 --> 00:42:15,422
so therefore, we need a
pubic void set method.

864
00:42:17,172 --> 00:42:19,472
Now you can this set
method anything you wish,

865
00:42:19,472 --> 00:42:22,412
but for consistency, we usually match

866
00:42:22,412 --> 00:42:24,812
the method name with the attribute name.

867
00:42:24,812 --> 00:42:28,132
So I'm going to call this setMessageList,

868
00:42:28,132 --> 00:42:30,112
and it will receive a parameter

869
00:42:30,112 --> 00:42:34,792
of a matching type string
array in this case.

870
00:42:36,062 --> 00:42:39,132
Now the implementation of
this is going to be trivial.

871
00:42:39,132 --> 00:42:41,932
We're just going to set the message list

872
00:42:41,932 --> 00:42:46,152
to be whatever was passed in.

873
00:42:46,152 --> 00:42:47,152
Now it's a bit odd this

874
00:42:47,152 --> 00:42:49,732
in this particular implementation.

875
00:42:49,732 --> 00:42:53,772
The getTodaysMessage implementation

876
00:42:53,772 --> 00:42:55,952
is going to be the same as it was

877
00:42:55,952 --> 00:42:59,532
in my previous DailyDynamicImpl

878
00:42:59,532 --> 00:43:01,332
so if you'll forgive me,

879
00:43:01,332 --> 00:43:03,172
I'm just going to copy and paste this.

880
00:43:03,172 --> 00:43:05,712
I probably shouldn't copy and paste,

881
00:43:05,712 --> 00:43:08,332
but just for speed,

882
00:43:08,332 --> 00:43:09,632
just to get the idea across

883
00:43:09,632 --> 00:43:12,332
I'll do it just this once.

884
00:43:12,332 --> 00:43:14,372
I just need a simple change in here,

885
00:43:14,372 --> 00:43:17,172
which is I've called
in messages previously

886
00:43:17,172 --> 00:43:20,572
so in this class it's now message list.

887
00:43:20,572 --> 00:43:25,572
So this is a more flexible
version of that DailyDynamicImpl

888
00:43:25,572 --> 00:43:30,352
This time around I can pass
in the messages instead.

889
00:43:30,352 --> 00:43:34,392
So for the XML file, I'm
going copy that class name,

890
00:43:34,392 --> 00:43:36,132
and I'm going to change now so that

891
00:43:36,132 --> 00:43:39,992
Spring is now instantiating our new

892
00:43:39,992 --> 00:43:43,932
DailyDynamicConfigurableImpl.

893
00:43:43,932 --> 00:43:46,172
Now as things stand,

894
00:43:46,172 --> 00:43:49,412
if I run this application,

895
00:43:49,412 --> 00:43:51,012
yeah I'm going to get a crash,

896
00:43:51,012 --> 00:43:51,772
and I'm getting a crash

897
00:43:51,772 --> 00:43:54,372
it's a null pointer exception

898
00:43:54,372 --> 00:43:57,652
simply because I haven't configured

899
00:43:57,652 --> 00:43:59,732
the message list property.

900
00:43:59,732 --> 00:44:01,192
So we need to do that,

901
00:44:01,192 --> 00:44:03,312
and we know how to do that by now.

902
00:44:03,312 --> 00:44:05,512
It's property

903
00:44:05,512 --> 00:44:08,752
name= followed by the
name of the property,

904
00:44:08,752 --> 00:44:13,532
which in this case is message list.

905
00:44:13,532 --> 00:44:15,592
Now before, we set a value,

906
00:44:15,592 --> 00:44:17,752
which was a single string value,

907
00:44:17,752 --> 00:44:20,512
but of course here we've
got more than one string

908
00:44:20,512 --> 00:44:21,952
in an array.

909
00:44:21,952 --> 00:44:25,052
Well the answer is we don't
specify the value here.

910
00:44:25,052 --> 00:44:29,192
We close the tag and
inside the property tag

911
00:44:29,192 --> 00:44:33,632
we can tell Spring that we're
giving it a list of values.

912
00:44:33,632 --> 00:44:37,092
So we use the list XML tag

913
00:44:37,092 --> 00:44:39,192
and then inside that tag,

914
00:44:39,192 --> 00:44:42,752
we can supply multiple values

915
00:44:42,752 --> 00:44:44,572
so there's value one,

916
00:44:44,572 --> 00:44:47,472
there's value two,

917
00:44:47,472 --> 00:44:48,752
and so on.

918
00:44:48,752 --> 00:44:50,752
Well for us this is going to be

919
00:44:50,752 --> 00:44:52,432
the messages for the day of the week.

920
00:44:52,432 --> 00:44:55,992
I think first in the list
needs to be the Sunday message,

921
00:44:55,992 --> 00:44:58,092
and I'm not really

922
00:44:59,632 --> 00:45:02,722
very inspired right now.

923
00:45:03,892 --> 00:45:06,412
I'm just going to plug in the day

924
00:45:06,412 --> 00:45:08,152
names of the days of the weeks.

925
00:45:08,152 --> 00:45:13,082
So Tuesday and Wednesday

926
00:45:15,412 --> 00:45:17,502
and Thursday

927
00:45:20,622 --> 00:45:24,692
and Friday, this is very boring,

928
00:45:24,692 --> 00:45:27,912
and Saturday.

929
00:45:27,912 --> 00:45:31,652
I don't think I need that final value tag.

930
00:45:31,652 --> 00:45:33,972
So that's a technique that enables me

931
00:45:33,972 --> 00:45:38,972
to pass in multiple values
into some kind of a collection.

932
00:45:39,192 --> 00:45:42,212
It could've been a list
rather than an array.

933
00:45:42,212 --> 00:45:44,102
Let's see if that works.

934
00:45:46,372 --> 00:45:48,092
And that looks good.

935
00:45:48,092 --> 00:45:49,692
I'm seeing the value of Friday.

936
00:45:49,692 --> 00:45:52,332
So this third implementation

937
00:45:52,332 --> 00:45:54,012
is a lot more flexible now

938
00:45:54,012 --> 00:45:55,772
that we can configure the messages

939
00:45:55,772 --> 00:45:58,912
using the Spring XML.

940
00:45:58,912 --> 00:46:01,292
Now just before we finish this chapter,

941
00:46:01,292 --> 00:46:03,732
I just want to go back
to the client application

942
00:46:03,732 --> 00:46:05,252
and just show you there is one small

943
00:46:05,252 --> 00:46:08,932
optimization that you
can make on this code.

944
00:46:08,932 --> 00:46:11,112
Let's have a look at the line here.

945
00:46:11,112 --> 00:46:13,292
Let's get a highlighter on that.

946
00:46:13,292 --> 00:46:15,912
Now remember this is where
we're asking the container

947
00:46:15,912 --> 00:46:19,792
for the object we've
asked it to configure.

948
00:46:19,792 --> 00:46:24,152
We gave it the ID of motdService,

949
00:46:24,152 --> 00:46:26,292
and we know that its class,

950
00:46:26,292 --> 00:46:31,292
or at least its interface is
the MessageOfTheDayService.

951
00:46:31,662 --> 00:46:35,372
Now, it is a little bit
tedious to have to look up

952
00:46:35,372 --> 00:46:38,652
or remember this object name.

953
00:46:38,652 --> 00:46:42,212
And as it turns out, from
later versions of Spring

954
00:46:42,212 --> 00:46:44,552
I think this first
arrived in something like

955
00:46:44,552 --> 00:46:47,012
version 2.5 of Spring.

956
00:46:47,012 --> 00:46:51,742
You can remove the ID
from the get bean method.

957
00:46:52,972 --> 00:46:55,292
Now what this is telling Spring

958
00:46:55,292 --> 00:47:00,292
is that it needs to look for
the bean inside the container

959
00:47:00,392 --> 00:47:03,872
that's implementing the
MessageOfTheDayService

960
00:47:03,872 --> 00:47:06,112
and since there's only one of them,

961
00:47:06,112 --> 00:47:08,572
it knows which one to return back.

962
00:47:08,572 --> 00:47:10,632
So it's quite handy, that.

963
00:47:10,632 --> 00:47:13,532
It can often save you having to look up,

964
00:47:13,532 --> 00:47:17,372
remember the ID of the object.

965
00:47:17,372 --> 00:47:22,242
If I just run that through,
then you'll see it still working

966
00:47:23,312 --> 00:47:25,332
Now the problem with this,

967
00:47:25,332 --> 00:47:27,672
it's not actually much of
a problem as it happens,

968
00:47:27,672 --> 00:47:29,312
but the problem would be of course

969
00:47:29,312 --> 00:47:33,742
if for some reason you had two beans

970
00:47:34,672 --> 00:47:36,292
which need to have different names,

971
00:47:36,292 --> 00:47:39,212
so I'll call this motd2,

972
00:47:39,212 --> 00:47:42,632
and maybe the class of this
one is something different,

973
00:47:42,632 --> 00:47:47,522
virtualPairProgrammersMotd.MessageOfTheDay

974
00:47:54,512 --> 00:47:58,552
we'll make this be the basic input.

975
00:47:58,552 --> 00:48:00,432
I won't bother putting
the property in for now

976
00:48:00,432 --> 00:48:03,652
because I don't need it to
demonstrate the concept.

977
00:48:03,652 --> 00:48:07,372
We now have two classes in the container.

978
00:48:07,372 --> 00:48:10,292
Implementing the same interface.

979
00:48:10,292 --> 00:48:11,912
Well in this case if I run,

980
00:48:11,912 --> 00:48:14,512
and maximize the console.

981
00:48:14,512 --> 00:48:16,372
We have an exception,

982
00:48:16,372 --> 00:48:20,932
and it's saying there
is no qualifying bean

983
00:48:20,932 --> 00:48:23,852
of type MessageOfTheDayService,

984
00:48:23,852 --> 00:48:25,252
and yeah that's helpful.

985
00:48:25,252 --> 00:48:28,732
It's saying it's expecting
a single matching bean,

986
00:48:28,732 --> 00:48:31,312
but it found two and they're called

987
00:48:31,312 --> 00:48:34,712
motdService and motd2.

988
00:48:34,712 --> 00:48:37,632
So if there were multiple implementations

989
00:48:37,632 --> 00:48:40,112
inside the same container,

990
00:48:40,112 --> 00:48:43,512
then in that case you would
need to qualify things

991
00:48:43,512 --> 00:48:48,512
by specifying the ID here.

992
00:48:53,652 --> 00:48:55,652
And now the code runs.

993
00:48:55,652 --> 00:48:57,452
But you're going to find actually

994
00:48:57,452 --> 00:49:00,552
even in quite complicated
production systems

995
00:49:00,552 --> 00:49:05,152
that in a single container you
only have one implementation

996
00:49:05,152 --> 00:49:08,172
of any particular interface.

997
00:49:08,172 --> 00:49:09,412
And we'll have to go a little further

998
00:49:09,412 --> 00:49:12,512
with Spring before I
can prove that to you,

999
00:49:12,512 --> 00:49:15,272
but it just is the case

1000
00:49:15,272 --> 00:49:18,152
that often you only
have one implementation

1001
00:49:18,152 --> 00:49:19,352
of a particular interface.

1002
00:49:19,352 --> 00:49:21,532
So it's quite the useful optimization

1003
00:49:21,532 --> 00:49:24,272
that we can often remove

1004
00:49:24,272 --> 00:49:26,792
the name of the bean we
are trying to look up.

1005
00:49:26,792 --> 00:49:29,172
Just for the purposed of
the practicals of code

1006
00:49:29,172 --> 00:49:31,412
I will remove that second implementation

1007
00:49:31,412 --> 00:49:34,612
because it's not really
doing anything useful.

1008
00:49:34,612 --> 00:49:36,092
Well I can hear music playing now,

1009
00:49:36,092 --> 00:49:37,852
so we're nearly finished
with this chapter,

1010
00:49:37,852 --> 00:49:40,792
but just as a closing comment,

1011
00:49:40,792 --> 00:49:43,732
you probably felt a little disgusted

1012
00:49:43,732 --> 00:49:45,492
with my class names here,

1013
00:49:45,492 --> 00:49:47,972
and they were getting pretty ugly.

1014
00:49:47,972 --> 00:49:50,012
Especially this third one,

1015
00:49:50,012 --> 00:49:53,112
the DailyDynamicConfigurableImpl.

1016
00:49:53,112 --> 00:49:55,232
But you're going to find that a lot

1017
00:49:55,232 --> 00:49:57,452
of Spring projects do
use these fairly clunky

1018
00:49:57,452 --> 00:49:59,112
implementation names,

1019
00:49:59,112 --> 00:50:02,852
and my feeling on this is
it really doesn't matter.

1020
00:50:02,852 --> 00:50:06,552
It's actually quite useful
to give a good description

1021
00:50:06,552 --> 00:50:10,932
of why you have a
particular implementation.

1022
00:50:10,932 --> 00:50:12,572
Now you might object because

1023
00:50:12,572 --> 00:50:14,752
well it's a lot of typing,

1024
00:50:14,752 --> 00:50:17,472
and it's going to make
your code look uglier,

1025
00:50:17,472 --> 00:50:20,492
but I just want to draw
your attention to the fact

1026
00:50:20,492 --> 00:50:22,812
that in fact in the code,

1027
00:50:22,812 --> 00:50:26,192
we never referred to the
implementation class.

1028
00:50:26,192 --> 00:50:28,912
We never used that ugly class name.

1029
00:50:28,912 --> 00:50:32,852
Throughout the code, we've
been using the interface name,

1030
00:50:32,852 --> 00:50:36,992
which I will always strive
to make a very nice,

1031
00:50:36,992 --> 00:50:40,332
crisp, short name.

1032
00:50:40,332 --> 00:50:42,472
MessageOfTheDayService.

1033
00:50:42,472 --> 00:50:45,652
Okay, we do use the implementation name

1034
00:50:45,652 --> 00:50:48,472
in the XML, but well that's ugly anyways

1035
00:50:48,472 --> 00:50:50,692
so I'm not too worried about that.

1036
00:50:50,692 --> 00:50:52,452
The naming conventions that you have

1037
00:50:52,452 --> 00:50:54,212
on your project will obviously depend

1038
00:50:54,212 --> 00:50:55,892
either on your personal taste

1039
00:50:55,892 --> 00:50:59,692
or on the coding
conventions on your project.

1040
00:50:59,692 --> 00:51:02,032
Well that's certainly the
way that I like to work.

1041
00:51:02,032 --> 00:51:05,192
Good friendly names for the interfaces,

1042
00:51:05,192 --> 00:51:07,172
and potentially long winded,

1043
00:51:07,172 --> 00:51:09,712
but nonetheless descriptive names

1044
00:51:09,712 --> 00:51:12,602
for the implementing classes.

1045
00:51:14,292 --> 00:51:16,312
(upbeat music)

1046
00:51:16,312 --> 00:51:19,492
So we've used Spring for the first time.

1047
00:51:19,492 --> 00:51:22,112
Okay it's just a Hello World application,

1048
00:51:22,112 --> 00:51:24,392
but one of the great things about Spring

1049
00:51:24,392 --> 00:51:28,272
is that once you understand
the most basic principles

1050
00:51:28,272 --> 00:51:32,132
going to a real application
is not that hard.

1051
00:51:32,132 --> 00:51:35,432
We've used XML to configure the container

1052
00:51:35,432 --> 00:51:37,052
for the first time.

1053
00:51:37,052 --> 00:51:38,512
There are other options.

1054
00:51:38,512 --> 00:51:41,212
We'll be seeing those
much later in the course.

1055
00:51:41,212 --> 00:51:45,012
This is considered the classic
way of working in Spring.

1056
00:51:45,012 --> 00:51:50,012
The ability to switch implementation
classes is so important

1057
00:51:50,772 --> 00:51:53,412
We changed our MessageOfTheDayService

1058
00:51:53,412 --> 00:51:56,912
with three different implementations.

1059
00:51:56,912 --> 00:51:59,172
Later on this is going
to give us the chance

1060
00:51:59,172 --> 00:52:03,832
to change entire tiers of our application.

1061
00:52:03,832 --> 00:52:07,672
Finally we still had to
inject all this to values.

1062
00:52:07,672 --> 00:52:10,412
I'm not sure we'll need to
do this again on the course,

1063
00:52:10,412 --> 00:52:13,112
so I wanted to slip it in somewhere.

1064
00:52:13,112 --> 00:52:14,452
It's not a big deal,

1065
00:52:14,452 --> 00:52:16,952
but probably worth remembering.

1066
00:52:16,952 --> 00:52:19,552
That's it for the Hello World application.

1067
00:52:19,552 --> 00:52:20,952
In the next chapter,

1068
00:52:20,952 --> 00:52:23,892
we'll move on to something
more substantial.

1069
00:52:23,892 --> 00:52:27,502
In the chapter called Wiring with Spring.

1
00:00:09,980 --> 00:00:10,955
- [Voiceover] Welcome back.

2
00:00:10,955 --> 00:00:13,165
In chapter four, we are
going to be looking at

3
00:00:13,165 --> 00:00:16,584
what Wiring in Spring is.

4
00:00:16,584 --> 00:00:18,762
Really, all we will be
doing in this chapter

5
00:00:18,762 --> 00:00:20,810
is applying what we learnt from the

6
00:00:20,810 --> 00:00:23,406
Hello World example into something

7
00:00:23,406 --> 00:00:25,818
a little bit more realistic.

8
00:00:25,818 --> 00:00:28,032
We will be using dependency injection

9
00:00:28,032 --> 00:00:30,651
and the spring container to configure

10
00:00:30,651 --> 00:00:32,068
a service bean.

11
00:00:32,068 --> 00:00:34,105
I'm going to mention a technique

12
00:00:34,105 --> 00:00:38,427
that we at Virtual Pair
Programmers call a mock.

13
00:00:38,427 --> 00:00:42,631
A mock is really a
prototype or fake object

14
00:00:42,631 --> 00:00:44,530
that we are writing as a quick and dirty

15
00:00:44,530 --> 00:00:47,484
throwaway class that we will be replacing

16
00:00:47,484 --> 00:00:49,937
with a more sophisticated version

17
00:00:49,937 --> 00:00:52,427
some time in the future.

18
00:00:52,427 --> 00:00:55,159
The XML in Spring is often called

19
00:00:55,159 --> 00:00:58,344
the wiring because the container contains

20
00:00:58,344 --> 00:01:01,584
a pile of objects that
need to be connected

21
00:01:01,584 --> 00:01:03,915
together in a sensible way.

22
00:01:03,915 --> 00:01:05,749
So it sometimes feel like you are

23
00:01:05,749 --> 00:01:08,531
wiring the objects together.

24
00:01:08,531 --> 00:01:10,694
So that's the purpose of this chapter,

25
00:01:10,694 --> 00:01:13,194
to practice some basic wiring.

26
00:01:14,793 --> 00:01:17,530
To explain the concepts,
we have chosen a system,

27
00:01:17,530 --> 00:01:20,567
which we hope you will
all be familiar with.

28
00:01:20,567 --> 00:01:23,957
This is going to be an online book seller.

29
00:01:23,957 --> 00:01:25,609
We are thinking about
an application that's

30
00:01:25,609 --> 00:01:28,600
going to allow customers to buy books,

31
00:01:28,600 --> 00:01:31,369
to view books by a particular author,

32
00:01:31,369 --> 00:01:33,291
to be able to given a list of

33
00:01:33,291 --> 00:01:36,584
recommended books based on
their previous preferences

34
00:01:36,584 --> 00:01:37,417
and so on.

35
00:01:38,321 --> 00:01:40,703
In the practical sessions on the course,

36
00:01:40,703 --> 00:01:43,666
you will be working on a different system.

37
00:01:43,666 --> 00:01:45,670
I'm going to be using this bookstore

38
00:01:45,670 --> 00:01:47,875
through all of the theory sessions

39
00:01:47,875 --> 00:01:50,982
so that we have a
relativity simple example

40
00:01:50,982 --> 00:01:53,741
in order to explain the concepts.

41
00:01:53,741 --> 00:01:55,572
Now we are going to build this system

42
00:01:55,572 --> 00:01:58,388
as a series of components.

43
00:01:58,388 --> 00:02:02,273
Now components is really
nothing more than a class

44
00:02:02,273 --> 00:02:05,818
that's representing a
collection of business logic

45
00:02:05,818 --> 00:02:08,401
the clients can access.

46
00:02:08,401 --> 00:02:09,999
Now we are decided that we are going to

47
00:02:09,999 --> 00:02:12,415
probably need several components in fact

48
00:02:12,415 --> 00:02:15,592
but the main one is going to be this

49
00:02:15,592 --> 00:02:18,722
BookService component.

50
00:02:18,722 --> 00:02:21,287
This is going to be the
component that allows

51
00:02:21,287 --> 00:02:23,771
us to manage our books.

52
00:02:23,771 --> 00:02:25,443
You will notice here that the

53
00:02:25,443 --> 00:02:27,690
interface name that we have chosen is

54
00:02:27,690 --> 00:02:29,107
just BookService.

55
00:02:30,051 --> 00:02:32,819
Of course you can call
your interfaces and classes

56
00:02:32,819 --> 00:02:35,213
anything you like in Spring.

57
00:02:35,213 --> 00:02:36,815
It is just that it is becoming a

58
00:02:36,815 --> 00:02:40,702
very popular pattern to
follow in the industry.

59
00:02:40,702 --> 00:02:44,686
You may well have heard of
service oriented architecture

60
00:02:44,686 --> 00:02:48,504
or SOA, which is really a
subject for another course,

61
00:02:48,504 --> 00:02:51,135
but suffice to say it is
becoming a very common

62
00:02:51,135 --> 00:02:54,850
and popular term to use this service

63
00:02:54,850 --> 00:02:59,017
when defining the component
level of an application.

64
00:02:59,882 --> 00:03:02,031
Now we have our BookService interface here

65
00:03:02,031 --> 00:03:06,151
and the methods you can see
on there are fairly routine.

66
00:03:06,151 --> 00:03:07,623
We are going to be able to

67
00:03:07,623 --> 00:03:11,394
query all of the books
by a particular author.

68
00:03:11,394 --> 00:03:14,474
That's going to return a Java list.

69
00:03:14,474 --> 00:03:16,303
We are going to somehow be able to get

70
00:03:16,303 --> 00:03:20,211
all the recommended books
for our particular user.

71
00:03:20,211 --> 00:03:21,518
We are going to be able to search

72
00:03:21,518 --> 00:03:24,023
books by ISBN number.

73
00:03:24,023 --> 00:03:27,319
An ISBN number by the way
is an industry standard

74
00:03:27,319 --> 00:03:29,545
in the publishing industry.

75
00:03:29,545 --> 00:03:32,281
You can think of the ISBN as being

76
00:03:32,281 --> 00:03:34,598
the primary key of the book.

77
00:03:34,598 --> 00:03:38,098
Every book has its own unique ISBN number.

78
00:03:39,196 --> 00:03:41,632
We can get the entire catalog

79
00:03:41,632 --> 00:03:44,547
and we can also register new books

80
00:03:44,547 --> 00:03:45,972
on to the system.

81
00:03:45,972 --> 00:03:48,249
In real life, there would be far more

82
00:03:48,249 --> 00:03:49,082
methods than this.

83
00:03:49,082 --> 00:03:51,901
We'd probably be able to remove books from

84
00:03:51,901 --> 00:03:54,427
the system and so on.

85
00:03:54,427 --> 00:03:56,426
These methods though will be certainly

86
00:03:56,426 --> 00:03:58,924
plenty for the course.

87
00:03:58,924 --> 00:04:01,244
We will see the code for this in a moment,

88
00:04:01,244 --> 00:04:04,808
but it is just going to
be plain regular Java.

89
00:04:04,808 --> 00:04:07,015
The next step would be to

90
00:04:07,015 --> 00:04:09,162
implement the interface.

91
00:04:09,162 --> 00:04:12,333
Now we won't have a lot
to say there for now.

92
00:04:12,333 --> 00:04:15,181
The implementation of the
BookService is presumably

93
00:04:15,181 --> 00:04:18,179
going to be calling some domain classes.

94
00:04:18,179 --> 00:04:20,984
It is going to be running
some kind of Java logic

95
00:04:20,984 --> 00:04:23,228
and that could well be
talking to a backend

96
00:04:23,228 --> 00:04:25,994
relational database or a web service

97
00:04:25,994 --> 00:04:27,943
or something like that.

98
00:04:27,943 --> 00:04:30,800
We will be seeing a lot
more about those topics

99
00:04:30,800 --> 00:04:32,831
later in the course.

100
00:04:32,831 --> 00:04:35,062
We also need to think
about how we can allow

101
00:04:35,062 --> 00:04:37,479
a client to call our service.

102
00:04:38,807 --> 00:04:40,763
Well really we've done this work already.

103
00:04:40,763 --> 00:04:44,276
We did the Hello World
service in a previous chapter

104
00:04:44,276 --> 00:04:47,816
and here the scenario will be the same.

105
00:04:47,816 --> 00:04:51,113
We will configure the
BookService using spring

106
00:04:51,113 --> 00:04:52,983
and we will look up the service

107
00:04:52,983 --> 00:04:56,075
using that container that we've seen.

108
00:04:56,075 --> 00:04:57,337
That will allow our clients

109
00:04:57,337 --> 00:04:59,412
whether it is a web tier,

110
00:04:59,412 --> 00:05:02,746
whether it is a standalone
client or whatever,

111
00:05:02,746 --> 00:05:05,746
they will be able to call a service.

112
00:05:07,140 --> 00:05:10,438
One very important point
that we haven't made yet

113
00:05:10,438 --> 00:05:13,174
is how far do you go

114
00:05:13,174 --> 00:05:14,237
with spring?

115
00:05:14,237 --> 00:05:16,683
In our application, we are likely to

116
00:05:16,683 --> 00:05:19,077
have some further classes such as

117
00:05:19,077 --> 00:05:23,163
catalog, author, customer review,

118
00:05:23,163 --> 00:05:25,316
and of course book.

119
00:05:25,316 --> 00:05:27,104
These are the classes that are typically

120
00:05:27,104 --> 00:05:30,115
going to implement the business logic.

121
00:05:30,115 --> 00:05:32,154
We've got to be a bit careful here.

122
00:05:32,154 --> 00:05:36,767
We are talking up here about
a BookService implementation

123
00:05:36,767 --> 00:05:38,679
but generally what we we are doing

124
00:05:38,679 --> 00:05:41,928
with the service class is those methods

125
00:05:41,928 --> 00:05:44,537
are just there so the client has something

126
00:05:44,537 --> 00:05:47,239
simple to call, but we wouldnt

127
00:05:47,239 --> 00:05:50,278
want to put much if any business logic

128
00:05:50,278 --> 00:05:53,893
inside the BookService
implementation itself.

129
00:05:53,893 --> 00:05:56,121
We would want the BookService

130
00:05:56,121 --> 00:05:58,597
to call the domain classes.

131
00:05:58,597 --> 00:06:01,281
And then the domain classes can implement

132
00:06:01,281 --> 00:06:03,227
the business logic.

133
00:06:03,227 --> 00:06:05,100
There are lots of good reasons for this,

134
00:06:05,100 --> 00:06:08,163
but the main one well really
when we are working in

135
00:06:08,163 --> 00:06:11,614
object orientation, the behavior should be

136
00:06:11,614 --> 00:06:14,174
spread across different objects

137
00:06:14,174 --> 00:06:16,607
and that makes everything much easier

138
00:06:16,607 --> 00:06:18,431
to unit test.

139
00:06:18,431 --> 00:06:21,078
If we put all of our logic into just one

140
00:06:21,078 --> 00:06:23,186
great big BookService class that would be

141
00:06:23,186 --> 00:06:25,534
really difficult to test.

142
00:06:25,534 --> 00:06:27,278
I should also say at this point that

143
00:06:27,278 --> 00:06:30,447
it depends on your style of development,

144
00:06:30,447 --> 00:06:34,534
whether or not you actually
have any domain classes.

145
00:06:34,534 --> 00:06:37,466
Some systems might call
the database directly

146
00:06:37,466 --> 00:06:41,580
and you might have logic
such as stored procedures

147
00:06:41,580 --> 00:06:43,617
in your database.

148
00:06:43,617 --> 00:06:46,317
Now there are a lot of religious debates

149
00:06:46,317 --> 00:06:50,289
about whether it is best
to do object orientation

150
00:06:50,289 --> 00:06:53,339
or whether it is best
to use stored procedures

151
00:06:53,339 --> 00:06:56,920
and I tend to be a bit
neutral on that really.

152
00:06:56,920 --> 00:07:01,027
Different projects will
choose different approaches.

153
00:07:01,027 --> 00:07:03,124
If you are interested,
you might also want to

154
00:07:03,124 --> 00:07:05,363
look at the concepts of

155
00:07:05,363 --> 00:07:07,783
an Anemic Domain Model.

156
00:07:07,783 --> 00:07:10,014
Now put those words up on the screen.

157
00:07:10,014 --> 00:07:12,329
This is a term that was commonly used

158
00:07:12,329 --> 00:07:15,543
by Martin Fowler, one of the great writers

159
00:07:15,543 --> 00:07:17,419
on object orientation.

160
00:07:17,419 --> 00:07:19,772
I've given you a link there for a page

161
00:07:19,772 --> 00:07:23,638
to study where Martin talks
about how some systems

162
00:07:23,638 --> 00:07:26,397
and where all of the business logic

163
00:07:26,397 --> 00:07:30,224
is up here in kind of the service layer

164
00:07:30,224 --> 00:07:34,863
and the domain classes become
just really data containers

165
00:07:34,863 --> 00:07:38,357
with get set methods
and no business logic.

166
00:07:38,357 --> 00:07:40,840
He has called it Anemic because I think

167
00:07:40,840 --> 00:07:45,675
anemic means lacking in blood, bloodless.

168
00:07:45,675 --> 00:07:49,903
And an Anemic Domain Model
isn't really very powerful,

169
00:07:49,903 --> 00:07:52,451
because you can't test the domain classes

170
00:07:52,451 --> 00:07:54,978
because they are not
doing anything useful.

171
00:07:54,978 --> 00:07:57,957
Your service classes get quite bloated.

172
00:07:57,957 --> 00:08:00,372
I think Martin is
definitely using the term

173
00:08:00,372 --> 00:08:04,250
Anemic Domain Model as a
kind of a negative term.

174
00:08:04,250 --> 00:08:06,410
Something not to do,

175
00:08:06,410 --> 00:08:08,483
but you will find that some projects

176
00:08:08,483 --> 00:08:13,207
do go down the Anemic Domain Model path.

177
00:08:13,207 --> 00:08:16,320
Now that's really a discussion
for a different course.

178
00:08:16,320 --> 00:08:18,556
I'm going to assume for this course that

179
00:08:18,556 --> 00:08:20,798
while we are writing a Java application,

180
00:08:20,798 --> 00:08:22,301
therefore it is going to be

181
00:08:22,301 --> 00:08:24,420
an object oriented application.

182
00:08:24,420 --> 00:08:26,679
Therefore we do have a domain model

183
00:08:26,679 --> 00:08:29,213
and that is going to be interesting

184
00:08:29,213 --> 00:08:32,589
business logic in there
that can be tested.

185
00:08:32,589 --> 00:08:36,394
The service layer is more
of an interface layer.

186
00:08:36,394 --> 00:08:38,439
So that the clients don't have to

187
00:08:38,439 --> 00:08:41,565
work with the small low
level classes down here,

188
00:08:41,565 --> 00:08:44,251
but they can call big rich methods

189
00:08:44,251 --> 00:08:46,834
like get all recommended books.

190
00:08:48,293 --> 00:08:49,801
Now the point I want to make is

191
00:08:49,801 --> 00:08:51,715
let's have a look at the relationship

192
00:08:51,715 --> 00:08:54,739
between book and author for example.

193
00:08:54,739 --> 00:08:57,721
Now obviously these two
classes are related.

194
00:08:57,721 --> 00:09:00,619
There is a dependency between them.

195
00:09:00,619 --> 00:09:03,636
In this case each book is going to be

196
00:09:03,636 --> 00:09:07,731
written by one or more authors.

197
00:09:07,731 --> 00:09:10,577
In the other direction, each author

198
00:09:10,577 --> 00:09:13,188
can write one more more books.

199
00:09:13,188 --> 00:09:17,355
A perfectly natural relationship
between books and authors.

200
00:09:18,435 --> 00:09:22,918
Should we be configuring
this dependency using spring?

201
00:09:22,918 --> 00:09:26,518
Using the XML that we've seen before?

202
00:09:26,518 --> 00:09:29,976
In general here, the answer is no.

203
00:09:29,976 --> 00:09:31,933
If we were to use spring to configure

204
00:09:31,933 --> 00:09:33,971
the domain classes,

205
00:09:33,971 --> 00:09:36,644
we'd soon end up with a massive XML file

206
00:09:36,644 --> 00:09:40,477
that nobody could understand
and we'd lose control

207
00:09:40,477 --> 00:09:44,105
of the business relationships in our code.

208
00:09:44,105 --> 00:09:45,448
That's not the real reason.

209
00:09:45,448 --> 00:09:47,169
The real reason is that spring's purpose

210
00:09:47,169 --> 00:09:50,585
is to allow you to
configure the relationships

211
00:09:50,585 --> 00:09:53,633
that are likely to change as a result of

212
00:09:53,633 --> 00:09:56,110
changing requirements.

213
00:09:56,110 --> 00:09:59,366
Not as a result of dynamic behavior

214
00:09:59,366 --> 00:10:01,815
that's happening in your code.

215
00:10:01,815 --> 00:10:03,889
For example we may need in the future

216
00:10:03,889 --> 00:10:06,902
to create more than one implementation

217
00:10:06,902 --> 00:10:09,095
of the BookService.

218
00:10:09,095 --> 00:10:11,898
It maybe that we upgrade the service

219
00:10:11,898 --> 00:10:14,138
for different customers.

220
00:10:14,138 --> 00:10:16,176
More likely it could be that we

221
00:10:16,176 --> 00:10:19,761
use a version of the
BookService for testing

222
00:10:19,761 --> 00:10:23,318
and one for production and so on.

223
00:10:23,318 --> 00:10:25,584
Now these are changes that need to be made

224
00:10:25,584 --> 00:10:28,078
configuratively.

225
00:10:28,078 --> 00:10:32,217
That means through some
kind of configuration file.

226
00:10:32,217 --> 00:10:34,375
These are changes that
are likely to be made

227
00:10:34,375 --> 00:10:37,375
not at run time, but at deploy time,

228
00:10:38,291 --> 00:10:40,563
i.e., when you start the application.

229
00:10:40,563 --> 00:10:43,624
Now spring is designed for this.

230
00:10:43,624 --> 00:10:46,554
The relationship between book and author

231
00:10:46,554 --> 00:10:49,244
is far more of a business relationship.

232
00:10:49,244 --> 00:10:52,050
When we add a new book to the system,

233
00:10:52,050 --> 00:10:56,090
we need to link the correct
author to the correct book.

234
00:10:56,090 --> 00:10:58,485
This is going to happen at the run time

235
00:10:58,485 --> 00:11:01,743
as a result of our business logic running.

236
00:11:01,743 --> 00:11:04,375
It will be probably be or possibly be

237
00:11:04,375 --> 00:11:06,960
an update in the database.

238
00:11:06,960 --> 00:11:10,579
Therefore, spring just isn't
a good place to do this

239
00:11:10,579 --> 00:11:12,007
kind of configuration.

240
00:11:12,007 --> 00:11:14,285
We think that's an important point.

241
00:11:14,285 --> 00:11:16,715
I've seen many projects, especially in my

242
00:11:16,715 --> 00:11:19,317
early days of using
Spring a few years ago,

243
00:11:19,317 --> 00:11:21,801
that assume that you have to use Spring

244
00:11:21,801 --> 00:11:24,378
throughout the entire application

245
00:11:24,378 --> 00:11:28,241
and ended up getting in
a really horrible mess.

246
00:11:28,241 --> 00:11:31,751
Therefore, let's emphasize
that we are going to use

247
00:11:31,751 --> 00:11:33,909
Spring to configure the elements

248
00:11:33,909 --> 00:11:36,919
of our application that
are likely to change

249
00:11:36,919 --> 00:11:40,208
as a result of changing architecture.

250
00:11:40,208 --> 00:11:42,441
Things like the service tier,

251
00:11:42,441 --> 00:11:44,761
the data access tier,

252
00:11:44,761 --> 00:11:48,472
database connection pools and so on.

253
00:11:48,472 --> 00:11:51,639
Usually spring has no effect down here

254
00:11:52,579 --> 00:11:54,378
on the domains here.

255
00:11:54,378 --> 00:11:55,596
Let's switch to the code

256
00:11:55,596 --> 00:11:58,730
and see how all of this works in practice.

257
00:11:58,730 --> 00:12:00,199
Now going back into eclipse

258
00:12:00,199 --> 00:12:02,914
and this is the state of my workspace

259
00:12:02,914 --> 00:12:05,773
as it was at the end
of the previous chapter

260
00:12:05,773 --> 00:12:08,903
when we worked on that
message of the day system.

261
00:12:08,903 --> 00:12:10,571
Now in this particular workspace,

262
00:12:10,571 --> 00:12:13,169
we have more than one project.

263
00:12:13,169 --> 00:12:16,920
There's the message project
that we were working on before,

264
00:12:16,920 --> 00:12:18,916
but there's also another project in there

265
00:12:18,916 --> 00:12:20,333
called bookstore,

266
00:12:21,238 --> 00:12:23,929
and I want to open that
project in Eclipse.

267
00:12:23,929 --> 00:12:26,011
In your workspace, you might there are

268
00:12:26,011 --> 00:12:28,238
more projects than this
because Ill probably be

269
00:12:28,238 --> 00:12:31,814
adding more as I do further recordings,

270
00:12:31,814 --> 00:12:34,052
but at the moment in the recording,

271
00:12:34,052 --> 00:12:35,399
we've just got these two projects.

272
00:12:35,399 --> 00:12:38,784
Now I want to open up
the bookstore project.

273
00:12:38,784 --> 00:12:41,329
To do that in Eclipse, the best way is

274
00:12:41,329 --> 00:12:43,720
first of all I'm going to close down

275
00:12:43,720 --> 00:12:46,803
any files that I had open previously.

276
00:12:47,995 --> 00:12:52,099
And then I'm going to close
the message of the day project.

277
00:12:52,099 --> 00:12:53,751
Just right click on the project

278
00:12:53,751 --> 00:12:55,834
and select close project.

279
00:12:56,801 --> 00:12:59,864
Now that's just to stop me accidentally

280
00:12:59,864 --> 00:13:01,934
opening up files from that project

281
00:13:01,934 --> 00:13:03,609
and getting confused.

282
00:13:03,609 --> 00:13:05,613
You can always open the project up again

283
00:13:05,613 --> 00:13:09,956
just with a right click
and select open projects.

284
00:13:09,956 --> 00:13:11,705
Once the project is closed,

285
00:13:11,705 --> 00:13:13,499
I will repeat the steps I did earlier

286
00:13:13,499 --> 00:13:17,082
of file, new, Java project,

287
00:13:18,113 --> 00:13:20,215
and then for project name

288
00:13:20,215 --> 00:13:22,325
exactly the same as the folder name.

289
00:13:22,325 --> 00:13:25,165
That is BookStore.

290
00:13:25,165 --> 00:13:27,726
Capital B and capital S

291
00:13:27,726 --> 00:13:29,476
and it should be telling
us that the wizard

292
00:13:29,476 --> 00:13:31,725
will automatically configure.

293
00:13:31,725 --> 00:13:34,546
We can now click finish.

294
00:13:34,546 --> 00:13:37,049
Now this project is pretty much the same

295
00:13:37,049 --> 00:13:39,212
as our Hello World project.

296
00:13:39,212 --> 00:13:42,871
I have given you some
partially completed files.

297
00:13:42,871 --> 00:13:45,968
We will have a look at those in a moment.

298
00:13:45,968 --> 00:13:50,186
We also have a skeleton
application dot XML file.

299
00:13:50,186 --> 00:13:53,127
We will need to add a
little bit into that.

300
00:13:53,127 --> 00:13:55,646
The main difference is if you look in the

301
00:13:55,646 --> 00:13:57,091
ELIB directory,

302
00:13:57,091 --> 00:14:00,625
I have given you a lot more
Java files in this project.

303
00:14:00,625 --> 00:14:01,641
Now what I've done here is

304
00:14:01,641 --> 00:14:03,998
I've given you all of the Java files

305
00:14:03,998 --> 00:14:07,400
that you are going to need
for the entire course.

306
00:14:07,400 --> 00:14:09,795
There are some fairly advanced Java files

307
00:14:09,795 --> 00:14:12,476
in here that we certainly
don't need immediately,

308
00:14:12,476 --> 00:14:14,143
but we will need them soon.

309
00:14:14,143 --> 00:14:15,101
You will need to make sure that

310
00:14:15,101 --> 00:14:16,556
all of these are on your build path.

311
00:14:16,556 --> 00:14:19,847
If you select all of those Java files,

312
00:14:19,847 --> 00:14:21,180
then right click

313
00:14:22,460 --> 00:14:23,710
and Build Path.

314
00:14:24,655 --> 00:14:28,287
If you see the option
of Add to Build Path,

315
00:14:28,287 --> 00:14:30,731
then please select that option,

316
00:14:30,731 --> 00:14:33,214
because Eclipse has already
put these Java files

317
00:14:33,214 --> 00:14:36,820
on my Build path, there
are no actions available.

318
00:14:36,820 --> 00:14:38,349
Now the package structure is that

319
00:14:38,349 --> 00:14:40,546
we have three packages,

320
00:14:40,546 --> 00:14:42,088
one for the client tier,

321
00:14:42,088 --> 00:14:44,113
one for the domain tier,

322
00:14:44,113 --> 00:14:46,834
and one of the services tier.

323
00:14:46,834 --> 00:14:48,747
The roots of the package name is just

324
00:14:48,747 --> 00:14:50,829
called the Virtual Pair Programmers.

325
00:14:50,829 --> 00:14:53,720
And this project happens to be called

326
00:14:53,720 --> 00:14:56,121
Avalon for some reason.

327
00:14:56,121 --> 00:14:59,577
That's the reason for the package names.

328
00:14:59,577 --> 00:15:02,134
Now let's start here
with the domain class.

329
00:15:02,134 --> 00:15:03,598
We have a single domain class here

330
00:15:03,598 --> 00:15:07,218
called Book and once again

331
00:15:07,218 --> 00:15:09,383
if you are familiar with
Java there should be

332
00:15:09,383 --> 00:15:11,338
nothing complicated here.

333
00:15:11,338 --> 00:15:15,244
Regular domain class, four attributes.

334
00:15:15,244 --> 00:15:19,077
The ISBN, the title, the
author and the price.

335
00:15:20,395 --> 00:15:22,950
We have a regular constrictor

336
00:15:22,950 --> 00:15:26,757
and a regular to string method as well.

337
00:15:26,757 --> 00:15:28,792
Of course in a real application,

338
00:15:28,792 --> 00:15:30,699
this class would be far richer and more

339
00:15:30,699 --> 00:15:33,805
complicated and obviously
as we develop further,

340
00:15:33,805 --> 00:15:36,557
we'd start to add methods into here.

341
00:15:36,557 --> 00:15:39,046
I will leave that as an exercise.

342
00:15:39,046 --> 00:15:41,415
This class isn't actually that important

343
00:15:41,415 --> 00:15:43,501
for learning Spring.

344
00:15:43,501 --> 00:15:45,659
Let's switch across to the service package

345
00:15:45,659 --> 00:15:49,326
and we will look at the service interface.

346
00:15:49,326 --> 00:15:51,781
This is the BookService
and all I've done here

347
00:15:51,781 --> 00:15:54,021
is I've transferred the methods

348
00:15:54,021 --> 00:15:56,298
those method signatures that you saw

349
00:15:56,298 --> 00:15:58,416
in the design before.

350
00:15:58,416 --> 00:16:01,668
Now we've reached a
problem because of course

351
00:16:01,668 --> 00:16:04,501
we need to implement this service.

352
00:16:05,412 --> 00:16:09,331
In one sense, the implementation
is just regular Java,

353
00:16:09,331 --> 00:16:11,243
but at this point in the course,

354
00:16:11,243 --> 00:16:14,534
we don't yet know how to
do anything sophisticated

355
00:16:14,534 --> 00:16:17,069
such as calling a database.

356
00:16:17,069 --> 00:16:19,427
Now it is often the case in real life

357
00:16:19,427 --> 00:16:21,749
that maybe we want to just prototype

358
00:16:21,749 --> 00:16:24,403
the front end of the application.

359
00:16:24,403 --> 00:16:27,522
We want to work on the
web pages and so on.

360
00:16:27,522 --> 00:16:32,123
We haven't yet built the
backend, the database.

361
00:16:32,123 --> 00:16:34,562
This is a good chance for us to use

362
00:16:34,562 --> 00:16:38,098
the theory that we've
already learnt about Spring.

363
00:16:38,098 --> 00:16:39,921
What we can do is we can

364
00:16:39,921 --> 00:16:42,254
mock the service.

365
00:16:43,303 --> 00:16:46,313
Now my idea is that yes ultimately

366
00:16:46,313 --> 00:16:49,693
I've got an interface called BookService

367
00:16:49,693 --> 00:16:53,882
and I need to produce a
production standard implementation

368
00:16:53,882 --> 00:16:56,568
which I'm planning to call in the future

369
00:16:56,568 --> 00:16:58,202
BookService input.

370
00:16:58,202 --> 00:17:00,607
There will be database code in there

371
00:17:00,607 --> 00:17:04,056
and all kinds of sophisticated stuff.

372
00:17:04,056 --> 00:17:08,604
However, what I'm going
to do now is temporarily

373
00:17:08,604 --> 00:17:11,867
ignore the production
standard implementation.

374
00:17:11,867 --> 00:17:13,203
We will do that later

375
00:17:13,203 --> 00:17:16,905
but I'm going to create an
alternative implementation.

376
00:17:16,905 --> 00:17:18,173
I'm going to call it

377
00:17:18,173 --> 00:17:21,131
mock BookService.

378
00:17:21,131 --> 00:17:24,111
The idea behind this mock BookService

379
00:17:24,111 --> 00:17:26,999
is that it will implement
all of the methods

380
00:17:26,999 --> 00:17:28,704
that I need in the interface

381
00:17:28,704 --> 00:17:30,934
but I'm not going to bother

382
00:17:30,934 --> 00:17:34,961
implementing it to production standards.

383
00:17:34,961 --> 00:17:37,194
I can write throwaway methods.

384
00:17:37,194 --> 00:17:40,527
I could hard-code data into the methods.

385
00:17:41,387 --> 00:17:43,332
Now the purpose of doing this is that

386
00:17:43,332 --> 00:17:47,854
I can connect everything up
using the Spring XML file

387
00:17:47,854 --> 00:17:51,682
and I can immediately
test that my client's tier

388
00:17:51,682 --> 00:17:53,556
is working and it is almost like

389
00:17:53,556 --> 00:17:56,482
I'm simulating the backend.

390
00:17:56,482 --> 00:17:58,846
Then once we have the theory

391
00:17:58,846 --> 00:18:01,579
and the knowledge to build that backend

392
00:18:01,579 --> 00:18:04,317
we can come back and create the proper

393
00:18:04,317 --> 00:18:08,185
production quality implementation class.

394
00:18:08,185 --> 00:18:09,607
As you might be able to guess

395
00:18:09,607 --> 00:18:11,722
from the work we did before

396
00:18:11,722 --> 00:18:14,124
all we would need to do is change some

397
00:18:14,124 --> 00:18:16,279
XML to switch from the mock

398
00:18:16,279 --> 00:18:19,861
to the production standard implementation.

399
00:18:19,861 --> 00:18:22,153
Let's go into Eclipse and Ill show you

400
00:18:22,153 --> 00:18:25,857
how you might implement a simple mock.

401
00:18:25,857 --> 00:18:28,628
In Eclipse, you will find
in the service package

402
00:18:28,628 --> 00:18:32,378
a book service mock implementation.

403
00:18:32,378 --> 00:18:34,446
And I've already started to create

404
00:18:34,446 --> 00:18:37,011
this mock implementation
because it is really

405
00:18:37,011 --> 00:18:38,767
just standard java.

406
00:18:38,767 --> 00:18:39,913
So it is part done.

407
00:18:39,913 --> 00:18:42,516
Let's go through what's happened so far.

408
00:18:42,516 --> 00:18:46,728
I've created a class called
BookService mock input

409
00:18:46,728 --> 00:18:50,191
and by the way you really
do need to use that word

410
00:18:50,191 --> 00:18:52,591
mock in this class so that everybody

411
00:18:52,591 --> 00:18:54,232
knows that this is not

412
00:18:54,232 --> 00:18:57,649
a series implementation of the interface.

413
00:18:59,040 --> 00:19:00,826
Another thing to mention is that

414
00:19:00,826 --> 00:19:04,693
there are some frameworks
called mocking frameworks.

415
00:19:04,693 --> 00:19:07,907
They do some fairly
sophisticated things to do

416
00:19:07,907 --> 00:19:09,576
with unit testing.

417
00:19:09,576 --> 00:19:11,284
Really I'm just using the term

418
00:19:11,284 --> 00:19:15,250
mock here in a sort of lighthearted way.

419
00:19:15,250 --> 00:19:18,413
It is not an official
standard by any means.

420
00:19:18,413 --> 00:19:21,263
If you prefer your project to call this

421
00:19:21,263 --> 00:19:25,695
prototype implementation
or fake implementation

422
00:19:25,695 --> 00:19:27,323
or anything you want.

423
00:19:27,323 --> 00:19:30,584
It is non-official but it works for me.

424
00:19:30,584 --> 00:19:33,517
Now what I have decided to do in this mock

425
00:19:33,517 --> 00:19:35,975
is I'm holding some data in

426
00:19:35,975 --> 00:19:39,089
this attribute called test books.

427
00:19:39,089 --> 00:19:41,753
That data is the data
that you would ordinarily

428
00:19:41,753 --> 00:19:44,003
be storing in the database.

429
00:19:45,001 --> 00:19:48,091
A map is a really good
a choice of collection

430
00:19:48,091 --> 00:19:50,323
for simulating database because we can do

431
00:19:50,323 --> 00:19:52,634
things like finding by key.

432
00:19:52,634 --> 00:19:56,128
I've got that in an
attribute called test books.

433
00:19:56,128 --> 00:19:58,245
And the next thing I've decided to do

434
00:19:58,245 --> 00:20:03,002
is in this constructor, I've created three

435
00:20:03,002 --> 00:20:06,002
stock, hard-coded books.

436
00:20:06,956 --> 00:20:09,188
Of course again this is not good practice

437
00:20:09,188 --> 00:20:11,345
in regular production code because

438
00:20:11,345 --> 00:20:13,841
it is hard coding, but the great thing

439
00:20:13,841 --> 00:20:17,374
about mock is we can be
fairly free and loose.

440
00:20:17,374 --> 00:20:19,160
As long as the mock appears to work

441
00:20:19,160 --> 00:20:22,334
like a true implementation of the service

442
00:20:22,334 --> 00:20:25,346
how it is implemented isn't so important.

443
00:20:25,346 --> 00:20:29,139
I've got three books than
each with different data

444
00:20:29,139 --> 00:20:31,374
and then I've added them to map.

445
00:20:31,374 --> 00:20:34,494
Further down here is we've
got the implementations

446
00:20:34,494 --> 00:20:35,758
of the business methods.

447
00:20:35,758 --> 00:20:37,869
Now I've haven't gotten
around to doing this yet

448
00:20:37,869 --> 00:20:39,936
at the moment, so I'm returning nulls

449
00:20:39,936 --> 00:20:42,160
or I've left the methods blank.

450
00:20:42,160 --> 00:20:43,704
So let's go through these.

451
00:20:43,704 --> 00:20:47,371
First of all we've got
the get book by ISBN.

452
00:20:48,847 --> 00:20:52,162
And that you will notice,
I've used the ISBN

453
00:20:52,162 --> 00:20:55,100
as the key in a map.

454
00:20:55,100 --> 00:20:57,094
This should be fairly simple really.

455
00:20:57,094 --> 00:21:01,623
I'm just going to have to
return test books dot get

456
00:21:01,623 --> 00:21:05,850
and Ill pass in the ISBN
number I've been supplied.

457
00:21:05,850 --> 00:21:08,249
For get inside catalog,

458
00:21:08,249 --> 00:21:10,606
I'm not sure the best way to do this.

459
00:21:10,606 --> 00:21:13,626
I need to return the list of book objects,

460
00:21:13,626 --> 00:21:17,001
so I can't return the entire
map because that has keys

461
00:21:17,001 --> 00:21:18,674
in it as well.

462
00:21:18,674 --> 00:21:22,841
So what I can do I
think is call test books

463
00:21:25,257 --> 00:21:30,157
dot values will retrieve
a collection of values

464
00:21:30,157 --> 00:21:33,630
from the map but that's not a list,

465
00:21:33,630 --> 00:21:37,371
so I can create a new
array list on the fly

466
00:21:37,371 --> 00:21:40,793
and Ill tell Java that they
are going to contain books.

467
00:21:40,793 --> 00:21:43,029
I dont know if you know
this about collections

468
00:21:43,029 --> 00:21:46,160
but whenever you instantiate a collection,

469
00:21:46,160 --> 00:21:48,522
whether it is a list, a map, or whatever,

470
00:21:48,522 --> 00:21:52,914
you can always pass in a
pre-existing collection

471
00:21:52,914 --> 00:21:55,133
into the constructs and
it will kind of create

472
00:21:55,133 --> 00:21:57,883
a new list based on those values.

473
00:21:58,842 --> 00:22:00,878
The details of the implementation

474
00:22:00,878 --> 00:22:02,794
are really far less important

475
00:22:02,794 --> 00:22:05,640
than the point of this,
which is to simulate

476
00:22:05,640 --> 00:22:08,322
the database, so let's quickly add in

477
00:22:08,322 --> 00:22:11,083
an implementation of register book.

478
00:22:11,083 --> 00:22:13,201
I guess that's just going to be

479
00:22:13,201 --> 00:22:16,252
taking our testbooks map and putting

480
00:22:16,252 --> 00:22:17,598
in the object.

481
00:22:17,598 --> 00:22:20,216
I'm going to need to get the key

482
00:22:20,216 --> 00:22:21,114
from the book,

483
00:22:21,114 --> 00:22:24,159
so that's going to be the get ISBN number

484
00:22:24,159 --> 00:22:27,088
and for the value, well
that's just going to be

485
00:22:27,088 --> 00:22:29,642
the book object itself.

486
00:22:29,642 --> 00:22:31,925
And that's that method done.

487
00:22:31,925 --> 00:22:33,949
Now there are another
couple of methods here.

488
00:22:33,949 --> 00:22:35,137
Get all books by author

489
00:22:35,137 --> 00:22:37,185
and get all recommended books,

490
00:22:37,185 --> 00:22:39,552
but Ill do those at a later date.

491
00:22:39,552 --> 00:22:41,635
I'm not going to be calling them just yet

492
00:22:41,635 --> 00:22:43,760
so I can leave them for now.

493
00:22:43,760 --> 00:22:44,807
There we are.

494
00:22:44,807 --> 00:22:46,249
We have a mock.

495
00:22:46,249 --> 00:22:47,930
It is very simple but it means

496
00:22:47,930 --> 00:22:51,402
we can now get busy on the clients here.

497
00:22:51,402 --> 00:22:54,057
As in our previous example,
we are going to need

498
00:22:54,057 --> 00:22:57,190
an XML file to configure the application.

499
00:22:57,190 --> 00:22:59,466
Now as you saw previously,

500
00:22:59,466 --> 00:23:01,369
I've just given you the skeleton here,

501
00:23:01,369 --> 00:23:04,947
so inside here we need
to configure a bean.

502
00:23:04,947 --> 00:23:08,120
We need to give this bean an ID.

503
00:23:08,120 --> 00:23:10,559
Now this is going to be our BookService.

504
00:23:10,559 --> 00:23:13,559
So I suggest we call it BookService.

505
00:23:14,516 --> 00:23:18,064
It is usual practice with
bean IDS to use camel K,

506
00:23:18,064 --> 00:23:20,798
so that means a lower case first letter,

507
00:23:20,798 --> 00:23:24,546
then capitals for every subsequent word.

508
00:23:24,546 --> 00:23:27,026
Then we need to specify the class

509
00:23:27,026 --> 00:23:29,974
that we want Spring to instantiate from.

510
00:23:29,974 --> 00:23:33,105
Now for me that was going
to be com dot virtual

511
00:23:33,105 --> 00:23:37,295
pair programmers dot Avalon

512
00:23:37,295 --> 00:23:39,571
and we start the implementation

513
00:23:39,571 --> 00:23:41,904
in a package called service.

514
00:23:42,830 --> 00:23:45,437
And then the implementation class

515
00:23:45,437 --> 00:23:47,884
is the BookService

516
00:23:47,884 --> 00:23:51,177
mock IMPL.

517
00:23:51,177 --> 00:23:55,216
Because that's the cluster
we want Spring to use.

518
00:23:55,216 --> 00:23:58,614
Now ordinarily if I
just complete that XML,

519
00:23:58,614 --> 00:24:00,770
we would add in any properties

520
00:24:00,770 --> 00:24:03,672
that the class needs right here.

521
00:24:03,672 --> 00:24:06,281
But one of the great things about mocks

522
00:24:06,281 --> 00:24:10,477
is that often they don't need
any data in order to run.

523
00:24:10,477 --> 00:24:13,259
I've hard coded all that data in.

524
00:24:13,259 --> 00:24:15,792
Now of course I could have made it so that

525
00:24:15,792 --> 00:24:19,057
we could inject the test data

526
00:24:19,057 --> 00:24:22,390
as a dependency and then
we could add more books

527
00:24:22,390 --> 00:24:24,393
using the XML file.

528
00:24:24,393 --> 00:24:25,528
That would be fine.

529
00:24:25,528 --> 00:24:27,048
It would make the mock a little bit

530
00:24:27,048 --> 00:24:30,273
more sophisticated, but I
really don't need to do that.

531
00:24:30,273 --> 00:24:32,791
There is nothing more to do here

532
00:24:32,791 --> 00:24:35,886
in the application dot XML file.

533
00:24:35,886 --> 00:24:37,215
All that remains then is to write

534
00:24:37,215 --> 00:24:41,026
the client's application
and all I have at the moment

535
00:24:41,026 --> 00:24:43,527
is a very basic skeleton with just the

536
00:24:43,527 --> 00:24:46,054
public static void main.

537
00:24:46,054 --> 00:24:47,805
Really everything that we do in here

538
00:24:47,805 --> 00:24:50,973
is exactly the same
that we've done before.

539
00:24:50,973 --> 00:24:54,595
We need to open the Spring container,

540
00:24:54,595 --> 00:24:56,991
then get the required object

541
00:24:56,991 --> 00:24:59,772
and then start to call its methods.

542
00:24:59,772 --> 00:25:01,189
If you remember how to do that,

543
00:25:01,189 --> 00:25:05,128
we are going to need that class path, XML,

544
00:25:05,128 --> 00:25:07,822
and here is a little trick in Eclipse.

545
00:25:07,822 --> 00:25:08,715
I dont know if you know it

546
00:25:08,715 --> 00:25:12,421
but I'm just going to
press control and space.

547
00:25:12,421 --> 00:25:15,835
That's going to be command
and space on a Mac.

548
00:25:15,835 --> 00:25:18,585
And Eclipse will automatically search the

549
00:25:18,585 --> 00:25:20,107
all the Java files that we have

550
00:25:20,107 --> 00:25:22,332
and it finds any matches

551
00:25:22,332 --> 00:25:24,200
and because there is only one match

552
00:25:24,200 --> 00:25:25,735
for the string I typed in.

553
00:25:25,735 --> 00:25:28,417
It's filled it in automatically.

554
00:25:28,417 --> 00:25:31,282
Notice it's a capital P there.

555
00:25:31,282 --> 00:25:33,653
I think I typed in a small P at first

556
00:25:33,653 --> 00:25:35,557
but anyway, we've got it now.

557
00:25:35,557 --> 00:25:38,581
I'm going to call this the container.

558
00:25:38,581 --> 00:25:40,603
And we just instantiate that

559
00:25:40,603 --> 00:25:43,137
with the same process as before

560
00:25:43,137 --> 00:25:45,573
control and space and we are going to

561
00:25:45,573 --> 00:25:49,659
pass in the name of our XML file

562
00:25:49,659 --> 00:25:52,792
into the constructor.

563
00:25:52,792 --> 00:25:55,230
Just a few words on this file.

564
00:25:55,230 --> 00:25:57,718
The way class path XML application concept

565
00:25:57,718 --> 00:26:00,763
works is it searches for this file

566
00:26:00,763 --> 00:26:03,444
not just anywhere on your hard drive

567
00:26:03,444 --> 00:26:07,400
but basically from the SRC folder.

568
00:26:07,400 --> 00:26:10,201
So if we wanted to, we could store

569
00:26:10,201 --> 00:26:13,109
the XML file in a package

570
00:26:13,109 --> 00:26:15,271
and we would just add in the package

571
00:26:15,271 --> 00:26:17,876
name in here you use forward slashes

572
00:26:17,876 --> 00:26:19,996
for each sub package.

573
00:26:19,996 --> 00:26:22,954
Then it will search down the class path.

574
00:26:22,954 --> 00:26:25,398
I think in many cases we
want to keep this file

575
00:26:25,398 --> 00:26:27,594
right to the top of the class path.

576
00:26:27,594 --> 00:26:30,072
You will find this is quite common.

577
00:26:30,072 --> 00:26:32,765
Now I need to get the service object

578
00:26:32,765 --> 00:26:34,604
from the container.

579
00:26:34,604 --> 00:26:37,823
Notice very importantly
here I'm going to program

580
00:26:37,823 --> 00:26:39,240
to the interface.

581
00:26:40,541 --> 00:26:42,039
Now by programming to the interface

582
00:26:42,039 --> 00:26:44,431
that means I'm going to use the interface

583
00:26:44,431 --> 00:26:46,343
here as the reference

584
00:26:46,343 --> 00:26:48,596
rather than the concrete class,

585
00:26:48,596 --> 00:26:51,362
which is the mock implementation.

586
00:26:51,362 --> 00:26:53,144
I know I've talked about this already

587
00:26:53,144 --> 00:26:54,811
but it is probably the most important

588
00:26:54,811 --> 00:26:56,442
thing on this course.

589
00:26:56,442 --> 00:26:59,237
That means that if we
change the implementation

590
00:26:59,237 --> 00:27:02,932
later and we know we are going to do that

591
00:27:02,932 --> 00:27:06,240
when we bring in the true
production quality implementation

592
00:27:06,240 --> 00:27:09,446
we won't have to change
all of the client code.

593
00:27:09,446 --> 00:27:11,969
Ill call that service

594
00:27:11,969 --> 00:27:14,006
and we do that by calling

595
00:27:14,006 --> 00:27:17,033
the get bean method on the container.

596
00:27:17,033 --> 00:27:19,270
You will remember from
the previous chapter

597
00:27:19,270 --> 00:27:21,544
that there several
different ways of doing this

598
00:27:21,544 --> 00:27:24,753
but probably the easiest is just to say

599
00:27:24,753 --> 00:27:26,898
what we wanted to look in the container

600
00:27:26,898 --> 00:27:29,621
and find any class which implements

601
00:27:29,621 --> 00:27:31,044
the BookService interface.

602
00:27:31,044 --> 00:27:32,301
There's only one of them

603
00:27:32,301 --> 00:27:35,127
so it will know which one to retrieve.

604
00:27:35,127 --> 00:27:37,244
Now all that remains
is to call the methods.

605
00:27:37,244 --> 00:27:39,809
So I can now call the

606
00:27:39,809 --> 00:27:42,168
get entire catalog method

607
00:27:42,168 --> 00:27:45,668
and that will retrieve me a list of books.

608
00:27:48,391 --> 00:27:51,928
Let's call that variable all books

609
00:27:51,928 --> 00:27:56,160
and then really Spring is
out of the picture now.

610
00:27:56,160 --> 00:27:58,033
It is just regular Java.

611
00:27:58,033 --> 00:28:01,033
I can just iterate through that book

612
00:28:02,606 --> 00:28:06,008
collection and I'm just going to output

613
00:28:06,008 --> 00:28:08,758
each of them in turn.

614
00:28:09,955 --> 00:28:11,374
Now I have a few compilers here

615
00:28:11,374 --> 00:28:13,409
because I'm missing some input

616
00:28:13,409 --> 00:28:16,754
so the usual control shift and O

617
00:28:16,754 --> 00:28:20,042
and be very careful if you
are following along here.

618
00:28:20,042 --> 00:28:22,219
When you are importing the
book, you need to choose

619
00:28:22,219 --> 00:28:24,785
our book and not the other book class

620
00:28:24,785 --> 00:28:26,737
that's in the Java library.

621
00:28:26,737 --> 00:28:31,039
Similarly for list, this
one is even scarier.

622
00:28:31,039 --> 00:28:32,829
You need to be sure to select

623
00:28:32,829 --> 00:28:36,578
Java dot Util dot list.

624
00:28:36,578 --> 00:28:37,997
It looks like we are good to go.

625
00:28:37,997 --> 00:28:39,747
Ill give this a run.

626
00:28:41,986 --> 00:28:46,502
Well we have what looks like
a Spring exception here.

627
00:28:46,502 --> 00:28:49,479
By the way these first two lines here

628
00:28:49,479 --> 00:28:51,562
these log for J warnings,

629
00:28:52,502 --> 00:28:56,243
we can ignore that warning
for quite a long time.

630
00:28:56,243 --> 00:28:58,231
It is just warning as the Spring won't be

631
00:28:58,231 --> 00:29:00,802
able to write any logs.

632
00:29:00,802 --> 00:29:03,687
You'll find that you
don't actually need much

633
00:29:03,687 --> 00:29:07,425
of the Spring logging, at least
until later in the course.

634
00:29:07,425 --> 00:29:09,347
You can safely ignore these two lines,

635
00:29:09,347 --> 00:29:12,526
but you certainly can't
ignore the rest of it.

636
00:29:12,526 --> 00:29:15,943
It is another ugly, big Spring exception.

637
00:29:16,806 --> 00:29:20,296
And if I put a highlight on this line here

638
00:29:20,296 --> 00:29:21,836
I think this is the cause.

639
00:29:21,836 --> 00:29:23,936
Spring is trying to create the class

640
00:29:23,936 --> 00:29:25,404
that we told it to create,

641
00:29:25,404 --> 00:29:28,089
which is com dot Virtual Pair
Programmers dot Avalon dot

642
00:29:28,089 --> 00:29:31,360
service dot BookService mock input

643
00:29:31,360 --> 00:29:34,501
and it is saying that
class can't be found.

644
00:29:34,501 --> 00:29:36,860
We certainly did write that class.

645
00:29:36,860 --> 00:29:40,643
I've almost certainly got a typo in here.

646
00:29:40,643 --> 00:29:44,810
And if I just switch
to my package explorer,

647
00:29:46,365 --> 00:29:48,603
and Ill just make sure the exception

648
00:29:48,603 --> 00:29:49,946
is visible there.

649
00:29:49,946 --> 00:29:52,464
If we look in here, the package is

650
00:29:52,464 --> 00:29:54,630
com dot Virtual Pair Programmers

651
00:29:54,630 --> 00:29:57,834
dot Avalon dot, and if you
can see what I've done there

652
00:29:57,834 --> 00:30:02,001
the package is called
services with an S on the end

653
00:30:02,960 --> 00:30:07,148
but I put in the XML just service

654
00:30:07,148 --> 00:30:08,231
without an S.

655
00:30:09,264 --> 00:30:12,199
A small slip leading to a big exception

656
00:30:12,199 --> 00:30:14,967
but obviously Spring had
no chance of creating

657
00:30:14,967 --> 00:30:18,740
a class from a package that didn't exist.

658
00:30:18,740 --> 00:30:20,500
Now as you can see, whenever you run

659
00:30:20,500 --> 00:30:23,224
a Spring application for the first time,

660
00:30:23,224 --> 00:30:24,819
you are going to find that these little

661
00:30:24,819 --> 00:30:28,473
typos do cause some fairly
alarming cold chains.

662
00:30:28,473 --> 00:30:30,639
Often it is just the class names.

663
00:30:30,639 --> 00:30:32,556
Sometimes an XML error.

664
00:30:33,814 --> 00:30:35,882
Well actually in a
couple of chapters' time,

665
00:30:35,882 --> 00:30:37,508
I will be able to show you a way of

666
00:30:37,508 --> 00:30:40,349
kind of checking the XML for errors

667
00:30:40,349 --> 00:30:42,098
before we even run the program

668
00:30:42,098 --> 00:30:44,215
but I can't do that just yet

669
00:30:44,215 --> 00:30:47,229
because we do need a
little bit more theory.

670
00:30:47,229 --> 00:30:48,896
Anyway you need to learn

671
00:30:48,896 --> 00:30:50,848
how to correct these errors manually,

672
00:30:50,848 --> 00:30:53,551
so that was worthwhile.

673
00:30:53,551 --> 00:30:55,634
Let's go for another run.

674
00:30:57,538 --> 00:31:00,265
And wonderfully we are now
getting a good response,

675
00:31:00,265 --> 00:31:04,252
but don't forget you can
ignore this red text here.

676
00:31:04,252 --> 00:31:06,333
It is just a warning.

677
00:31:06,333 --> 00:31:07,684
So Ill emphasize just once more

678
00:31:07,684 --> 00:31:10,490
what we could now we
do is we could upgrade

679
00:31:10,490 --> 00:31:14,110
the service to a true
database implementation

680
00:31:14,110 --> 00:31:17,723
of the service and we will
certainly be doing that later.

681
00:31:17,723 --> 00:31:20,428
And we wouldnt have to change

682
00:31:20,428 --> 00:31:22,396
the client from N.

683
00:31:22,396 --> 00:31:24,504
Now I know that's not a big deal now

684
00:31:24,504 --> 00:31:26,915
when we've only got a few lines in here,

685
00:31:26,915 --> 00:31:29,331
but we could if we wanted to even though

686
00:31:29,331 --> 00:31:31,773
we are not ready with the
production service yet.

687
00:31:31,773 --> 00:31:34,174
We could go and build all of the web pages

688
00:31:34,174 --> 00:31:36,708
for the application and not worry

689
00:31:36,708 --> 00:31:40,736
that we haven't yet got
the production BookService.

690
00:31:40,736 --> 00:31:43,328
That's because Spring has decoupled

691
00:31:43,328 --> 00:31:46,350
the tiers of our application
and we've got freedom

692
00:31:46,350 --> 00:31:48,925
really to work in any way that we choose

693
00:31:48,925 --> 00:31:51,699
and any direction that we want to go.

694
00:31:51,699 --> 00:31:53,446
I hope you like what we've done there

695
00:31:53,446 --> 00:31:55,359
because we will be doing a lot of it

696
00:31:55,359 --> 00:31:58,655
through the rest of this course.

697
00:31:58,655 --> 00:32:01,063
We've started to do some slightly more

698
00:32:01,063 --> 00:32:03,067
realistic work now with Spring.

699
00:32:03,067 --> 00:32:04,613
There's still a long way to go

700
00:32:04,613 --> 00:32:06,113
but it is a start.

701
00:32:07,107 --> 00:32:09,464
We've written a mock implementation

702
00:32:09,464 --> 00:32:11,061
of a service.

703
00:32:11,061 --> 00:32:13,458
This class is a kind of stand-in

704
00:32:13,458 --> 00:32:16,145
temporary class that we are using until

705
00:32:16,145 --> 00:32:18,820
we have the time and resources to build

706
00:32:18,820 --> 00:32:21,839
a production standard implementation.

707
00:32:21,839 --> 00:32:23,362
That's a good technique.

708
00:32:23,362 --> 00:32:26,771
We call it a mock here at
Virtual Pair Programmers,

709
00:32:26,771 --> 00:32:29,942
but there are other terms in use for it

710
00:32:29,942 --> 00:32:32,442
such as a prototype or a fake.

711
00:32:33,518 --> 00:32:37,514
The XML is often called the wiring.

712
00:32:37,514 --> 00:32:39,671
And whilst we made a start of it,

713
00:32:39,671 --> 00:32:42,928
there is still much more to come.

714
00:32:42,928 --> 00:32:46,238
But now it is over to
you in the next chapter,

715
00:32:46,238 --> 00:32:49,649
you will be meeting the first
fully practical exercise

716
00:32:49,649 --> 00:32:51,850
where you will be attempting to build a

717
00:32:51,850 --> 00:32:54,823
customer relationship management system

718
00:32:54,823 --> 00:32:57,240
yourself almost from scratch.

719
00:32:58,216 --> 00:33:02,133
Have a good break before
rejoining us for that.

1
00:00:00,241 --> 00:00:05,241
(calm music)

2
00:00:10,283 --> 00:00:13,755
- [Voiceover] Welcome back to
this first practical chapter

3
00:00:13,755 --> 00:00:16,758
on the Spring Framework
Fundamentals course.

4
00:00:16,758 --> 00:00:21,758
We're now ready to begin
writing a real application.

5
00:00:22,077 --> 00:00:24,665
Now, we've been contracted
by a client to write

6
00:00:24,665 --> 00:00:28,722
a Customer Relationship Management system.

7
00:00:28,722 --> 00:00:31,390
Our client is having serious problems

8
00:00:31,390 --> 00:00:34,054
in managing their customers.

9
00:00:34,054 --> 00:00:38,183
At the moment, customers are
calling their call center,

10
00:00:38,183 --> 00:00:40,909
and members of staff are
promising to do things

11
00:00:40,909 --> 00:00:45,129
but then completely forgetting
to do what they've promised,

12
00:00:45,129 --> 00:00:49,313
and it's because their system
is very ad-hoc at the moment.

13
00:00:49,313 --> 00:00:53,294
Each member of staff is
keeping their own to-do lists,

14
00:00:53,294 --> 00:00:57,909
some using Microsoft Outlook,
some using Google Calendar,

15
00:00:57,909 --> 00:00:59,182
and actually most of them are using

16
00:00:59,182 --> 00:01:02,840
post-it notes and scraps of paper.

17
00:01:02,840 --> 00:01:04,357
We've been asked to write a system

18
00:01:04,357 --> 00:01:09,357
that can store the details
of all the customers,

19
00:01:09,517 --> 00:01:12,518
and every time we get a new customer

20
00:01:12,518 --> 00:01:16,401
we need to be able to
record their details.

21
00:01:16,401 --> 00:01:19,902
And every time a customer
calls the company

22
00:01:19,902 --> 00:01:21,478
we need to be able to record

23
00:01:21,478 --> 00:01:24,459
the details of the customer's call,

24
00:01:24,459 --> 00:01:29,166
for example, "4:30 on the 2nd of December

25
00:01:29,166 --> 00:01:32,883
"Martha from Acme called".

26
00:01:32,883 --> 00:01:35,217
When a call is received from a customer

27
00:01:35,217 --> 00:01:37,292
and the call is being logged,

28
00:01:37,292 --> 00:01:42,292
we may need to record one or
more actions against the call.

29
00:01:42,745 --> 00:01:45,493
An action would be something like,

30
00:01:45,493 --> 00:01:48,840
"We need to call Martha
back by the 9th of December

31
00:01:48,840 --> 00:01:52,684
"to order 144 boxes".

32
00:01:52,684 --> 00:01:56,664
Finally, the system must
be able to manage a diary

33
00:01:56,664 --> 00:01:59,105
for all users of the system.

34
00:01:59,105 --> 00:02:01,845
We'll be able to get
things by email alerts

35
00:02:01,845 --> 00:02:06,509
telling users when a
particular action is due.

36
00:02:06,509 --> 00:02:09,310
In your starting workspace folder

37
00:02:09,310 --> 00:02:11,203
you'll find there's another subfolder

38
00:02:11,203 --> 00:02:16,014
in there called "CRMSystem",

39
00:02:16,014 --> 00:02:17,290
and in there we've given you

40
00:02:17,290 --> 00:02:20,041
all of the Java you need to get started.

41
00:02:20,041 --> 00:02:23,191
We haven't done any of the Spring for you

42
00:02:23,191 --> 00:02:27,082
but we have given you all
of the routing Java code.

43
00:02:27,082 --> 00:02:29,132
Starting with the "lib" folder,

44
00:02:29,132 --> 00:02:30,443
I think you've seen that I just put here

45
00:02:30,443 --> 00:02:32,853
all of the JAR files you'll need

46
00:02:32,853 --> 00:02:36,536
to write a full Spring application.

47
00:02:36,536 --> 00:02:39,760
Back up to the "src" folder

48
00:02:39,760 --> 00:02:43,866
the first thing I'd like to
show you is under the "com",

49
00:02:43,866 --> 00:02:46,949
"visualpairprogrammers" package,

50
00:02:46,949 --> 00:02:50,275
there's a subfolder called "domain".

51
00:02:50,275 --> 00:02:52,699
In here are all of the domain classes,

52
00:02:52,699 --> 00:02:55,048
so we've got a class representing

53
00:02:55,048 --> 00:02:57,731
each of the objects in our system,

54
00:02:57,731 --> 00:03:02,562
so we've got three classes,
Action, Call and Customer.

55
00:03:02,562 --> 00:03:05,947
Let's have a look in detail
at what those classes are.

56
00:03:05,947 --> 00:03:09,727
The Customer class
represents a single customer,

57
00:03:09,727 --> 00:03:13,491
so for every customer we'll
have an instance of this class

58
00:03:13,491 --> 00:03:17,359
and we'll have in there details
such as the company name,

59
00:03:17,359 --> 00:03:20,947
the customer's telephone
number, email address

60
00:03:20,947 --> 00:03:24,346
and general notes about the customer.

61
00:03:24,346 --> 00:03:29,346
The Call class represents a
single call made by a customer.

62
00:03:30,379 --> 00:03:35,379
So, for example, "Martha called
at 4:30 on October 4, 2008."

63
00:03:37,410 --> 00:03:39,943
I'll show you the
attributes inside this class

64
00:03:39,943 --> 00:03:43,108
when we go across the Java.

65
00:03:43,108 --> 00:03:45,784
The Action class represents a job

66
00:03:45,784 --> 00:03:49,574
that we have to perform
as a result of a call.

67
00:03:49,574 --> 00:03:52,211
For example something like,

68
00:03:52,211 --> 00:03:54,883
"Check with marketing
that the sales brochure

69
00:03:54,883 --> 00:03:59,839
"will be ready by November 6, 2008".

70
00:03:59,839 --> 00:04:03,137
The classes are related as follows:

71
00:04:03,137 --> 00:04:07,887
each Customer can make many Calls

72
00:04:07,887 --> 00:04:12,887
and each Call is owned
by a single Customer.

73
00:04:13,652 --> 00:04:15,210
If you're familiar with UML

74
00:04:15,210 --> 00:04:19,911
then we've expressed that
diagram graphically here.

75
00:04:19,911 --> 00:04:24,073
Of course we'll see these in
the Java in a few moments.

76
00:04:24,073 --> 00:04:26,023
Note that we're not relating

77
00:04:26,023 --> 00:04:28,927
the Call and Action class together.

78
00:04:28,927 --> 00:04:31,921
I've decided to keep them
separate for two reasons:

79
00:04:31,921 --> 00:04:34,211
firstly, the Actions might be stored

80
00:04:34,211 --> 00:04:38,325
in some kind of third-party
calendar or diary system

81
00:04:38,325 --> 00:04:41,888
so it might be worthwhile
to keep them separate,

82
00:04:41,888 --> 00:04:43,665
but the real reason is number two,

83
00:04:43,665 --> 00:04:45,496
and that's that I just wanted to keep

84
00:04:45,496 --> 00:04:50,357
the amounts of SQL that we
write on the course to a minimum

85
00:04:50,357 --> 00:04:53,614
in order to keep focused on the Spring.

86
00:04:53,614 --> 00:04:56,468
If we do relate Call and Action together

87
00:04:56,468 --> 00:04:58,992
then to do some fairly simple operations

88
00:04:58,992 --> 00:05:02,707
we might have to do some complex joins.

89
00:05:02,707 --> 00:05:03,920
To get started in Eclipse,

90
00:05:03,920 --> 00:05:07,286
this project is in the same
workspace that we've been using

91
00:05:07,286 --> 00:05:09,563
since the start of the course,

92
00:05:09,563 --> 00:05:12,556
so if you've been following along with me

93
00:05:12,556 --> 00:05:17,556
you'll want to close any
existing files that you have open

94
00:05:18,213 --> 00:05:21,855
and then close any projects
that you already have open.

95
00:05:21,855 --> 00:05:24,489
So, I've just been
working on the bookstore

96
00:05:24,489 --> 00:05:26,193
from the previous chapter,

97
00:05:26,193 --> 00:05:28,750
so I'm going to close that project.

98
00:05:28,750 --> 00:05:30,756
If you haven't been following along

99
00:05:30,756 --> 00:05:34,111
then fire up Eclipse
and point the workspace

100
00:05:34,111 --> 00:05:36,364
at our starting workspace

101
00:05:36,364 --> 00:05:38,746
that we've supplied with the course.

102
00:05:38,746 --> 00:05:42,499
Then from there you'll
want to open the project,

103
00:05:42,499 --> 00:05:47,499
it's the usual steps
File, New, Java project,

104
00:05:48,208 --> 00:05:53,096
and then the project name
must be "CRM System",

105
00:05:53,096 --> 00:05:55,656
make sure you get the case correct,

106
00:05:55,656 --> 00:05:58,052
and, think you've seen this before,

107
00:05:58,052 --> 00:05:59,027
it will say that the wizard will

108
00:05:59,027 --> 00:06:02,135
automatically configure the project.

109
00:06:02,135 --> 00:06:04,226
We can click Finish there,

110
00:06:04,226 --> 00:06:07,224
and then you can expand the tab here

111
00:06:07,224 --> 00:06:09,926
to see the contents of the project.

112
00:06:09,926 --> 00:06:11,302
Let's start by looking at those

113
00:06:11,302 --> 00:06:14,223
three classes that we were talking about,

114
00:06:14,223 --> 00:06:19,065
and you'll find them all
in the domain package.

115
00:06:19,065 --> 00:06:22,780
Starting with Customer.java,

116
00:06:22,780 --> 00:06:23,788
well, you can probably guess

117
00:06:23,788 --> 00:06:28,150
this is going to be a pretty simple class.

118
00:06:28,150 --> 00:06:29,638
Now, when you come to open this file

119
00:06:29,638 --> 00:06:33,376
you might see some differences
between your version

120
00:06:33,376 --> 00:06:35,918
and the version you can
see on the screen here,

121
00:06:35,918 --> 00:06:37,776
and that will be because as I go ahead

122
00:06:37,776 --> 00:06:39,780
and record the rest of this course

123
00:06:39,780 --> 00:06:43,623
I might see things that need
to be added to this file,

124
00:06:43,623 --> 00:06:45,261
in particular, later in the course,

125
00:06:45,261 --> 00:06:47,213
we're going to be doing Hibernate

126
00:06:47,213 --> 00:06:48,574
and I think I'm going to need to add

127
00:06:48,574 --> 00:06:52,012
some annotations to this class later on.

128
00:06:52,012 --> 00:06:52,956
So don't worry about

129
00:06:52,956 --> 00:06:56,099
some minor differences
between these classes

130
00:06:56,099 --> 00:06:57,665
as long as you get a basic feel

131
00:06:57,665 --> 00:07:00,218
for the contents of this class now.

132
00:07:00,218 --> 00:07:03,185
We have first of all a customer ID

133
00:07:03,185 --> 00:07:07,391
and we'll make sure that's a
unique value for each customer.

134
00:07:07,391 --> 00:07:10,569
We'll store the company
name of the customer,

135
00:07:10,569 --> 00:07:12,650
their email address,

136
00:07:12,650 --> 00:07:14,504
their telephone number

137
00:07:14,504 --> 00:07:18,111
and any notes associated
with that customer.

138
00:07:18,111 --> 00:07:22,108
Now, i've just kept them
Strings to keep things simple,

139
00:07:22,108 --> 00:07:25,845
of course these could be
any Java types that we like.

140
00:07:25,845 --> 00:07:29,113
More interestingly the
last of the attributes

141
00:07:29,113 --> 00:07:34,055
is a list of any calls that
this customer has made.

142
00:07:34,055 --> 00:07:36,954
Now, when we first instantiate a customer

143
00:07:36,954 --> 00:07:41,043
we won't have any calls
associated with that customer,

144
00:07:41,043 --> 00:07:44,336
we're gong to be adding them over time.

145
00:07:44,336 --> 00:07:47,528
Then we have a regular Java constructor

146
00:07:47,528 --> 00:07:49,743
where we can pass in the customer ID,

147
00:07:49,743 --> 00:07:51,462
the company name, the email,

148
00:07:51,462 --> 00:07:53,944
the telephone and the notes

149
00:07:53,944 --> 00:07:57,106
and we'll store all as values away.

150
00:07:57,106 --> 00:07:58,825
In fact, we've made the telephone number

151
00:07:58,825 --> 00:08:02,928
and the notes optional by
overloading the constructor,

152
00:08:02,928 --> 00:08:07,612
so both forms of the constructor
will call this code here,

153
00:08:07,612 --> 00:08:10,915
and notice that the calls
list is indeed initialized

154
00:08:10,915 --> 00:08:14,070
to an empty list at first.

155
00:08:14,070 --> 00:08:15,995
Now, we then have the business methods

156
00:08:15,995 --> 00:08:20,373
and, really, the only interesting
one is the addCall method

157
00:08:20,373 --> 00:08:24,987
so over time we're going to
be able to pass in new calls

158
00:08:24,987 --> 00:08:27,582
whenever this customer makes a call.

159
00:08:27,582 --> 00:08:31,166
I've also provided a very
basic toString implementation

160
00:08:31,166 --> 00:08:36,000
so we can output details of
the customer on a console.

161
00:08:36,000 --> 00:08:37,549
Then there are some very boring

162
00:08:37,549 --> 00:08:40,324
get methods for the attributes,

163
00:08:40,324 --> 00:08:42,230
and as you can see there's really

164
00:08:42,230 --> 00:08:45,044
nothing very interesting there.

165
00:08:45,044 --> 00:08:49,158
Similarly, if we switch
over to the Call class

166
00:08:49,158 --> 00:08:53,429
we have inside here the
date and time of the call,

167
00:08:53,429 --> 00:08:55,895
and we have any notes about the call

168
00:08:55,895 --> 00:08:58,265
in the form of a String.

169
00:08:58,265 --> 00:09:01,192
The constructor is really simple.

170
00:09:01,192 --> 00:09:04,875
Note that we don't have to
pass in the date and time

171
00:09:04,875 --> 00:09:08,710
because we can use the
Date's default constructor

172
00:09:08,710 --> 00:09:10,895
which will default to now,

173
00:09:10,895 --> 00:09:12,381
which is exactly what we want,

174
00:09:12,381 --> 00:09:16,063
the timestamp of when
the call was recorded.

175
00:09:16,063 --> 00:09:18,610
There is an alternative
constructor that allows us

176
00:09:18,610 --> 00:09:21,604
to pass in the timestamp
that might be used

177
00:09:21,604 --> 00:09:24,312
for things like Unit Testing.

178
00:09:24,312 --> 00:09:26,365
And then we have the Action class

179
00:09:26,365 --> 00:09:30,128
which is perhaps a
little more interesting.

180
00:09:30,128 --> 00:09:32,420
The attributes here, the ID,

181
00:09:32,420 --> 00:09:35,208
any details about the action,

182
00:09:35,208 --> 00:09:37,512
the required by date,

183
00:09:37,512 --> 00:09:39,755
which will be some date in the future,

184
00:09:39,755 --> 00:09:44,034
so I need something richer
than java.util.Date,

185
00:09:44,034 --> 00:09:47,189
I'm using here the Calendar class.

186
00:09:47,189 --> 00:09:48,944
And we're also going to record

187
00:09:48,944 --> 00:09:52,427
the owning user of that action.

188
00:09:52,427 --> 00:09:56,375
We also have in here a Boolean,
a true or false saying,

189
00:09:56,375 --> 00:09:59,496
has this action be completed by the user?

190
00:09:59,496 --> 00:10:01,313
Here's the constructor,

191
00:10:01,313 --> 00:10:04,658
we'll pass in the details
of the required by date,

192
00:10:04,658 --> 00:10:06,300
the owning user,

193
00:10:06,300 --> 00:10:09,549
and notice I'm always
setting complete to false

194
00:10:09,549 --> 00:10:12,486
because presumably all new actions

195
00:10:12,486 --> 00:10:15,582
are going to start as being incomplete.

196
00:10:15,582 --> 00:10:17,598
Now, going a little further in this class

197
00:10:17,598 --> 00:10:19,265
because I wanted to stress that

198
00:10:19,265 --> 00:10:21,830
the points of a Java domain class is that

199
00:10:21,830 --> 00:10:24,992
we will tend to put
business logic in here.

200
00:10:24,992 --> 00:10:26,561
It's always a problem
with training courses

201
00:10:26,561 --> 00:10:29,462
that we write relatively
simple applications

202
00:10:29,462 --> 00:10:33,501
so there isn't really much
business logic for us to do.

203
00:10:33,501 --> 00:10:37,526
But to remind us that there
should be logic in there

204
00:10:37,526 --> 00:10:40,646
I've added one business method,

205
00:10:40,646 --> 00:10:44,507
and that's the method that
I've called isOverdue.

206
00:10:44,507 --> 00:10:46,685
Now, this method will return true

207
00:10:46,685 --> 00:10:48,998
if the action has not been performed

208
00:10:48,998 --> 00:10:51,403
by the required by date,

209
00:10:51,403 --> 00:10:54,979
and it will return false otherwise.

210
00:10:54,979 --> 00:10:57,632
The logic in here is quite simple

211
00:10:57,632 --> 00:11:02,020
but it is logic and of
course in a real application

212
00:11:02,020 --> 00:11:03,966
it would be a lot richer.

213
00:11:03,966 --> 00:11:06,037
I've also provided a toString method,

214
00:11:06,037 --> 00:11:09,209
again, just for testing on the console.

215
00:11:09,209 --> 00:11:11,078
That's all the domain classes,

216
00:11:11,078 --> 00:11:12,866
nothing complicated in there,

217
00:11:12,866 --> 00:11:14,405
but I want to remind you that there is

218
00:11:14,405 --> 00:11:19,405
no Spring in any of the domain classes.

219
00:11:19,787 --> 00:11:22,418
Now, there's subpackage
of the domain package

220
00:11:22,418 --> 00:11:26,523
called the TestPackage, here.

221
00:11:26,523 --> 00:11:29,794
Now, I have in here just a single class

222
00:11:29,794 --> 00:11:33,776
and it's a JUnit Test class.

223
00:11:33,776 --> 00:11:35,654
Now, if you don't know about JUnit

224
00:11:35,654 --> 00:11:38,590
you can probably ignore this class.

225
00:11:38,590 --> 00:11:42,707
There we do cover JUnit on
our Java Fundamentals course

226
00:11:42,707 --> 00:11:45,511
if you want to learn more about JUnit.

227
00:11:45,511 --> 00:11:49,409
If you do know JUnit then I'll
just tell you about this test

228
00:11:49,409 --> 00:11:51,868
to test the functionality
of the business method

229
00:11:51,868 --> 00:11:55,500
that I've just described
in the Action class.

230
00:11:55,500 --> 00:11:59,156
So I want to be able to
test, if we get true or false

231
00:11:59,156 --> 00:12:02,864
depending on whether the
action is overdue or not.

232
00:12:02,864 --> 00:12:04,688
I've not intended this class

233
00:12:04,688 --> 00:12:07,995
to be a really robust JUnit test,

234
00:12:07,995 --> 00:12:10,589
it's just a demo just to remind you

235
00:12:10,589 --> 00:12:15,150
that at this stage we will
write an extensive test suite

236
00:12:15,150 --> 00:12:16,953
for our domains here,

237
00:12:16,953 --> 00:12:20,259
there was no Spring
code in the domains here

238
00:12:20,259 --> 00:12:22,260
so we wouldn't need anything specific

239
00:12:22,260 --> 00:12:25,559
to Spring in the unit tests either,

240
00:12:25,559 --> 00:12:29,014
so they will be standard JUnit tests.

241
00:12:29,014 --> 00:12:34,014
Well, the second addition of
this course, released in 2014,

242
00:12:34,175 --> 00:12:39,175
I've used JUnit 4, which
uses these test annotations,

243
00:12:42,182 --> 00:12:44,372
here and here.

244
00:12:44,372 --> 00:12:48,884
In the first edition back
in 2008 I used JUnit 3

245
00:12:48,884 --> 00:12:50,241
which was a little bit different

246
00:12:50,241 --> 00:12:53,158
but the structure of the
test is largely the same

247
00:12:53,158 --> 00:12:55,152
as it was back then.

248
00:12:55,152 --> 00:12:57,380
I think we ought to test that this works,

249
00:12:57,380 --> 00:13:00,767
and you can do that by
right-clicking on the project,

250
00:13:00,767 --> 00:13:05,767
select Run As and then JUnit Test.

251
00:13:07,744 --> 00:13:10,381
And all be well we should have a green bar

252
00:13:10,381 --> 00:13:13,077
with the two test methods passing.

253
00:13:13,077 --> 00:13:16,043
Now, for the use cases that
we're going to implement

254
00:13:16,043 --> 00:13:19,794
through the rest of the practical
sessions for this course.

255
00:13:19,794 --> 00:13:22,414
And, by the way, a use
case is nothing more

256
00:13:22,414 --> 00:13:26,492
than a piece of functionality
that we're going to implement.

257
00:13:26,492 --> 00:13:30,921
The first one, the easiest,
would be Create Customer.

258
00:13:30,921 --> 00:13:31,979
To create customer,

259
00:13:31,979 --> 00:13:36,063
this is when a new customer
calls for the first time,

260
00:13:36,063 --> 00:13:38,103
we need to capture that
information which will be

261
00:13:38,103 --> 00:13:41,140
their email address, telephone number,

262
00:13:41,140 --> 00:13:44,915
and also, by the way, we'll
need a matching Delete Customer

263
00:13:44,915 --> 00:13:47,169
and Update Customer use case.

264
00:13:47,169 --> 00:13:51,855
I'm not terribly interested
in those method for the calls

265
00:13:51,855 --> 00:13:53,997
but they will need to
be there in real life,

266
00:13:53,997 --> 00:13:57,519
and if you want to add them
later then you can do so.

267
00:13:57,519 --> 00:14:01,940
Use case number two
will be Add Call Report.

268
00:14:01,940 --> 00:14:06,438
This is when a call is made
or received by the user.

269
00:14:06,438 --> 00:14:10,631
The details of the call are
entered into the system,

270
00:14:10,631 --> 00:14:13,532
and we'll be recording the
time and data of the call,

271
00:14:13,532 --> 00:14:18,025
and, optionally, notes about
what happened on that call.

272
00:14:18,025 --> 00:14:20,945
In addition, any actions that are required

273
00:14:20,945 --> 00:14:24,565
are also recorded, for example,

274
00:14:24,565 --> 00:14:26,895
"We need to call Claire back next Monday

275
00:14:26,895 --> 00:14:29,594
"with Ross' availability".

276
00:14:29,594 --> 00:14:34,574
These actions are going to be
recorded in the user's diary.

277
00:14:34,574 --> 00:14:39,407
Use case number three will be
Viewing the Customer Details.

278
00:14:39,407 --> 00:14:40,701
We'd like to be able to list

279
00:14:40,701 --> 00:14:43,080
all of the customers in the system

280
00:14:43,080 --> 00:14:47,281
or be able to search by
various criteria such as

281
00:14:47,281 --> 00:14:48,860
let's search for all the customers

282
00:14:48,860 --> 00:14:51,387
matching a particular name.

283
00:14:51,387 --> 00:14:53,284
Additionally, we'll also be able

284
00:14:53,284 --> 00:14:55,796
to select a particular customer

285
00:14:55,796 --> 00:14:58,209
and then see the full list of calls

286
00:14:58,209 --> 00:15:01,567
or call log for that customer.

287
00:15:01,567 --> 00:15:05,659
A final use case for the
course will be View Diary.

288
00:15:05,659 --> 00:15:07,161
This will allow the user to see

289
00:15:07,161 --> 00:15:10,567
all of the actions that
they need to perform,

290
00:15:10,567 --> 00:15:11,642
and for this course we're going to go

291
00:15:11,642 --> 00:15:14,623
for a very simple list of actions.

292
00:15:14,623 --> 00:15:16,692
The final thing I need to show you is

293
00:15:16,692 --> 00:15:20,643
I've given you two interfaces pre-prepared

294
00:15:20,643 --> 00:15:24,117
and it's these interfaces that
you're going to implement.

295
00:15:24,117 --> 00:15:27,009
Let's switch across to Eclipse
and have a look at them.

296
00:15:27,009 --> 00:15:30,732
So we're looking now in
the Services package,

297
00:15:30,732 --> 00:15:33,512
and in fact there are three subpackages

298
00:15:33,512 --> 00:15:35,597
of the Services package,

299
00:15:35,597 --> 00:15:38,030
there's one for calls, one for customers

300
00:15:38,030 --> 00:15:41,068
and one for managing the diary.

301
00:15:41,068 --> 00:15:44,218
Let's start with the Customers package

302
00:15:44,218 --> 00:15:45,755
and there's an interface in there

303
00:15:45,755 --> 00:15:49,813
called CustomerManagementService.

304
00:15:49,813 --> 00:15:53,511
We have in here fairly
call straight methods

305
00:15:53,511 --> 00:15:58,511
like newCustomer, updateCustomer,
deleteCustomer and so on.

306
00:15:59,277 --> 00:16:02,040
I just want to warn you here that

307
00:16:02,040 --> 00:16:04,766
it can be a little bit misleading this

308
00:16:04,766 --> 00:16:08,034
although possibly many of these
methods are going to result

309
00:16:08,034 --> 00:16:11,272
in single database calls.

310
00:16:11,272 --> 00:16:12,840
For instance you can imagine there will be

311
00:16:12,840 --> 00:16:17,840
an insert statement executed
as a result of this method.

312
00:16:18,227 --> 00:16:20,749
I want you to remember that
we also have the option

313
00:16:20,749 --> 00:16:24,698
of adding Java logic to
this methods as well,

314
00:16:24,698 --> 00:16:29,320
so these aren't just
simple database commands,

315
00:16:29,320 --> 00:16:33,355
there could well be more
to the code than that.

316
00:16:33,355 --> 00:16:34,410
It's just that because this is

317
00:16:34,410 --> 00:16:37,229
quite a simple application at the moment

318
00:16:37,229 --> 00:16:39,574
you can certainly imagine
many of these methods

319
00:16:39,574 --> 00:16:43,181
just being mapped to a database statement.

320
00:16:43,181 --> 00:16:46,727
So we've also got methods
like findCustomerById,

321
00:16:46,727 --> 00:16:49,971
findCustomersByName and so on.

322
00:16:49,971 --> 00:16:52,951
So this is just an interface
and your job will be

323
00:16:52,951 --> 00:16:54,642
to implement it.

324
00:16:54,642 --> 00:16:56,769
The second of the interfaces

325
00:16:56,769 --> 00:17:00,491
you'll find in the Diary package,

326
00:17:00,491 --> 00:17:05,463
I've called this service
the DiaryManagementService.

327
00:17:05,463 --> 00:17:08,050
Now, we have in here just two methods:

328
00:17:08,050 --> 00:17:10,449
we can record an action

329
00:17:10,449 --> 00:17:14,944
and we can get a list of all
of the incomplete actions.

330
00:17:14,944 --> 00:17:18,608
Now, there is a third
interface in the other package,

331
00:17:18,608 --> 00:17:20,904
this is the Calls package,

332
00:17:20,904 --> 00:17:24,812
but we don't need this interface just yet,

333
00:17:24,812 --> 00:17:27,356
this is there for a later chapter,

334
00:17:27,356 --> 00:17:32,259
so please ignore the
CallHandlingService for now.

335
00:17:32,259 --> 00:17:33,846
So your job now then is to,

336
00:17:33,846 --> 00:17:37,404
firstly, create mock implementations

337
00:17:37,404 --> 00:17:41,792
of those two service interfaces.

338
00:17:41,792 --> 00:17:46,425
And then, step two, configure
the mock implementations

339
00:17:46,425 --> 00:17:49,395
in Spring using the XML

340
00:17:49,395 --> 00:17:51,198
that you should now be familiar with.

341
00:17:51,198 --> 00:17:56,198
And finally, write a simple
console-based test harness

342
00:17:56,347 --> 00:18:01,347
that gets the service beans
and tests their functionality.

343
00:18:01,351 --> 00:18:03,588
All of the details for
this practical session

344
00:18:03,588 --> 00:18:08,537
are in the PDF document in your
practicals and code folder.

345
00:18:08,537 --> 00:18:11,269
Now I'd really like you to go away

346
00:18:11,269 --> 00:18:14,893
and have a try at doing
these steps yourself,

347
00:18:14,893 --> 00:18:19,792
but of course, if you have any
problems there's example code

348
00:18:19,792 --> 00:18:23,825
in the solutions folder,
in practicals and code,

349
00:18:23,825 --> 00:18:27,175
but also the rest of this video

350
00:18:27,175 --> 00:18:31,177
is a full worked solution
for this practical.

351
00:18:31,177 --> 00:18:34,013
Now, I urge you to pause the video now

352
00:18:34,013 --> 00:18:37,544
and only use the video
if you run into problems

353
00:18:37,544 --> 00:18:41,507
or if you want to compare
your solution with mine.

354
00:18:41,507 --> 00:18:46,507
Please try to do the
code for yourself first.

355
00:18:46,564 --> 00:18:49,212
So, that's it for the project.

356
00:18:49,212 --> 00:18:51,183
Good luck with it.

357
00:18:53,543 --> 00:18:55,748
Okay, we go then with my worked solution

358
00:18:55,748 --> 00:18:59,840
for the first part of
the practical exercise.

359
00:18:59,840 --> 00:19:02,987
Now, because these walkthrough
are just going through code

360
00:19:02,987 --> 00:19:05,148
and I'm not aiming to teach anything

361
00:19:05,148 --> 00:19:10,148
I'll probably not going to
as much detail as I'm coding,

362
00:19:10,481 --> 00:19:11,746
and I certainly won't keep

363
00:19:11,746 --> 00:19:15,003
a running commentary going at all times,

364
00:19:15,003 --> 00:19:17,283
so the aim of this really is to show you

365
00:19:17,283 --> 00:19:20,043
every single step of the coding process.

366
00:19:20,043 --> 00:19:25,043
So it's certainly not going
to be exciting or entertaining

367
00:19:25,089 --> 00:19:28,534
but I hope it will be helpful
if you run into any problems.

368
00:19:28,534 --> 00:19:33,534
And the objective was to
write a real application,

369
00:19:34,137 --> 00:19:35,949
so I'm starting here with Eclipse

370
00:19:35,949 --> 00:19:38,433
in the same state it was in when I went

371
00:19:38,433 --> 00:19:42,402
through the basics of the
project a few moments ago,

372
00:19:42,402 --> 00:19:47,120
and the first requirement was
to implement the interface.

373
00:19:47,120 --> 00:19:51,969
So I'll start with my
CustomerManagementService,

374
00:19:51,969 --> 00:19:56,590
so I need to create a new class,

375
00:19:56,590 --> 00:19:58,102
and the first decision is

376
00:19:58,102 --> 00:20:01,654
which package should this class live in?

377
00:20:01,654 --> 00:20:03,338
You could put this class

378
00:20:03,338 --> 00:20:05,762
in a different package to the interface

379
00:20:05,762 --> 00:20:07,262
but I think in this course

380
00:20:07,262 --> 00:20:09,239
the system's not going to be too big

381
00:20:09,239 --> 00:20:13,493
so I think I'm going to
put it in the same package

382
00:20:13,493 --> 00:20:16,351
the Customer Service package,

383
00:20:16,351 --> 00:20:18,834
that's the package that
contains the interface

384
00:20:18,834 --> 00:20:23,181
and I think that would be fine
for a project of this size.

385
00:20:23,181 --> 00:20:28,181
This is going to be the
CustomerManagementMockImpl

386
00:20:29,056 --> 00:20:30,849
and I talked a lot in the theory

387
00:20:30,849 --> 00:20:33,426
about what I mean by a mock,

388
00:20:33,426 --> 00:20:37,064
this is going to be a plain
Java class that pretends to be

389
00:20:37,064 --> 00:20:39,964
a production standard implementation,

390
00:20:39,964 --> 00:20:42,075
and later on in the course we will do

391
00:20:42,075 --> 00:20:45,112
a proper production implementation.

392
00:20:45,112 --> 00:20:47,523
And I'm going to make
sure that this implements

393
00:20:47,523 --> 00:20:52,523
the CustomerManagementService interface

394
00:20:54,070 --> 00:20:56,312
so add that to this box here.

395
00:20:56,312 --> 00:20:59,139
And because this box here is ticked

396
00:20:59,139 --> 00:21:03,676
when I click Finish
Eclipse has added skeletons

397
00:21:03,676 --> 00:21:07,050
of all of the methods
that I need to implement.

398
00:21:07,050 --> 00:21:09,502
And first thing I'm going to
be doing inside this class

399
00:21:09,502 --> 00:21:14,378
is we need to store the fake data

400
00:21:14,378 --> 00:21:17,714
that this class is going to represent,

401
00:21:17,714 --> 00:21:19,975
and as in theory I'm going to hold that

402
00:21:19,975 --> 00:21:24,141
in a private attribute which
is going to be a HashMap,

403
00:21:24,141 --> 00:21:26,595
and they keys are going to be Strings,

404
00:21:26,595 --> 00:21:28,743
that's going to be customer IDs,

405
00:21:28,743 --> 00:21:30,079
and the values are going to be

406
00:21:30,079 --> 00:21:33,422
the Customer objects themselves.

407
00:21:33,422 --> 00:21:37,008
I think I'll call this
variable customerMap

408
00:21:37,008 --> 00:21:41,194
and I could instantiate it here

409
00:21:41,194 --> 00:21:43,395
but I think I'll instantiate it

410
00:21:43,395 --> 00:21:46,902
in the constructor of this class.

411
00:21:46,902 --> 00:21:50,030
So add the constructor right now.

412
00:21:52,090 --> 00:21:54,555
You might notice that you
can either instantiate

413
00:21:54,555 --> 00:21:57,936
an attribute inside the constructor

414
00:21:57,936 --> 00:22:02,773
or you can do it inline
here with an "= new",

415
00:22:02,773 --> 00:22:07,138
it's a bit of a personal taste
really which one you go for.

416
00:22:07,138 --> 00:22:11,525
This customerMap is
going to be a new HashMap

417
00:22:12,621 --> 00:22:15,322
and because I'm using Java 5 generics

418
00:22:15,322 --> 00:22:18,174
I need to specify type of the key

419
00:22:18,174 --> 00:22:21,991
and type of the value here as well.

420
00:22:21,991 --> 00:22:23,247
Now, I have a compile error here

421
00:22:23,247 --> 00:22:25,758
because I haven't imported HashMap,

422
00:22:25,758 --> 00:22:30,730
so as on the theory "Ctrl +
Shift + O" or "Cmd + Shift + O"

423
00:22:30,730 --> 00:22:35,641
will allow me to import
the java.util.HashMap.

424
00:22:35,641 --> 00:22:37,904
Great, that's compiling.

425
00:22:37,904 --> 00:22:39,542
Now, what I'd like to do in the mock

426
00:22:39,542 --> 00:22:42,636
is in the constructor I'm going to create

427
00:22:42,636 --> 00:22:45,235
a small number of Customer objects

428
00:22:45,235 --> 00:22:47,628
and immediately put them into the Map.

429
00:22:47,628 --> 00:22:49,532
That will kind of simulate a system

430
00:22:49,532 --> 00:22:52,001
that's already been running for some time

431
00:22:52,001 --> 00:22:54,684
and has some data in the database.

432
00:22:54,684 --> 00:22:55,630
You don't have to do that,

433
00:22:55,630 --> 00:22:58,357
we can start with an
empty customer service

434
00:22:58,357 --> 00:23:01,121
and we could then just
start calling newCustomer

435
00:23:01,121 --> 00:23:05,180
but I'd like to have
something in there immediately

436
00:23:05,180 --> 00:23:08,479
so "customerMap.put".

437
00:23:08,479 --> 00:23:09,988
And the customer IDs are going to be

438
00:23:09,988 --> 00:23:14,988
some kind of random generated Strings,

439
00:23:15,928 --> 00:23:19,417
and each customer will
have its own unique ID.

440
00:23:19,417 --> 00:23:21,631
Now, I don't know exactly how
we're going to define that

441
00:23:21,631 --> 00:23:23,924
in the business but just
for the sake of science

442
00:23:23,924 --> 00:23:28,924
I'll invent some kind of random key.

443
00:23:29,274 --> 00:23:31,384
You can put anything you
want in there, really,

444
00:23:31,384 --> 00:23:34,782
as long as you make sure it's unique.

445
00:23:34,782 --> 00:23:37,821
And this is going to be
a new Customer object,

446
00:23:37,821 --> 00:23:40,035
and I need to specify the customer ID

447
00:23:40,035 --> 00:23:43,629
which will need to be
the same number again.

448
00:23:43,629 --> 00:23:46,181
Then we have the company name,

449
00:23:47,531 --> 00:23:50,097
I'll call it "Acme Ltd".

450
00:23:50,097 --> 00:23:53,055
Third value in this
constructor is some notes

451
00:23:53,055 --> 00:23:57,756
and I'll just put some
nonsense information in there.

452
00:23:57,756 --> 00:24:00,419
Just to make it a little
bit more interesting

453
00:24:00,419 --> 00:24:05,419
I'll add in another couple of
customers with different IDs,

454
00:24:10,043 --> 00:24:11,999
and I'll change this company name

455
00:24:11,999 --> 00:24:15,647
to "VirtualPairProgrammers",

456
00:24:16,751 --> 00:24:19,755
an ugly company name but it works for us,

457
00:24:19,755 --> 00:24:21,931
and for this one

458
00:24:21,931 --> 00:24:24,566
I'll go for "Microsoft",

459
00:24:24,566 --> 00:24:27,558
the first name that came
into my head, really.

460
00:24:27,558 --> 00:24:29,132
We did something very
similar to this, by the way,

461
00:24:29,132 --> 00:24:31,728
in our Spring MVC course.

462
00:24:31,728 --> 00:24:34,130
On that course we built a bookstore

463
00:24:34,130 --> 00:24:37,047
and in the constructor
there I went mad, really,

464
00:24:37,047 --> 00:24:40,084
and added something like
100 hard-coded books

465
00:24:40,084 --> 00:24:42,746
just to make webpages look interesting.

466
00:24:42,746 --> 00:24:44,052
Anyway, that's for another course.

467
00:24:44,052 --> 00:24:47,304
The next job now, I'll just maximize this,

468
00:24:47,304 --> 00:24:50,791
is to, oh, dear, go ahead and
implement all of these methods

469
00:24:50,791 --> 00:24:54,919
which looks like quite
a daunting list, really,

470
00:24:54,919 --> 00:24:57,997
but, oh, well, none of the implementations

471
00:24:57,997 --> 00:24:59,044
should be too difficult

472
00:24:59,044 --> 00:25:01,665
so let's just take a
breath and get on with it.

473
00:25:01,665 --> 00:25:03,262
For the newCustomer method

474
00:25:03,262 --> 00:25:06,081
I'm just going to need to take the Map

475
00:25:06,081 --> 00:25:08,982
and put in there the local variable

476
00:25:08,982 --> 00:25:11,161
here is called newCustomer,

477
00:25:11,161 --> 00:25:12,778
I'll need to put in the key

478
00:25:12,778 --> 00:25:17,015
so I'll need to call the
getId method on the customer,

479
00:25:17,015 --> 00:25:21,497
and the value is going to
be the newCustomer itself.

480
00:25:21,497 --> 00:25:24,306
And I've got a compile error here.

481
00:25:25,256 --> 00:25:27,713
Yeah, I'm not sure if
that was called "getId",

482
00:25:27,713 --> 00:25:30,433
let me just hit the dot again.

483
00:25:30,433 --> 00:25:35,433
Oh, yes, it was "getCustomerId"
rather than "getId".

484
00:25:35,751 --> 00:25:37,865
So that's okay, that's now compiling.

485
00:25:37,865 --> 00:25:41,757
Now, updateCustomer is
a little bit strange

486
00:25:41,757 --> 00:25:44,446
because in the production implementation

487
00:25:44,446 --> 00:25:46,776
this is going to be a
really important method

488
00:25:46,776 --> 00:25:48,709
because, of course, this will result

489
00:25:48,709 --> 00:25:51,806
in some kind of database update.

490
00:25:51,806 --> 00:25:55,506
For this little test system
it's going to be a bit strange

491
00:25:55,506 --> 00:26:00,040
because we'll probably pass the
customer bytes of the client

492
00:26:00,040 --> 00:26:03,011
and we would have actually
just passed a reference

493
00:26:03,011 --> 00:26:05,524
to that customer tot he client.

494
00:26:05,524 --> 00:26:08,475
Now, when the updateCustomer
method is called

495
00:26:08,475 --> 00:26:13,475
we'll just get the same
reference back, so it's ...

496
00:26:15,236 --> 00:26:16,720
Believe it or not, I think we can get away

497
00:26:16,720 --> 00:26:18,961
with doing nothing in this method,

498
00:26:18,961 --> 00:26:21,694
but if that's confused you,

499
00:26:21,694 --> 00:26:25,146
and Java references can
be a little bit confusing,

500
00:26:25,146 --> 00:26:29,912
I am going to do a "customerMap.put"

501
00:26:29,912 --> 00:26:32,643
with the key in the value,

502
00:26:32,643 --> 00:26:37,643
so this is the
"changedCustomer.getCustomerId"

503
00:26:38,870 --> 00:26:42,834
and the value will be the changedCustomer.

504
00:26:42,834 --> 00:26:45,713
And you can think of that as overriding

505
00:26:45,713 --> 00:26:49,333
the original record
with the changed record,

506
00:26:49,333 --> 00:26:53,459
but really this method isn't
going to be doing anything,

507
00:26:53,459 --> 00:26:55,538
it's just going to be
putting the same reference

508
00:26:55,538 --> 00:26:58,473
back into the Map that was already there.

509
00:26:58,473 --> 00:26:59,938
This method would come into its own

510
00:26:59,938 --> 00:27:03,468
if we were to make these
remote method indications

511
00:27:03,468 --> 00:27:05,589
but that's a topic for another day,

512
00:27:05,589 --> 00:27:09,148
let's not worry too much
about that just now.

513
00:27:09,148 --> 00:27:12,812
For the deleteCustomer method

514
00:27:12,812 --> 00:27:17,812
we just need to do "customerMap.remove",

515
00:27:20,886 --> 00:27:24,397
the customer's ID.

516
00:27:24,397 --> 00:27:29,397
I think, really, I ought to
check if this customer exists

517
00:27:29,618 --> 00:27:31,360
before trying to remove it,

518
00:27:31,360 --> 00:27:33,956
but I've noticed in my
interface I haven't got

519
00:27:33,956 --> 00:27:36,766
a "throws CustomerNotFoundException"

520
00:27:36,766 --> 00:27:39,630
so I won't bother here today

521
00:27:39,630 --> 00:27:42,873
but if you want to add
that that would be fine.

522
00:27:42,873 --> 00:27:47,248
Now, findCustomerById
should be very simple

523
00:27:47,248 --> 00:27:49,697
as long as you know how to use a Map.

524
00:27:49,697 --> 00:27:54,277
I can just return, from the customerMap

525
00:27:54,277 --> 00:27:56,612
I can call the get method,

526
00:27:56,612 --> 00:27:58,567
pass in the key that we're looking for

527
00:27:58,567 --> 00:28:03,104
and that's going to be the
customerId that I've been sent.

528
00:28:03,104 --> 00:28:04,437
I need to do a bit more than that

529
00:28:04,437 --> 00:28:09,074
because I do need to throw
a CustomerNotFoundException

530
00:28:09,074 --> 00:28:11,184
if that customer is not there.

531
00:28:11,184 --> 00:28:15,174
So, I'll hold this customer
in a local variable

532
00:28:15,174 --> 00:28:18,911
called foundCustomer,

533
00:28:18,911 --> 00:28:22,434
and if the foundCustomer --

534
00:28:22,434 --> 00:28:24,004
That should say "Customer".

535
00:28:24,004 --> 00:28:28,271
If the foundCustomer is
null then we will throw

536
00:28:28,271 --> 00:28:31,889
a new CustomerNotFoundException.

537
00:28:36,932 --> 00:28:41,500
It is my style, if I'm doing
something like this to do that

538
00:28:41,500 --> 00:28:43,274
in a single line of code.

539
00:28:43,274 --> 00:28:46,444
Now, I know that some
coding standards would say

540
00:28:46,444 --> 00:28:49,167
you're supposed to have
a curly bracket block,

541
00:28:49,167 --> 00:28:52,951
and that's fine, it's just the style I use

542
00:28:52,951 --> 00:28:55,861
because it's fewer lines of code.

543
00:28:55,861 --> 00:28:58,776
If we get to here, though,
we found the customer

544
00:28:58,776 --> 00:29:01,948
and we can return that foundCustomer.

545
00:29:01,948 --> 00:29:03,786
Great, that's compiling.

546
00:29:03,786 --> 00:29:05,799
Now, findCustomerByName is going to be

547
00:29:05,799 --> 00:29:10,062
a little bit more awkward
because in the Java API

548
00:29:10,062 --> 00:29:13,303
there's no kind of methods for finding

549
00:29:13,303 --> 00:29:17,610
particular values in a
Map apart from by the key,

550
00:29:17,610 --> 00:29:18,596
so I'm going to have to do

551
00:29:18,596 --> 00:29:22,259
a little bit of heavy lifting work here.

552
00:29:22,259 --> 00:29:24,441
The usual way of doing
this would be to create

553
00:29:24,441 --> 00:29:28,282
a temporary list of customers,

554
00:29:28,282 --> 00:29:30,938
and we'll call this the "results",

555
00:29:30,938 --> 00:29:32,553
and we'll just instantiate that

556
00:29:32,553 --> 00:29:36,713
as a new empty list of Customers,

557
00:29:36,713 --> 00:29:40,095
an ArrayList of Customers in this case.

558
00:29:40,095 --> 00:29:45,020
I'll need to do a "Ctrl + Shift
+ O" that import ArrayList.

559
00:29:45,020 --> 00:29:49,012
Now I'm going to loop
around my customerMap,

560
00:29:49,012 --> 00:29:54,012
so standard Java 5 it's right to syntax.

561
00:29:54,199 --> 00:29:56,853
And I'm looking through
here the values in the Map,

562
00:29:56,853 --> 00:30:01,853
so this is going to be
the "customerMap.values".

563
00:30:03,656 --> 00:30:07,688
And it's going to be the case
that if these next customers,

564
00:30:07,688 --> 00:30:09,762
and I need to check the --

565
00:30:09,762 --> 00:30:11,922
It's the company name's
we're working on here

566
00:30:11,922 --> 00:30:14,285
so we'll get the companyName,

567
00:30:14,285 --> 00:30:17,205
and if that "companyName.equals",

568
00:30:17,205 --> 00:30:19,447
be careful to use the "equals" method here

569
00:30:19,447 --> 00:30:22,811
and not the "=" symbol,

570
00:30:22,811 --> 00:30:24,960
if that equals the name
that's being passed in

571
00:30:24,960 --> 00:30:29,960
then we'll add to the results
list that particular customer.

572
00:30:33,148 --> 00:30:35,401
And then at the end of the loop

573
00:30:35,401 --> 00:30:37,159
we can return back the results,

574
00:30:37,159 --> 00:30:41,638
which could be an empty
list which would be fine.

575
00:30:41,638 --> 00:30:44,112
Okay, then for getAllCustomers,

576
00:30:44,112 --> 00:30:46,449
this one should be a lot easier,

577
00:30:46,449 --> 00:30:50,472
I can return the customerMap,

578
00:30:50,472 --> 00:30:52,632
and I can call the values method

579
00:30:52,632 --> 00:30:55,601
which will get me the customer values.

580
00:30:55,601 --> 00:30:57,955
A quirk here though is that

581
00:30:57,955 --> 00:31:00,786
the type of the values
is not really known,

582
00:31:00,786 --> 00:31:02,967
it's a collection,

583
00:31:02,967 --> 00:31:07,967
which is an abstract class
in the collections design,

584
00:31:09,065 --> 00:31:12,645
so what we have to do is create a new,

585
00:31:12,645 --> 00:31:13,893
it can be anything, really,

586
00:31:13,893 --> 00:31:16,991
but I'm going to go for a new ArrayList,

587
00:31:16,991 --> 00:31:19,488
and in all of the constructors
for the collections

588
00:31:19,488 --> 00:31:23,169
you can always pass in
an existing collection,

589
00:31:23,169 --> 00:31:26,978
it will create a new list
based on those values.

590
00:31:26,978 --> 00:31:30,809
Now, this is an odd one, this
getFullCustomerDetail method,

591
00:31:30,809 --> 00:31:33,527
and I don't think I mentioned
this in the introduction.

592
00:31:33,527 --> 00:31:38,527
We already have a
findCustomerById method up here

593
00:31:40,179 --> 00:31:42,178
and yet we seem to have this method

594
00:31:42,178 --> 00:31:45,171
called getFullCustomerDetail.

595
00:31:45,171 --> 00:31:48,233
Well, the clue is in the interface.

596
00:31:48,233 --> 00:31:50,751
If I look in the interface
there is a JAVADOC here:

597
00:31:50,751 --> 00:31:52,643
"For the specified customer,

598
00:31:52,643 --> 00:31:55,472
"return the customer object together

599
00:31:55,472 --> 00:32:00,472
"with all of the calls
associated with that customer".

600
00:32:01,141 --> 00:32:04,371
Now, for this in-memory version,

601
00:32:04,371 --> 00:32:08,363
actually the original
findCustomerById will do just that,

602
00:32:08,363 --> 00:32:11,817
will return the customer
and all of the calls.

603
00:32:11,817 --> 00:32:14,127
The reason for having these two methods is

604
00:32:14,127 --> 00:32:15,819
because in a later chapter

605
00:32:15,819 --> 00:32:18,721
when we start to work on databases

606
00:32:18,721 --> 00:32:20,214
we need to be careful

607
00:32:20,214 --> 00:32:23,827
that we don't always return too much data.

608
00:32:23,827 --> 00:32:25,260
A customer could potentially have

609
00:32:25,260 --> 00:32:28,850
thousands of calls associated with it

610
00:32:28,850 --> 00:32:30,100
and it might be that the client

611
00:32:30,100 --> 00:32:32,526
just wants the customer information.

612
00:32:32,526 --> 00:32:35,087
So the idea is that this first method

613
00:32:35,087 --> 00:32:37,716
will just return the customer

614
00:32:37,716 --> 00:32:41,189
and presumably a null for the calls,

615
00:32:41,189 --> 00:32:42,756
whereas this method down here

616
00:32:42,756 --> 00:32:46,072
will return everything for that customer.

617
00:32:46,072 --> 00:32:48,611
Now, for the in-memory version
it won't make a difference

618
00:32:48,611 --> 00:32:51,556
so I'm just going to return here,

619
00:32:51,556 --> 00:32:56,172
I'll just delegate to the
findCustomerById method,

620
00:32:56,172 --> 00:32:58,962
it will make no difference.

621
00:32:58,962 --> 00:33:00,514
Now, for the recordCall method,

622
00:33:00,514 --> 00:33:05,290
this is perhaps the most
business-like method that we have,

623
00:33:05,290 --> 00:33:07,564
we got to think a little bit harder here.

624
00:33:07,564 --> 00:33:10,251
The signature of the method is that

625
00:33:10,251 --> 00:33:14,688
we'll get a customer ID, not
the entire Customer object,

626
00:33:14,688 --> 00:33:19,299
and a new Call to associate
with that customer.

627
00:33:19,299 --> 00:33:22,423
Now, for the implementation,
I think what we want to do

628
00:33:22,423 --> 00:33:25,739
is first of all find the
customer that we're dealing with

629
00:33:25,739 --> 00:33:28,285
and we want to find the customer

630
00:33:28,285 --> 00:33:31,114
together with all of the calls,

631
00:33:31,114 --> 00:33:32,778
so I think in fact we want to call

632
00:33:32,778 --> 00:33:36,324
this method here first of all.

633
00:33:36,324 --> 00:33:41,324
So if I say my customer is
"this.getFullCustomerDetail"

634
00:33:43,376 --> 00:33:45,979
and pass in the customerId

635
00:33:45,979 --> 00:33:48,031
then we will either get the customer

636
00:33:48,031 --> 00:33:49,834
that we want to deal with

637
00:33:49,834 --> 00:33:54,318
or we'll get an exception
thrown, which is good.

638
00:33:54,318 --> 00:33:57,718
Then once we have the customer we can call

639
00:33:57,718 --> 00:34:00,982
an addCall method on that customer,

640
00:34:00,982 --> 00:34:03,186
which already exists,

641
00:34:03,186 --> 00:34:06,314
it looks like that's
already being implemented,

642
00:34:06,314 --> 00:34:08,030
I didn't realize that was implemented.

643
00:34:08,030 --> 00:34:09,873
If I just press F3 in Eclipse

644
00:34:09,873 --> 00:34:12,617
while I'm hovering over a method

645
00:34:12,617 --> 00:34:13,658
it will take me straight

646
00:34:13,658 --> 00:34:15,832
to the implementation of that method.

647
00:34:15,832 --> 00:34:19,746
And I didn't realize that
we have in the starting code

648
00:34:19,746 --> 00:34:23,380
already provided you
with an addCall method.

649
00:34:23,380 --> 00:34:27,632
So, this mock implementation
is not clever,

650
00:34:27,632 --> 00:34:29,616
it's not efficient,

651
00:34:29,616 --> 00:34:32,303
I guess this findCustomerByName method

652
00:34:32,303 --> 00:34:35,891
could be a little bit
slow but it's kind of

653
00:34:35,891 --> 00:34:39,977
a small simulation of
what our eventual backend

654
00:34:39,977 --> 00:34:41,645
is going to look like.

655
00:34:41,645 --> 00:34:45,158
So that's the first of
the services implemented.

656
00:34:45,158 --> 00:34:49,598
Now let's go to the second one,
this DiaryManagementService,

657
00:34:49,598 --> 00:34:51,976
just two methods in there.

658
00:34:51,976 --> 00:34:56,658
Same process again, I'll keep
it in Diary Services package,

659
00:34:56,658 --> 00:35:01,658
so this will be
DiaryManagementServiceMockImpl,

660
00:35:04,029 --> 00:35:06,440
I'll add the interface,

661
00:35:08,057 --> 00:35:11,907
and we'll get all of the inherited methods

662
00:35:11,907 --> 00:35:14,618
implemented with stubs.

663
00:35:14,618 --> 00:35:16,371
So we're up and running again

664
00:35:16,371 --> 00:35:18,542
a very similar process to before,

665
00:35:18,542 --> 00:35:21,887
I'm going to store all of
the actions in the system

666
00:35:21,887 --> 00:35:23,774
in a private variable.

667
00:35:23,774 --> 00:35:27,040
This time around I don't need a Map

668
00:35:27,040 --> 00:35:30,656
because the actions don't have IDs

669
00:35:30,656 --> 00:35:35,656
so I'm going to go for a List or a Set,

670
00:35:35,789 --> 00:35:38,314
it really doesn't matter.

671
00:35:38,314 --> 00:35:39,914
I don't know how much work you've done

672
00:35:39,914 --> 00:35:42,570
with the Java Collections API,

673
00:35:42,570 --> 00:35:46,226
we do cover them on our
Java Fundamentals course.

674
00:35:46,226 --> 00:35:48,787
I think I can get away with a Set

675
00:35:48,787 --> 00:35:52,864
because actions don't
have any particular order,

676
00:35:54,224 --> 00:35:56,022
we don't have a zero element

677
00:35:56,022 --> 00:35:58,456
and a one and a two and a three,

678
00:35:58,456 --> 00:36:01,615
and there's no kind of ordering
or sorting on the actions,

679
00:36:01,615 --> 00:36:05,489
so a Set will actually
do the job quite well.

680
00:36:05,489 --> 00:36:08,515
On the first edition of
this course I used a List

681
00:36:08,515 --> 00:36:10,707
which was fine, that works as well,

682
00:36:10,707 --> 00:36:13,517
but a List has an index

683
00:36:13,517 --> 00:36:16,109
which I don't think I really need.

684
00:36:16,109 --> 00:36:19,059
So I'll call this "allActions"

685
00:36:19,059 --> 00:36:23,027
and I will instantiate this as a HashSet.

686
00:36:24,150 --> 00:36:26,221
Again, we cover that on Java Fundamentals,

687
00:36:26,221 --> 00:36:27,978
but a HashSet is just sort of

688
00:36:27,978 --> 00:36:31,470
the most efficient implementation

689
00:36:31,470 --> 00:36:36,470
of a Set in the Java API.

690
00:36:37,850 --> 00:36:40,964
So recordAction is going to be trivial,

691
00:36:40,964 --> 00:36:43,018
we'll just take allActions

692
00:36:43,018 --> 00:36:46,820
and we'll add that action to the set.

693
00:36:46,820 --> 00:36:48,523
Something a little bit
more complicated though

694
00:36:48,523 --> 00:36:53,523
is this getAllIncompleteActions
for a particular user.

695
00:36:54,623 --> 00:36:58,918
Now I'm going to need an
algorithm in here, I think.

696
00:36:58,918 --> 00:37:02,316
Of course in a production system
we'll have something like,

697
00:37:02,316 --> 00:37:06,343
it's probably a single line of SQL,

698
00:37:06,343 --> 00:37:08,536
so we'll have to work a little bit harder

699
00:37:08,536 --> 00:37:10,326
than that in the mock.

700
00:37:10,326 --> 00:37:13,629
And rather similar to when
we were finding customers,

701
00:37:13,629 --> 00:37:17,967
I'll need a List to store the results,

702
00:37:17,967 --> 00:37:22,967
so I'll make up a new
ArrayList of Actions.

703
00:37:26,096 --> 00:37:29,529
By the way, notice that this
method here is returning a List

704
00:37:29,529 --> 00:37:32,804
even though I'm storing
the actions as a Set.

705
00:37:32,804 --> 00:37:35,243
That's okay, that's fine.

706
00:37:35,243 --> 00:37:38,114
I'll need to import ArrayList.

707
00:37:38,114 --> 00:37:42,310
So the rough algorithm is going to be,

708
00:37:42,310 --> 00:37:46,475
I'm going to just look
around all of the actions

709
00:37:47,968 --> 00:37:50,319
using a standard iterator,

710
00:37:50,319 --> 00:37:53,254
I'll call each element next,

711
00:37:53,254 --> 00:37:55,990
and, well, the logic is going to be,

712
00:37:55,990 --> 00:37:59,137
if this particular action,

713
00:37:59,137 --> 00:38:03,648
and there's a method in
there for getOwningUser,

714
00:38:03,648 --> 00:38:07,653
so that's saying who owns this action.

715
00:38:07,653 --> 00:38:08,967
All I'm basically saying is

716
00:38:08,967 --> 00:38:13,967
if that user equals the required user

717
00:38:16,833 --> 00:38:20,661
then we've found an action
for the required user.

718
00:38:20,661 --> 00:38:22,435
But that's not quite enough,

719
00:38:22,435 --> 00:38:27,368
we also want to check that
this action is incomplete,

720
00:38:27,368 --> 00:38:31,611
so I'm saying if the action
matches the correct user

721
00:38:31,611 --> 00:38:36,611
and the action is complete --

722
00:38:37,125 --> 00:38:38,766
No, I think that's the wrong way around,

723
00:38:38,766 --> 00:38:42,597
we want the action to be incomplete.

724
00:38:42,597 --> 00:38:47,597
So I'll just use a NOT
operator on the front of that.

725
00:38:48,495 --> 00:38:51,544
So I hope that's not too bad,
it looks a little bit ugly,

726
00:38:51,544 --> 00:38:54,814
but taking the next action in the set

727
00:38:54,814 --> 00:38:59,118
if the owning user is
the one that's required

728
00:38:59,118 --> 00:39:02,311
and the action is not complete

729
00:39:02,311 --> 00:39:05,969
then we found an action
that we want to work with

730
00:39:05,969 --> 00:39:10,969
so we'll add it to the results
list and then keep going.

731
00:39:12,820 --> 00:39:17,820
And once the loop is finished
we can return the results.

732
00:39:17,972 --> 00:39:20,635
Now, I'm not sure if that's
a brilliant implementation,

733
00:39:20,635 --> 00:39:23,934
to be honest, and it was a
frequently asked question

734
00:39:23,934 --> 00:39:25,751
on the first edition of this course,

735
00:39:25,751 --> 00:39:27,811
when we did something very similar.

736
00:39:27,811 --> 00:39:30,846
People asked, "Well,
shouldn't we have a unit test

737
00:39:30,846 --> 00:39:33,197
"for this mock implementation?"

738
00:39:33,197 --> 00:39:34,864
And the answer is yeah, I guess, really,

739
00:39:34,864 --> 00:39:38,365
we should write a unit test
for these mock implementations,

740
00:39:38,365 --> 00:39:41,243
they're quite easy to unit test.

741
00:39:41,243 --> 00:39:42,585
Some people argue that because

742
00:39:42,585 --> 00:39:44,471
these are kind of throwaway objects

743
00:39:44,471 --> 00:39:47,530
it doesn't really matter if
they work properly or not

744
00:39:47,530 --> 00:39:50,286
and you don't need to unit test,

745
00:39:50,286 --> 00:39:53,360
and my feeling on that
is it depends, really.

746
00:39:53,360 --> 00:39:55,713
If these are just quick and dirty objects

747
00:39:55,713 --> 00:39:58,783
that you're never going
to use in any serious way

748
00:39:58,783 --> 00:40:02,207
then I guess it doesn't matter
if they break occasionally.

749
00:40:02,207 --> 00:40:07,168
If i was planning a
demonstration to my client

750
00:40:07,168 --> 00:40:09,485
and I wanted to be sure that these work

751
00:40:09,485 --> 00:40:10,809
in the way that they should work

752
00:40:10,809 --> 00:40:14,127
then, yeah, I probably
would write a unit test.

753
00:40:14,127 --> 00:40:16,519
Feel free to write a
unit test for yourself,

754
00:40:16,519 --> 00:40:18,169
because this is a Spring course

755
00:40:18,169 --> 00:40:21,209
I don't want to get too hung up here

756
00:40:21,209 --> 00:40:24,036
so I'll leave that as an exercise for you.

757
00:40:24,036 --> 00:40:28,070
So that completes the mock for
our DairyManagementService.

758
00:40:28,070 --> 00:40:30,979
The second part of the practical session

759
00:40:30,979 --> 00:40:33,220
was to configure the XML,

760
00:40:33,220 --> 00:40:35,839
and this is definitely
the most important part

761
00:40:35,839 --> 00:40:38,010
of the practical session.

762
00:40:38,010 --> 00:40:40,875
So let's have a look at application.xml.

763
00:40:40,875 --> 00:40:44,156
I've given you just a
skeleton of that file,

764
00:40:44,156 --> 00:40:45,891
we can remove the comment,

765
00:40:45,891 --> 00:40:48,181
and the job is that we need to tell Spring

766
00:40:48,181 --> 00:40:51,042
that we want it to configure an instance

767
00:40:51,042 --> 00:40:53,380
of the DiaryManagementService

768
00:40:53,380 --> 00:40:56,393
and the CustomerManagementService.

769
00:40:56,393 --> 00:40:58,391
So you know how to do this now,

770
00:40:58,391 --> 00:41:00,178
we're going to need a bean tag

771
00:41:00,178 --> 00:41:03,266
and each of these two
beans will need an ID.

772
00:41:03,266 --> 00:41:07,365
I'm going to call the first
one the "customerService",

773
00:41:07,365 --> 00:41:09,231
you can call it anything you like,

774
00:41:09,231 --> 00:41:10,449
and the class is going to be

775
00:41:10,449 --> 00:41:14,225
the fully qualified packaging class name,

776
00:41:14,225 --> 00:41:17,703
so "com.visualpairprogrammers",

777
00:41:17,703 --> 00:41:19,127
I need to remind myself,

778
00:41:19,127 --> 00:41:23,760
".services.customers"

779
00:41:23,760 --> 00:41:28,760
and then we have
"CustomerManagementMockImpl".

780
00:41:31,290 --> 00:41:34,661
As I mentioned in the
theory sessions often,

781
00:41:34,661 --> 00:41:38,973
you don't need any
properties inside a mock

782
00:41:38,973 --> 00:41:42,375
because we can get away
with a lot of hard coding.

783
00:41:42,375 --> 00:41:43,698
You do the same for the,

784
00:41:43,698 --> 00:41:45,188
I'll just call it "diaryService"

785
00:41:45,188 --> 00:41:48,846
rather than "diaryManagement".

786
00:41:48,846 --> 00:41:53,846
So, "virtualpairprogrammers.services"

787
00:41:57,736 --> 00:41:59,716
and then just check package name,

788
00:41:59,716 --> 00:42:04,716
"diary.DiaryManagementServiceMockImpl".

789
00:42:11,533 --> 00:42:15,438
So I'll just maximize that
file so you can see it all.

790
00:42:15,438 --> 00:42:17,799
If you've had any problems
doing it for yourself

791
00:42:17,799 --> 00:42:19,317
you can pause the video here

792
00:42:19,317 --> 00:42:22,816
but I think for now that's
all the XML we need.

793
00:42:22,816 --> 00:42:26,636
If you're thinking this
course is a bit simple, basic,

794
00:42:26,636 --> 00:42:28,074
don't worry, it won't be very long

795
00:42:28,074 --> 00:42:31,390
before this file is actually pretty big.

796
00:42:31,390 --> 00:42:33,824
So the next step then is part three,

797
00:42:33,824 --> 00:42:36,739
which is to write a test on this.

798
00:42:36,739 --> 00:42:38,481
It shouldn't be too complicated,

799
00:42:38,481 --> 00:42:41,510
this is going to be a new Class.

800
00:42:41,510 --> 00:42:44,814
Now, we don't have a package
for this, I don't think,

801
00:42:44,814 --> 00:42:47,597
so I'll need to create a new one.

802
00:42:47,597 --> 00:42:49,383
So, "com.visualpairprogrammers",

803
00:42:49,383 --> 00:42:52,591
I'll just call this the "client" package.

804
00:42:52,591 --> 00:42:54,067
For the name I'm going to be consistent

805
00:42:54,067 --> 00:42:55,926
with the first edition of the course,

806
00:42:55,926 --> 00:43:00,926
I'm going to call this "SimpleClientTest"

807
00:43:01,530 --> 00:43:04,888
just to remind us that is
just a basic test, this one.

808
00:43:04,888 --> 00:43:05,951
And I'm going to click the

809
00:43:05,951 --> 00:43:09,121
"Generate public static void main method"

810
00:43:09,121 --> 00:43:13,933
because it's getting
late and I'm a bit lazy.

811
00:43:13,933 --> 00:43:16,844
And I can delete the comment.

812
00:43:16,844 --> 00:43:19,487
So pretty much the same routine

813
00:43:19,487 --> 00:43:20,970
as in theory sessions,

814
00:43:20,970 --> 00:43:24,726
the first job will be to
open the Spring container,

815
00:43:24,726 --> 00:43:27,024
which they call the ClassPath,

816
00:43:27,024 --> 00:43:32,008
let's not type any further,
"Ctrl" or "Opt + Space"

817
00:43:32,008 --> 00:43:33,591
will give me the option now

818
00:43:33,591 --> 00:43:37,583
of ClassPathXmlApplicationContext.

819
00:43:37,583 --> 00:43:39,776
I'm going to call this "container"

820
00:43:39,776 --> 00:43:43,017
and it's going to be a new ClassPath,

821
00:43:43,017 --> 00:43:45,657
once again use the shortcut

822
00:43:45,657 --> 00:43:50,278
and file is "application.xml".

823
00:43:50,278 --> 00:43:54,132
An, so that I don't forget
something I didn't do

824
00:43:54,132 --> 00:43:56,340
in the first edition of this course is

825
00:43:56,340 --> 00:43:59,807
at the end of the program I'm
going to close the container.

826
00:43:59,807 --> 00:44:03,790
Not crucial, not necessary
in an application like this

827
00:44:03,790 --> 00:44:05,186
where the objects are just going to be

828
00:44:05,186 --> 00:44:07,378
garbage-collected anyway,

829
00:44:07,378 --> 00:44:08,851
but it won't be long before we add

830
00:44:08,851 --> 00:44:11,413
database connections into the system,

831
00:44:11,413 --> 00:44:13,613
and then it will be more important

832
00:44:13,613 --> 00:44:15,674
to close that container down.

833
00:44:15,674 --> 00:44:18,399
Now, for the video I'm
just going to test out

834
00:44:18,399 --> 00:44:21,127
my CustomerManagementService.

835
00:44:21,127 --> 00:44:26,127
So I need to get hold of the
CustomerManagementService,

836
00:44:26,838 --> 00:44:30,223
and I'm sorry if you're
getting bored at this point,

837
00:44:30,223 --> 00:44:31,357
that I keep repeating this,

838
00:44:31,357 --> 00:44:34,437
but I think it's the most
important points of the course

839
00:44:34,437 --> 00:44:37,659
is this is the interface,
and I'm not going to refer

840
00:44:37,659 --> 00:44:41,055
to the concrete class
name, that "MockImpl",

841
00:44:41,055 --> 00:44:43,531
anywhere in the code.

842
00:44:43,531 --> 00:44:47,265
So I'll call this "customerService".

843
00:44:48,119 --> 00:44:51,511
And to get hold of the
CustomerManagementService

844
00:44:51,511 --> 00:44:54,849
we've got several options.

845
00:44:54,849 --> 00:44:59,717
One of the options I showed
you in the theory session was

846
00:44:59,717 --> 00:45:04,717
I can refer to the ID and
then specify the type in here,

847
00:45:08,268 --> 00:45:12,028
"CustomerManagementService.class".

848
00:45:12,028 --> 00:45:14,458
That's one way of doing it.

849
00:45:14,458 --> 00:45:15,876
Oh, I'm sorry, I forgot
to call the method,

850
00:45:15,876 --> 00:45:19,956
it's "container.getBean" of course.

851
00:45:19,956 --> 00:45:22,315
Okay, I'll just maximize that.

852
00:45:22,315 --> 00:45:25,306
That's one way of doing it that
I showed you in the theory.

853
00:45:25,306 --> 00:45:27,942
On the first edition of this course

854
00:45:27,942 --> 00:45:32,127
I think the version of
Spring I used five years ago

855
00:45:32,127 --> 00:45:34,877
didn't have this version of the method,

856
00:45:34,877 --> 00:45:39,633
and your only option in those
days was to call "getBean"

857
00:45:39,633 --> 00:45:42,474
with the ID of the bean here,

858
00:45:42,474 --> 00:45:44,236
and you can see there's
a compile error there

859
00:45:44,236 --> 00:45:47,800
and that's because you will
need a type cast if you do that,

860
00:45:47,800 --> 00:45:52,800
so it will be CustomerService right here.

861
00:45:55,162 --> 00:45:58,737
Sorry, CustomerManagementService.

862
00:46:01,460 --> 00:46:03,739
You've got to be careful
to get that type correct

863
00:46:03,739 --> 00:46:06,752
so you won't get a ClassCastException.

864
00:46:06,752 --> 00:46:08,375
So you might see that approach

865
00:46:08,375 --> 00:46:11,313
used in slightly all the code,

866
00:46:11,313 --> 00:46:16,313
I think today the
preferred approach would be

867
00:46:17,329 --> 00:46:20,050
the version I showed you
in the theory session.

868
00:46:20,050 --> 00:46:23,030
But there is a third way,
I'm gonna mention this,

869
00:46:23,030 --> 00:46:27,073
you can drop the ID if
there is only one object

870
00:46:27,073 --> 00:46:29,995
of that type in the Spring container.

871
00:46:29,995 --> 00:46:31,689
Now, we'll talk about this later on

872
00:46:31,689 --> 00:46:34,069
but you might be thinking,
"Well, it's very likely

873
00:46:34,069 --> 00:46:35,968
"to be more than one implementation

874
00:46:35,968 --> 00:46:37,704
"because we've got a mock here"

875
00:46:37,704 --> 00:46:39,754
but gonna show why.

876
00:46:39,754 --> 00:46:41,847
We'll have a production
standard implementation

877
00:46:41,847 --> 00:46:45,607
of the same interface but
you're going to find that

878
00:46:45,607 --> 00:46:48,767
within a single XML configuration,

879
00:46:48,767 --> 00:46:51,825
in other words, within a single context

880
00:46:51,825 --> 00:46:54,299
you'd only define one implementation.

881
00:46:54,299 --> 00:46:55,441
In other words, what I'm saying is,

882
00:46:55,441 --> 00:47:00,441
we'll have an XML file for our
testing version of the system

883
00:47:00,496 --> 00:47:03,343
that will have the mock implementation

884
00:47:03,343 --> 00:47:05,718
and we'll have an alternative XML file

885
00:47:05,718 --> 00:47:08,863
for the production standard version,

886
00:47:08,863 --> 00:47:09,722
and that will have

887
00:47:09,722 --> 00:47:12,011
one production implementation
of the service.

888
00:47:12,011 --> 00:47:15,715
So, that's why often this is the best way

889
00:47:15,715 --> 00:47:18,418
of calling the "getBean" method.

890
00:47:18,418 --> 00:47:20,874
Anyway, we need to something
with the customerService

891
00:47:20,874 --> 00:47:25,874
so let's call the,

892
00:47:26,052 --> 00:47:29,839
let's call "getAllCustomers"

893
00:47:30,730 --> 00:47:33,854
and store that results in a List.

894
00:47:36,389 --> 00:47:40,504
I'll need to do the required
imports, java.util.List,

895
00:47:40,504 --> 00:47:44,381
and expect the Customer
import automatically.

896
00:47:44,381 --> 00:47:49,381
And then I can loop
around all the customers

897
00:47:52,088 --> 00:47:54,225
with a simple ...

898
00:47:55,239 --> 00:47:58,973
I'm just going to print
out each customer in turn.

899
00:47:58,973 --> 00:48:01,406
So hopefully nothing too difficult,

900
00:48:01,406 --> 00:48:03,586
it's still baby steps with the application

901
00:48:03,586 --> 00:48:05,748
but at least we've got the foundations

902
00:48:05,748 --> 00:48:08,741
of something that looks
like a real system.

903
00:48:08,741 --> 00:48:10,728
I'll get this a test with a right-click

904
00:48:10,728 --> 00:48:15,728
and Run As and Java Application.

905
00:48:15,730 --> 00:48:17,359
And of course I have an exception.

906
00:48:17,359 --> 00:48:22,359
I think I almost never get a
successful run the first time

907
00:48:22,466 --> 00:48:24,745
when I write a Spring program.

908
00:48:24,745 --> 00:48:27,440
So it's a ClassNotFoundException.

909
00:48:27,440 --> 00:48:28,816
Spring is telling me that it's trying

910
00:48:28,816 --> 00:48:32,054
to instantiate this class here.

911
00:48:32,054 --> 00:48:36,783
Now, I know I wrote it
so clearly I have a typo,

912
00:48:36,783 --> 00:48:39,095
it looks like I've got fat fingers.

913
00:48:39,095 --> 00:48:41,826
I typed "virtualpairprogrammers"
incorrectly.

914
00:48:41,826 --> 00:48:45,816
I can't even spell the
name of my own company,

915
00:48:45,816 --> 00:48:47,785
that I work for.

916
00:48:47,785 --> 00:48:50,783
So it's in the XML file and ...

917
00:48:50,783 --> 00:48:52,162
Yeah, it's just there,

918
00:48:52,162 --> 00:48:56,655
that should have said "programmers"
instead of "pogrammers".

919
00:48:57,950 --> 00:48:59,149
In the next chapter, by the way,

920
00:48:59,149 --> 00:49:01,144
I'll be showing you a plugin for Eclipse

921
00:49:01,144 --> 00:49:06,144
that would have pick that
typo before we ran the system.

922
00:49:06,588 --> 00:49:08,556
Let's try again.

923
00:49:10,523 --> 00:49:15,523
And I have another
ClassNotFoundException on the same class.

924
00:49:17,851 --> 00:49:19,000
Well, I don't know if you can tell

925
00:49:19,000 --> 00:49:21,500
from the Eclipse timestamps here

926
00:49:21,500 --> 00:49:25,225
but it is five o' clock
on a Friday afternoon,

927
00:49:25,225 --> 00:49:29,138
and I think I'm starting
to make silly mistakes now.

928
00:49:29,138 --> 00:49:32,155
Just off camera I paused
the recording there

929
00:49:32,155 --> 00:49:34,360
and I looked to this for a long while and

930
00:49:34,360 --> 00:49:36,802
in fact I have typed that correctly,

931
00:49:36,802 --> 00:49:38,937
it turns out that, I don't
know if you noticed this,

932
00:49:38,937 --> 00:49:40,014
but when I was writing

933
00:49:40,014 --> 00:49:44,559
the DiaryManagementServiceMockImpl class

934
00:49:44,559 --> 00:49:48,857
I missed an "a" in DiaryManagement.

935
00:49:48,857 --> 00:49:51,025
My brilliant typing again.

936
00:49:51,025 --> 00:49:53,495
And to fix that I'll need to,

937
00:49:53,495 --> 00:49:55,582
you can't just go in there and add an "a"

938
00:49:55,582 --> 00:49:59,756
because the file needs
to be renamed as well,

939
00:49:59,756 --> 00:50:02,479
so I right-click on the name there,

940
00:50:02,479 --> 00:50:05,653
Refactor and Rename,

941
00:50:05,653 --> 00:50:10,261
and I can make the
change directly in there

942
00:50:10,261 --> 00:50:12,484
and then press Enter.

943
00:50:12,484 --> 00:50:16,583
Now, the warning here,

944
00:50:16,583 --> 00:50:18,612
you know I think it's just because

945
00:50:18,612 --> 00:50:20,449
I did save the wrong point there,

946
00:50:20,449 --> 00:50:22,808
I think I can continue there,

947
00:50:22,808 --> 00:50:24,722
and certainly there's
no compile errors now.

948
00:50:24,722 --> 00:50:27,493
So this is going to be the last time

949
00:50:27,493 --> 00:50:28,877
I try to run this program,

950
00:50:28,877 --> 00:50:32,891
if this doesn't work I'm
going home for the weekend.

951
00:50:32,891 --> 00:50:33,878
Well, that looks good,

952
00:50:33,878 --> 00:50:35,836
so we've got the three companies.

953
00:50:35,836 --> 00:50:37,176
Now, I could go a little further

954
00:50:37,176 --> 00:50:39,183
and test a few of the other methods now

955
00:50:39,183 --> 00:50:43,013
but I realized that really
that's not testing the Spring.

956
00:50:43,013 --> 00:50:45,465
We know that the object
is correctly configured

957
00:50:45,465 --> 00:50:48,165
in the Spring container and I think

958
00:50:48,165 --> 00:50:50,513
that's enough for me here right now.

959
00:50:50,513 --> 00:50:53,032
So, I hope if you had any problems

960
00:50:53,032 --> 00:50:55,021
in doing the practical for yourself

961
00:50:55,021 --> 00:50:57,559
this video has helped you through it,

962
00:50:57,559 --> 00:51:00,144
if not of course we're
always here for support,

963
00:51:00,144 --> 00:51:02,998
do contact us through the content page

964
00:51:02,998 --> 00:51:05,111
on the VirtualPairProgrammers website

965
00:51:05,111 --> 00:51:08,066
and we'll aim to get you going okay.

966
00:51:08,066 --> 00:51:10,169
In the next chapter we're
going to be expanding

967
00:51:10,169 --> 00:51:13,303
our knowledge of the
Spring XML a little bit,

968
00:51:13,303 --> 00:51:16,079
and then in the next practical session

969
00:51:16,079 --> 00:51:17,727
we'll be making this system

970
00:51:17,727 --> 00:51:20,136
a little bit more professional and robust

971
00:51:20,136 --> 00:51:23,322
by introducing another service class.

972
00:51:23,322 --> 00:51:25,137
And the next chapter
we're also going to be

973
00:51:25,137 --> 00:51:27,016
introducing the Spring plugin

974
00:51:27,016 --> 00:51:29,095
which I think you're
going to like very much,

975
00:51:29,095 --> 00:51:31,739
it can certainly make
your life a lot easier.

976
00:51:31,739 --> 00:51:33,508
So, well done so far,

977
00:51:33,508 --> 00:51:36,537
I'll see you in the next chapter.

1
00:00:00,240 --> 00:00:05,240
(light music)

2
00:00:10,502 --> 00:00:11,305
- [Voiceover] Welcome back.

3
00:00:11,305 --> 00:00:15,517
This is Chapter 6 of Spring
Framework Fundamentals.

4
00:00:15,517 --> 00:00:17,778
We're going to look at a few more concepts

5
00:00:17,778 --> 00:00:20,961
relating to the Spring container.

6
00:00:20,961 --> 00:00:23,975
So far we've only used
simple string values

7
00:00:23,975 --> 00:00:25,972
for our properties.

8
00:00:25,972 --> 00:00:28,517
But most of the time we want to inject

9
00:00:28,517 --> 00:00:31,729
full objects as dependencies.

10
00:00:31,729 --> 00:00:34,303
This will need a new XML concept,

11
00:00:34,303 --> 00:00:37,988
so we'll start by looking
at how to do that.

12
00:00:37,988 --> 00:00:41,253
Then we'll look in a little
detail at what is happening

13
00:00:41,253 --> 00:00:44,276
when Spring creates those beans.

14
00:00:44,276 --> 00:00:47,007
We'll look at the difference
between singletons

15
00:00:47,007 --> 00:00:49,236
and prototypes.

16
00:00:49,236 --> 00:00:52,831
Finally, I'll talk about
constructor injection

17
00:00:52,831 --> 00:00:56,575
and how it's different
from setter injection.

18
00:00:56,575 --> 00:00:58,974
I'm going to be using
constructor injection

19
00:00:58,974 --> 00:01:01,767
throughout the course so it is important

20
00:01:01,767 --> 00:01:05,066
that you see this chapter
through to the end.

21
00:01:05,066 --> 00:01:07,828
So far in the Spring XML,

22
00:01:07,828 --> 00:01:12,585
we've only configured
simple values - strings.

23
00:01:12,585 --> 00:01:16,244
I'm going to show you now
how to pass an entire object

24
00:01:16,244 --> 00:01:17,978
as a property.

25
00:01:17,978 --> 00:01:21,385
As an example I'm going to
extend the book application

26
00:01:21,385 --> 00:01:23,189
that we wrote earlier.

27
00:01:23,189 --> 00:01:26,335
You'll be familiar now
with the Book Service

28
00:01:26,335 --> 00:01:29,247
and we have some kind
of an implementation.

29
00:01:29,247 --> 00:01:31,092
That could be a mock

30
00:01:31,092 --> 00:01:35,514
or later in the course it will
a database implementation.

31
00:01:36,504 --> 00:01:41,504
What we're going to do now
is adding a second service.

32
00:01:41,770 --> 00:01:42,948
Now this is going to manage

33
00:01:42,948 --> 00:01:45,781
all of the accounts for the system,

34
00:01:45,781 --> 00:01:49,952
and by accounts I mean
the financial accounts.

35
00:01:50,836 --> 00:01:53,476
As a starter, we've
added in there a method

36
00:01:53,476 --> 00:01:56,746
called raise invoice.

37
00:01:56,746 --> 00:01:59,914
We passed some kind of
parameters into that method

38
00:01:59,914 --> 00:02:04,223
and an invoice would be
raised for that customer.

39
00:02:04,223 --> 00:02:07,210
What I would like to do
now is to write a use case

40
00:02:07,210 --> 00:02:09,620
called buyBook.

41
00:02:09,620 --> 00:02:12,383
And what this method will
do is it will, first of all,

42
00:02:12,383 --> 00:02:17,366
call the Book Service to find
the book the customer wants,

43
00:02:17,366 --> 00:02:20,819
and then, secondly, it will
go to the Accounts Service

44
00:02:20,819 --> 00:02:24,605
to raise an invoice for that customer.

45
00:02:24,605 --> 00:02:28,095
Now I could implement
this by simply calling

46
00:02:28,095 --> 00:02:32,766
the two services directly
from our clients.

47
00:02:33,620 --> 00:02:35,942
However, I don't really like that

48
00:02:35,942 --> 00:02:38,232
from an object-oriented point of view

49
00:02:38,232 --> 00:02:41,335
because the client should
really be able to call

50
00:02:41,335 --> 00:02:45,617
a simple integrated method called buyBook.

51
00:02:46,687 --> 00:02:51,384
I've decided, therefore, to
create a third service class.

52
00:02:51,384 --> 00:02:55,455
We are going to call this
the Purchasing Service.

53
00:02:55,455 --> 00:02:58,249
The idea behind this is
we have a method in there

54
00:02:58,249 --> 00:03:00,361
called buyBook.

55
00:03:00,361 --> 00:03:03,647
Service makes life very
easy for the clients,

56
00:03:03,647 --> 00:03:06,943
they just call a single method.

57
00:03:06,943 --> 00:03:11,593
The Purchasing Service then
delegates the work by calling:

58
00:03:11,593 --> 00:03:15,963
step one, Book Service to
find the appropriate book,

59
00:03:15,963 --> 00:03:18,955
and then step two, the Accounts Service

60
00:03:18,955 --> 00:03:21,429
to invoice the customer.

61
00:03:21,429 --> 00:03:24,261
Now I should stress that
we don't go creating

62
00:03:24,261 --> 00:03:28,170
entire service classes
every time we have a method

63
00:03:28,170 --> 00:03:30,655
that we want to add to our system,

64
00:03:30,655 --> 00:03:32,820
but in this case I think we've identified

65
00:03:32,820 --> 00:03:37,578
some functionality, general
purchasing functionality,

66
00:03:37,578 --> 00:03:40,874
that didn't have a good
place in which to live.

67
00:03:40,874 --> 00:03:43,377
And if you think about it,
before long we'll be introducing

68
00:03:43,377 --> 00:03:47,903
other purchasing function,
such as cancelling the orders,

69
00:03:47,903 --> 00:03:51,412
and maybe getting a list of
orders and that kind of thing,

70
00:03:51,412 --> 00:03:53,385
and those methods would live well

71
00:03:53,385 --> 00:03:56,499
in this new purchasing service.

72
00:03:56,499 --> 00:03:58,527
This is my first attempt

73
00:03:58,527 --> 00:04:01,652
at implementing the purchasing service.

74
00:04:01,652 --> 00:04:04,211
You'll notice, first of
all, that I'm following

75
00:04:04,211 --> 00:04:08,362
the usual pattern of
programming to an interface.

76
00:04:08,362 --> 00:04:13,350
So I've written a purchasing
service interface.

77
00:04:13,350 --> 00:04:15,962
I won't bore you with the details of that.

78
00:04:15,962 --> 00:04:19,477
There would be a single
method in there called buyBook

79
00:04:19,477 --> 00:04:22,771
and this is just the implementation.

80
00:04:22,771 --> 00:04:26,303
Now this is just my first attempt.

81
00:04:26,303 --> 00:04:30,456
I'd like you to have a look
at this code, review the code

82
00:04:30,456 --> 00:04:35,263
and think about the big
mistake that I've made in here.

83
00:04:35,263 --> 00:04:37,983
It's not a compile error
or anything like that,

84
00:04:37,983 --> 00:04:40,304
it's more of a design error.

85
00:04:40,304 --> 00:04:42,510
And if you want, you can
just pause the video here

86
00:04:42,510 --> 00:04:46,510
for a few moments and have
a good think about it.

87
00:04:48,750 --> 00:04:51,953
The mistake I made goes back
to the coupling discussion

88
00:04:51,953 --> 00:04:55,438
that we had earlier on in the course.

89
00:04:55,438 --> 00:04:59,494
What I've done with these
two lines of code here

90
00:04:59,494 --> 00:05:04,494
is I've hard coded the creation
of the implementation class.

91
00:05:05,258 --> 00:05:07,962
This means if I need to
change the implementation

92
00:05:07,962 --> 00:05:11,604
of the Accounts Service or Book Service,

93
00:05:11,604 --> 00:05:13,823
I would have to go into this code,

94
00:05:13,823 --> 00:05:17,076
which, bear in mind, probably
works perfectly well,

95
00:05:17,076 --> 00:05:19,892
I would have to change
it, I'd have to recompile

96
00:05:19,892 --> 00:05:21,980
and potentially break it.

97
00:05:21,980 --> 00:05:25,253
Of course, I'd also have to retest it.

98
00:05:25,253 --> 00:05:28,153
And don't forget that I'm almost certain

99
00:05:28,153 --> 00:05:31,119
to want to change these
implementing classes

100
00:05:31,119 --> 00:05:34,442
when I'm testing, as I'm
going to do in a moment.

101
00:05:34,442 --> 00:05:36,909
I would like to use a mock implementation

102
00:05:36,909 --> 00:05:40,641
of the Accounts Service
and the Book Service.

103
00:05:40,641 --> 00:05:43,060
But when I go through to production,

104
00:05:43,060 --> 00:05:45,439
I want to use the proper implementation

105
00:05:45,439 --> 00:05:48,958
which for us will be using a database.

106
00:05:48,958 --> 00:05:52,246
I need the flexibility
to be able to change

107
00:05:52,246 --> 00:05:55,975
this implementation
class, but at the moment

108
00:05:55,975 --> 00:05:58,222
I'm hard coding them in.

109
00:05:58,222 --> 00:06:02,644
So I need to be able to inject
the actual implementations

110
00:06:02,644 --> 00:06:05,652
at these interfaces, and
we've seen how to do that

111
00:06:05,652 --> 00:06:09,253
in previous chapters on
dependency injection.

112
00:06:09,253 --> 00:06:12,564
We want the Accounts
Service and the Book Service

113
00:06:12,564 --> 00:06:15,785
to be parameterized.

114
00:06:15,785 --> 00:06:19,656
So this is how I could do it instead.

115
00:06:19,656 --> 00:06:21,844
This is a much better implementation

116
00:06:21,844 --> 00:06:24,180
of the Purchasing Service.

117
00:06:24,180 --> 00:06:27,434
Step one: I've made both
the Accounts Service

118
00:06:27,434 --> 00:06:29,545
and the Book Service now become

119
00:06:29,545 --> 00:06:32,969
private attributes of the class.

120
00:06:32,969 --> 00:06:34,989
This means that I can also provide

121
00:06:34,989 --> 00:06:38,463
a setAccountsService method

122
00:06:38,463 --> 00:06:42,207
and a setBookService method.

123
00:06:42,207 --> 00:06:47,178
And I'm going to let
Spring call those methods

124
00:06:47,178 --> 00:06:50,004
and Spring will pass in the actual objects

125
00:06:50,004 --> 00:06:52,532
which could be from any class

126
00:06:52,532 --> 00:06:55,516
that implements those services.

127
00:06:56,746 --> 00:06:59,573
So notice that throughout this code

128
00:06:59,573 --> 00:07:04,573
now I am not mentioning the
concrete class that I'm using,

129
00:07:04,962 --> 00:07:08,725
I'm only referencing the interfaces.

130
00:07:08,725 --> 00:07:11,903
Now, of course, what I also
need to do is to write the XML

131
00:07:11,903 --> 00:07:14,654
to configure those run time classes

132
00:07:14,654 --> 00:07:17,855
that I want to pass into
this Purchasing Service.

133
00:07:17,855 --> 00:07:20,095
So let's switch across to Eclipse

134
00:07:20,095 --> 00:07:22,228
and have a look at this in practice.

135
00:07:22,228 --> 00:07:26,207
Now, because this bookstore
is not our series application

136
00:07:26,207 --> 00:07:27,657
that we're writing on this course,

137
00:07:27,657 --> 00:07:32,202
you can open up the bookstore
yourself if you want.

138
00:07:32,202 --> 00:07:35,092
But if you're happy
just to watch this video

139
00:07:35,092 --> 00:07:37,769
then that will be absolutely fine as well.

140
00:07:37,769 --> 00:07:39,316
Of course, everything I do here

141
00:07:39,316 --> 00:07:41,226
you'll be putting into practice

142
00:07:41,226 --> 00:07:45,108
when we go back to the CRM system.

143
00:07:45,108 --> 00:07:48,927
So here is my implementation
of the Purchasing Service,

144
00:07:48,927 --> 00:07:52,451
pretty much exactly as you saw.

145
00:07:52,451 --> 00:07:56,095
By the way, I've closed the CRM system

146
00:07:56,095 --> 00:07:58,742
that we were working on
in the previous chapter

147
00:07:58,742 --> 00:08:02,644
and I've reopened my bookstore example.

148
00:08:02,644 --> 00:08:04,952
So a quick review then.

149
00:08:04,952 --> 00:08:08,742
We have two attributes here

150
00:08:08,742 --> 00:08:11,503
holding the service objects;

151
00:08:11,503 --> 00:08:14,548
we have a pair of set methods;

152
00:08:14,548 --> 00:08:17,471
and there's the buyBook method.

153
00:08:17,471 --> 00:08:20,074
And that's going to, first
of all, use the Book Service

154
00:08:20,074 --> 00:08:22,591
to find the particular book

155
00:08:22,591 --> 00:08:26,741
and then we call the Accounts Service.

156
00:08:26,741 --> 00:08:30,015
Just a little bit of a by-the-way notice.

157
00:08:30,015 --> 00:08:33,930
My class name here for my implementation.

158
00:08:33,930 --> 00:08:36,765
I just make this area a little bigger.

159
00:08:36,765 --> 00:08:40,414
So far my implementations,

160
00:08:40,414 --> 00:08:43,007
I had the Book Service implementation

161
00:08:43,007 --> 00:08:45,287
and the Accounts Service implementation,

162
00:08:45,287 --> 00:08:49,877
well, they were both mock implementations.

163
00:08:49,877 --> 00:08:52,597
Now that I'm writing
this Purchasing Service

164
00:08:52,597 --> 00:08:56,479
I've decided that this is
not a mock implementation,

165
00:08:56,479 --> 00:09:01,395
it is actually a production
standard implementation.

166
00:09:01,395 --> 00:09:04,788
Now I know that we're not
using the database yet

167
00:09:04,788 --> 00:09:08,607
but this Purchasing Service
doesn't need to use a database

168
00:09:08,607 --> 00:09:11,301
anyway because it's delegating the work

169
00:09:11,301 --> 00:09:14,932
to the Book Service and
the Accounts Service.

170
00:09:14,932 --> 00:09:17,388
So it's quite strange, this really,

171
00:09:17,388 --> 00:09:21,137
that this particular interface
doesn't really need a mock

172
00:09:21,137 --> 00:09:24,016
and a production standard implementation,

173
00:09:24,016 --> 00:09:26,996
it serves as both.

174
00:09:26,996 --> 00:09:30,499
I've also written a client application

175
00:09:30,499 --> 00:09:33,168
to test this code.

176
00:09:33,168 --> 00:09:36,834
Very similar to the client
that we had earlier on

177
00:09:36,834 --> 00:09:38,740
in the course.

178
00:09:38,740 --> 00:09:43,071
So in the main method I'm
printing a string to the user

179
00:09:43,071 --> 00:09:45,706
just to say we're testing buying a book.

180
00:09:45,706 --> 00:09:50,288
This is the book that I want to buy.

181
00:09:50,288 --> 00:09:53,290
It's the book with the key ISBN1.

182
00:09:53,290 --> 00:09:56,465
And, by the way, the ISBN number, ISBN1,

183
00:09:56,465 --> 00:10:00,383
was one of those three
hard coded ISBN numbers

184
00:10:00,383 --> 00:10:03,465
that we have in our mock.

185
00:10:03,465 --> 00:10:07,668
So then I'm going to go
to the Spring container,

186
00:10:07,668 --> 00:10:10,474
which I'm opening up on this line,

187
00:10:10,474 --> 00:10:14,634
then I'm going to access
the Purchasing Service bean,

188
00:10:14,634 --> 00:10:17,553
and then I'm going to
call the buyBook method,

189
00:10:17,553 --> 00:10:21,268
and then finally, I'm going
to close the container.

190
00:10:22,591 --> 00:10:27,338
All that remains then is to set
up the XML to do the wiring.

191
00:10:27,338 --> 00:10:30,047
I've already made a start on this.

192
00:10:30,047 --> 00:10:34,090
What I've done so far is I've
created the Accounts Service,

193
00:10:34,090 --> 00:10:38,506
or at least I'm asking
Spring to instantiate

194
00:10:38,506 --> 00:10:42,441
the mock implementation
of the Accounts Service.

195
00:10:42,441 --> 00:10:45,492
Then, I've told Spring to instantiate

196
00:10:45,492 --> 00:10:49,098
the mock implementation
of the Book Service.

197
00:10:49,098 --> 00:10:52,080
And finally, I've told
Spring to instantiate

198
00:10:52,080 --> 00:10:56,415
the implementation of
the Purchasing Service.

199
00:10:56,415 --> 00:10:59,081
And remember it's this Purchasing Service

200
00:10:59,081 --> 00:11:04,030
that I am looking up and
calling from our clients.

201
00:11:05,123 --> 00:11:07,466
Now I'm going to give this a run,

202
00:11:07,466 --> 00:11:08,809
and you might be able to tell,

203
00:11:08,809 --> 00:11:12,490
if you review the XML here,
you might be able to tell

204
00:11:12,490 --> 00:11:15,998
what's going to happen
when I run this code.

205
00:11:20,330 --> 00:11:22,890
Okay, will we have an exception?

206
00:11:22,890 --> 00:11:27,546
As you can see from here,
it's a null pointer exception

207
00:11:27,546 --> 00:11:31,135
and the source of this
null pointer exception

208
00:11:31,135 --> 00:11:35,914
is on line 23 of the Purchasing Service.

209
00:11:35,914 --> 00:11:37,996
I can click the link there

210
00:11:37,996 --> 00:11:41,626
to take me straight to
the line that failed.

211
00:11:41,626 --> 00:11:44,159
You can see that when
I'm calling this method

212
00:11:44,159 --> 00:11:47,071
on this object called Books,

213
00:11:47,071 --> 00:11:49,938
apparently this reference is null.

214
00:11:49,938 --> 00:11:52,820
And this is because,
going back to the XML,

215
00:11:52,820 --> 00:11:56,394
I haven't told Spring to
inject the Book Service

216
00:11:56,394 --> 00:11:59,458
and indeed the Accounts Service

217
00:11:59,458 --> 00:12:03,381
into the Purchasing
Service as a dependency.

218
00:12:03,381 --> 00:12:06,452
So we need to upgrade
the XML in other words.

219
00:12:06,452 --> 00:12:09,961
So what we need to do here
in the Purchasing Service.

220
00:12:09,961 --> 00:12:13,887
If I expend this XML a little bit.

221
00:12:13,887 --> 00:12:16,003
I'm just going to open up the tag there

222
00:12:16,003 --> 00:12:20,159
so that I've got room to
insert properties here.

223
00:12:20,159 --> 00:12:24,351
And what we really want to do
is we want to set the property

224
00:12:24,351 --> 00:12:28,308
with the name of,

225
00:12:28,308 --> 00:12:30,479
now I can't remember the
name of this property.

226
00:12:30,479 --> 00:12:34,911
So if I go into the Purchasing
Service implementation,

227
00:12:34,911 --> 00:12:36,724
the property that I'm working here

228
00:12:36,724 --> 00:12:40,180
is the Book Service property.

229
00:12:40,180 --> 00:12:41,593
And as always, we're following

230
00:12:41,593 --> 00:12:43,489
the JavaBean Naming Convention.

231
00:12:43,489 --> 00:12:46,242
So we're looking here for the set method.

232
00:12:46,242 --> 00:12:50,644
We can see the set method
is called setBookService,

233
00:12:50,644 --> 00:12:53,607
so the property name will be book

234
00:12:53,607 --> 00:12:57,450
with the lowercase B and Service.

235
00:12:57,450 --> 00:12:59,949
Now, it's a common source of confusion.

236
00:12:59,949 --> 00:13:03,763
It doesn't matter that the
attribute that we're working with

237
00:13:03,763 --> 00:13:07,496
is called book, that's
called something different.

238
00:13:07,496 --> 00:13:11,487
Spring is always calling the method.

239
00:13:11,487 --> 00:13:14,943
So it really doesn't matter
what the attribute's called.

240
00:13:14,943 --> 00:13:17,981
So I need to in here the property

241
00:13:17,981 --> 00:13:21,625
with the name bookService.

242
00:13:21,625 --> 00:13:25,407
I want to pass a value into this property.

243
00:13:25,407 --> 00:13:29,729
Now we've done this before
using the value attributes.

244
00:13:29,729 --> 00:13:32,511
You remember doing that back
in the Hello World example,

245
00:13:32,511 --> 00:13:36,743
but unfortunately values
are only or injecting

246
00:13:36,743 --> 00:13:41,565
string values or primitive values.

247
00:13:41,565 --> 00:13:44,568
Now I want to pass in here an object

248
00:13:44,568 --> 00:13:48,506
and it's an object that
Spring itself has created

249
00:13:48,506 --> 00:13:51,242
elsewhere in the container.

250
00:13:51,242 --> 00:13:53,823
So that's really the main thing to learn

251
00:13:53,823 --> 00:13:55,253
on this chapter of the course.

252
00:13:55,253 --> 00:13:58,890
When you're passing in an
object as a dependency,

253
00:13:58,890 --> 00:14:03,714
instead of using value we
use the attribute called ref,

254
00:14:03,714 --> 00:14:06,253
or R-E-F.

255
00:14:08,996 --> 00:14:13,279
It means that we're
referring here to an object

256
00:14:13,279 --> 00:14:18,260
that has been created elsewhere
in the Spring configuration.

257
00:14:18,260 --> 00:14:20,508
In our case the object, I'm working

258
00:14:20,508 --> 00:14:23,008
on the idea of the object here,

259
00:14:23,008 --> 00:14:27,502
the object is called bookService.

260
00:14:27,502 --> 00:14:29,780
Now it's a little bit
confusing that really

261
00:14:29,780 --> 00:14:32,991
that the word here is the same

262
00:14:32,991 --> 00:14:35,433
as the word that we have here,

263
00:14:35,433 --> 00:14:38,986
but they are referring
to different things.

264
00:14:38,986 --> 00:14:43,476
Remember, the property name is
referring to which set method

265
00:14:43,476 --> 00:14:46,196
do we want Spring to call.

266
00:14:46,196 --> 00:14:50,760
The ref is pointing to the objects here.

267
00:14:51,750 --> 00:14:56,750
So if, for example, I was
to rename this ID to books,

268
00:14:57,225 --> 00:15:01,215
then the ref here would
be changed to books

269
00:15:01,215 --> 00:15:04,041
and this would now be valid.

270
00:15:04,041 --> 00:15:05,770
However, I'm going to undo those changes

271
00:15:05,770 --> 00:15:08,286
because you're going to find that often,

272
00:15:08,286 --> 00:15:11,188
well, if the property's
called bookService,

273
00:15:11,188 --> 00:15:14,877
then the object name, the
object ID that we give it

274
00:15:14,877 --> 00:15:18,580
in the Spring probably
ought to be the same name.

275
00:15:18,580 --> 00:15:22,847
It's very common to see the
same word here and in here.

276
00:15:22,847 --> 00:15:24,246
Now, of course, we're going to have to do

277
00:15:24,246 --> 00:15:28,031
exactly the same thing
for the Accounts Service.

278
00:15:28,031 --> 00:15:30,017
So if I just double-check again,

279
00:15:30,017 --> 00:15:31,348
yes, it's the same thing here.

280
00:15:31,348 --> 00:15:36,249
setAccountsService means that the property

281
00:15:37,503 --> 00:15:40,994
will have the name accountsService,

282
00:15:40,994 --> 00:15:44,426
and once again the ref is going to be

283
00:15:44,426 --> 00:15:48,761
the word that we have
here: accountsService.

284
00:15:50,324 --> 00:15:53,768
So I'm going to run the
clients application again.

285
00:15:59,767 --> 00:16:03,185
And this sign, well, we have
those two lines of red logging

286
00:16:03,185 --> 00:16:06,259
but it's telling us that
an invoice has been raised

287
00:16:06,259 --> 00:16:08,671
for that particular book.

288
00:16:08,671 --> 00:16:11,721
Oh and by the way, I don't
think I showed you this.

289
00:16:11,721 --> 00:16:14,217
The Accounts Service implementation,

290
00:16:14,217 --> 00:16:16,010
which of course isn't mock,

291
00:16:16,010 --> 00:16:18,548
I've just put a stub in there.

292
00:16:18,548 --> 00:16:19,999
You might be familiar with stubs.

293
00:16:19,999 --> 00:16:22,698
That's when you put in a
very basic implementation

294
00:16:22,698 --> 00:16:24,623
just so you can test

295
00:16:24,623 --> 00:16:27,532
that something is hanging
together correctly.

296
00:16:27,532 --> 00:16:29,727
So the point of this exercise then

297
00:16:29,727 --> 00:16:32,084
is, if we go back to the XML,

298
00:16:32,084 --> 00:16:35,787
and probably the most important
point in this chapter,

299
00:16:35,787 --> 00:16:40,645
is that when we're injecting
an object into a property,

300
00:16:40,645 --> 00:16:44,737
we use the ref attribute here.

301
00:16:44,737 --> 00:16:47,828
And you're going to find
that from this point forward

302
00:16:47,828 --> 00:16:51,690
most of the time we're injecting objects

303
00:16:51,690 --> 00:16:55,604
rather than basic string properties.

304
00:16:55,604 --> 00:16:59,433
It's time to mention
now what Spring is doing

305
00:16:59,433 --> 00:17:01,285
when it's instantiating the objects

306
00:17:01,285 --> 00:17:03,705
that we've been working with.

307
00:17:03,705 --> 00:17:05,193
Now to illustrate I'm going to go

308
00:17:05,193 --> 00:17:08,735
into our Purchasing Service implementation

309
00:17:08,735 --> 00:17:12,765
and I'm going to add into
here a very quick constructor.

310
00:17:15,768 --> 00:17:18,260
Regular Java constructor.

311
00:17:18,260 --> 00:17:21,417
And I'm just going to
add a print line saying

312
00:17:21,417 --> 00:17:26,417
"Now creating the purchasing service".

313
00:17:27,935 --> 00:17:30,266
So with this we're going to be able to see

314
00:17:30,266 --> 00:17:35,209
exactly when Spring is
creating these objects.

315
00:17:35,209 --> 00:17:37,503
Now what I'm going to do is
I'm going to run this client

316
00:17:37,503 --> 00:17:39,615
under debug mode,

317
00:17:39,615 --> 00:17:42,548
and now we can have a
careful look at the console

318
00:17:42,548 --> 00:17:45,566
and we can see what is happening and when.

319
00:17:45,566 --> 00:17:48,554
Just in case you're not
familiar we go to the client

320
00:17:48,554 --> 00:17:50,889
and, first of all, I'm
going to add in a breakpoint

321
00:17:50,889 --> 00:17:54,676
by double-clicking on the area here

322
00:17:54,676 --> 00:17:57,823
on the left-hand side of the editor window

323
00:17:57,823 --> 00:17:59,977
and that's on the first line of code.

324
00:17:59,977 --> 00:18:02,233
You'll notice there's now a little disc

325
00:18:02,233 --> 00:18:05,243
in that area of the editor.

326
00:18:05,243 --> 00:18:08,530
That's a breakpoint and it
will force Eclipse to stop

327
00:18:08,530 --> 00:18:12,435
before that line of code is executed.

328
00:18:12,435 --> 00:18:15,008
But that only works if I run under debug

329
00:18:15,008 --> 00:18:18,509
so that, say, right-click here,

330
00:18:18,509 --> 00:18:20,420
Debug as,

331
00:18:20,420 --> 00:18:24,948
not Run as but Debug as Java application.

332
00:18:24,948 --> 00:18:27,423
Now if this is the first time
you've done a debug session,

333
00:18:27,423 --> 00:18:31,871
you'll be asked, "Do you want
to switch the perspective?"

334
00:18:31,871 --> 00:18:33,503
Now what that means is,

335
00:18:33,503 --> 00:18:35,817
and you want to remember this decision,

336
00:18:35,817 --> 00:18:39,615
say Yes to that and you'll
see that the window set

337
00:18:39,615 --> 00:18:42,313
has been completely changed around.

338
00:18:42,313 --> 00:18:46,932
And this window set is just
more useful for debugging.

339
00:18:46,932 --> 00:18:49,492
Now, this is telling
me, the green line here

340
00:18:49,492 --> 00:18:53,407
is telling me that the
execution is currently paused

341
00:18:53,407 --> 00:18:57,044
and it hasn't yet executed
that line of code.

342
00:18:57,044 --> 00:18:59,530
Now I don't have the toolbar visible

343
00:18:59,530 --> 00:19:03,060
at the minute so I'll
just need to go to Window

344
00:19:03,060 --> 00:19:05,012
and Show Toolbar.

345
00:19:05,012 --> 00:19:06,634
Now what I can do with the toolbar

346
00:19:06,634 --> 00:19:10,394
is now there's an icon
here called Step Over

347
00:19:10,394 --> 00:19:14,887
and that will execute the next
line of code and then stop.

348
00:19:14,887 --> 00:19:19,505
So you can see in the console
that system print line works.

349
00:19:20,835 --> 00:19:24,052
Now if I step over the
next line, this is boring,

350
00:19:24,052 --> 00:19:28,073
that's just going to create a
variable called required ISBN.

351
00:19:28,073 --> 00:19:32,180
The variable's now displayed
in this window here.

352
00:19:32,180 --> 00:19:34,431
And for the interesting bit.

353
00:19:34,431 --> 00:19:36,852
I'm going to step over the line of code

354
00:19:36,852 --> 00:19:40,809
where the Spring container
has been created.

355
00:19:40,809 --> 00:19:43,500
So watch the console really carefully.

356
00:19:47,474 --> 00:19:50,728
Now you can see that as
soon as the Spring container

357
00:19:50,728 --> 00:19:52,240
was created,

358
00:19:52,240 --> 00:19:57,160
Spring has instantiated the
Purchasing Service object,

359
00:19:57,160 --> 00:19:59,092
and therefore, if you think about it,

360
00:19:59,092 --> 00:20:01,969
it's also instantiated the Book Service

361
00:20:01,969 --> 00:20:04,489
and the Accounts Service.

362
00:20:04,489 --> 00:20:06,955
So what this proves is that Spring

363
00:20:06,955 --> 00:20:11,262
is eagerly instantiating objects.

364
00:20:11,262 --> 00:20:14,047
All the objects configured
inside that wiring file

365
00:20:14,047 --> 00:20:15,554
are being created at the point

366
00:20:15,554 --> 00:20:18,924
that the container is created.

367
00:20:18,924 --> 00:20:21,183
So if we step over the next
line, this is where our client

368
00:20:21,183 --> 00:20:24,746
wants to get access to
a purchasing service,

369
00:20:24,746 --> 00:20:26,497
watch the console here.

370
00:20:27,987 --> 00:20:30,479
You can see that nothing special happened.

371
00:20:30,479 --> 00:20:33,625
And that's because Spring
already had the object created

372
00:20:33,625 --> 00:20:37,055
and it's just handed as back a reference.

373
00:20:37,055 --> 00:20:40,766
I'll just click the Resume button here.

374
00:20:40,766 --> 00:20:42,230
That ends the application

375
00:20:42,230 --> 00:20:45,470
and I can switch back
to the Java perspective.

376
00:20:45,470 --> 00:20:48,329
Now that's the default behavior of Spring

377
00:20:48,329 --> 00:20:50,463
and you're going to
find that almost always

378
00:20:50,463 --> 00:20:53,407
that's the behavior you want.

379
00:20:53,407 --> 00:20:56,345
When Spring is starting up
you want all of your objects

380
00:20:56,345 --> 00:20:59,295
to be set up and you
probably want any errors

381
00:20:59,295 --> 00:21:03,402
in your wiring configuration
to be sort of exposed

382
00:21:03,402 --> 00:21:06,345
at the point you're
starting the application.

383
00:21:06,345 --> 00:21:08,788
But there are some occasional cases

384
00:21:08,788 --> 00:21:10,772
where you don't want that to happen

385
00:21:10,772 --> 00:21:14,154
and you'd prefer that Spring
only creates the objects

386
00:21:14,154 --> 00:21:17,663
at the point it's used for the first time.

387
00:21:17,663 --> 00:21:20,662
It might be that you
have an entire subsystem

388
00:21:20,662 --> 00:21:25,386
of your application that is
particularly memory intensive,

389
00:21:25,386 --> 00:21:30,362
or uses a lot of resources,
or is slow to start up,

390
00:21:30,362 --> 00:21:34,932
but you don't always use that
subsystem in your application,

391
00:21:34,932 --> 00:21:38,730
so it will be kind of
wasteful to have it start up

392
00:21:38,730 --> 00:21:40,757
when the program starts.

393
00:21:41,757 --> 00:21:45,727
If that was the case, then you
could go into your XML file

394
00:21:45,727 --> 00:21:49,706
and you can add in, let's do
it for the Purchasing Service.

395
00:21:49,706 --> 00:21:52,031
We can add in a property here

396
00:21:52,031 --> 00:21:57,031
which is the lazy-init property.

397
00:21:57,638 --> 00:22:01,039
And if I set that to
true, Spring now knows

398
00:22:01,039 --> 00:22:03,259
at starter we won't bother

399
00:22:03,259 --> 00:22:05,129
instantiating the Purchasing Service,

400
00:22:05,129 --> 00:22:09,275
we will wait and we'll wait
until it needs to be used

401
00:22:09,275 --> 00:22:11,359
for the first time.

402
00:22:11,359 --> 00:22:14,267
I'm going to now rerun this under debug,

403
00:22:15,747 --> 00:22:20,285
just to prove that that's
had the desired effect.

404
00:22:20,285 --> 00:22:22,772
So watch the console again.

405
00:22:22,772 --> 00:22:25,225
So we'll step over line 1, that's boring,

406
00:22:25,225 --> 00:22:27,007
and line 2 is boring.

407
00:22:27,007 --> 00:22:28,790
Now watch carefully when I step over

408
00:22:28,790 --> 00:22:30,756
the creation of the container.

409
00:22:34,268 --> 00:22:36,756
Yeah, we can see the logging,

410
00:22:36,756 --> 00:22:39,081
but there's no sign that
that Purchasing Service

411
00:22:39,081 --> 00:22:41,247
was instantiated.

412
00:22:41,247 --> 00:22:43,326
Now it might be the case
that two hours later

413
00:22:43,326 --> 00:22:47,230
we reach this line of code and this time,

414
00:22:47,230 --> 00:22:51,027
yep, you can see that Spring
created the object right there

415
00:22:51,027 --> 00:22:52,970
at the point of first use.

416
00:22:52,970 --> 00:22:55,289
Spring, by the way, will
now keep hold of that object

417
00:22:55,289 --> 00:23:00,212
in the container until we reach the close.

418
00:23:00,212 --> 00:23:03,449
I would guess it depends on
your application, of course,

419
00:23:03,449 --> 00:23:07,241
but I would guess that it's
a fairly rare requirement

420
00:23:07,241 --> 00:23:10,771
to need lazy initialization
on your Spring bean,

421
00:23:10,771 --> 00:23:13,802
so you certainly won't see me
use this again on the course,

422
00:23:13,802 --> 00:23:16,746
but I guess it's good to know it's there.

423
00:23:16,746 --> 00:23:18,239
Now another important point to make

424
00:23:18,239 --> 00:23:20,246
about how the Spring container works

425
00:23:20,246 --> 00:23:24,382
is to look at the question
of how many of these objects

426
00:23:24,382 --> 00:23:26,921
is Spring going to create?

427
00:23:26,921 --> 00:23:30,890
Let's say, for example, going
to my client application here.

428
00:23:30,890 --> 00:23:34,218
And although I've currently accessed

429
00:23:34,218 --> 00:23:36,820
the Purchasing Service once,

430
00:23:36,820 --> 00:23:38,250
I'm now going to go ahead

431
00:23:38,250 --> 00:23:42,226
and copy and paste that line of code.

432
00:23:42,226 --> 00:23:45,266
I'm now going to do that several times.

433
00:23:45,266 --> 00:23:49,249
Now of course, I'll need
to rename these variables.

434
00:23:49,249 --> 00:23:53,516
So, I know it looks silly,
but here I'm accessing

435
00:23:53,516 --> 00:23:56,308
the Purchasing Service six times,

436
00:23:56,308 --> 00:24:00,501
each time with a call
to the get bean method.

437
00:24:00,501 --> 00:24:03,499
Of course, this is not a sensible
thing to do in this client

438
00:24:03,499 --> 00:24:06,460
but I'm really simulating what will happen

439
00:24:06,460 --> 00:24:09,246
when we have lots of different clients

440
00:24:09,246 --> 00:24:11,626
and all those clients are trying to access

441
00:24:11,626 --> 00:24:15,263
the same purchasing service.

442
00:24:15,263 --> 00:24:17,827
The question is now, will Spring create

443
00:24:17,827 --> 00:24:21,484
six separate objects in memory,

444
00:24:21,484 --> 00:24:25,130
or will it create the
purchasing service just once

445
00:24:25,130 --> 00:24:29,523
and keep reusing that reference each time?

446
00:24:29,523 --> 00:24:32,713
Well, we could toss a coin
and guess what Spring does

447
00:24:32,713 --> 00:24:36,263
but, of course, I can also
run this under debug again

448
00:24:37,493 --> 00:24:39,519
and will repeat the process.

449
00:24:39,519 --> 00:24:41,855
Those two lines are boring.

450
00:24:41,855 --> 00:24:44,989
We'll step over the
creation of the container.

451
00:24:45,999 --> 00:24:48,991
Now notice that the Purchasing
Service has been created.

452
00:24:48,991 --> 00:24:52,094
Remember I've removed
the lazy initialization

453
00:24:52,094 --> 00:24:56,042
so it's eagerly created that
Purchasing Service objects.

454
00:24:56,042 --> 00:24:58,762
But now watch what happens as I step over

455
00:24:58,762 --> 00:25:02,602
these six get beans.

456
00:25:02,602 --> 00:25:06,622
You see that each time
nothing special is happening,

457
00:25:06,622 --> 00:25:09,203
it's certainly not instantiating

458
00:25:09,203 --> 00:25:11,723
another Purchasing Service object,

459
00:25:11,723 --> 00:25:14,260
and if you want to get really
technical about this icon,

460
00:25:14,260 --> 00:25:16,351
look at the variables and you'll see

461
00:25:16,351 --> 00:25:20,018
that all of these references are pointing

462
00:25:20,018 --> 00:25:22,591
at the same object.

463
00:25:22,591 --> 00:25:24,759
It's the object that Java's internally

464
00:25:24,759 --> 00:25:28,505
giving the ID of 48-2.

465
00:25:28,505 --> 00:25:32,383
I'll carry on stepping
through and clearly from that

466
00:25:32,383 --> 00:25:34,519
Spring only creates one

467
00:25:34,519 --> 00:25:38,009
of each of the objects in the container.

468
00:25:38,009 --> 00:25:40,237
Now for many applications, in fact,

469
00:25:40,237 --> 00:25:45,237
this default behavior makes good sense.

470
00:25:45,500 --> 00:25:50,500
Now these objects that we
are working with in Spring,

471
00:25:50,533 --> 00:25:52,863
at the moment we have service objects,

472
00:25:52,863 --> 00:25:56,526
later on we'll be adding
data access objects,

473
00:25:56,526 --> 00:25:58,516
connection pools.

474
00:25:58,516 --> 00:26:00,239
Now we'll need to wait
until later in the course

475
00:26:00,239 --> 00:26:04,013
before I can prove it, but it turns out

476
00:26:04,013 --> 00:26:06,995
that for objects, like service objects,

477
00:26:06,995 --> 00:26:11,605
we often only ever need
one instance of them.

478
00:26:11,605 --> 00:26:13,525
But why is that?

479
00:26:13,525 --> 00:26:16,288
Well, imagine that we
do have multiple clients

480
00:26:16,288 --> 00:26:20,009
and they all want to access
the Purchasing Service.

481
00:26:20,009 --> 00:26:24,318
We know now that each of
the clients will by default

482
00:26:24,318 --> 00:26:29,311
get a reference to the same
purchasing service object.

483
00:26:29,311 --> 00:26:33,512
But as long as the service
object isn't holding any data

484
00:26:33,512 --> 00:26:38,512
specifically for single clients,
this is the right behavior.

485
00:26:39,023 --> 00:26:42,196
Many or possibly most Spring applications

486
00:26:42,196 --> 00:26:44,841
will actually have the service objects

487
00:26:44,841 --> 00:26:48,255
ultimately calling a database.

488
00:26:48,255 --> 00:26:51,444
We're going to see how to set
that up in a later chapter,

489
00:26:51,444 --> 00:26:54,339
but for now just try
to imagine the database

490
00:26:54,339 --> 00:26:57,480
being in the background somewhere.

491
00:26:57,480 --> 00:26:59,891
And all this service object is doing

492
00:26:59,891 --> 00:27:04,090
is passing that data
across to that database.

493
00:27:04,090 --> 00:27:06,025
That might be running some business logic

494
00:27:06,025 --> 00:27:09,567
but it's not holding the data for a client

495
00:27:09,567 --> 00:27:12,768
in any kind of attributes.

496
00:27:12,768 --> 00:27:17,383
So it doesn't matter that
every client is sharing

497
00:27:17,383 --> 00:27:20,233
this service object because any data

498
00:27:20,233 --> 00:27:21,759
that the client sends across

499
00:27:21,759 --> 00:27:25,172
will just end up being
stored in the database.

500
00:27:25,172 --> 00:27:29,791
But sometimes, and only sometimes,

501
00:27:29,791 --> 00:27:33,731
you might mean data for a client

502
00:27:33,731 --> 00:27:37,758
to be held in memory by a Spring bean.

503
00:27:37,758 --> 00:27:38,771
I've changed an example

504
00:27:38,771 --> 00:27:41,271
and it is a bit of a cliche this one,

505
00:27:41,271 --> 00:27:42,989
but let's say that we're writing

506
00:27:42,989 --> 00:27:46,076
a shopping cart application.

507
00:27:46,076 --> 00:27:49,751
I want to be storing a user's shopping

508
00:27:49,751 --> 00:27:54,185
in memory inside the Spring
bean, and then I guess

509
00:27:54,185 --> 00:27:58,409
at the end of the process
when the client checks out

510
00:27:58,409 --> 00:28:00,760
we'd then take the contents of the cart

511
00:28:00,760 --> 00:28:03,529
and send it to the database.

512
00:28:03,529 --> 00:28:04,660
Now that's easy enough.

513
00:28:04,660 --> 00:28:06,508
We could have an attribute

514
00:28:06,508 --> 00:28:09,461
inside the shopping cart service here

515
00:28:09,461 --> 00:28:13,258
holding a particular client's shopping.

516
00:28:13,258 --> 00:28:16,244
But you can see now that
the default way of working

517
00:28:16,244 --> 00:28:19,519
in Spring would be no good here at all.

518
00:28:19,519 --> 00:28:22,079
Let's say client 1 was
the client that added

519
00:28:22,079 --> 00:28:26,882
these three items into the
shopping cart services memory.

520
00:28:26,882 --> 00:28:28,966
But now when client 2 comes along

521
00:28:28,966 --> 00:28:31,752
and tries to access the same service,

522
00:28:31,752 --> 00:28:35,327
it will get a reference
to the same objects,

523
00:28:35,327 --> 00:28:39,488
and therefore it will the
first client shopping.

524
00:28:39,488 --> 00:28:42,698
Obviously, this is not
what we want at all.

525
00:28:42,698 --> 00:28:45,973
Now this type of bean,
the shopping cart service,

526
00:28:45,973 --> 00:28:49,343
is called a stateful bean,

527
00:28:49,343 --> 00:28:51,700
Now to repeat, that's
when I want to store data

528
00:28:51,700 --> 00:28:56,243
in an attribute for a particular client.

529
00:28:57,343 --> 00:29:00,086
Now we need some way of making sure,

530
00:29:00,086 --> 00:29:04,639
more like this, that
each individual client

531
00:29:04,639 --> 00:29:09,033
will get their own personal
shopping cart service instance

532
00:29:09,033 --> 00:29:11,145
from Spring.

533
00:29:11,145 --> 00:29:15,265
Then the clients can add
their own data into that bean

534
00:29:15,265 --> 00:29:19,993
and the data won't be shared
with any of the other clients.

535
00:29:19,993 --> 00:29:22,035
It's easy enough to make a bean become

536
00:29:22,035 --> 00:29:25,502
a stateful bean in Spring.

537
00:29:25,502 --> 00:29:28,884
It's just that Spring
calls a stateful bean

538
00:29:28,884 --> 00:29:32,501
a prototype bean.

539
00:29:32,501 --> 00:29:35,380
Now I don't think that's
a very nice term at all.

540
00:29:35,380 --> 00:29:39,690
Prototype to me suggests a
kind of working progress.

541
00:29:39,690 --> 00:29:41,993
In fact, the term comes
from the Gang of Four

542
00:29:41,993 --> 00:29:45,339
Design Patterns, if you're
familiar with those.

543
00:29:45,339 --> 00:29:49,524
So, all we have to do is in our XML,

544
00:29:49,524 --> 00:29:53,204
if, for example, we wanted
the purchasing service

545
00:29:53,204 --> 00:29:56,223
to become a stateful
bean where every client

546
00:29:56,223 --> 00:30:00,010
gets their own personal
copy of that object,

547
00:30:00,010 --> 00:30:03,026
then we would add here

548
00:30:03,026 --> 00:30:07,604
as an attribute to the
bean tag the following.

549
00:30:07,604 --> 00:30:10,980
We would say scope =

550
00:30:10,980 --> 00:30:13,480
and then prototype.

551
00:30:14,980 --> 00:30:19,010
And that tells Spring that
every time we call get bean

552
00:30:19,010 --> 00:30:24,010
for this particular bean it
must instantiate a new one.

553
00:30:24,628 --> 00:30:27,089
Let's give this a run under debug.

554
00:30:29,501 --> 00:30:32,457
I'll skip the first two lines as usual.

555
00:30:32,457 --> 00:30:35,508
Now we're creating the container

556
00:30:35,508 --> 00:30:38,751
and notice that the
container is now created

557
00:30:38,751 --> 00:30:41,759
but it has not instantiated

558
00:30:41,759 --> 00:30:44,239
an instance of the purchasing service.

559
00:30:44,239 --> 00:30:48,052
That's because all prototype
beans are lazily initialized,

560
00:30:48,052 --> 00:30:50,740
they're only initialized
when a clients tries to get

561
00:30:50,740 --> 00:30:52,244
one of them.

562
00:30:52,244 --> 00:30:56,287
Now see what happens each
time we call get bean.

563
00:30:56,287 --> 00:31:00,649
A new instance is created.

564
00:31:00,649 --> 00:31:02,831
And of course, each of
those instances will have

565
00:31:02,831 --> 00:31:07,359
their own private attribute
and their own values.

566
00:31:07,359 --> 00:31:10,506
Now I must stress, I know
I've said this already,

567
00:31:10,506 --> 00:31:13,898
but I must stress that a
prototype bean would be

568
00:31:13,898 --> 00:31:16,050
a relatively rare thing to have.

569
00:31:16,050 --> 00:31:20,426
We certainly would not have
one for the purchasing service.

570
00:31:20,426 --> 00:31:22,313
We only need a single instance.

571
00:31:22,313 --> 00:31:25,823
So we could say in here
"scope = singleton".

572
00:31:25,823 --> 00:31:29,428
But, in fact, you've seen
now that that's the default.

573
00:31:29,428 --> 00:31:32,684
So often times you won't
see a scope mentioned

574
00:31:32,684 --> 00:31:35,231
in the Spring XML at all.

575
00:31:35,231 --> 00:31:37,276
They're all, by the way, few of the values

576
00:31:37,276 --> 00:31:39,156
we can specify the scope.

577
00:31:39,156 --> 00:31:41,922
We won't really need those
and so we get to building

578
00:31:41,922 --> 00:31:45,919
web applications with,
for instance, Spring MVC.

579
00:31:45,919 --> 00:31:50,417
So for now the default singleton
is usually good enough,

580
00:31:50,417 --> 00:31:54,704
just occasionally you might
need that prototype scope.

581
00:31:54,704 --> 00:31:57,772
Well, I hope by now you're
starting to feel comfortable

582
00:31:57,772 --> 00:32:01,119
with the idea of dependency injection.

583
00:32:01,119 --> 00:32:02,727
Just to recap let's have a look

584
00:32:02,727 --> 00:32:06,101
in the purchasing service implementation.

585
00:32:06,101 --> 00:32:09,343
And remember that we've
made the two dependencies,

586
00:32:09,343 --> 00:32:12,165
the Accounts Service and the Book Service,

587
00:32:12,165 --> 00:32:16,617
be kind of properties of this class.

588
00:32:16,617 --> 00:32:20,137
And we've told Spring that we
want to be able to configure

589
00:32:20,137 --> 00:32:24,761
these objects at run time
and we know that Spring calls

590
00:32:24,761 --> 00:32:28,759
these set methods to do so.

591
00:32:28,759 --> 00:32:33,516
However, there is an alternative
to using set methods,

592
00:32:34,486 --> 00:32:37,488
and I'm going to illustrate
that by removing the set methods

593
00:32:37,488 --> 00:32:39,275
completely.

594
00:32:39,275 --> 00:32:43,526
Instead of using the set
methods I'm going to ask Spring

595
00:32:43,526 --> 00:32:48,260
to pass in these dependent
objects into the constructor.

596
00:32:49,225 --> 00:32:51,892
Now, this is really just standard Java.

597
00:32:51,892 --> 00:32:53,289
What we would do in the constructor

598
00:32:53,289 --> 00:32:57,353
is we would add in two parameters.

599
00:32:59,400 --> 00:33:03,004
Let the Accounts Service be first

600
00:33:05,004 --> 00:33:08,975
and the Book Service

601
00:33:08,975 --> 00:33:10,507
will go in second.

602
00:33:12,247 --> 00:33:15,965
And then, I think that's Accounts Service

603
00:33:15,965 --> 00:33:17,252
with an S in there.

604
00:33:18,772 --> 00:33:20,361
Yeah, that's okay now.

605
00:33:20,361 --> 00:33:22,591
And then the usual business really.

606
00:33:22,591 --> 00:33:25,745
We just stash those values away.

607
00:33:28,486 --> 00:33:31,729
And I know I've been a
little bit inconsistent here

608
00:33:31,729 --> 00:33:36,404
and that I've called the
attributes just accounts and books,

609
00:33:36,404 --> 00:33:40,107
rather than the full word.

610
00:33:40,107 --> 00:33:42,839
But that's okay, and I
think it's actually useful

611
00:33:42,839 --> 00:33:46,324
to emphasise the difference
between these local names

612
00:33:46,324 --> 00:33:49,129
and the names of the attributes.

613
00:33:49,129 --> 00:33:53,581
So now we can only pass
in these dependencies

614
00:33:53,581 --> 00:33:57,187
through the constructor
and that means at the point

615
00:33:57,187 --> 00:34:00,969
that the Purchasing
Service object is created.

616
00:34:00,969 --> 00:34:04,564
Now I need to change the XML a little bit.

617
00:34:04,564 --> 00:34:08,628
These are now no longer
properties of the class.

618
00:34:08,628 --> 00:34:12,981
Instead we have to tell
Spring inside the bean tag

619
00:34:12,981 --> 00:34:17,044
that we have two constructor arguments.

620
00:34:17,044 --> 00:34:21,265
And we do that with constructor arg,

621
00:34:21,265 --> 00:34:25,541
and we specify which
bean we're referring to

622
00:34:25,541 --> 00:34:27,263
with the ref tag again.

623
00:34:29,003 --> 00:34:32,276
Now because there's no value
inside this constructor arg tag

624
00:34:32,276 --> 00:34:35,060
I can just close the tag like that.

625
00:34:35,060 --> 00:34:38,021
And then for the second
constructor argument

626
00:34:38,021 --> 00:34:40,670
I do the same again,

627
00:34:40,670 --> 00:34:45,003
but we're referring to
the Accounts Service.

628
00:34:46,036 --> 00:34:48,393
Now notice that these
constructor arguments

629
00:34:48,393 --> 00:34:50,975
can be in any order.

630
00:34:50,975 --> 00:34:53,407
We go to the Purchasing
Service implementation,

631
00:34:53,407 --> 00:34:57,761
the first parameter is
the Accounts Service

632
00:34:57,761 --> 00:35:01,577
and the second parameter
is the Book Service,

633
00:35:01,577 --> 00:35:04,042
but I've done them the other way around

634
00:35:04,042 --> 00:35:05,076
here in the wiring.

635
00:35:05,076 --> 00:35:08,788
But that's fine because Spring
works on the types of these.

636
00:35:08,788 --> 00:35:12,159
It knows that it needs
to inject a book service

637
00:35:12,159 --> 00:35:16,532
into the constructor, so
it looks at the constructor

638
00:35:16,532 --> 00:35:19,945
and sees, "oh yes, the second
parameter is the Book Service

639
00:35:19,945 --> 00:35:24,458
"so I'll use that object
for the second parameter."

640
00:35:24,458 --> 00:35:28,725
Now very rarely, if
you've got the same type

641
00:35:28,725 --> 00:35:31,956
appearing in the
constructor more than once,

642
00:35:31,956 --> 00:35:34,026
then you've got a problem,

643
00:35:34,026 --> 00:35:36,831
and in that case you do have to specify

644
00:35:36,831 --> 00:35:40,116
which of the parameters
you're talking about.

645
00:35:40,116 --> 00:35:43,434
And we do that using the index value.

646
00:35:43,434 --> 00:35:46,889
So it would look, if it were ambiguous,

647
00:35:46,889 --> 00:35:49,204
it would look something like this.

648
00:35:49,204 --> 00:35:53,288
So I'm saying here that the second element

649
00:35:53,288 --> 00:35:56,703
of the constructor is going
to be the Book Service

650
00:35:56,703 --> 00:36:00,012
and the first element
is the Accounts Service.

651
00:36:00,012 --> 00:36:04,095
It's annoying the index is zero based.

652
00:36:04,095 --> 00:36:07,336
But remember you only need this index

653
00:36:07,336 --> 00:36:11,660
if you have more than one instance

654
00:36:11,660 --> 00:36:14,993
of a particular type in the constructor.

655
00:36:15,993 --> 00:36:18,015
So I don't need it here
but I'll leave it in

656
00:36:18,015 --> 00:36:19,882
just to check that that works.

657
00:36:19,882 --> 00:36:22,262
I give my application a run.

658
00:36:22,262 --> 00:36:25,332
Yep, it's raising the invoice correctly.

659
00:36:25,332 --> 00:36:28,228
And because I don't need
them here I'm going to remove

660
00:36:28,228 --> 00:36:31,316
the indexes,

661
00:36:31,316 --> 00:36:34,500
just to prove that Spring
can work out for itself.

662
00:36:36,230 --> 00:36:38,025
Yep, that's still running fine.

663
00:36:38,025 --> 00:36:39,956
Spring can work it out for itself

664
00:36:39,956 --> 00:36:44,253
if there's only one element of
each type in the constructor.

665
00:36:45,545 --> 00:36:49,986
So that's two very different
ways of injecting dependencies

666
00:36:49,986 --> 00:36:52,821
into an object.

667
00:36:52,821 --> 00:36:56,010
And really you have a
choice as to which one

668
00:36:56,010 --> 00:36:59,380
you'll use: setter methods or constructor.

669
00:36:59,380 --> 00:37:01,695
Now I must say there's
been a fair bit of debate

670
00:37:01,695 --> 00:37:04,905
over the years as to which
one is the best approach,

671
00:37:04,905 --> 00:37:07,525
but the best advice I can give you

672
00:37:07,525 --> 00:37:12,525
is that really constructor
injection is better

673
00:37:13,116 --> 00:37:17,273
if your dependency is
a required dependency.

674
00:37:18,153 --> 00:37:20,406
Now remember when we were writing this

675
00:37:20,406 --> 00:37:24,750
about half an hour ago,
when I hadn't yet injected

676
00:37:24,750 --> 00:37:27,092
the properties in the XML,

677
00:37:27,092 --> 00:37:30,901
and when I run the program I
got a null pointer exception

678
00:37:30,901 --> 00:37:34,332
and I seem to remember it
was on this line of code here

679
00:37:34,332 --> 00:37:37,762
when we were accessing the Book
Service for the first time.

680
00:37:37,762 --> 00:37:41,160
And that happened because I'd forgotten

681
00:37:41,160 --> 00:37:43,913
to inject the dependency.

682
00:37:43,913 --> 00:37:47,188
Well, the great thing
with constructor injection

683
00:37:47,188 --> 00:37:50,002
is, let's say I forget a dependency,

684
00:37:50,002 --> 00:37:52,223
let's forget both of them, in fact.

685
00:37:52,223 --> 00:37:56,638
So this Purchasing Service
is completely unconfigured.

686
00:37:56,638 --> 00:37:59,253
Now if I run the application this time,

687
00:38:00,483 --> 00:38:02,752
well, I have a crash.

688
00:38:03,972 --> 00:38:07,113
Ever creating the bean
with Purchasing Service,

689
00:38:07,113 --> 00:38:09,290
bla-bla-bla-bla-bla-bla-bla-bla,

690
00:38:09,290 --> 00:38:11,465
cannot instantiate the bean.

691
00:38:11,465 --> 00:38:12,970
Well, they're going on a little bit

692
00:38:12,970 --> 00:38:16,276
but "no default constructor found".

693
00:38:16,276 --> 00:38:20,383
It's saying that it can't
find the correct constructor

694
00:38:20,383 --> 00:38:23,518
based on the XML that we've written.

695
00:38:23,518 --> 00:38:26,943
Now, all right, it's still a crash.

696
00:38:26,943 --> 00:38:28,617
If we were using setter injection,

697
00:38:28,617 --> 00:38:31,199
we'd have had a null pointer exception.

698
00:38:31,199 --> 00:38:33,247
But this isn't improvement
and the improvement

699
00:38:33,247 --> 00:38:37,247
is that the crash has happened
at the start of the program,

700
00:38:37,247 --> 00:38:41,254
when it was trying to
wire the beans together.

701
00:38:41,254 --> 00:38:45,515
Now, that's much, much better
to have bad configurations

702
00:38:45,515 --> 00:38:50,000
be exposed before the
program has really started,

703
00:38:50,000 --> 00:38:53,119
rather than as we had before
with setter injection.

704
00:38:53,119 --> 00:38:56,998
The crash happened at
some unspecified point

705
00:38:56,998 --> 00:38:59,657
in the middle of the code running.

706
00:38:59,657 --> 00:39:02,028
So far this reason I recommend

707
00:39:02,028 --> 00:39:05,585
to always use constructor injection

708
00:39:05,585 --> 00:39:09,298
for any required fields

709
00:39:09,298 --> 00:39:12,708
and setter methods are
better if the dependency

710
00:39:12,708 --> 00:39:15,957
is an optional dependency.

711
00:39:15,957 --> 00:39:18,719
I must admit that in the
first edition of this course

712
00:39:18,719 --> 00:39:22,068
I used setter injection everywhere

713
00:39:22,068 --> 00:39:25,766
and I don't think I even
mentioned constructor injection

714
00:39:25,766 --> 00:39:27,794
anywhere on the course.

715
00:39:27,794 --> 00:39:30,516
And the reason for this
is probably historical.

716
00:39:30,516 --> 00:39:34,049
When Spring was first released,
the creators of Spring

717
00:39:34,049 --> 00:39:37,316
just seem to favor setter injection.

718
00:39:37,316 --> 00:39:41,984
All of their examples,
reference manual, blog posts,

719
00:39:41,984 --> 00:39:46,463
and so on, seemed to use setter
injection as their examples

720
00:39:46,463 --> 00:39:49,417
and the rest of us kind
of followed their lead.

721
00:39:49,417 --> 00:39:52,209
And it was only after experience,
after a few years really,

722
00:39:52,209 --> 00:39:54,400
that we realized that
constructor injection

723
00:39:54,400 --> 00:39:58,058
is slightly more powerful,
it's slightly tighter.

724
00:39:58,058 --> 00:40:01,808
But please don't worry about
it, it's not a big deal,

725
00:40:01,808 --> 00:40:04,684
and just to lead by example
I'm going to carry on

726
00:40:04,684 --> 00:40:07,850
through this course using
constructor injection

727
00:40:07,850 --> 00:40:10,975
for any required dependencies.

728
00:40:10,975 --> 00:40:13,162
But don't worry, if you're
working on a project

729
00:40:13,162 --> 00:40:15,510
that uses setter methods everywhere,

730
00:40:15,510 --> 00:40:18,255
it's really not that important.

731
00:40:19,391 --> 00:40:22,014
So a bit of a miscellaneous chapter,

732
00:40:22,014 --> 00:40:25,251
nothing too heavy in there I
hope, but you'll need to know

733
00:40:25,251 --> 00:40:27,498
how to inject objects

734
00:40:27,498 --> 00:40:30,643
and you use ref to do that.

735
00:40:30,643 --> 00:40:33,615
Most of the time you'll
be injecting objects

736
00:40:33,615 --> 00:40:35,636
as dependencies.

737
00:40:35,636 --> 00:40:38,279
The default behavior is for the container

738
00:40:38,279 --> 00:40:41,407
to eagerly create singletons,

739
00:40:41,407 --> 00:40:45,236
and that for many uses of
Spring is the best behavior.

740
00:40:45,236 --> 00:40:49,663
But you now know how to
create so-called prototypes

741
00:40:49,663 --> 00:40:53,603
and that just means a
brand-new fresh object

742
00:40:53,603 --> 00:40:58,111
is created each time the
get bean method is called.

743
00:40:58,111 --> 00:41:00,650
You probably won't need
to use them very often

744
00:41:00,650 --> 00:41:05,523
but it is important to
understand what Spring is doing.

745
00:41:05,523 --> 00:41:10,514
And finally, constructor
injection versus setter injection.

746
00:41:10,514 --> 00:41:14,028
The big debate, but I tend to recommend

747
00:41:14,028 --> 00:41:18,392
constructor injection if
the dependency is required,

748
00:41:18,392 --> 00:41:22,903
and that helps your
application to fail quickly,

749
00:41:22,903 --> 00:41:26,922
if for some reason you
forgot that dependency.

750
00:41:26,922 --> 00:41:29,215
Don't worry about the difference too much.

751
00:41:29,215 --> 00:41:32,778
I've used setter injection
for most of my time in Spring

752
00:41:32,778 --> 00:41:35,760
but for this edition of the
course I thought I'd bring

753
00:41:35,760 --> 00:41:39,274
constructor injection into the limelight

754
00:41:39,274 --> 00:41:41,506
and I'll be using it from this point on.

755
00:41:43,236 --> 00:41:46,953
Okay, working with XML is tedious

756
00:41:46,953 --> 00:41:49,033
so you will want to watch Chapter 7

757
00:41:49,033 --> 00:41:51,807
where I show this Spring IDE,

758
00:41:51,807 --> 00:41:54,633
a really useful plugin for Eclipse

759
00:41:54,633 --> 00:41:56,772
that makes life much simpler.

1
00:00:00,139 --> 00:00:02,639
(light music)

2
00:00:09,860 --> 00:00:11,142
- [Voiceover] This is Chapter Seven of the

3
00:00:11,142 --> 00:00:14,628
Spring Framework Fundamentals course.

4
00:00:14,628 --> 00:00:17,592
Not a long chapter, this, but useful.

5
00:00:17,592 --> 00:00:20,386
I'm going to show you the Spring IDE.

6
00:00:20,386 --> 00:00:21,355
A plugin for Eclipse

7
00:00:21,355 --> 00:00:25,125
that makes your Spring life much easier.

8
00:00:25,125 --> 00:00:27,501
We'll start by installing the plugin,

9
00:00:27,501 --> 00:00:29,885
and then we'll see its features.

10
00:00:29,885 --> 00:00:33,391
Perhaps the two biggest
features are that our beans

11
00:00:33,391 --> 00:00:38,197
are validated, and that means
that any typos in the xml file

12
00:00:38,197 --> 00:00:41,047
are picked up immediately
without needing to run

13
00:00:41,047 --> 00:00:43,297
and debug nasty exceptions.

14
00:00:44,601 --> 00:00:46,785
And we get a graph of our beans,

15
00:00:46,785 --> 00:00:49,417
which is a great way of spotting mistakes,

16
00:00:49,417 --> 00:00:52,477
such as missing dependencies.

17
00:00:52,477 --> 00:00:56,495
I'll also mention at the end
the SpringSource Tool Suite,

18
00:00:56,495 --> 00:00:59,328
which your project might be using.

19
00:01:01,150 --> 00:01:04,669
Although you can get
by in your Spring work

20
00:01:04,669 --> 00:01:07,658
by just using a basic xml editor

21
00:01:07,658 --> 00:01:11,752
like we've been doing so far,
for years now there have been

22
00:01:11,752 --> 00:01:13,928
plugins available for really

23
00:01:13,928 --> 00:01:16,928
every major development environment.

24
00:01:17,928 --> 00:01:22,336
Now personally, usually,
I generally avoid using

25
00:01:22,336 --> 00:01:24,336
extra tools and plugins,

26
00:01:25,330 --> 00:01:27,316
and wizards wherever I can.

27
00:01:27,316 --> 00:01:31,704
Because often I'd rather
use my brain then letting

28
00:01:31,704 --> 00:01:34,250
some kind of tool guide
me through a wizard

29
00:01:34,250 --> 00:01:36,274
or something like that.

30
00:01:36,274 --> 00:01:40,378
I think that using too many
tools can make you lazy.

31
00:01:40,378 --> 00:01:42,315
But in the case of Spring

32
00:01:42,315 --> 00:01:45,089
we've got a lot of xml to deal with.

33
00:01:45,089 --> 00:01:47,513
Well, we haven't yet, I think the xml

34
00:01:47,513 --> 00:01:50,277
is fairly manageable
so far but believe me,

35
00:01:50,277 --> 00:01:52,727
in just a few chapters
time, we're going to have

36
00:01:52,727 --> 00:01:55,477
an awful lot of xml to deal with.

37
00:01:56,851 --> 00:01:59,795
Now as you know, we will
be later on in the course

38
00:01:59,795 --> 00:02:03,971
looking at how we can
avoid the xml altogether.

39
00:02:03,971 --> 00:02:08,006
But you might be working on
a project that does use xml

40
00:02:08,006 --> 00:02:10,297
and as I've already
mentioned on the course,

41
00:02:10,297 --> 00:02:15,026
I think it is good for learning
to use the xml at first.

42
00:02:15,026 --> 00:02:18,950
So I really do think that
using an external tool

43
00:02:18,950 --> 00:02:21,268
is going to be a really big help.

44
00:02:21,268 --> 00:02:23,673
So in this chapter I'm going to introduce

45
00:02:23,673 --> 00:02:25,756
the so-called Spring IDE.

46
00:02:26,644 --> 00:02:29,905
And you don't have to use
it if you don't like it,

47
00:02:29,905 --> 00:02:32,202
but I think you will.

48
00:02:32,202 --> 00:02:35,270
So, yeah, the most common and
certainly the most popular

49
00:02:35,270 --> 00:02:39,437
tool for working in Spring
is called the Spring IDE.

50
00:02:41,702 --> 00:02:44,152
That is a little bit of a misnomer.

51
00:02:44,152 --> 00:02:47,098
It's not a separate
development environment.

52
00:02:47,098 --> 00:02:49,348
It is a plugin for Eclipse.

53
00:02:50,926 --> 00:02:52,760
I can install it really easily

54
00:02:52,760 --> 00:02:55,020
and I'll take you through the steps

55
00:02:55,020 --> 00:02:57,710
and show you a few of its features.

56
00:02:57,710 --> 00:03:00,094
So following the usual
standard process for

57
00:03:00,094 --> 00:03:03,086
installing plugins into Eclipse,

58
00:03:03,086 --> 00:03:04,748
while I hope this hasn't changed

59
00:03:04,748 --> 00:03:06,762
by the time you'll watch this video,

60
00:03:06,762 --> 00:03:08,634
it's been like this for many years now,

61
00:03:08,634 --> 00:03:10,296
we go to the Help menu,

62
00:03:10,296 --> 00:03:13,404
we select install new software.

63
00:03:13,404 --> 00:03:17,032
And what you'll need to
do on this field here

64
00:03:17,032 --> 00:03:19,032
is click the Add button.

65
00:03:20,158 --> 00:03:22,676
And you need to enter some
descriptive naming here.

66
00:03:22,676 --> 00:03:25,630
So that can be anything
that you understand.

67
00:03:25,630 --> 00:03:28,604
So I'm just going to
put Spring IDE in here.

68
00:03:28,604 --> 00:03:33,137
And for the location you
need to enter the URL

69
00:03:33,137 --> 00:03:35,470
where this plugin is hosted.

70
00:03:36,716 --> 00:03:39,472
Now we have a little
bit of a problem here.

71
00:03:39,472 --> 00:03:43,566
In the first edition of the
course, the URL was the URL

72
00:03:43,566 --> 00:03:45,096
you can see here.

73
00:03:45,096 --> 00:03:48,679
It was springide.org/updatesite.

74
00:03:52,914 --> 00:03:56,876
Well, what happened after I
recorded the original course

75
00:03:56,876 --> 00:04:00,998
was they changed the URL to
something completely different.

76
00:04:00,998 --> 00:04:05,165
In fact it was the URL you
can see on the screen now.

77
00:04:07,202 --> 00:04:10,736
So, my old video broke and
I had a lot of complaints.

78
00:04:10,736 --> 00:04:15,496
So what I did back in June
2010 was I wrote a blog post.

79
00:04:15,496 --> 00:04:18,232
And I used this blog post
to track what the current

80
00:04:18,232 --> 00:04:21,528
working URL for this plugin is.

81
00:04:21,528 --> 00:04:25,726
Now what happened around July
2011 was it seemed that they

82
00:04:25,726 --> 00:04:30,154
brought back the springide.org
address and I think

83
00:04:30,154 --> 00:04:32,490
what they've done is
they've set up a redirect

84
00:04:32,490 --> 00:04:35,768
from that address to the new one.

85
00:04:35,768 --> 00:04:37,658
And it all got a little
bit confusing because

86
00:04:37,658 --> 00:04:41,906
the other address stopped
working as well at some point.

87
00:04:41,906 --> 00:04:45,782
And it can be rather
awkward, this update site.

88
00:04:45,782 --> 00:04:48,637
So all I can say is, if you
have any problems following

89
00:04:48,637 --> 00:04:51,145
the procedure that we're about to follow,

90
00:04:51,145 --> 00:04:54,025
first of all go to my blog
post, check if there are

91
00:04:54,025 --> 00:04:55,933
any updates on there.

92
00:04:55,933 --> 00:04:58,223
And if it's still not working
for you then, of course,

93
00:04:58,223 --> 00:05:01,481
do send me a message
through the contact page

94
00:05:01,481 --> 00:05:04,351
at Virtual Pair Programmers
and I'll investigate,

95
00:05:04,351 --> 00:05:08,503
get back to you, and of course
I'll update the blog as well.

96
00:05:08,503 --> 00:05:10,487
So, at the time of this recording

97
00:05:10,487 --> 00:05:13,557
we can use either of the two URLs.

98
00:05:13,557 --> 00:05:15,703
So I'm going to go for
the easier one to type,

99
00:05:15,703 --> 00:05:19,536
which was springide.org/updatesite.

100
00:05:21,697 --> 00:05:25,279
But as of this recording you
can still use the other URL.

101
00:05:25,279 --> 00:05:27,275
So we'll click OK.

102
00:05:27,275 --> 00:05:29,829
Now we're presented with
a rather bewildering,

103
00:05:29,829 --> 00:05:33,915
long list of plugins that we can install.

104
00:05:33,915 --> 00:05:36,879
Now I'll come back later and talk about

105
00:05:36,879 --> 00:05:39,425
what some of these entries are.

106
00:05:39,425 --> 00:05:43,539
But for this course all
we're going to need to take

107
00:05:43,539 --> 00:05:45,456
is the Core Spring IDE.

108
00:05:47,595 --> 00:05:50,265
Now these entries do change over time,

109
00:05:50,265 --> 00:05:54,265
so you're looking for
something like Spring IDE.

110
00:05:55,403 --> 00:05:58,007
For the course we don't
need dm Server Tools,

111
00:05:58,007 --> 00:05:59,840
and we don't need STS.

112
00:06:00,905 --> 00:06:02,823
We'll come back to those and
tell you what they are shortly,

113
00:06:02,823 --> 00:06:05,085
but we don't need them for now.

114
00:06:05,085 --> 00:06:09,252
So once we've ticked Spring
IDE, we'll click Next.

115
00:06:11,697 --> 00:06:15,421
After a delay and I did
edit the delay there,

116
00:06:15,421 --> 00:06:16,855
so y'alls may have taken longer,

117
00:06:16,855 --> 00:06:19,989
it should give you a
confirmation screen that, yep,

118
00:06:19,989 --> 00:06:23,723
we do want to install Spring IDE Core.

119
00:06:23,723 --> 00:06:26,241
The next page is a license agreement.

120
00:06:26,241 --> 00:06:27,931
While you're going to need to accept it,

121
00:06:27,931 --> 00:06:31,822
I guess you should read it first, but,

122
00:06:31,822 --> 00:06:33,881
I did that off camera of course.

123
00:06:33,881 --> 00:06:35,714
And then click Finish.

124
00:06:37,795 --> 00:06:38,728
Well that took a long while

125
00:06:38,728 --> 00:06:41,671
so I just edited out the
long installation process,

126
00:06:41,671 --> 00:06:43,602
but hopefully you should see the same

127
00:06:43,602 --> 00:06:45,720
when yours is finished.

128
00:06:45,720 --> 00:06:48,256
It's suggesting that we
need to restart Eclipse.

129
00:06:48,256 --> 00:06:50,089
Yes we should do that.

130
00:06:51,486 --> 00:06:55,237
And we'll reopen the
same workspace as before,

131
00:06:55,237 --> 00:06:57,158
and here we are back again.

132
00:06:57,158 --> 00:06:58,916
Now nothing seems to have changed,

133
00:06:58,916 --> 00:07:00,785
but we have installed the IDE.

134
00:07:00,785 --> 00:07:03,076
So, let's have a look
at how we can use these

135
00:07:03,076 --> 00:07:04,743
Spring plugin tools.

136
00:07:05,794 --> 00:07:07,435
First of all, if we wanted to start

137
00:07:07,435 --> 00:07:10,185
a brand new project using Spring,

138
00:07:11,094 --> 00:07:14,268
we could go to the file menu, select New,

139
00:07:14,268 --> 00:07:17,435
select the second item, the Project...

140
00:07:19,968 --> 00:07:24,470
And you should now see
a new folder for Spring.

141
00:07:24,470 --> 00:07:28,867
And we can select from
there Spring Projects.

142
00:07:28,867 --> 00:07:31,652
Now that would be if we were
starting a brand new project,

143
00:07:31,652 --> 00:07:33,952
but we already have a project.

144
00:07:33,952 --> 00:07:36,346
Now what we need to do
is we need to, kind of,

145
00:07:36,346 --> 00:07:39,929
retrospectively make
this a Spring project.

146
00:07:41,076 --> 00:07:43,117
And to do that's really easy.

147
00:07:43,117 --> 00:07:45,086
You just right click on the project

148
00:07:45,086 --> 00:07:47,280
here in the package explorer.

149
00:07:47,280 --> 00:07:50,565
And the menu option we're
looking for is a long way

150
00:07:50,565 --> 00:07:54,213
down the list it's down
here, Spring Tools.

151
00:07:54,213 --> 00:07:58,404
And I think the camera
is just catching that.

152
00:07:58,404 --> 00:08:00,466
Just move my IDE up a little bit

153
00:08:00,466 --> 00:08:02,877
so the camera will catch it better.

154
00:08:02,877 --> 00:08:05,575
We're looking for Spring Tools,

155
00:08:05,575 --> 00:08:07,192
and there's just a single option on there,

156
00:08:07,192 --> 00:08:10,109
which is Add Spring Project Nature.

157
00:08:11,015 --> 00:08:15,054
That effectively enables
the plugins for Spring.

158
00:08:15,054 --> 00:08:16,661
So we'll select that,

159
00:08:16,661 --> 00:08:18,675
and nothing dramatic has happened,

160
00:08:18,675 --> 00:08:21,248
but I'll zoom in on this.

161
00:08:21,248 --> 00:08:22,720
You might just be able to see

162
00:08:22,720 --> 00:08:26,803
that the icon for this
project now has a small s.

163
00:08:27,840 --> 00:08:32,448
And that tells us that
this is a Spring project.

164
00:08:32,448 --> 00:08:34,414
Now the next step is we need to configure

165
00:08:34,414 --> 00:08:36,884
the project properties.

166
00:08:36,884 --> 00:08:41,051
Now this is on the normal
project properties menu.

167
00:08:42,452 --> 00:08:46,202
Here there is now a
Spring entry on the list.

168
00:08:47,496 --> 00:08:49,662
Now that would not have been there

169
00:08:49,662 --> 00:08:52,816
until I added that Spring project nature.

170
00:08:52,816 --> 00:08:55,155
Now we need to drop the tab down

171
00:08:55,155 --> 00:08:58,072
and select the Beans Support entry.

172
00:08:59,342 --> 00:09:03,380
Now what we're looking for
is the Config Files tab.

173
00:09:03,380 --> 00:09:05,280
Now this is giving me a list of all of the

174
00:09:05,280 --> 00:09:09,260
Spring xml files that
the plugin knows about.

175
00:09:09,260 --> 00:09:13,156
Now because there's no standard
name for a Spring xml file,

176
00:09:13,156 --> 00:09:15,702
the plugin has no way of kind of guessing

177
00:09:15,702 --> 00:09:17,619
what the xml files are.

178
00:09:18,514 --> 00:09:21,306
So what we need to do
is click the Add button.

179
00:09:21,306 --> 00:09:24,622
Now this menu is showing me a
list of our entire class path,

180
00:09:24,622 --> 00:09:27,006
we can ignore the jar files.

181
00:09:27,006 --> 00:09:30,370
We just need to drill into our src folder,

182
00:09:30,370 --> 00:09:33,922
and there is our application.xml file.

183
00:09:33,922 --> 00:09:35,172
We'll click OK.

184
00:09:36,262 --> 00:09:38,314
Now we may need this later in the course,

185
00:09:38,314 --> 00:09:40,946
so I'd just like you to also tick the

186
00:09:40,946 --> 00:09:43,779
Enable support for import element.

187
00:09:44,888 --> 00:09:46,370
We'll be coming back to that later,

188
00:09:46,370 --> 00:09:48,401
but I think we'll need it.

189
00:09:48,401 --> 00:09:51,484
Once we've done that we can click OK.

190
00:09:52,336 --> 00:09:56,609
So now the plugin knows
where our xml files are.

191
00:09:56,609 --> 00:09:58,454
First thing I can do with this plugin

192
00:09:58,454 --> 00:10:00,287
is display a new view.

193
00:10:01,190 --> 00:10:04,182
And I'll do that by
going to the Window menu.

194
00:10:04,182 --> 00:10:05,599
Select Show View.

195
00:10:06,679 --> 00:10:10,512
Now we're looking here
for the Spring Explorer

196
00:10:11,706 --> 00:10:16,333
While I can't see it on the
list so if I click on Other

197
00:10:16,333 --> 00:10:21,055
then there should be a Spring
entry in this list of folders

198
00:10:21,055 --> 00:10:22,907
and if I drop that down there it is.

199
00:10:22,907 --> 00:10:24,574
The Spring Explorer.

200
00:10:25,547 --> 00:10:26,380
Click OK.

201
00:10:28,331 --> 00:10:30,641
And this gives me a view down here

202
00:10:30,641 --> 00:10:34,237
which I'm then to double
click to maximize.

203
00:10:34,237 --> 00:10:36,745
Now I can drill down through this,

204
00:10:36,745 --> 00:10:40,821
and it's showing me the
structure of the xml file

205
00:10:40,821 --> 00:10:42,071
in a tree form.

206
00:10:43,623 --> 00:10:47,679
It's showing me the three
beans that I have here,

207
00:10:47,679 --> 00:10:49,161
and in my purchasing service

208
00:10:49,161 --> 00:10:51,745
if I drill a little deeper into that,

209
00:10:51,745 --> 00:10:53,617
it's showing me the properties

210
00:10:53,617 --> 00:10:56,295
that the purchasing service has.

211
00:10:56,295 --> 00:10:58,613
And I can see here that it's referencing

212
00:10:58,613 --> 00:11:02,433
book Service and the account service.

213
00:11:02,433 --> 00:11:05,529
And I can do things like
double clicking on this,

214
00:11:05,529 --> 00:11:08,037
for instance, account Service bean,

215
00:11:08,037 --> 00:11:10,954
and it takes me straight to the xml

216
00:11:11,943 --> 00:11:14,137
for that particular bean.

217
00:11:14,137 --> 00:11:16,959
If I go back to the Spring explorer,

218
00:11:16,959 --> 00:11:19,733
I can also right click
on any of these elements

219
00:11:19,733 --> 00:11:22,249
such as the purchasing service,

220
00:11:22,249 --> 00:11:25,166
and I can select Open Java Element.

221
00:11:26,121 --> 00:11:29,825
And that will take me straight to the Java

222
00:11:29,825 --> 00:11:32,627
for that particular bean implementation.

223
00:11:32,627 --> 00:11:36,275
So this view really does
help you navigate the xml,

224
00:11:36,275 --> 00:11:40,192
and it also connects the
xml to your Java code.

225
00:11:41,301 --> 00:11:43,373
Now the other thing the plugin does,

226
00:11:43,373 --> 00:11:46,421
is that it validates the xml

227
00:11:46,421 --> 00:11:50,175
in a far stricter form than we had before.

228
00:11:50,175 --> 00:11:54,677
Now up until now, we've only
had validation along the lines

229
00:11:54,677 --> 00:11:59,579
of if we type in a tag name
wrong, let's say I, I don't know

230
00:11:59,579 --> 00:12:03,075
put a space in there,
then we would immediately

231
00:12:03,075 --> 00:12:07,967
get an error because the
xml isn't valid xml anymore.

232
00:12:07,967 --> 00:12:10,371
But the plugin goes a lot further.

233
00:12:10,371 --> 00:12:14,381
Let's say I type in a
class name incorrectly.

234
00:12:14,381 --> 00:12:18,541
So I'll put an obvious, deliberate
typing mistake in there.

235
00:12:18,541 --> 00:12:22,883
Previously, without the
IDE, this code would still

236
00:12:22,883 --> 00:12:26,123
have run and I would have had no errors.

237
00:12:26,123 --> 00:12:28,459
But I would get a runtime exception

238
00:12:28,459 --> 00:12:30,967
when it can't find that class.

239
00:12:30,967 --> 00:12:34,777
If I do a save I can
prove that by running it

240
00:12:34,777 --> 00:12:38,391
and it will run perfectly
well, but we're going to see

241
00:12:38,391 --> 00:12:41,715
and exception and it
will be a class not found

242
00:12:41,715 --> 00:12:43,653
exception at runtime.

243
00:12:43,653 --> 00:12:45,297
But I guess you've noticed by now,

244
00:12:45,297 --> 00:12:49,464
as soon as I save this xml,
I'm now seeing a big red X

245
00:12:51,301 --> 00:12:54,531
here in the gutter of the editor.

246
00:12:54,531 --> 00:12:57,865
There's also an error marker here and,

247
00:12:57,865 --> 00:13:01,475
perhaps most usefully of all,
if I click the problems tab,

248
00:13:01,475 --> 00:13:05,770
this is now showing up as
an error, class not found.

249
00:13:05,770 --> 00:13:08,195
Now that's great because
these type of typos

250
00:13:08,195 --> 00:13:12,362
can be really difficult to
debug without that plugin.

251
00:13:13,543 --> 00:13:17,181
So I'll revert that
error and save, and yeah.

252
00:13:17,181 --> 00:13:19,222
Now the error's gone away.

253
00:13:19,222 --> 00:13:22,577
Now perhaps the best
part of the Spring IDE

254
00:13:22,577 --> 00:13:24,577
is the graphical aspect.

255
00:13:25,834 --> 00:13:28,654
I can go into the Spring Explorer here,

256
00:13:28,654 --> 00:13:32,796
and if I right-click on
the application.xml entry,

257
00:13:32,796 --> 00:13:35,713
I can select Open Dependency Graph.

258
00:13:38,480 --> 00:13:40,313
Now this is wonderful.

259
00:13:41,274 --> 00:13:45,036
It's showing me here of course,
a graphical representation

260
00:13:45,036 --> 00:13:48,159
of my three bean definitions.

261
00:13:48,159 --> 00:13:51,172
And also how they're related.

262
00:13:51,172 --> 00:13:54,744
So I can see at a glance
that the purchasing service

263
00:13:54,744 --> 00:13:57,919
has a dependency of the account service

264
00:13:57,919 --> 00:13:59,919
and of the book service.

265
00:14:01,053 --> 00:14:03,609
Now okay at the moment my bean definitions

266
00:14:03,609 --> 00:14:06,003
aren't terribly complicated but

267
00:14:06,003 --> 00:14:08,559
in just two or three
sessions time on this course

268
00:14:08,559 --> 00:14:10,905
we're going to be
grappling with some fairly

269
00:14:10,905 --> 00:14:13,841
complicated graphs of beans.

270
00:14:13,841 --> 00:14:16,359
Now this is a read-only view.

271
00:14:16,359 --> 00:14:20,045
I can't drag any of these elements around,

272
00:14:20,045 --> 00:14:23,997
and I can't make any changes
to the connections here.

273
00:14:23,997 --> 00:14:27,549
But I can double-click on any of the boxes

274
00:14:27,549 --> 00:14:29,915
such as the purchasing service,

275
00:14:29,915 --> 00:14:34,082
and it takes me straight to
the relevant piece of xml.

276
00:14:35,035 --> 00:14:37,573
By going back to the picture
I can also right-click

277
00:14:37,573 --> 00:14:40,431
on the boxes and either go to the Java

278
00:14:40,431 --> 00:14:43,187
or the Configuration file.

279
00:14:43,187 --> 00:14:46,265
I can even do the same
thing for the arrow here.

280
00:14:46,265 --> 00:14:48,583
If I double-click on the arrow

281
00:14:48,583 --> 00:14:51,481
it will take me straight
to the part of the xml

282
00:14:51,481 --> 00:14:55,137
where that injection is happening.

283
00:14:55,137 --> 00:14:59,451
So this is really the
best part of the plugin.

284
00:14:59,451 --> 00:15:02,443
And we're going to be
constantly referring to it

285
00:15:02,443 --> 00:15:04,011
through the course.

286
00:15:04,011 --> 00:15:05,683
So the final thing to say is that

287
00:15:05,683 --> 00:15:10,329
this Spring IDE plugin
is specific to Eclipse.

288
00:15:10,329 --> 00:15:13,149
If you happen to be using
one of the other IDEs

289
00:15:13,149 --> 00:15:16,181
then the support for Spring varies.

290
00:15:16,181 --> 00:15:17,909
But at the time of recording,

291
00:15:17,909 --> 00:15:22,337
IntelliJ has really good
built-in support for Spring.

292
00:15:22,337 --> 00:15:25,709
You don't have to go and
download any particular plugins,

293
00:15:25,709 --> 00:15:29,851
and you get pretty much the
same support as we've seen here.

294
00:15:29,851 --> 00:15:32,518
There were plugins for NetBeans.

295
00:15:34,505 --> 00:15:37,838
But from Version 6.1 of NetBeans onwards

296
00:15:39,075 --> 00:15:41,658
Spring support is now built in.

297
00:15:43,521 --> 00:15:45,497
We're going to be using the Eclipse plugin

298
00:15:45,497 --> 00:15:47,797
through the rest of the
course but, obviously,

299
00:15:47,797 --> 00:15:49,887
if you're interested you can investigate

300
00:15:49,887 --> 00:15:54,037
the NetBeans and IntelliJ
support for yourself.

301
00:15:54,037 --> 00:15:57,097
Now to close, you might have heard of

302
00:15:57,097 --> 00:16:01,264
the SpringSource Tool Suite,
otherwise known as STS.

303
00:16:04,041 --> 00:16:05,733
Now I'm here at the webpage

304
00:16:05,733 --> 00:16:08,287
for the SpringSource Tool Suite.

305
00:16:08,287 --> 00:16:12,307
The URL has changed
considerably over the years.

306
00:16:12,307 --> 00:16:15,807
It's currently spring.io/tools.

307
00:16:18,225 --> 00:16:22,063
Now SpringSource Tool Suite was an attempt

308
00:16:22,063 --> 00:16:24,495
by the Spring people to create their own

309
00:16:24,495 --> 00:16:27,412
full-blown development environment.

310
00:16:28,409 --> 00:16:31,943
Now it is still Eclipse, but it's Eclipse

311
00:16:31,943 --> 00:16:34,641
with their own extensions added and,

312
00:16:34,641 --> 00:16:37,167
there are so many extensions added that

313
00:16:37,167 --> 00:16:39,619
it really does feel like a

314
00:16:39,619 --> 00:16:43,543
full-blown development
environment in it's own right.

315
00:16:43,543 --> 00:16:47,285
So in STS you will get the Spring IDE

316
00:16:47,285 --> 00:16:50,725
that we've used so far,
but they go a lot further

317
00:16:50,725 --> 00:16:53,869
and they add integration to web service,

318
00:16:53,869 --> 00:16:57,535
and a lot of other advanced features.

319
00:16:57,535 --> 00:17:01,497
This was originally a commercial project.

320
00:17:01,497 --> 00:17:04,253
You did have to pay for the STS.

321
00:17:04,253 --> 00:17:07,670
But from 2009 they made the product free.

322
00:17:09,011 --> 00:17:13,107
Not open-source, it's
still a commercial license,

323
00:17:13,107 --> 00:17:16,345
but it doesn't cost anything to download.

324
00:17:16,345 --> 00:17:19,965
I recommend that when
you're learning Spring

325
00:17:19,965 --> 00:17:23,243
for the first time that
you stay with a basic

326
00:17:23,243 --> 00:17:27,410
development environment and
maybe just the Spring IDE

327
00:17:28,429 --> 00:17:31,631
plugin that we've used in this chapter.

328
00:17:31,631 --> 00:17:34,433
Then, once you're on top of Spring,

329
00:17:34,433 --> 00:17:36,021
and you really understand it,

330
00:17:36,021 --> 00:17:40,637
then you can consider moving
across to the Spring Tool Suite

331
00:17:40,637 --> 00:17:43,297
and you'll get all of the
other advanced features

332
00:17:43,297 --> 00:17:47,297
such as integration to
Git and Maven and AspectJ

333
00:17:48,675 --> 00:17:51,553
and all of the features listed here.

334
00:17:51,553 --> 00:17:55,283
Now in my working life, a few
projects that I've worked with

335
00:17:55,283 --> 00:17:58,366
do use the STS suite and that's fine.

336
00:17:59,587 --> 00:18:02,579
It's worked well for them,
but probably most of the

337
00:18:02,579 --> 00:18:04,527
projects I've worked with are still

338
00:18:04,527 --> 00:18:06,860
using a regular Eclipse IDE.

339
00:18:08,241 --> 00:18:12,941
So I don't want you to think
that you have to use STS

340
00:18:12,941 --> 00:18:15,249
if you want to work with Spring.

341
00:18:15,249 --> 00:18:17,473
You really, really don't.

342
00:18:17,473 --> 00:18:19,933
But some projects find it valuable

343
00:18:19,933 --> 00:18:21,516
and find it useful.

344
00:18:22,821 --> 00:18:25,813
So you don't need the
SpringSource Tool Suite.

345
00:18:25,813 --> 00:18:28,949
It is just Eclipse with a lot of plugins

346
00:18:28,949 --> 00:18:30,699
including Spring IDE.

347
00:18:32,093 --> 00:18:34,781
I think most Spring
developers would benefit

348
00:18:34,781 --> 00:18:38,384
from using at least the Spring IDE though.

349
00:18:38,384 --> 00:18:41,766
And we'll be using it through the course.

350
00:18:41,766 --> 00:18:43,787
The problem with installing it is that

351
00:18:43,787 --> 00:18:48,025
over the years the URL for
the update site has changed,

352
00:18:48,025 --> 00:18:50,582
and there seems to be two alternatives now

353
00:18:50,582 --> 00:18:54,078
and sometimes one works and
sometimes the other works.

354
00:18:54,078 --> 00:18:57,911
We've used the springide.org
based site today.

355
00:18:58,759 --> 00:19:01,754
I hope it's worked for you,
and if you've had any problems,

356
00:19:01,754 --> 00:19:03,254
check out my blog.

357
00:19:04,213 --> 00:19:05,837
We can now validate our beans,

358
00:19:05,837 --> 00:19:08,540
which means we'll see errors in the IDE

359
00:19:08,540 --> 00:19:10,912
before we even run the code.

360
00:19:10,912 --> 00:19:13,827
And we can view a bean graph.

361
00:19:13,827 --> 00:19:15,565
And that's something that I'll rely on

362
00:19:15,565 --> 00:19:17,448
through this course.

363
00:19:17,448 --> 00:19:19,621
So we've completed the
basics of the course.

364
00:19:19,621 --> 00:19:22,816
We're going to start
integrating the databases in,

365
00:19:22,816 --> 00:19:25,580
but before then, it's time
for some more practical work

366
00:19:25,580 --> 00:19:27,956
where you can use the Spring IDE

367
00:19:27,956 --> 00:19:30,956
to add more beans to your container.

1
00:00:00,000 --> 00:00:04,526
(light instrumental music)

2
00:00:10,038 --> 00:00:11,923
- [Voiceover] This is the second of the

3
00:00:11,923 --> 00:00:14,257
practical chapters on the course.

4
00:00:14,257 --> 00:00:18,792
I'm going to switch back
across to our CRM system.

5
00:00:19,739 --> 00:00:23,537
So far we've implemented
two service classes.

6
00:00:23,537 --> 00:00:25,894
A customer management service

7
00:00:25,894 --> 00:00:29,017
and the diary management service.

8
00:00:29,017 --> 00:00:33,517
At the moment, these two
services work independently.

9
00:00:33,517 --> 00:00:35,759
The customer management service

10
00:00:35,759 --> 00:00:38,029
only deals with customers

11
00:00:38,029 --> 00:00:40,442
and the diary management service

12
00:00:40,442 --> 00:00:43,551
only records actions.

13
00:00:43,551 --> 00:00:45,544
In this chapter we're going to code

14
00:00:45,544 --> 00:00:48,697
a new use case or system feature.

15
00:00:48,697 --> 00:00:52,501
This is where we record a call.

16
00:00:52,501 --> 00:00:55,516
This is more complicated
than you might think

17
00:00:55,516 --> 00:00:58,260
because there are two steps involved.

18
00:00:58,260 --> 00:01:02,417
Firstly, we have to update
the customer service

19
00:01:02,417 --> 00:01:05,238
with the details of the new call.

20
00:01:05,238 --> 00:01:08,042
Now, we do have a method

21
00:01:08,042 --> 00:01:11,285
in that class called Record Call

22
00:01:11,285 --> 00:01:14,249
but that just records the fact

23
00:01:14,249 --> 00:01:17,030
that a customer called.

24
00:01:17,030 --> 00:01:21,384
We have more information
to store in this process.

25
00:01:21,384 --> 00:01:24,755
We also need to record
details of any actions

26
00:01:24,755 --> 00:01:29,006
that have arisen as a result of that call.

27
00:01:29,006 --> 00:01:32,766
Actions aren't stored in the
customer management service.

28
00:01:32,766 --> 00:01:35,022
They're held in the diary.

29
00:01:35,022 --> 00:01:38,713
So we're going to have a
second step where we update

30
00:01:38,713 --> 00:01:43,713
the diary service with any
actions from that call.

31
00:01:43,959 --> 00:01:47,023
Now what we could do is
implement this very simply

32
00:01:47,023 --> 00:01:51,004
with no real further
work by making the client

33
00:01:51,004 --> 00:01:54,515
call the customer management service first

34
00:01:54,515 --> 00:01:58,389
and then go on to call the
diary management service.

35
00:01:58,389 --> 00:01:59,890
Easy.

36
00:01:59,890 --> 00:02:02,243
Now that would be ok.

37
00:02:02,243 --> 00:02:04,524
There are different ways
of implementing anything

38
00:02:04,524 --> 00:02:06,825
but this isn't ideal.

39
00:02:06,825 --> 00:02:11,511
We've made the client more
complicated than it needs to be.

40
00:02:11,511 --> 00:02:15,138
All the client should be doing
is getting the information

41
00:02:15,138 --> 00:02:18,777
from the user and then
passing that information

42
00:02:18,777 --> 00:02:22,469
across to preferably a single method

43
00:02:22,469 --> 00:02:26,259
that I'd like to call Record Call.

44
00:02:26,259 --> 00:02:29,979
Having to code those two
steps into the client

45
00:02:29,979 --> 00:02:33,451
is making the client more
complicated than it needs to be.

46
00:02:33,451 --> 00:02:37,002
So that means that when we
want to change the client

47
00:02:37,002 --> 00:02:39,115
we're going to have to reimplement

48
00:02:39,115 --> 00:02:42,552
those new steps in the new client.

49
00:02:43,442 --> 00:02:45,642
By the way, it is very common

50
00:02:45,642 --> 00:02:48,251
to want to change clients.

51
00:02:48,251 --> 00:02:51,999
On this course we're
starting with a text-based

52
00:02:51,999 --> 00:02:56,199
console application but
of course in a real system

53
00:02:56,199 --> 00:02:59,009
we're going to want to
build maybe a webpage

54
00:02:59,009 --> 00:03:01,907
as a front end for the application.

55
00:03:01,907 --> 00:03:05,517
That's going to need new client code.

56
00:03:05,517 --> 00:03:07,740
Then we might want a GUI,

57
00:03:07,740 --> 00:03:10,258
a graphical user interface
for the front end

58
00:03:10,258 --> 00:03:13,392
or a web service or more likely these days

59
00:03:13,392 --> 00:03:15,986
a mobile phone front end.

60
00:03:15,986 --> 00:03:18,746
It goes on and on.

61
00:03:18,746 --> 00:03:20,980
Another way of doing this is we could make

62
00:03:20,980 --> 00:03:23,765
the existing Record Call method

63
00:03:23,765 --> 00:03:27,905
in the customer service go on to call

64
00:03:27,905 --> 00:03:32,487
the diary management's
Record Action method.

65
00:03:32,487 --> 00:03:34,119
So we'd effectively then be making

66
00:03:34,119 --> 00:03:37,875
the two services dependent on each other.

67
00:03:37,875 --> 00:03:41,463
Now that is a possible solution but for me

68
00:03:41,463 --> 00:03:44,014
it doesn't feel right either
because then we'd have

69
00:03:44,014 --> 00:03:46,696
these two services which were previously

70
00:03:46,696 --> 00:03:48,666
independent of each other,

71
00:03:48,666 --> 00:03:52,255
we'd now have them tied together.

72
00:03:52,255 --> 00:03:54,758
So the way that we are
going to implement this

73
00:03:54,758 --> 00:03:56,757
is very similar to what we did in

74
00:03:56,757 --> 00:03:59,758
the theory sessions on the course.

75
00:03:59,758 --> 00:04:03,039
We're going to include
a third service class

76
00:04:03,039 --> 00:04:07,246
which I'm calling here
Call Handling Service.

77
00:04:07,246 --> 00:04:09,751
Now this is going to be
responsible for handling

78
00:04:09,751 --> 00:04:13,732
the work flow involved in managing calls.

79
00:04:13,732 --> 00:04:17,771
In our case it's those
two steps in a process.

80
00:04:17,771 --> 00:04:22,251
So we can have a method
called Record Call in there

81
00:04:22,251 --> 00:04:25,997
and that's going to be
implemented by step one,

82
00:04:25,997 --> 00:04:28,758
call the customer management service

83
00:04:28,758 --> 00:04:31,248
and just coincidentally really,

84
00:04:31,248 --> 00:04:34,516
the method in there is
called Record Call as well.

85
00:04:34,516 --> 00:04:38,220
That's fine and then in step two

86
00:04:38,220 --> 00:04:40,983
we'll call the diary management services

87
00:04:40,983 --> 00:04:43,506
Record Action method.

88
00:04:43,506 --> 00:04:46,737
So now the customer management service

89
00:04:46,737 --> 00:04:48,992
and the diary management service

90
00:04:48,992 --> 00:04:52,001
are not tied together directly.

91
00:04:52,001 --> 00:04:56,278
They're now dependencies of
the call handling service.

92
00:04:56,278 --> 00:04:58,752
So I think this is cleanest solution.

93
00:04:58,752 --> 00:05:00,503
The client remains simple.

94
00:05:00,503 --> 00:05:02,251
It's going to make a single call

95
00:05:02,251 --> 00:05:06,245
to the call management service
or the call handling service

96
00:05:06,245 --> 00:05:08,377
but the customer management service

97
00:05:08,377 --> 00:05:12,764
and diary management service
are unaffected by this change.

98
00:05:12,764 --> 00:05:16,757
They remain uncoupled and
can still work on their own.

99
00:05:18,247 --> 00:05:21,498
The call handling service
is going to be quite easy

100
00:05:21,498 --> 00:05:23,911
to implement because it's delegating

101
00:05:23,911 --> 00:05:27,244
most of the work to the existing classes.

102
00:05:27,244 --> 00:05:30,504
So really if you like, this
call handling service is there

103
00:05:30,504 --> 00:05:35,478
to capture the work
flow of handling calls.

104
00:05:35,478 --> 00:05:37,531
We're also going to have a good place now

105
00:05:37,531 --> 00:05:41,778
to handle any future call
handling requirements.

106
00:05:41,778 --> 00:05:43,418
Well I can't think of any right now

107
00:05:43,418 --> 00:05:46,503
but I bet we'll get some before long.

108
00:05:46,503 --> 00:05:50,749
Back in Eclipse you will need
to have your CRM system open.

109
00:05:50,749 --> 00:05:55,249
So either open the work space
that you have that project in.

110
00:05:55,249 --> 00:05:58,514
Now for me, I have all of my projects

111
00:05:58,514 --> 00:05:59,988
in the same work space.

112
00:05:59,988 --> 00:06:02,259
So to keep things tidy I'm going to close

113
00:06:02,259 --> 00:06:05,258
the bookstore project,

114
00:06:05,258 --> 00:06:08,029
the one that I'm using for the theory,

115
00:06:08,969 --> 00:06:13,969
and I'll close any open
files here with Close All.

116
00:06:14,242 --> 00:06:17,014
Then I'll right click on the CRM system

117
00:06:17,014 --> 00:06:20,452
and open that project.

118
00:06:20,452 --> 00:06:24,272
You may not have noticed
but in your project

119
00:06:24,272 --> 00:06:27,409
there is a third interface

120
00:06:27,409 --> 00:06:32,035
in the services.calls package.

121
00:06:33,015 --> 00:06:34,505
This one here

122
00:06:34,505 --> 00:06:38,015
and it's called Call Handling Service.

123
00:06:38,015 --> 00:06:39,997
Now we haven't used it so far.

124
00:06:39,997 --> 00:06:42,766
So here is the interface and there is

125
00:06:42,766 --> 00:06:44,755
the single method that we're implementing

126
00:06:44,755 --> 00:06:48,522
in this chapter called Record Call.

127
00:06:48,522 --> 00:06:51,880
We have then three tasks to complete.

128
00:06:51,880 --> 00:06:55,340
Firstly, you need to
implement this service

129
00:06:55,340 --> 00:06:57,853
and you need to make the two other

130
00:06:57,853 --> 00:07:02,269
existing services
dependencies of this class.

131
00:07:03,279 --> 00:07:04,927
Now of course you're
going to need to write

132
00:07:04,927 --> 00:07:07,559
some XML to make that happen.

133
00:07:07,559 --> 00:07:11,636
You can use either setter
or constructor injection.

134
00:07:11,636 --> 00:07:15,740
I don't mind but as these
are required dependencies,

135
00:07:15,740 --> 00:07:19,549
the code won't work if you
forget either of the dependencies

136
00:07:19,549 --> 00:07:22,777
so I'm going to use constructor injection

137
00:07:22,777 --> 00:07:26,498
in the solution video
and I'll also be using

138
00:07:26,498 --> 00:07:30,552
the SpringIDE to check the dependencies.

139
00:07:30,552 --> 00:07:32,757
So I'd like to encourage you

140
00:07:32,757 --> 00:07:35,765
to do the same in this practical.

141
00:07:35,765 --> 00:07:38,222
You'll find more details on the practical

142
00:07:38,222 --> 00:07:40,434
in the practical's PDF guide.

143
00:07:40,434 --> 00:07:42,746
There's also a sample solution

144
00:07:42,746 --> 00:07:45,768
in the practicals in code folder.

145
00:07:45,768 --> 00:07:48,201
Pause the video now and have a go

146
00:07:48,201 --> 00:07:50,527
at implementing this for yourself.

147
00:07:50,527 --> 00:07:54,368
The rest of this video
is a full work solution

148
00:07:54,368 --> 00:07:57,058
which you can use if you have any problems

149
00:07:57,058 --> 00:08:00,802
but do try for yourself
first and good luck.

150
00:08:05,256 --> 00:08:08,525
So this is the work
solution for the second

151
00:08:08,525 --> 00:08:10,897
of our practicals on the course.

152
00:08:10,897 --> 00:08:13,498
The real purpose of this practical

153
00:08:13,498 --> 00:08:17,196
was to practice injecting objects

154
00:08:17,196 --> 00:08:20,812
as dependencies into a class.

155
00:08:20,812 --> 00:08:23,981
The first part of the
exercise was to provide

156
00:08:23,981 --> 00:08:26,774
an implementation of this interface

157
00:08:26,774 --> 00:08:29,758
called Call Handling Service.

158
00:08:29,758 --> 00:08:32,030
So I'll start there
and we're going to want

159
00:08:32,030 --> 00:08:37,030
this class to go into
services.calls package.

160
00:08:37,445 --> 00:08:40,264
So we'll put a new class in there.

161
00:08:40,264 --> 00:08:41,813
Now I'm going to call this

162
00:08:41,813 --> 00:08:46,259
Call Handling Service Impl

163
00:08:46,259 --> 00:08:48,006
or I-M-P-L.

164
00:08:48,006 --> 00:08:51,143
I think I've said this before
but this is an interesting one

165
00:08:51,143 --> 00:08:54,864
that this is a production
service implementation

166
00:08:54,864 --> 00:08:58,522
because we're not mocking
anything inside here.

167
00:08:58,522 --> 00:08:59,988
We're just doing two steps

168
00:08:59,988 --> 00:09:03,232
and we're delegating to two other services

169
00:09:03,232 --> 00:09:07,262
which may or may not be mocks themselves

170
00:09:07,262 --> 00:09:10,251
but this class itself, as far as I know,

171
00:09:10,251 --> 00:09:13,512
is going to be coded to
a production standard.

172
00:09:13,512 --> 00:09:15,738
So that's the name I've gone for

173
00:09:15,738 --> 00:09:18,270
and I want to add the interface.

174
00:09:19,270 --> 00:09:22,255
I just type a few of the letters in there.

175
00:09:22,255 --> 00:09:24,006
There's only one match now

176
00:09:24,006 --> 00:09:26,515
which is the call handling service.

177
00:09:26,515 --> 00:09:30,006
To save time you'll want to
leave this check box here ticked

178
00:09:30,006 --> 00:09:32,528
which will automatically create stubs

179
00:09:32,528 --> 00:09:36,455
for the methods in that interface.

180
00:09:36,455 --> 00:09:39,498
Ok so that's created a
skeleton implementation

181
00:09:39,498 --> 00:09:42,978
of Record Call but the
important thing really

182
00:09:42,978 --> 00:09:46,509
for the practical is these dependencies.

183
00:09:46,509 --> 00:09:48,505
We have two of them so
we're going to hold them as

184
00:09:48,505 --> 00:09:53,255
private attributes and the
first of them is the customer--

185
00:09:53,255 --> 00:09:56,353
I can't quite remember the
full name of the class.

186
00:09:56,353 --> 00:09:59,992
So I'm just using Ctrl and space there

187
00:09:59,992 --> 00:10:01,523
because I'm on a PC.

188
00:10:01,523 --> 00:10:04,246
It's Cmd and space on a Macintosh

189
00:10:04,246 --> 00:10:07,616
and I'm programming to the
interface so I'm looking for

190
00:10:07,616 --> 00:10:12,019
the customer management service interface.

191
00:10:12,019 --> 00:10:14,115
Now I know I've talked a lot about this

192
00:10:14,115 --> 00:10:16,215
on the theory sessions but it would be

193
00:10:16,215 --> 00:10:20,182
a really bad mistake to
use the mock implementation

194
00:10:20,182 --> 00:10:23,445
as the type there because
then we'd be locked

195
00:10:23,445 --> 00:10:26,895
to that mock implementation all the time.

196
00:10:26,895 --> 00:10:28,743
We can call this anything we like.

197
00:10:28,743 --> 00:10:31,665
I'm going to call this customer service

198
00:10:31,665 --> 00:10:33,584
and then I'm going to repeat the process

199
00:10:33,584 --> 00:10:35,092
of the second of the services.

200
00:10:35,092 --> 00:10:37,492
That's the diary service.

201
00:10:37,492 --> 00:10:40,742
So again I'm using Ctrl and space

202
00:10:40,742 --> 00:10:44,269
and being careful to select the interface.

203
00:10:44,269 --> 00:10:47,764
I'll call that one the diary service.

204
00:10:47,764 --> 00:10:51,202
If you wanted to use setter injection

205
00:10:51,202 --> 00:10:53,482
then you'd now go ahead and create

206
00:10:53,482 --> 00:10:57,288
a pair of set methods but as I mentioned

207
00:10:57,288 --> 00:11:01,269
as we always need these
dependencies to be injected

208
00:11:01,269 --> 00:11:04,035
we can't tolerate nulls.

209
00:11:04,035 --> 00:11:07,528
I'm going to make this
a constructor injection.

210
00:11:07,528 --> 00:11:11,260
Now this is the second
edition of this course

211
00:11:11,260 --> 00:11:14,254
and way back when I
recorded the first edition,

212
00:11:14,254 --> 00:11:16,496
I used setter injections.

213
00:11:16,496 --> 00:11:21,252
So I do want to stress that
it's not a great big deal.

214
00:11:21,252 --> 00:11:24,026
Some people get very excited

215
00:11:24,026 --> 00:11:26,369
and angry about this

216
00:11:26,369 --> 00:11:28,985
but I don't think it's
worth sweating about

217
00:11:28,985 --> 00:11:31,740
but it is slightly more elegant I think

218
00:11:31,740 --> 00:11:35,325
to use constructor injection.

219
00:11:35,325 --> 00:11:38,497
Notice it really doesn't matter what names

220
00:11:38,497 --> 00:11:41,513
I'm giving to the local variables here.

221
00:11:41,513 --> 00:11:43,264
The implementation of this

222
00:11:43,264 --> 00:11:45,022
is going to be very straight forward.

223
00:11:45,022 --> 00:11:47,517
We're going to set the customer service

224
00:11:47,517 --> 00:11:49,836
to be to whatever is passed in

225
00:11:49,836 --> 00:11:53,002
and the diary service similarly.

226
00:11:53,002 --> 00:11:55,906
So that has now effectively set up

227
00:11:55,906 --> 00:11:59,972
constructor injection for this class.

228
00:11:59,972 --> 00:12:02,012
Let's go head now and implement

229
00:12:02,012 --> 00:12:05,701
the Record Call method.

230
00:12:05,701 --> 00:12:07,266
Now I'll just tidy up

231
00:12:07,266 --> 00:12:11,046
this generated stub here.

232
00:12:11,966 --> 00:12:14,247
Just to remind myself,

233
00:12:14,247 --> 00:12:16,257
as I mentioned, there were two steps here.

234
00:12:16,257 --> 00:12:21,257
Step one is we need to call the
customer management service,

235
00:12:21,730 --> 00:12:23,632
I'll just call it customer service,

236
00:12:23,632 --> 00:12:27,242
to record the call and then in step two

237
00:12:27,242 --> 00:12:30,523
we need to call the diary service

238
00:12:30,523 --> 00:12:34,255
to record the actions.

239
00:12:34,255 --> 00:12:36,975
So I think step one is
going to be quite easy

240
00:12:36,975 --> 00:12:40,977
because on the customer service

241
00:12:40,977 --> 00:12:43,751
we have a method in there called--

242
00:12:43,751 --> 00:12:46,759
I hope we do, Record Call.

243
00:12:46,759 --> 00:12:50,243
The parameters we need in
there are the customer ID.

244
00:12:50,243 --> 00:12:52,004
Well that's easy because that's being

245
00:12:52,004 --> 00:12:54,490
passed into this method.

246
00:12:54,490 --> 00:12:56,990
For the call details,

247
00:12:56,990 --> 00:12:59,490
well that's the call object

248
00:12:59,490 --> 00:13:04,225
which we called in the
parameter list New Call.

249
00:13:04,225 --> 00:13:05,830
So that's really easy.

250
00:13:05,830 --> 00:13:08,273
That's just a one liner.

251
00:13:08,273 --> 00:13:10,858
Step two is a little bit harder though.

252
00:13:10,858 --> 00:13:13,790
If we have a look in the diary service,

253
00:13:16,000 --> 00:13:20,009
the method there is called Record Action.

254
00:13:20,009 --> 00:13:23,489
Just a singular action whereas we've been

255
00:13:23,489 --> 00:13:27,017
passed a collection of actions.

256
00:13:27,017 --> 00:13:29,986
Well this is really just standard Java.

257
00:13:29,986 --> 00:13:32,973
So I don't know how you would handle this

258
00:13:32,973 --> 00:13:35,755
but I think really all we're looking for

259
00:13:35,755 --> 00:13:40,506
is we'll loop around the
collection of actions

260
00:13:40,506 --> 00:13:45,467
and I'll just call each
variable Next Action.

261
00:13:45,467 --> 00:13:49,784
That's from the actions and inside there

262
00:13:49,784 --> 00:13:53,258
we call the diary services Record Action

263
00:13:53,258 --> 00:13:57,489
passing in that next action.

264
00:13:57,489 --> 00:13:59,877
Not too complicated and by the way,

265
00:13:59,877 --> 00:14:02,754
if this customer ID does not exist,

266
00:14:02,754 --> 00:14:05,649
then the customer service
will throw an exception.

267
00:14:05,649 --> 00:14:08,500
Customer not found
exception but that's ok.

268
00:14:08,500 --> 00:14:10,059
We don't have to catch it here

269
00:14:10,059 --> 00:14:14,584
because we've declared it in
the signature of the method.

270
00:14:14,584 --> 00:14:19,584
So it will propagate back to
the client if that gets thrown.

271
00:14:19,776 --> 00:14:21,628
The next step in the process then

272
00:14:21,628 --> 00:14:25,279
is we need to set up our XML.

273
00:14:26,769 --> 00:14:30,506
So we'll go into the application.xml

274
00:14:30,506 --> 00:14:32,620
and I'll maximize that.

275
00:14:32,620 --> 00:14:36,414
This is the third of the beams
we've created on the course.

276
00:14:36,414 --> 00:14:38,484
You can call the beam anything you like.

277
00:14:38,484 --> 00:14:42,268
I will call this Call Service

278
00:14:42,268 --> 00:14:45,479
and the class is the fully qualified

279
00:14:46,489 --> 00:14:49,379
class name that we just wrote so for me

280
00:14:49,379 --> 00:14:53,746
that's
com.virtualpairprogrammers.services.

281
00:14:53,746 --> 00:14:58,203
I think it's calls plural and then

282
00:14:58,203 --> 00:15:01,083
call handling service import.

283
00:15:05,483 --> 00:15:07,137
For the first time in the practical

284
00:15:07,137 --> 00:15:10,878
we have a property to inject.

285
00:15:10,878 --> 00:15:13,007
Well actually I should say

286
00:15:13,007 --> 00:15:15,497
I've used constructor injections

287
00:15:15,497 --> 00:15:18,244
so we have a pair of arguments

288
00:15:18,244 --> 00:15:20,608
to pass into the constructor.

289
00:15:20,608 --> 00:15:23,483
So we use the constructor arg tag

290
00:15:23,483 --> 00:15:26,582
and that's going to be referring to

291
00:15:26,582 --> 00:15:29,086
the customer service beam.

292
00:15:29,086 --> 00:15:31,252
Notice I'm getting a pop up here

293
00:15:31,252 --> 00:15:34,268
and that's because I've got
the SpringIDE installed.

294
00:15:34,268 --> 00:15:37,687
I don't think I mentioned
that in the theory session.

295
00:15:37,687 --> 00:15:40,402
So we've got to inject
into the constructor

296
00:15:40,402 --> 00:15:42,767
the customer service.

297
00:15:43,727 --> 00:15:47,269
That's good and we also have to inject

298
00:15:48,229 --> 00:15:52,558
the diary service.

299
00:15:53,788 --> 00:15:56,502
I'm sure I mentioned
this on the earlier video

300
00:15:56,502 --> 00:15:58,250
but it doesn't matter what order

301
00:15:58,250 --> 00:16:00,697
these constructor arguments go

302
00:16:00,697 --> 00:16:02,933
because Spring will just work out

303
00:16:02,933 --> 00:16:05,738
which one is which by comparing the types

304
00:16:05,738 --> 00:16:08,775
that are required by the constructor.

305
00:16:08,775 --> 00:16:11,311
Only if you have a clash here

306
00:16:11,311 --> 00:16:14,993
and you've got two
objects of the same type

307
00:16:14,993 --> 00:16:17,919
then you have to put an index in place.

308
00:16:17,919 --> 00:16:21,016
I don't actually need that closing tag.

309
00:16:21,016 --> 00:16:25,263
I can do it like that instead.

310
00:16:25,263 --> 00:16:27,013
Well I think that's all of the XML

311
00:16:27,013 --> 00:16:29,504
we need for this practical.

312
00:16:29,504 --> 00:16:31,991
So all that remains now is to test

313
00:16:31,991 --> 00:16:33,747
everything hangs together properly.

314
00:16:33,747 --> 00:16:37,259
So I'm going to go into
my simple client test.

315
00:16:37,259 --> 00:16:39,378
Don't worry that this code is going to

316
00:16:39,378 --> 00:16:41,454
start getting a bit messy.

317
00:16:41,454 --> 00:16:43,527
This is just a bit of a playground.

318
00:16:43,527 --> 00:16:46,551
It's a sandbox where we
can just try things out.

319
00:16:46,551 --> 00:16:50,252
It's not a formal test
or anything like that.

320
00:16:50,252 --> 00:16:52,081
Now at the moment we're looking at

321
00:16:52,081 --> 00:16:54,137
the customer management service

322
00:16:54,137 --> 00:16:57,561
and we're listing all of
the customers in the system.

323
00:16:57,561 --> 00:16:59,805
So I'm going to back off on that code.

324
00:16:59,805 --> 00:17:02,029
I'm going to take out where I'm calling

325
00:17:02,029 --> 00:17:05,327
get all customers and
I'm looping around them.

326
00:17:05,327 --> 00:17:08,438
I don't want to do that anymore.

327
00:17:08,438 --> 00:17:11,806
Do I need the lookup of
the customer service?

328
00:17:11,806 --> 00:17:14,157
Well, I'm not sure.

329
00:17:14,157 --> 00:17:17,003
I might need it later
but again just to be tidy

330
00:17:17,003 --> 00:17:19,703
I'll take it out just in case
because in this practical

331
00:17:19,703 --> 00:17:24,061
I want to be looking at
the call handling service.

332
00:17:25,011 --> 00:17:29,964
I'll just call that Call Service I think.

333
00:17:29,964 --> 00:17:32,497
I've got several ways I can do this

334
00:17:32,497 --> 00:17:35,988
but I'm going to need the Get Beam method.

335
00:17:35,988 --> 00:17:38,645
I think I prefer the typed version.

336
00:17:38,645 --> 00:17:42,990
So I'm just looking up the
only beam in the container

337
00:17:42,990 --> 00:17:47,007
which is a type call handling service.

338
00:17:47,007 --> 00:17:48,762
So let's have a look at what we need to do

339
00:17:48,762 --> 00:17:50,775
to call the method in there.

340
00:17:50,775 --> 00:17:53,845
We have the Record Call method in there.

341
00:17:53,845 --> 00:17:55,649
First of all we've got to pass in

342
00:17:55,649 --> 00:17:59,495
the customer ID that made this call.

343
00:17:59,495 --> 00:18:03,777
Now I can't remember the customer IDs.

344
00:18:03,777 --> 00:18:06,759
So remember that's coded into our mock.

345
00:18:06,759 --> 00:18:10,017
So let's have a little peak
in our mock implementation.

346
00:18:10,017 --> 00:18:11,273
Well there's several of them.

347
00:18:11,273 --> 00:18:15,764
Let's go for the customer

348
00:18:15,764 --> 00:18:18,996
representing Acme Limited.

349
00:18:20,516 --> 00:18:23,408
I'll just copy that into place.

350
00:18:23,408 --> 00:18:26,268
We need to pass in a call object

351
00:18:26,268 --> 00:18:28,506
and any actions that are required.

352
00:18:28,506 --> 00:18:30,032
So it looks like we're going to have to do

353
00:18:30,032 --> 00:18:33,223
a little bit of Java object work.

354
00:18:33,223 --> 00:18:37,745
So I need call, which I'm
going to call New Call.

355
00:18:37,745 --> 00:18:40,660
The only parameter we
have to pass in there

356
00:18:40,660 --> 00:18:44,034
are the notes of the call.

357
00:18:44,034 --> 00:18:48,495
We've even got the Java doc
here giving this an example.

358
00:18:48,495 --> 00:18:51,790
So I don't know what
to put in here really.

359
00:18:51,790 --> 00:18:56,574
I'll just say Larry Wall called from Acme.

360
00:19:02,011 --> 00:19:04,848
Now I need to be careful
when importing this call.

361
00:19:04,848 --> 00:19:07,065
If I do a Ctrl + Shift + O

362
00:19:07,065 --> 00:19:09,485
there is another call on the class path.

363
00:19:09,485 --> 00:19:11,024
Be careful not to choose that one.

364
00:19:11,024 --> 00:19:15,458
You definitely want the
Virtual Pair Programmers call.

365
00:19:15,458 --> 00:19:19,488
That's ok but we also need some actions.

366
00:19:19,488 --> 00:19:22,749
So let's say that in result of this call

367
00:19:22,749 --> 00:19:25,999
we need to record two separate actions.

368
00:19:25,999 --> 00:19:30,505
So I'll instantiate our first one.

369
00:19:30,505 --> 00:19:33,067
Again I need to be
careful with the import.

370
00:19:33,067 --> 00:19:35,247
There's lots of actions on the class path.

371
00:19:35,247 --> 00:19:38,268
Again it's the Virtual
Pair Programmers action

372
00:19:38,268 --> 00:19:40,280
that we need here.

373
00:19:40,280 --> 00:19:42,023
We've got three parameters into here.

374
00:19:42,023 --> 00:19:45,508
We've got the details which are--

375
00:19:45,508 --> 00:19:46,934
It doesn't really matter.

376
00:19:46,934 --> 00:19:49,027
Call back Larry

377
00:19:50,018 --> 00:19:54,754
to ask how things are going.

378
00:19:54,754 --> 00:19:56,258
The second parameter is--

379
00:19:56,258 --> 00:19:59,021
Oh no, it's a calendar.

380
00:19:59,021 --> 00:20:01,483
We need to record the required by date

381
00:20:01,483 --> 00:20:05,367
and I absolutely hate using
the Java calendar classes.

382
00:20:05,367 --> 00:20:07,514
Because this is a date in the future

383
00:20:07,514 --> 00:20:09,248
I'm going to have to instantiate

384
00:20:09,248 --> 00:20:12,774
an instance of the
Gregorian calendar I think

385
00:20:12,774 --> 00:20:14,910
and the parameters into that.

386
00:20:14,910 --> 00:20:16,927
Well I haven't installed the Java docs

387
00:20:16,927 --> 00:20:19,953
for the JDK here so I can't remember

388
00:20:19,953 --> 00:20:21,616
exactly what the parameters are

389
00:20:21,616 --> 00:20:23,749
but I think it's the year

390
00:20:23,749 --> 00:20:27,261
followed by the month which is zero-based

391
00:20:27,261 --> 00:20:29,747
and the day which is zero-based.

392
00:20:29,747 --> 00:20:34,446
So I think that should be
the first of January 2016

393
00:20:34,446 --> 00:20:37,993
and if it isn't well nevermind.

394
00:20:37,993 --> 00:20:40,393
Just make sure that's imported

395
00:20:40,393 --> 00:20:43,492
and then we have I
think a third parameter.

396
00:20:43,492 --> 00:20:47,262
Now this is the owning user
which is just a string.

397
00:20:47,262 --> 00:20:51,094
So this is presumably
the login ID of the user.

398
00:20:51,094 --> 00:20:55,524
So I'll just put in my
usual login ID which is RAC

399
00:20:55,524 --> 00:20:58,266
for Richard Alexander Chesterwood.

400
00:20:58,266 --> 00:21:00,894
Ok so that's one action
and I need to repeat

401
00:21:00,894 --> 00:21:04,514
the same tedious process all over again.

402
00:21:05,494 --> 00:21:10,036
Check our sales department to make sure

403
00:21:10,986 --> 00:21:14,264
Larry is being tracked.

404
00:21:14,264 --> 00:21:16,271
I don't know where that came from

405
00:21:16,271 --> 00:21:18,741
and I need another one of these

406
00:21:18,741 --> 00:21:21,808
silly Gregorian calendars.

407
00:21:23,248 --> 00:21:24,769
I think I'll record the same date

408
00:21:24,769 --> 00:21:27,253
in there just for speed.

409
00:21:27,253 --> 00:21:30,760
Again, the owning user will be me.

410
00:21:32,950 --> 00:21:35,308
There's two actions and in order to pass

411
00:21:35,308 --> 00:21:37,967
this collection of actions into the method

412
00:21:37,967 --> 00:21:40,295
I'm going to need to create a collection.

413
00:21:40,295 --> 00:21:43,003
So I'm going to go for a list

414
00:21:44,723 --> 00:21:48,052
and I won't commentate

415
00:21:48,052 --> 00:21:51,218
too much here because I'm assuming

416
00:21:51,218 --> 00:21:54,252
you're familiar with Java collections.

417
00:21:55,702 --> 00:21:59,072
It's rather long winded.

418
00:22:00,494 --> 00:22:04,529
I'll just make sure they're
imported from Java.util.

419
00:22:07,249 --> 00:22:09,513
Our first action

420
00:22:09,513 --> 00:22:14,513
and our second action.

421
00:22:14,673 --> 00:22:16,843
Ok now one compiler error here

422
00:22:16,843 --> 00:22:18,634
and that's because this method

423
00:22:18,634 --> 00:22:20,512
might throw an exception

424
00:22:20,512 --> 00:22:23,504
which is the customer not found exception.

425
00:22:23,504 --> 00:22:28,416
If I get this ID here wrong

426
00:22:28,416 --> 00:22:30,995
then it will throw that exception.

427
00:22:30,995 --> 00:22:33,300
So we'll have a triblock

428
00:22:37,460 --> 00:22:41,762
but we need to catch the
customer not found exception.

429
00:22:47,262 --> 00:22:49,524
Easy to deal with.

430
00:22:49,524 --> 00:22:54,277
That customer doesn't exist

431
00:22:54,277 --> 00:22:56,939
will be enough.

432
00:22:57,938 --> 00:22:59,041
I'll need to make sure that

433
00:22:59,041 --> 00:23:01,236
that's imported as well.

434
00:23:01,236 --> 00:23:04,741
So we have a very basic test harness here

435
00:23:04,741 --> 00:23:06,750
but it should throw up any errors

436
00:23:06,750 --> 00:23:09,408
that I might have in the XML.

437
00:23:09,408 --> 00:23:12,511
Well actually what I can of
course do before running this

438
00:23:12,511 --> 00:23:17,260
is to use the SpringIDE instead.

439
00:23:17,260 --> 00:23:19,988
Now this project is the same project

440
00:23:19,988 --> 00:23:21,992
I was working with earlier in the course

441
00:23:21,992 --> 00:23:25,751
and I haven't yet made
this a Spring project.

442
00:23:25,751 --> 00:23:28,400
So as on the theory session,

443
00:23:28,400 --> 00:23:30,272
I'll need to right click here.

444
00:23:30,272 --> 00:23:33,750
Oh I'm sorry, you can't see
the Spring tools item there.

445
00:23:33,750 --> 00:23:36,753
I'll just move my IDE up a little bit

446
00:23:36,753 --> 00:23:39,005
so the camera catches it.

447
00:23:39,005 --> 00:23:42,957
Spring tools and Add
Spring Project Nature.

448
00:23:42,957 --> 00:23:45,523
Of course if you haven't
installed the plugin

449
00:23:45,523 --> 00:23:47,247
then you will need to
go through the process

450
00:23:47,247 --> 00:23:50,872
I showed you on the earlier video.

451
00:23:50,872 --> 00:23:54,272
Now I'll need to go to
the project properties

452
00:23:55,732 --> 00:23:58,500
and the Spring tag.

453
00:24:00,213 --> 00:24:02,290
Beam Support.

454
00:24:06,230 --> 00:24:09,724
I need to add in this application.xml.

455
00:24:09,724 --> 00:24:12,134
I think we should tick the enable support

456
00:24:12,134 --> 00:24:15,001
for import element because
we will be using that

457
00:24:15,001 --> 00:24:16,760
at some point on this course.

458
00:24:16,760 --> 00:24:19,786
I don't know when but some point soon.

459
00:24:19,786 --> 00:24:22,208
So the Spring explorer is working now

460
00:24:22,208 --> 00:24:24,257
and you can play around with it as I did

461
00:24:24,257 --> 00:24:26,561
on the videos but the
thing I really want to see

462
00:24:26,561 --> 00:24:30,035
is the dependency graph and great.

463
00:24:30,035 --> 00:24:31,725
That's the kind of
thing we're looking for.

464
00:24:31,725 --> 00:24:36,253
We want to see the two
connections correctly wired up.

465
00:24:36,253 --> 00:24:38,517
Well that's good.

466
00:24:40,037 --> 00:24:44,042
We can now go into the
clients and see if this runs.

467
00:24:46,982 --> 00:24:50,480
Ok well we have the usual logging warning.

468
00:24:50,480 --> 00:24:54,988
The program has terminated
with no exceptions.

469
00:24:54,988 --> 00:24:58,265
Can't really see if that
did anything useful though.

470
00:24:58,265 --> 00:25:00,496
So I think what I ought
to do first of all,

471
00:25:00,496 --> 00:25:04,984
I'll put in a non-existent
customer ID into here.

472
00:25:05,954 --> 00:25:09,880
It's worth checking that and good.

473
00:25:09,880 --> 00:25:13,299
That's telling me the
customer doesn't exist.

474
00:25:13,299 --> 00:25:17,012
I'll now undo that change
but to see if this worked

475
00:25:17,012 --> 00:25:19,527
I think it's worth at the end

476
00:25:19,527 --> 00:25:24,416
of the test harness I'm going to print out

477
00:25:24,416 --> 00:25:29,054
a list of all of the outstanding
actions from the diary.

478
00:25:29,054 --> 00:25:34,054
Here are the outstanding actions.

479
00:25:34,224 --> 00:25:38,763
To do that, I need to
call the diary service.

480
00:25:38,763 --> 00:25:42,310
At the moment, I've only got
a handle on the call service

481
00:25:42,310 --> 00:25:45,260
but I hope it's clear that just because

482
00:25:45,260 --> 00:25:47,545
we've now tied the services together,

483
00:25:47,545 --> 00:25:50,624
there is nothing to
stop me getting hold of

484
00:25:50,624 --> 00:25:54,228
the diary management service directly

485
00:25:54,228 --> 00:25:57,984
and calling its methods.

486
00:25:57,984 --> 00:26:01,000
You do the same with the
customer service as well.

487
00:26:01,000 --> 00:26:04,056
I don't need to in this
case but I could do.

488
00:26:08,216 --> 00:26:10,655
So I'm using Get Beam again.

489
00:26:10,655 --> 00:26:12,751
Using the interfaces.

490
00:26:12,751 --> 00:26:14,069
I could've done that down here

491
00:26:14,069 --> 00:26:18,002
but I just think it's
tidier to put it at the top.

492
00:26:18,002 --> 00:26:21,019
So we'll call the diary services

493
00:26:21,019 --> 00:26:24,750
Get All Incomplete Actions method.

494
00:26:24,750 --> 00:26:26,732
Now the parameter needed here

495
00:26:26,732 --> 00:26:30,032
is the required user
which is the same string

496
00:26:30,032 --> 00:26:34,527
that we used up here, RAC for me.

497
00:26:34,527 --> 00:26:38,779
Now that's going to return
a collection of actions.

498
00:26:46,229 --> 00:26:49,222
So I'll call that the Incomplete Actions

499
00:26:49,222 --> 00:26:52,713
and then we'll just loop around them.

500
00:27:04,753 --> 00:27:07,513
Just print out each one.

501
00:27:07,513 --> 00:27:11,769
Now this collection class
will need to be imported.

502
00:27:12,729 --> 00:27:15,053
I think this method returns
a collection anyway.

503
00:27:15,053 --> 00:27:16,007
Let me check that.

504
00:27:16,007 --> 00:27:19,525
If I click on that method and press F3

505
00:27:19,525 --> 00:27:20,661
it will bounce me there.

506
00:27:20,661 --> 00:27:24,770
Well, in fact it's declared
as returning a list.

507
00:27:24,770 --> 00:27:27,976
So I could have made

508
00:27:27,976 --> 00:27:29,736
this type be list

509
00:27:29,736 --> 00:27:31,265
but I don't know if you know this

510
00:27:31,265 --> 00:27:34,477
but collection is in fact the super type

511
00:27:34,477 --> 00:27:36,747
of list in the API.

512
00:27:36,747 --> 00:27:39,982
So that will work just fine.

513
00:27:39,982 --> 00:27:41,543
Well at least I think it will.

514
00:27:41,543 --> 00:27:44,744
That was quite a confident prediction.

515
00:27:44,744 --> 00:27:47,003
Hmm, no it didn't work.

516
00:27:47,003 --> 00:27:48,227
Ok, why not?

517
00:27:48,227 --> 00:27:50,238
The customer doesn't exist apparently.

518
00:27:50,238 --> 00:27:52,243
Well it did before.

519
00:27:52,243 --> 00:27:53,989
I wonder if I made a mistake

520
00:27:53,989 --> 00:27:57,283
when I was editing that
and I undid a change.

521
00:27:57,283 --> 00:28:00,508
If I go back to my

522
00:28:00,508 --> 00:28:03,746
customer management mock implementation.

523
00:28:03,746 --> 00:28:06,731
Yes I think I have, that was the ID.

524
00:28:06,731 --> 00:28:11,256
I think I've lost some
of the numbers off there.

525
00:28:11,256 --> 00:28:12,903
I think I missed the--

526
00:28:12,903 --> 00:28:15,991
Oh I don't know what
I did there but anyway

527
00:28:15,991 --> 00:28:17,745
I think it's fixed now.

528
00:28:17,745 --> 00:28:21,503
So let's see if that's running.

529
00:28:21,503 --> 00:28:22,999
That looks really good.

530
00:28:22,999 --> 00:28:25,269
It's telling us there are indeed

531
00:28:25,269 --> 00:28:27,502
two outstanding actions

532
00:28:27,502 --> 00:28:31,757
for the user called RAC.

533
00:28:31,757 --> 00:28:33,999
Ok well that's as far as I'm going to go

534
00:28:33,999 --> 00:28:35,490
with this work solution.

535
00:28:35,490 --> 00:28:37,733
Of course you could've done it differently

536
00:28:37,733 --> 00:28:40,530
and there must be thousands
of ways of doing it

537
00:28:40,530 --> 00:28:42,952
but I hope if you had any problems

538
00:28:42,952 --> 00:28:44,822
that this walk through has helped you.

539
00:28:44,822 --> 00:28:47,528
Of course if not, then
do feel free to send us

540
00:28:47,528 --> 00:28:50,520
a contact message through the website

541
00:28:50,520 --> 00:28:53,512
but if you have got this
far and you're happy

542
00:28:53,512 --> 00:28:55,504
then have a good break.

543
00:28:55,504 --> 00:28:57,974
We have lots more still
to come on the course.

544
00:28:57,974 --> 00:29:00,254
Believe me, before long this XML

545
00:29:00,254 --> 00:29:03,518
will get quite a bit more complicated.

1
00:00:00,886 --> 00:00:03,969
(light techno music)

2
00:00:10,673 --> 00:00:13,590
- [Voiceover] Hello, and welcome
back to the Spring course.

3
00:00:13,590 --> 00:00:15,458
It's time now, to turn our attention

4
00:00:15,458 --> 00:00:18,644
to Spring's database support.

5
00:00:18,644 --> 00:00:21,261
Now Spring supports a wide variety

6
00:00:21,261 --> 00:00:25,412
of database strategies for
accessing your database.

7
00:00:25,412 --> 00:00:27,647
I'll briefly introduce the main ones

8
00:00:27,647 --> 00:00:30,700
that are available in
Java, and I will be going

9
00:00:30,700 --> 00:00:33,049
into depth on all of
them through the course,

10
00:00:33,049 --> 00:00:36,799
but this chapter will
focus on standard JDBC.

11
00:00:38,160 --> 00:00:39,993
Well JDBC is horrible.

12
00:00:41,124 --> 00:00:44,845
I'm going to spend the first
20 minutes reviewing JDBC

13
00:00:44,845 --> 00:00:47,881
and why I think it's so horrible.

14
00:00:47,881 --> 00:00:52,526
I would never want to use this
on a real project directly,

15
00:00:52,526 --> 00:00:54,549
but if you already know JDBC

16
00:00:54,549 --> 00:00:58,454
then you probably won't want
to hear me moaning about it,

17
00:00:58,454 --> 00:01:02,331
so you could skip the first 20 minutes.

18
00:01:02,331 --> 00:01:06,331
But Spring's support for
JDBC makes JDBC usable,

19
00:01:08,162 --> 00:01:11,996
bearable and even sometimes pleasurable.

20
00:01:11,996 --> 00:01:16,378
So, we're going to create a
DAO, or data access object,

21
00:01:16,378 --> 00:01:18,773
and we'll wire it up.

22
00:01:18,773 --> 00:01:20,154
And once it's wired,

23
00:01:20,154 --> 00:01:24,982
I'll introduce you the
Spring JDBCTemplate class,

24
00:01:24,982 --> 00:01:28,552
this is the class that
gives us so much support.

25
00:01:28,552 --> 00:01:31,355
Remember that when we're
working on the BookStore,

26
00:01:31,355 --> 00:01:33,475
you can either follow along,

27
00:01:33,475 --> 00:01:35,958
or if you prefer you can just watch,

28
00:01:35,958 --> 00:01:39,236
because you will be getting
full practice on all of this

29
00:01:39,236 --> 00:01:41,986
when we switch to the CRM system.

30
00:01:43,441 --> 00:01:48,157
Now very wisely, the Spring
team decided not to implement

31
00:01:48,157 --> 00:01:51,447
their own database access technology.

32
00:01:51,447 --> 00:01:52,910
There are just too many

33
00:01:52,910 --> 00:01:56,692
tried and tested techniques
already available.

34
00:01:56,692 --> 00:01:58,025
We have J-D-B-C.

35
00:01:59,972 --> 00:02:01,732
Now, this library is probably

36
00:02:01,732 --> 00:02:04,482
one of the oldest Java libraries.

37
00:02:05,520 --> 00:02:09,687
At the time of this recording
it's very nearly 20 years old,

38
00:02:11,448 --> 00:02:13,985
so it's a long-established library

39
00:02:13,985 --> 00:02:16,762
with millions of lines of production code

40
00:02:16,762 --> 00:02:20,609
out there in the real
world depending on it.

41
00:02:20,609 --> 00:02:22,801
It's a solid API but,

42
00:02:22,801 --> 00:02:26,342
it really is a horrible API to work with,

43
00:02:26,342 --> 00:02:30,766
it's very low-level, but
it does at least work.

44
00:02:30,766 --> 00:02:33,849
More recently in Java we have the JPA

45
00:02:35,101 --> 00:02:37,434
or the Java Persistence API.

46
00:02:38,643 --> 00:02:43,131
This is an industry standard
technique for automating SQL,

47
00:02:43,131 --> 00:02:47,298
and removing the need to convert
database rows into objects,

48
00:02:48,165 --> 00:02:50,734
well amongst many other things.

49
00:02:50,734 --> 00:02:53,962
Several years ago a
developer called Gavin King

50
00:02:53,962 --> 00:02:57,175
wrote an open-source
framework called Hibernate,

51
00:02:57,175 --> 00:03:00,697
which took the Java world by storm.

52
00:03:00,697 --> 00:03:04,864
Today, JPA is the official
standard, but the Hibernate API

53
00:03:06,118 --> 00:03:10,335
is still used by many
projects around the world.

54
00:03:10,335 --> 00:03:13,051
Another choice that you
could use to simplify

55
00:03:13,051 --> 00:03:17,784
your database access is a
framework called myBatis.

56
00:03:17,784 --> 00:03:21,696
Now, this framework used
to be called iBatis,

57
00:03:21,696 --> 00:03:24,990
and we do have a chat coming
up on how to use this.

58
00:03:24,990 --> 00:03:27,044
Now there are lots more
of these frameworks

59
00:03:27,044 --> 00:03:28,961
out there in the Java world,

60
00:03:28,961 --> 00:03:31,526
but at the time of recording
this second edition

61
00:03:31,526 --> 00:03:33,727
of the course, these would be,

62
00:03:33,727 --> 00:03:36,955
I would think, the most commonly used.

63
00:03:36,955 --> 00:03:40,252
So, there are so many APIs out there

64
00:03:40,252 --> 00:03:43,308
to simplify database
access that Spring decided

65
00:03:43,308 --> 00:03:45,902
that instead of competing with them,

66
00:03:45,902 --> 00:03:50,069
they would simply provide support
built into Spring so that,

67
00:03:51,026 --> 00:03:54,451
whatever type of Spring
application you're writing,

68
00:03:54,451 --> 00:03:57,122
you can very easily integrate

69
00:03:57,122 --> 00:04:01,039
with your database access
technology of choice.

70
00:04:02,167 --> 00:04:04,901
So we'll be studying
these different approaches

71
00:04:04,901 --> 00:04:08,261
through the next few chapters
but, in this chapter,

72
00:04:08,261 --> 00:04:10,974
we'll be concentrating
on how you can improve

73
00:04:10,974 --> 00:04:13,307
your JDBC code using Spring.

74
00:04:15,029 --> 00:04:17,652
A quick review, this is
the kind of architecture

75
00:04:17,652 --> 00:04:20,653
that we've built so far on the course.

76
00:04:20,653 --> 00:04:24,570
We have a client calling
some server-side code,

77
00:04:26,232 --> 00:04:30,133
which we put in a class
called BookService,

78
00:04:30,133 --> 00:04:34,300
or rather we've implemented an
interface called BookService.

79
00:04:35,485 --> 00:04:37,461
And we don't yet have the knowledge

80
00:04:37,461 --> 00:04:40,721
to implement a proper BookService,

81
00:04:40,721 --> 00:04:42,632
so what we did in the previous chapters

82
00:04:42,632 --> 00:04:45,965
was we implemented this MockBookService,

83
00:04:47,211 --> 00:04:48,592
and that was a great idea,

84
00:04:48,592 --> 00:04:52,630
it allowed us to hard-code
in some stock data,

85
00:04:52,630 --> 00:04:54,958
so that we could test the client tier,

86
00:04:54,958 --> 00:04:58,395
we could test our Spring
XML, and all the rest of it,

87
00:04:58,395 --> 00:05:02,034
so we know our system is hanging together.

88
00:05:02,034 --> 00:05:06,201
But it's time now to get
rid of that MockBookService,

89
00:05:08,234 --> 00:05:12,401
and to switch it for a more
sophisticated implementation.

90
00:05:13,238 --> 00:05:17,405
I'm now going to write a
class called BookServiceImpl,

91
00:05:18,507 --> 00:05:20,090
or BookServiceImpl.

92
00:05:21,180 --> 00:05:24,389
This by the way is quite common
practice in Java projects,

93
00:05:24,389 --> 00:05:28,556
when you see a class with
just a plain, regular name

94
00:05:29,848 --> 00:05:32,931
followed by Impl, you're suggesting that

95
00:05:32,931 --> 00:05:37,559
this is the production
standard implementation.

96
00:05:37,559 --> 00:05:38,881
Now because in this chapter

97
00:05:38,881 --> 00:05:41,831
we're looking at using a database,

98
00:05:41,831 --> 00:05:45,680
the plan is that this BookServiceImpl

99
00:05:45,680 --> 00:05:49,597
is going to make calls
to a data access object.

100
00:05:51,226 --> 00:05:53,726
Now it's abbreviated as D-A-O,

101
00:05:55,182 --> 00:05:58,932
and you'll often hear
it pronounced as a DAO.

102
00:05:59,991 --> 00:06:03,169
Now the DAO is a long-standing pattern

103
00:06:03,169 --> 00:06:07,609
in Java programming circles
and, not just Java in fact,

104
00:06:07,609 --> 00:06:11,172
but certainly Java programmers
use the term a lot,

105
00:06:11,172 --> 00:06:14,667
and it's a really fairly simple idea.

106
00:06:14,667 --> 00:06:16,788
The idea is that we abstract

107
00:06:16,788 --> 00:06:19,778
all of our database operations

108
00:06:19,778 --> 00:06:21,445
into this DAO class.

109
00:06:24,358 --> 00:06:27,874
So, if for example we're calling JDBC,

110
00:06:27,874 --> 00:06:31,390
then we'd have all of our JDBC code

111
00:06:31,390 --> 00:06:33,640
encapsulated into that DAO.

112
00:06:34,813 --> 00:06:36,921
This means that if we need to change

113
00:06:36,921 --> 00:06:40,171
database technologies later, we can do so

114
00:06:40,171 --> 00:06:44,845
without affecting any of the
other tiers in our application.

115
00:06:44,845 --> 00:06:46,845
And because there are so many different

116
00:06:46,845 --> 00:06:49,775
database technologies available in Java

117
00:06:49,775 --> 00:06:52,708
it is quite a common
requirement for projects

118
00:06:52,708 --> 00:06:55,958
to possibly move across from using JDBC

119
00:06:57,375 --> 00:07:00,668
to, after a few years maybe going across

120
00:07:00,668 --> 00:07:02,900
to Hibernate or similar.

121
00:07:02,900 --> 00:07:04,908
Also, you're probably aware

122
00:07:04,908 --> 00:07:07,954
there's a lot of movement
in databases at the moment,

123
00:07:07,954 --> 00:07:12,121
with the emergence of big
data, and NoSQL databases,

124
00:07:13,288 --> 00:07:17,921
so, it really is a good idea
to have database access code

125
00:07:17,921 --> 00:07:21,265
encapsulated into a single layer.

126
00:07:21,265 --> 00:07:24,311
But it also means that
if we had a bug say,

127
00:07:24,311 --> 00:07:27,639
in one of our database operations,

128
00:07:27,639 --> 00:07:30,832
we would know the source of that fault,

129
00:07:30,832 --> 00:07:33,734
or at least we'd know
the source of the bug

130
00:07:33,734 --> 00:07:37,567
is going to be somewhere
in one of those DAOs.

131
00:07:38,840 --> 00:07:41,202
So, it's all about good tiering,

132
00:07:41,202 --> 00:07:44,217
good layering of our architecture.

133
00:07:44,217 --> 00:07:47,696
So, let's have a look at
the structure of this DAO.

134
00:07:47,696 --> 00:07:52,600
And really, in Java terms,
there's not a lot to say,

135
00:07:52,600 --> 00:07:55,967
it's just a plain Java interface.

136
00:07:55,967 --> 00:08:00,608
There's certainly no impact
from Spring here, at all.

137
00:08:00,608 --> 00:08:03,642
So, this is my first cut of the interface,

138
00:08:03,642 --> 00:08:07,809
I have a find allBooks
method, a findByIsbn method,

139
00:08:09,006 --> 00:08:12,117
a create book method, a delete book method

140
00:08:12,117 --> 00:08:14,114
and another find method as well,

141
00:08:14,114 --> 00:08:16,993
and this is what you
typically see in DAOs,

142
00:08:16,993 --> 00:08:20,410
just creates, reads, updates and deletes.

143
00:08:22,148 --> 00:08:25,385
Let's switch across to Eclipse,
and we'll have a first look

144
00:08:25,385 --> 00:08:28,116
at how this might be implemented.

145
00:08:28,116 --> 00:08:30,617
So here we are back in
Eclipse, and I'm assuming

146
00:08:30,617 --> 00:08:33,890
that you probably did
the CRM system project

147
00:08:33,890 --> 00:08:38,060
in the previous chapter,
in the worked example.

148
00:08:38,060 --> 00:08:40,287
So, we're back now to the BookStore,

149
00:08:40,287 --> 00:08:41,693
our kind of simpler system

150
00:08:41,693 --> 00:08:43,580
that we're just using for illustration,

151
00:08:43,580 --> 00:08:45,826
so, if you're in the same position as me

152
00:08:45,826 --> 00:08:49,493
you'll want to close
the CRM system project,

153
00:08:51,037 --> 00:08:55,188
and close any files that
you have open, here,

154
00:08:55,188 --> 00:08:58,688
and then we'll open the BookStore project.

155
00:09:01,482 --> 00:09:05,555
Now just to save time typing, off camera,

156
00:09:05,555 --> 00:09:08,222
I've implemented a data package.

157
00:09:09,108 --> 00:09:12,811
I've just created a new package
there, and inside there,

158
00:09:12,811 --> 00:09:16,477
I've already created the BookDao interface

159
00:09:16,477 --> 00:09:18,993
which is exactly the same code

160
00:09:18,993 --> 00:09:22,430
that you just saw on the previous caption.

161
00:09:22,430 --> 00:09:24,932
Now, you can either pause the video now

162
00:09:24,932 --> 00:09:27,023
and type this in for yourself,

163
00:09:27,023 --> 00:09:28,483
or I think probably I'd recommend,

164
00:09:28,483 --> 00:09:31,207
just go into the Starting Code folder,

165
00:09:31,207 --> 00:09:34,784
and you'll find a folder
in there for this chapter,

166
00:09:34,784 --> 00:09:38,951
and you can dig these two
files from the data folder.

167
00:09:40,036 --> 00:09:42,956
These are the only changes
I've made to the project,

168
00:09:42,956 --> 00:09:45,774
so the rest of it is exactly the same

169
00:09:45,774 --> 00:09:49,089
as when you last saw the BookStore.

170
00:09:49,089 --> 00:09:52,496
So the next obvious thing that
we need to do with this DAO

171
00:09:52,496 --> 00:09:56,652
is to come up with some kind
of implementation for it.

172
00:09:56,652 --> 00:10:00,319
Now to illustrate how
helpful Spring can be,

173
00:10:01,449 --> 00:10:04,866
I decided to implement this DAO interface

174
00:10:06,589 --> 00:10:08,589
using regular JDBC code.

175
00:10:10,623 --> 00:10:13,420
Now this is the kind of code
that you would have written

176
00:10:13,420 --> 00:10:17,684
if you'd done a Java Fundamentals
course like our course,

177
00:10:17,684 --> 00:10:21,851
or if you've used any of
the standard Java textbooks.

178
00:10:23,114 --> 00:10:25,108
I really have to,

179
00:10:25,108 --> 00:10:27,922
I'm gonna put a highlighter
on this comment at the top,

180
00:10:27,922 --> 00:10:31,563
I'm warning you here this
is not production standard,

181
00:10:31,563 --> 00:10:35,631
the aim is we're going to
improve this dramatically

182
00:10:35,631 --> 00:10:37,805
through the course of this chapter.

183
00:10:37,805 --> 00:10:39,634
So, please don't go assuming

184
00:10:39,634 --> 00:10:44,320
that you could use this
code in a real project.

185
00:10:44,320 --> 00:10:48,250
So, I'm just using this
as a kind of a before,

186
00:10:48,250 --> 00:10:52,417
so that you can see just
how useful Spring is being.

187
00:10:53,509 --> 00:10:57,676
Now, before I start, I do
have some compile errors

188
00:10:58,733 --> 00:11:02,275
in the project, there
are three errors here.

189
00:11:02,275 --> 00:11:03,604
And they're all related to,

190
00:11:03,604 --> 00:11:06,051
if I just double-click
on the first of them,

191
00:11:06,051 --> 00:11:09,194
you'll probably have the same
errors if you've just copied

192
00:11:09,194 --> 00:11:12,032
these two files across to your project,

193
00:11:12,032 --> 00:11:15,525
it's just that our Book
class currently doesn't have

194
00:11:15,525 --> 00:11:19,785
a getTitle, getAuthor and getPrice method.

195
00:11:19,785 --> 00:11:22,582
I didn't need those methods
in the earlier chapter,

196
00:11:22,582 --> 00:11:24,689
so they're not there.

197
00:11:24,689 --> 00:11:27,410
I can fix that really
easily, if I just left-click

198
00:11:27,410 --> 00:11:30,743
on the icon here, on the left-hand side,

199
00:11:32,108 --> 00:11:34,409
it will offer me a quick fix of,

200
00:11:34,409 --> 00:11:38,331
I'll create that method,
getTitle in the Book class,

201
00:11:38,331 --> 00:11:41,989
and it comes up with a skeleton
implementation of getTitle

202
00:11:41,989 --> 00:11:44,769
which I will just need to plug into here,

203
00:11:44,769 --> 00:11:47,102
the returning of this.title,

204
00:11:48,963 --> 00:11:50,885
and, well I think it's
actually going to be quicker

205
00:11:50,885 --> 00:11:54,552
to type it, so I'll
also implement getAuthor

206
00:12:04,723 --> 00:12:06,556
and finally, getPrice.

207
00:12:11,871 --> 00:12:13,927
All very dull, but it now looks like

208
00:12:13,927 --> 00:12:17,114
my compile errors have gone away.

209
00:12:17,114 --> 00:12:21,443
I'd like to quickly review
this implementation of the DAO.

210
00:12:21,443 --> 00:12:25,610
The name of the class I've
chosen is BookDaoHorridJdbcImpl,

211
00:12:27,611 --> 00:12:31,778
just to remind you, this
is a horrible set of code.

212
00:12:32,688 --> 00:12:34,204
Now I think we saw this earlier,

213
00:12:34,204 --> 00:12:38,371
but the database that we're
using for this course is HSQLDB,

214
00:12:39,301 --> 00:12:41,106
which is a good database to use

215
00:12:41,106 --> 00:12:43,924
if you're prototyping and testing.

216
00:12:43,924 --> 00:12:47,378
And it's great because
it will run in File mode,

217
00:12:47,378 --> 00:12:51,259
meaning all we need is
the HSQLDB JAR file,

218
00:12:51,259 --> 00:12:53,408
and we don't need to install a database,

219
00:12:53,408 --> 00:12:55,575
or configure a database,

220
00:12:55,575 --> 00:12:58,542
so we have that JAR file on the classpath,

221
00:12:58,542 --> 00:13:02,692
and buried in the code here
is the name of the driver,

222
00:13:02,692 --> 00:13:05,738
the URL, the database
that we're working with,

223
00:13:05,738 --> 00:13:07,639
which is going to result in a file

224
00:13:07,639 --> 00:13:10,889
called database.dat on our file system.

225
00:13:12,925 --> 00:13:14,275
So, quick review then,

226
00:13:14,275 --> 00:13:18,442
if we have a look in the
constructor of this class,

227
00:13:19,409 --> 00:13:22,705
this is where we're setting
up the driver using this

228
00:13:22,705 --> 00:13:27,411
quite old-fashioned form of
setting up a driver in JDBC.

229
00:13:27,411 --> 00:13:30,183
Now, just in case you
haven't seen JDBC before,

230
00:13:30,183 --> 00:13:32,380
this is a bit of a routine line of code

231
00:13:32,380 --> 00:13:35,894
that you have to type
in just to force the JVM

232
00:13:35,894 --> 00:13:39,061
to load this driver class into memory.

233
00:13:40,364 --> 00:13:43,772
It's a bit of a strange one,
you don't instantiate class,

234
00:13:43,772 --> 00:13:46,549
you just make it load into memory,

235
00:13:46,549 --> 00:13:49,161
it's quite strange really.

236
00:13:49,161 --> 00:13:51,956
But, what I'm going to do
here is I'm going to call

237
00:13:51,956 --> 00:13:55,600
a private method called createTables,

238
00:13:55,600 --> 00:13:59,515
which is just a little further down here,

239
00:13:59,515 --> 00:14:02,111
and as the comment says,
I've added this method

240
00:14:02,111 --> 00:14:06,095
purely to make our sample
code self-contained.

241
00:14:06,095 --> 00:14:08,077
When I run this Java code,

242
00:14:08,077 --> 00:14:11,744
it will try to create
a table to hold books.

243
00:14:13,909 --> 00:14:16,344
If that fails then the assumption is

244
00:14:16,344 --> 00:14:20,413
it's because the book
table already exists.

245
00:14:20,413 --> 00:14:21,804
Now I've just done that
so you don't have to

246
00:14:21,804 --> 00:14:24,656
go around fussing around
with query browses,

247
00:14:24,656 --> 00:14:26,587
and all that kind of thing.

248
00:14:26,587 --> 00:14:29,585
I'm keeping everything self-contained.

249
00:14:29,585 --> 00:14:32,016
You wouldn't really have
that in a production system,

250
00:14:32,016 --> 00:14:34,016
or at least not usually.

251
00:14:35,303 --> 00:14:37,881
So, that's the setting
up, and then I've gone on,

252
00:14:37,881 --> 00:14:40,318
and I've just implemented
each of the methods

253
00:14:40,318 --> 00:14:44,941
that appeared in that interface,
using straightforward JDBC.

254
00:14:44,941 --> 00:14:49,108
So, I'll assume you have some
familiarity with the JDBC API,

255
00:14:50,629 --> 00:14:54,972
we do cover it in our Java
Fundamentals training course,

256
00:14:54,972 --> 00:14:57,973
and of course there's lots
of websites about it as well.

257
00:14:57,973 --> 00:15:00,364
If you're not familiar
then, believe it or not,

258
00:15:00,364 --> 00:15:04,531
this whole block of code
here is the whole process

259
00:15:05,801 --> 00:15:09,884
of inserting just a single
row into the database.

260
00:15:10,904 --> 00:15:13,716
I have to access a connection,

261
00:15:13,716 --> 00:15:16,799
I have to set the connection up here,

262
00:15:17,685 --> 00:15:21,821
I have to prepare the
statement, the insert statement,

263
00:15:21,821 --> 00:15:26,088
by the way these are
hard-coded lines of SQL

264
00:15:26,088 --> 00:15:29,610
that I've defined higher up here.

265
00:15:29,610 --> 00:15:33,027
There's an insert, a create and a select.

266
00:15:34,164 --> 00:15:38,000
I have to bind the parameters
into the SQL statement,

267
00:15:38,000 --> 00:15:41,595
and, then I have to execute the updates.

268
00:15:41,595 --> 00:15:43,610
But then I've got to
do resource management,

269
00:15:43,610 --> 00:15:45,494
I've got a finally block here,

270
00:15:45,494 --> 00:15:48,718
I've got to make sure
that this always happens

271
00:15:48,718 --> 00:15:51,253
even if something goes wrong up here,

272
00:15:51,253 --> 00:15:52,314
and I've got to be careful to

273
00:15:52,314 --> 00:15:54,564
close everything that I've used

274
00:15:54,564 --> 00:15:59,165
and I've got to handle
any exceptions as well,

275
00:15:59,165 --> 00:16:02,165
it's a really tedious block of code.

276
00:16:04,516 --> 00:16:07,376
In Java 7, there is a
better way of managing

277
00:16:07,376 --> 00:16:11,543
this try-catch block, it's
called try-with-resources.

278
00:16:13,266 --> 00:16:15,680
If you haven't seen that then check out

279
00:16:15,680 --> 00:16:18,111
our Java Fundamentals training course

280
00:16:18,111 --> 00:16:19,954
taught by Matt Greencroft,

281
00:16:19,954 --> 00:16:24,012
or you can read Matt's
blog post on the subject.

282
00:16:24,012 --> 00:16:28,179
The URL you can see here, and
it does tidy everything up.

283
00:16:29,188 --> 00:16:33,355
But that is Java 7, and I
would think most projects,

284
00:16:34,294 --> 00:16:37,078
at the time I recorded this course,

285
00:16:37,078 --> 00:16:40,448
haven't really used Java 7 very much.

286
00:16:40,448 --> 00:16:44,615
I would say most raw JDBC code
you'll see in the real world,

287
00:16:46,094 --> 00:16:48,686
at least for the next two or three years,

288
00:16:48,686 --> 00:16:53,296
looks more like this horrible
mess that I have here.

289
00:16:53,296 --> 00:16:55,790
Now I really should've
implemented the other methods

290
00:16:55,790 --> 00:16:59,603
in the interface but to be
honest I couldn't really face it.

291
00:16:59,603 --> 00:17:01,206
I've got the delete method here

292
00:17:01,206 --> 00:17:04,785
which would be similarly
big and complicated,

293
00:17:04,785 --> 00:17:07,560
and finding books by author, and so on.

294
00:17:07,560 --> 00:17:09,643
For now, just as a to-do,

295
00:17:10,918 --> 00:17:14,384
I'm throwing an unsupported
operation exception,

296
00:17:14,384 --> 00:17:17,327
just so that the code will compile.

297
00:17:17,327 --> 00:17:20,577
I have implemented the allBooks method,

298
00:17:21,764 --> 00:17:25,440
just so I can show you
what the query looks like,

299
00:17:25,440 --> 00:17:29,406
and really, I'm not going
to say much about it,

300
00:17:29,406 --> 00:17:33,213
except a query's even
worse than an update,

301
00:17:33,213 --> 00:17:37,941
and we have well over a
screenfull of code here.

302
00:17:37,941 --> 00:17:42,108
So, the point of all this is
that I've implemented our DAO

303
00:17:43,112 --> 00:17:46,290
using the most basic API that we can use,

304
00:17:46,290 --> 00:17:48,651
without any of Spring's help,

305
00:17:48,651 --> 00:17:52,228
and I'm sure you can see that it's fairly,

306
00:17:52,228 --> 00:17:54,630
well I think the word for
this would be laborious,

307
00:17:54,630 --> 00:17:57,473
it's certainly very verbose.

308
00:17:57,473 --> 00:17:59,069
But I think the most important thing

309
00:17:59,069 --> 00:18:00,904
to say about this code is,

310
00:18:00,904 --> 00:18:05,683
I'm not 100% sure that
it's completely safe.

311
00:18:05,683 --> 00:18:09,263
Have I closed all of
the resources correctly?

312
00:18:09,263 --> 00:18:11,886
Is there some kind of edge case where,

313
00:18:11,886 --> 00:18:14,902
if I get an exception in the wrong place,

314
00:18:14,902 --> 00:18:16,694
we might go into the catch block here

315
00:18:16,694 --> 00:18:20,123
and the finally block
hasn't correctly executed.

316
00:18:20,123 --> 00:18:22,731
You can look on Stack Overflow

317
00:18:22,731 --> 00:18:24,934
and you'll see a lot of questions saying

318
00:18:24,934 --> 00:18:29,433
"What's the best way to
close connections in JDBC?

319
00:18:29,433 --> 00:18:32,496
"Do I need the try-finally
block, or the try-catch-finally,

320
00:18:32,496 --> 00:18:36,634
"or some strange combination of the two?"

321
00:18:36,634 --> 00:18:40,619
And, really, I don't know,
and I do not want you

322
00:18:40,619 --> 00:18:45,273
to send me an email if you
see a bug in this code,

323
00:18:45,273 --> 00:18:46,835
I don't want an email saying

324
00:18:46,835 --> 00:18:48,250
"Well you should have done it like this."

325
00:18:48,250 --> 00:18:52,333
because it's just too
awful to have to deal with.

326
00:18:54,056 --> 00:18:57,713
I'm not 100% sure that
I've covered every base,

327
00:18:57,713 --> 00:19:00,473
and that this is going
to be completely safe

328
00:19:00,473 --> 00:19:02,619
on a production project.

329
00:19:02,619 --> 00:19:05,121
So, in this chapter
from this point onwards

330
00:19:05,121 --> 00:19:08,727
we're going to use Spring's
support to clean up this code,

331
00:19:08,727 --> 00:19:10,477
and to make it safer.

332
00:19:11,489 --> 00:19:14,651
Before we do that though, I
would like to at least test

333
00:19:14,651 --> 00:19:17,670
if this code works, if it runs,

334
00:19:17,670 --> 00:19:21,503
and I guess I could
instantiate this JDBC DAO,

335
00:19:23,463 --> 00:19:26,259
directly, from some kind of test harness.

336
00:19:26,259 --> 00:19:28,744
But since we're learning Spring here,

337
00:19:28,744 --> 00:19:32,106
I'm going to go through
the steps to wire up

338
00:19:32,106 --> 00:19:36,198
the complete application
using the Spring XML.

339
00:19:36,198 --> 00:19:38,916
And, we're going to need
to this wiring anyway

340
00:19:38,916 --> 00:19:42,054
in this chapter so we
may as well do it now.

341
00:19:42,054 --> 00:19:46,221
Let's switch across to our
XML that we have so far.

342
00:19:47,322 --> 00:19:50,620
And so far, all we've done
is, in the previous chapters

343
00:19:50,620 --> 00:19:55,517
we've wired up our service
beans, our accountsService,

344
00:19:55,517 --> 00:19:58,396
our bookService and our purchasingService.

345
00:19:58,396 --> 00:20:01,147
And I've just added comments
in there to make it clear

346
00:20:01,147 --> 00:20:04,006
that these are all of our services.

347
00:20:04,006 --> 00:20:06,631
Now, there's the bookService,
and at the moment

348
00:20:06,631 --> 00:20:10,573
I'm instantiating a mock implementation.

349
00:20:10,573 --> 00:20:13,258
So that's our XML so far,

350
00:20:13,258 --> 00:20:16,869
we also have a client application which,

351
00:20:16,869 --> 00:20:19,248
the last time we were
doing this we were testing

352
00:20:19,248 --> 00:20:21,793
what happens if you
create multiple instances

353
00:20:21,793 --> 00:20:23,834
of the purchasingService.

354
00:20:23,834 --> 00:20:25,090
We don't need this anymore,

355
00:20:25,090 --> 00:20:28,338
so I'm going to change
the client a little bit.

356
00:20:28,338 --> 00:20:31,518
I'm going to get rid of the
first two lines of code,

357
00:20:31,518 --> 00:20:33,282
and I'm going to leave in the line

358
00:20:33,282 --> 00:20:35,284
where we open the container,

359
00:20:35,284 --> 00:20:37,628
and I'm also going to leave
in the final line of code

360
00:20:37,628 --> 00:20:39,225
where we close the container,

361
00:20:39,225 --> 00:20:42,179
but I'm going to take out
everything in between.

362
00:20:42,179 --> 00:20:45,298
And for this chapter, I just want to test

363
00:20:45,298 --> 00:20:48,548
that I can get hold of the bookService,

364
00:20:50,618 --> 00:20:53,535
so this is all very straightforward

365
00:20:56,999 --> 00:20:59,082
code for you now, I hope.

366
00:21:01,030 --> 00:21:03,413
We get the bookService from the container,

367
00:21:03,413 --> 00:21:06,255
I'll need to do an import there,

368
00:21:06,255 --> 00:21:09,716
and then I think what I will do is

369
00:21:09,716 --> 00:21:12,099
just test that we can create a new book.

370
00:21:12,099 --> 00:21:14,597
Now, in the service class,

371
00:21:14,597 --> 00:21:18,505
the method is called registerNewBook,

372
00:21:18,505 --> 00:21:21,422
and I'll need to create a new book,

373
00:21:21,422 --> 00:21:25,357
and the parameters into
that are the ISBN number,

374
00:21:25,357 --> 00:21:27,471
I'll just put some rubbish in there,

375
00:21:27,471 --> 00:21:31,554
we have a title next,
let's go for War and Peace,

376
00:21:35,407 --> 00:21:38,324
the author I think was Leo Tolstoy,

377
00:21:39,789 --> 00:21:42,691
if my literature is correct,

378
00:21:42,691 --> 00:21:46,441
and the price, I'll put
in any random double.

379
00:21:48,327 --> 00:21:49,787
That will need importing as well,

380
00:21:49,787 --> 00:21:54,662
be careful to import the
correct domain class there.

381
00:21:54,662 --> 00:21:56,113
Then to test that that works,

382
00:21:56,113 --> 00:21:58,863
I'm going to get a list of books,

383
00:22:06,423 --> 00:22:10,603
and although in the DAO the
method is called allBooks,

384
00:22:10,603 --> 00:22:14,770
in the service class I've
called it getEntireCatalogue.

385
00:22:16,421 --> 00:22:17,928
I'll need to import the list,

386
00:22:17,928 --> 00:22:21,655
make sure you use the java.util.List

387
00:22:21,655 --> 00:22:24,655
and then, finally, we'll loop around

388
00:22:26,025 --> 00:22:27,358
all of the books

389
00:22:29,770 --> 00:22:31,687
and print each one out.

390
00:22:33,069 --> 00:22:37,378
Now if I were to run
this system right now,

391
00:22:37,378 --> 00:22:40,351
it is running, but
remember we currently have

392
00:22:40,351 --> 00:22:43,256
the mock implementation wired in,

393
00:22:43,256 --> 00:22:46,873
so I'm getting the three books
back that are in the mock,

394
00:22:46,873 --> 00:22:50,838
and I'm getting back the extra
book that I've just added.

395
00:22:50,838 --> 00:22:53,903
If I keep rerunning this client,

396
00:22:53,903 --> 00:22:58,050
you'll notice that each
time I run the application,

397
00:22:58,050 --> 00:23:01,100
I'm getting back the same data each time,

398
00:23:01,100 --> 00:23:03,456
even though I keep adding a new book in,

399
00:23:03,456 --> 00:23:04,893
and that's of course because,

400
00:23:04,893 --> 00:23:07,762
when I'm using a mock,
it's not persistent,

401
00:23:07,762 --> 00:23:11,388
at the end of the run, all
the data is being lost.

402
00:23:11,388 --> 00:23:13,213
So what we need to do now then,

403
00:23:13,213 --> 00:23:17,444
is to take that MockBookService,
to get rid of it,

404
00:23:17,444 --> 00:23:20,208
and to bring in a new BookService,

405
00:23:20,208 --> 00:23:23,997
which is coded to production standards.

406
00:23:23,997 --> 00:23:26,632
Now I'm sure I don't
need to say this again,

407
00:23:26,632 --> 00:23:29,953
but when we do bring
our new BookService in,

408
00:23:29,953 --> 00:23:32,322
because I've programmed to the interface,

409
00:23:32,322 --> 00:23:35,322
this client will not need to change.

410
00:23:36,363 --> 00:23:39,890
So going into our services package,

411
00:23:39,890 --> 00:23:42,618
we already have the mock implementation,

412
00:23:42,618 --> 00:23:46,785
but alongside it now I'm
going to create a new class,

413
00:23:48,778 --> 00:23:50,433
and this is going to be called,

414
00:23:50,433 --> 00:23:53,772
well I think on the captions
I've called it BookServiceImpl

415
00:23:53,772 --> 00:23:57,112
but, just to be absolutely clear,

416
00:23:57,112 --> 00:24:01,279
I'm going to call this instead
BookServiceProductionImpl,

417
00:24:04,637 --> 00:24:07,007
and I need to make sure that it implements

418
00:24:07,007 --> 00:24:09,174
the BookService interface,

419
00:24:11,999 --> 00:24:15,250
and as before make sure the
Inherit abstract methods

420
00:24:15,250 --> 00:24:16,333
is ticked on.

421
00:24:17,389 --> 00:24:19,390
So I think it's worth putting a comment

422
00:24:19,390 --> 00:24:21,473
at the top of this class.

423
00:24:22,427 --> 00:24:27,330
Let's go for "This is the
production implementation,

424
00:24:27,330 --> 00:24:28,913
"it will be calling

425
00:24:30,597 --> 00:24:32,264
"a 'real' database."

426
00:24:36,142 --> 00:24:37,610
OK.

427
00:24:37,610 --> 00:24:40,674
Now the key thing about this
production implementation is,

428
00:24:40,674 --> 00:24:44,489
if we, let's start with
the registerNewBook method,

429
00:24:44,489 --> 00:24:46,149
for example.

430
00:24:46,149 --> 00:24:46,982
Now, we,

431
00:24:49,633 --> 00:24:53,466
we want this book to be
put into the database.

432
00:24:55,792 --> 00:24:58,154
Now we could put the
database code in here,

433
00:24:58,154 --> 00:25:00,030
but I've already talked earlier

434
00:25:00,030 --> 00:25:03,647
about how it makes good
sense for many projects

435
00:25:03,647 --> 00:25:08,647
to put the database code in
a special class, that DAO.

436
00:25:08,647 --> 00:25:12,404
So, ultimately, we're going
to be able to call the DAO

437
00:25:12,404 --> 00:25:17,289
from here, and we're going
to call one of its methods.

438
00:25:17,289 --> 00:25:22,141
Now if you remember the method
in the DAO is called create,

439
00:25:22,141 --> 00:25:25,606
and I can pass in that new book.

440
00:25:25,606 --> 00:25:27,151
Now that might look a little bit odd,

441
00:25:27,151 --> 00:25:29,270
some people complain about this,

442
00:25:29,270 --> 00:25:31,282
that the name of the method here

443
00:25:31,282 --> 00:25:34,749
is not the same of the method in the DAO.

444
00:25:34,749 --> 00:25:36,052
But that's actually quite common,

445
00:25:36,052 --> 00:25:38,785
because the DAO is a low-level class,

446
00:25:38,785 --> 00:25:42,312
it's doing very low-level
database operations.

447
00:25:42,312 --> 00:25:46,479
So I expect to see in there,
methods called create, read,

448
00:25:47,351 --> 00:25:50,768
update, delete, or find, instead of read.

449
00:25:52,379 --> 00:25:54,232
Whereas the method here,

450
00:25:54,232 --> 00:25:57,441
registerNewBook is the method
that the client is calling,

451
00:25:57,441 --> 00:26:01,307
so that needs to have a
kind of a businesslike name,

452
00:26:01,307 --> 00:26:03,619
it needs to be very strongly worded

453
00:26:03,619 --> 00:26:06,954
so it makes good sense to the client.

454
00:26:06,954 --> 00:26:10,016
Now because we're writing
a fairly simple application

455
00:26:10,016 --> 00:26:13,022
on this course, we're going to find that,

456
00:26:13,022 --> 00:26:15,749
actually there's nothing
more to do in this

457
00:26:15,749 --> 00:26:20,172
method implementation, we
just go and call the database.

458
00:26:20,172 --> 00:26:22,368
And, we're going to find that, really,

459
00:26:22,368 --> 00:26:26,639
all of the methods in this
service class are like that.

460
00:26:26,639 --> 00:26:29,281
But, going forward with the application

461
00:26:29,281 --> 00:26:32,707
as it grows and it gets more complicated,

462
00:26:32,707 --> 00:26:35,067
we've at least got somewhere

463
00:26:35,067 --> 00:26:39,201
where we can add extra
custom business logic.

464
00:26:39,201 --> 00:26:43,731
For instance, this
getAllRecommendedBooks method here,

465
00:26:43,731 --> 00:26:46,192
I don't know how we're
going to implement that,

466
00:26:46,192 --> 00:26:50,109
in fact, on this course we
never will implement it.

467
00:26:50,109 --> 00:26:52,847
But in the real system we
would need to implement it

468
00:26:52,847 --> 00:26:54,781
and I could imagine that could be

469
00:26:54,781 --> 00:26:59,317
three or four separate
calls to different DAOs,

470
00:26:59,317 --> 00:27:00,704
and then we need some logic

471
00:27:00,704 --> 00:27:03,948
to combine the information together.

472
00:27:03,948 --> 00:27:07,179
Or it might be that in registerNewBook,

473
00:27:07,179 --> 00:27:09,823
we want to put a bit of validation logic

474
00:27:09,823 --> 00:27:13,027
at the front of the method to
check that the book is valid,

475
00:27:13,027 --> 00:27:17,202
and only if it's valid we
then go on to the database.

476
00:27:17,202 --> 00:27:20,167
So, although it does,
especially on a course,

477
00:27:20,167 --> 00:27:22,722
it looks like this class
isn't very interesting

478
00:27:22,722 --> 00:27:24,183
because every single method

479
00:27:24,183 --> 00:27:26,933
is just DAO.do this, DAO.do that,

480
00:27:28,847 --> 00:27:32,562
I think it's quite useful to
have this layer of separation.

481
00:27:32,562 --> 00:27:34,272
Not everyone agrees with that, by the way,

482
00:27:34,272 --> 00:27:36,359
and you will find a lot of blog posts,

483
00:27:36,359 --> 00:27:40,827
and a lot of textbooks that say
that the service and the DAO

484
00:27:40,827 --> 00:27:43,931
are so similar you may as
well combine them together.

485
00:27:43,931 --> 00:27:46,915
And, yeah, that's OK, there's
no right or wrong answers,

486
00:27:46,915 --> 00:27:50,248
it depends on your engineering judgment,

487
00:27:52,020 --> 00:27:54,341
it often depends on what the architects

488
00:27:54,341 --> 00:27:57,264
of your project has designed it.

489
00:27:57,264 --> 00:27:58,970
Now of course I have a compile error here

490
00:27:58,970 --> 00:28:01,863
because I haven't yet
created this DAO object,

491
00:28:01,863 --> 00:28:05,820
well that's just going to become
an attribute of this class,

492
00:28:05,820 --> 00:28:08,153
so its type will be BookDao,

493
00:28:09,417 --> 00:28:11,939
and how do we instantiate the BookDao?

494
00:28:11,939 --> 00:28:14,839
Well, I won't labor this any further,

495
00:28:14,839 --> 00:28:17,720
clearly this is a dependence object,

496
00:28:17,720 --> 00:28:18,713
and what we're going to do is

497
00:28:18,713 --> 00:28:22,331
we're going to ask Spring
to create that object,

498
00:28:22,331 --> 00:28:24,486
and we'll get Spring to pass it in,

499
00:28:24,486 --> 00:28:26,852
as a dependency to this class.

500
00:28:26,852 --> 00:28:29,836
So, you could use either setter injection

501
00:28:29,836 --> 00:28:32,018
or construction injection but,

502
00:28:32,018 --> 00:28:34,223
because we're always going to need it,

503
00:28:34,223 --> 00:28:38,390
as I've mentioned before I favor
now construction injection.

504
00:28:39,659 --> 00:28:42,326
So, let's write the constructor,

505
00:28:43,694 --> 00:28:48,065
and it's going to take in
a parameter called BookDao,

506
00:28:48,065 --> 00:28:51,217
and in there we'll just
store the DAO away.

507
00:28:51,217 --> 00:28:53,228
I hope you're familiar with that process,

508
00:28:53,228 --> 00:28:56,530
if not review the earlier chapters.

509
00:28:56,530 --> 00:28:58,217
Now it looks like I have a compile error

510
00:28:58,217 --> 00:29:01,300
because I need to import the BookDao.

511
00:29:02,643 --> 00:29:06,380
OK, so now I can implement
most of these methods,

512
00:29:06,380 --> 00:29:09,704
just by making simple delegating calls.

513
00:29:09,704 --> 00:29:12,126
For getBooksByAuthor, I can call

514
00:29:12,126 --> 00:29:14,876
the DAO findBooksByAuthor method,

515
00:29:16,970 --> 00:29:18,598
passing in the author.

516
00:29:18,598 --> 00:29:21,954
Notice again the method
names aren't the same,

517
00:29:21,954 --> 00:29:24,914
which is perfectly acceptable.

518
00:29:24,914 --> 00:29:28,337
I need to return the results of that.

519
00:29:28,337 --> 00:29:31,551
Then for getAllRecommendedBooks
we, as I say,

520
00:29:31,551 --> 00:29:34,848
we're not going to implement
this one, on the course.

521
00:29:34,848 --> 00:29:38,931
So I'll throw an unsupported
operation exception,

522
00:29:39,789 --> 00:29:43,722
I just added that method to
this class just to remind you

523
00:29:43,722 --> 00:29:47,073
that there can be methods in
here that aren't just simple

524
00:29:47,073 --> 00:29:50,323
find, create, update, delete and so on.

525
00:29:52,190 --> 00:29:54,213
getBookByIsbn should be easy,

526
00:29:54,213 --> 00:29:57,880
we'll just return the
DAO.findByIsbn method,

527
00:29:58,769 --> 00:30:00,186
passing the ISBN.

528
00:30:01,120 --> 00:30:03,511
And for getEntireCatalogue

529
00:30:03,511 --> 00:30:07,178
we have a method in the
DAO called allBooks.

530
00:30:12,198 --> 00:30:14,839
So how do we use this class then?

531
00:30:14,839 --> 00:30:16,875
Well, we know from the previous chapter

532
00:30:16,875 --> 00:30:20,621
that we just need to change
the XML around a little bit.

533
00:30:20,621 --> 00:30:25,020
Our current bookService is
the mock implementation,

534
00:30:25,020 --> 00:30:27,853
well we can change that now to the

535
00:30:32,444 --> 00:30:34,611
BookServiceProductionImpl.

536
00:30:38,179 --> 00:30:42,266
Now we immediately get an
error here in the Spring IDE,

537
00:30:42,266 --> 00:30:46,346
and it's telling us that
there is no constructor

538
00:30:46,346 --> 00:30:48,779
with no arguments in this class.

539
00:30:48,779 --> 00:30:53,195
It's telling us that we've
forgotten to pass in a property.

540
00:30:53,195 --> 00:30:57,530
You know that the bookService
is going to delegate to a DAO,

541
00:30:57,530 --> 00:31:02,270
so we have to tell Spring
that we want to inject

542
00:31:02,270 --> 00:31:05,288
a DAO object into the bookService.

543
00:31:05,288 --> 00:31:07,159
So the way that we're going to do that

544
00:31:07,159 --> 00:31:10,101
is by opening up the bean tag,

545
00:31:10,101 --> 00:31:12,126
if you're following along in this chapter,

546
00:31:12,126 --> 00:31:14,947
you don't have to, but if you are,

547
00:31:14,947 --> 00:31:18,146
I've just removed the forward slash there,

548
00:31:18,146 --> 00:31:22,313
and we can specify that we
have constructor argument

549
00:31:24,536 --> 00:31:28,039
referring to an object that
we haven't yet created,

550
00:31:28,039 --> 00:31:30,914
I'm going to call it the BookDao object,

551
00:31:30,914 --> 00:31:33,462
we can call it anything we like.

552
00:31:33,462 --> 00:31:36,260
So we've never mentioned
this BookDao object,

553
00:31:36,260 --> 00:31:38,555
so we are going to have to tell Spring

554
00:31:38,555 --> 00:31:40,972
that we wanted to create one.

555
00:31:41,939 --> 00:31:44,493
We do that just by adding another bean.

556
00:31:44,493 --> 00:31:48,482
Now, I'm kind of working from
bottom upwards in this XML,

557
00:31:48,482 --> 00:31:52,315
I'm going to declare the
BookDao bean up here,

558
00:31:53,361 --> 00:31:57,655
but in fact the Spring
XML is order-independent,

559
00:31:57,655 --> 00:31:59,295
I could have done this at the bottom,

560
00:31:59,295 --> 00:32:01,739
I could do it anywhere I like really but,

561
00:32:01,739 --> 00:32:05,906
I think it would be worthwhile
to put a comment in here,

562
00:32:09,337 --> 00:32:13,073
that this is where all of our
DAO beans are going to live.

563
00:32:13,073 --> 00:32:15,968
So the class in which this lives, I think,

564
00:32:15,968 --> 00:32:18,468
was com.virtualpairprogrammers

565
00:32:20,104 --> 00:32:23,313
.avalon for the project name,

566
00:32:23,313 --> 00:32:25,827
then we have a package called data,

567
00:32:25,827 --> 00:32:29,910
and the class was called,
I can't quite remember,

568
00:32:31,132 --> 00:32:34,299
here it is, the BookDaoHorridJdbcImpl.

569
00:32:38,045 --> 00:32:41,468
Now the DAO doesn't have any
properties at the moment,

570
00:32:41,468 --> 00:32:44,860
so that's going to be OK as it stands.

571
00:32:44,860 --> 00:32:49,816
I think it would be worth
going into the Spring Explorer

572
00:32:49,816 --> 00:32:52,363
and drilling down to the XML file

573
00:32:52,363 --> 00:32:55,646
and having a look at the dependency graph.

574
00:32:55,646 --> 00:32:58,216
So this is a bit of a sanity check,

575
00:32:58,216 --> 00:33:00,546
as you can see now, the purchasingService

576
00:33:00,546 --> 00:33:03,496
we're not using that for this exercise,

577
00:33:03,496 --> 00:33:05,898
but it's still pointing
to the accountsService

578
00:33:05,898 --> 00:33:09,336
and the bookService, this
is the important one,

579
00:33:09,336 --> 00:33:13,503
the bookService is now correctly
pointing at that BookDao.

580
00:33:16,517 --> 00:33:19,989
So it looks like I have
everything wired correctly,

581
00:33:19,989 --> 00:33:24,156
so all that remains now is
to try to run our clients,

582
00:33:25,567 --> 00:33:27,484
let's see what happens.

583
00:33:35,156 --> 00:33:39,955
OK, well it appears to be
running, it's created a table,

584
00:33:39,955 --> 00:33:43,016
this time around there's no
existing data in the database

585
00:33:43,016 --> 00:33:45,549
so it looks like I'm only
seeing that single book

586
00:33:45,549 --> 00:33:49,592
that I created in the harness,
but the difference this time

587
00:33:49,592 --> 00:33:52,509
is if I keep rerunning the clients,

588
00:33:54,675 --> 00:33:56,306
yeah, we've now got two books,

589
00:33:56,306 --> 00:33:58,736
because we've added a new one,

590
00:33:58,736 --> 00:34:00,383
and we can see that it's assuming

591
00:34:00,383 --> 00:34:02,107
that the BOOK table was already created

592
00:34:02,107 --> 00:34:06,190
and of course if I keep
running, I'm going to see

593
00:34:07,204 --> 00:34:11,005
more, and more books
appearing in the database.

594
00:34:11,005 --> 00:34:13,982
If you go back to your
Package Explorer in Eclipse,

595
00:34:13,982 --> 00:34:17,745
and right-click on the
project and select Refresh,

596
00:34:17,745 --> 00:34:20,469
you should now see that you have two files

597
00:34:20,469 --> 00:34:25,234
in your project area, one
called database.dat.properties,

598
00:34:25,234 --> 00:34:27,067
and one called script.

599
00:34:28,010 --> 00:34:29,340
It's actually inside this script file

600
00:34:29,340 --> 00:34:34,275
if I right-click and select
Open with Text Editor,

601
00:34:34,275 --> 00:34:38,114
that you will see the
contents of the database,

602
00:34:38,114 --> 00:34:40,502
these last lines here.

603
00:34:40,502 --> 00:34:42,597
If you have any problems
and for some reason

604
00:34:42,597 --> 00:34:45,298
you need to wipe away the database,

605
00:34:45,298 --> 00:34:47,867
you can just select these two files,

606
00:34:47,867 --> 00:34:50,784
right-click on them, select Delete,

607
00:34:52,178 --> 00:34:55,694
and if I run the application again now,

608
00:34:55,694 --> 00:34:57,944
it will recreate the table,

609
00:34:58,976 --> 00:35:01,882
and start adding the rows in again.

610
00:35:01,882 --> 00:35:04,875
So that's a good start,
we've used Spring now

611
00:35:04,875 --> 00:35:09,174
to configure a
production-quality service class,

612
00:35:09,174 --> 00:35:11,507
which is delegating to a DAO

613
00:35:13,059 --> 00:35:15,642
which is using a real database.

614
00:35:17,424 --> 00:35:19,085
But the problem is,

615
00:35:19,085 --> 00:35:22,188
as I've said many times
on this chapter now,

616
00:35:22,188 --> 00:35:25,607
JDBC is a very difficult API to work with,

617
00:35:25,607 --> 00:35:28,542
and remember, I haven't
implemented three or four

618
00:35:28,542 --> 00:35:31,652
of the methods because
I just can't face it.

619
00:35:31,652 --> 00:35:35,652
So, my aim now is to
reimplement this JDBC class

620
00:35:36,636 --> 00:35:41,448
with much cleaner
implementations of the methods.

621
00:35:41,448 --> 00:35:45,866
My create method here, was very
nearly a screenfull of code,

622
00:35:45,866 --> 00:35:47,166
but we're going to see now,

623
00:35:47,166 --> 00:35:51,333
how Spring will reduce this
down to almost a single line.

624
00:35:52,838 --> 00:35:56,808
Well before we start coding,
quick review of the design.

625
00:35:56,808 --> 00:36:01,221
We're back here with our
original BookDao interface.

626
00:36:01,221 --> 00:36:05,388
I'm now going to write a new,
clean, fresh implementation

627
00:36:06,271 --> 00:36:08,104
of that DAO interface.

628
00:36:09,685 --> 00:36:14,010
This time I'm going to
call it BookDaoJdbcImpl,

629
00:36:14,010 --> 00:36:17,053
and I'm not going to use
the word horrid in here

630
00:36:17,053 --> 00:36:21,106
because this is going to
be a nice implementation.

631
00:36:21,106 --> 00:36:24,481
Now as I mentioned at the
start of this chapter,

632
00:36:24,481 --> 00:36:27,470
the Spring Framework supplies a class

633
00:36:27,470 --> 00:36:29,470
called the JDBCTemplate,

634
00:36:31,933 --> 00:36:36,642
and you can think of this
as a kind of helper class.

635
00:36:36,642 --> 00:36:38,979
It's going to help our DAO,

636
00:36:38,979 --> 00:36:43,074
it's going to remove a lot
of that repetitive code,

637
00:36:43,074 --> 00:36:46,772
in particular, all of
the try-catch blocks.

638
00:36:46,772 --> 00:36:50,606
I don't know if you're
familiar with this symbol here,

639
00:36:50,606 --> 00:36:52,949
this is a UML symbol,

640
00:36:52,949 --> 00:36:57,573
and it just means that the DAO
will need to hold a reference

641
00:36:57,573 --> 00:37:00,748
to this template as an attribute.

642
00:37:00,748 --> 00:37:02,219
On this caption is a sketch

643
00:37:02,219 --> 00:37:04,960
of what this implementation
might look like.

644
00:37:04,960 --> 00:37:09,127
So as I mentioned we need an
instance of this JdbcTemplate,

645
00:37:10,267 --> 00:37:13,161
held in a private attribute.

646
00:37:13,161 --> 00:37:16,923
As we've done so many times
before on the course so far,

647
00:37:16,923 --> 00:37:21,090
we're going to inject this
object in through the wiring.

648
00:37:22,003 --> 00:37:25,613
On the first edition of the
course I used the set method,

649
00:37:25,613 --> 00:37:29,156
I called it setJdbcTemplate
but, as you know now,

650
00:37:29,156 --> 00:37:32,448
I'm leaning towards construct injection

651
00:37:32,448 --> 00:37:36,442
because we always need this
attribute to be set up,

652
00:37:36,442 --> 00:37:38,710
so I've decided to make the template

653
00:37:38,710 --> 00:37:41,960
be a parameter of the constructor here.

654
00:37:43,725 --> 00:37:44,907
Let's switch across to Eclipse

655
00:37:44,907 --> 00:37:48,787
and we'll see this template in action.

656
00:37:48,787 --> 00:37:52,594
This is my horrid JDBC implementation.

657
00:37:52,594 --> 00:37:55,038
I'm now creating a new class,

658
00:37:55,038 --> 00:37:58,955
I'm going to keep it in
the data package again,

659
00:38:01,339 --> 00:38:04,172
and this time it's called BookDao,

660
00:38:05,389 --> 00:38:10,271
well I just called it JdbcImpl
on the caption but I think,

661
00:38:10,271 --> 00:38:12,726
really to emphasize what I'm doing here,

662
00:38:12,726 --> 00:38:16,559
I'm going to call this
BookDaoCleanerJdbcImpl,

663
00:38:17,602 --> 00:38:20,498
of course, you can call
it anything you want.

664
00:38:20,498 --> 00:38:23,003
But the important thing
is it must implement

665
00:38:23,003 --> 00:38:24,836
the BookDao interface,

666
00:38:28,636 --> 00:38:31,365
and it will have exactly
the same structure

667
00:38:31,365 --> 00:38:35,003
as our previous horrible implementation.

668
00:38:35,003 --> 00:38:36,380
Make sure that's ticked,

669
00:38:36,380 --> 00:38:39,059
and we'll come onto the method
implementations in a minute,

670
00:38:39,059 --> 00:38:40,835
but as I said on the caption,

671
00:38:40,835 --> 00:38:44,168
this class is going to hold an attribute

672
00:38:45,743 --> 00:38:47,493
of type JdbcTemplate.

673
00:38:49,583 --> 00:38:51,726
You can call the attribute
anything you want,

674
00:38:51,726 --> 00:38:56,029
but I'm just going to call
it jdbcTemplate again.

675
00:38:56,029 --> 00:38:59,174
Now, crucially, when I do
the Control + Shift + O

676
00:38:59,174 --> 00:39:02,453
or the equivalent key
presses on the Macintosh,

677
00:39:02,453 --> 00:39:05,007
if you check the import
list, you'll see that

678
00:39:05,007 --> 00:39:09,359
this JDBC class is a class
from the Spring Framework,

679
00:39:09,359 --> 00:39:11,364
you can tell by its package name,

680
00:39:11,364 --> 00:39:14,947
org.springframework.jdbc.core.JdbcTemplate,

681
00:39:17,910 --> 00:39:22,721
so it's getting this class from
one of the Spring JAR files.

682
00:39:22,721 --> 00:39:25,734
Now we need to be able
to inject this object,

683
00:39:25,734 --> 00:39:27,668
because it's the dependency,

684
00:39:27,668 --> 00:39:31,251
so I'm going to write
a public constructor,

685
00:39:35,883 --> 00:39:40,739
which takes in a single
parameter of type JdbcTemplate,

686
00:39:40,739 --> 00:39:43,737
I can call that local
variable anything I like,

687
00:39:43,737 --> 00:39:44,987
and let's store

688
00:39:46,266 --> 00:39:49,349
that object into the attribute there.

689
00:39:50,562 --> 00:39:53,612
Now that's all very well,
but I haven't told you yet

690
00:39:53,612 --> 00:39:57,658
what this template object
is going to do for us.

691
00:39:57,658 --> 00:40:00,283
Well, I'm going to start by
looking at the create method,

692
00:40:00,283 --> 00:40:02,252
which is somewhere in the middle here,

693
00:40:02,252 --> 00:40:04,803
yes, there it is right there.

694
00:40:04,803 --> 00:40:08,954
Now recall, that the previous
implementation of this method

695
00:40:08,954 --> 00:40:12,037
was very nearly a screenfull of code,

696
00:40:13,188 --> 00:40:15,489
but with this JdbcTemplate,

697
00:40:15,489 --> 00:40:19,937
we can do the insert in
a single line of code,

698
00:40:19,937 --> 00:40:22,721
it's going to look something like this.

699
00:40:22,721 --> 00:40:25,479
Inside that template object,

700
00:40:25,479 --> 00:40:28,062
so if I just type JdbcTemplate.

701
00:40:29,702 --> 00:40:34,156
you will find in there
a method called update,

702
00:40:34,156 --> 00:40:36,644
well in fact there are
six different versions

703
00:40:36,644 --> 00:40:41,642
of the update method, with
various different argument lists.

704
00:40:41,642 --> 00:40:43,739
We won't be looking at all
these different versions,

705
00:40:43,739 --> 00:40:45,506
I'm just going to show you the main use

706
00:40:45,506 --> 00:40:48,762
of the update method, I
would say the main one

707
00:40:48,762 --> 00:40:52,275
is the version with two parameters.

708
00:40:52,275 --> 00:40:56,129
Now the two parameters are, first of all,

709
00:40:56,129 --> 00:41:00,296
the SQL statement that you
want to issue to the database,

710
00:41:02,009 --> 00:41:05,176
which for us, is the insert into BOOK,

711
00:41:06,091 --> 00:41:08,136
well, I'm not going to
type all that out again,

712
00:41:08,136 --> 00:41:11,306
I can recover that from our code here

713
00:41:11,306 --> 00:41:13,988
in our original implementation.

714
00:41:13,988 --> 00:41:17,045
So, in fact I'm going to
copy all three lines here,

715
00:41:17,045 --> 00:41:20,906
they were our three lines
of SQL that we used before,

716
00:41:20,906 --> 00:41:25,073
and I'm going to transfer those
across into the new version.

717
00:41:26,692 --> 00:41:30,389
So I'm using here the INSERT_BOOK_SQL,

718
00:41:30,389 --> 00:41:33,806
so I pass that in as the first parameter,

719
00:41:35,469 --> 00:41:38,525
and for the second
parameter, I need to pass in

720
00:41:38,525 --> 00:41:43,198
an object array, which is going
to hold all of the arguments

721
00:41:43,198 --> 00:41:46,079
that I want to pass into the SQL.

722
00:41:46,079 --> 00:41:50,296
Now for this insert statement
I need to pass in the ISBN,

723
00:41:50,296 --> 00:41:53,016
the title, the author and the price.

724
00:41:53,016 --> 00:41:55,670
Now I don't know if you
know how to do this,

725
00:41:55,670 --> 00:41:58,859
but you can create an
object array on the fly

726
00:41:58,859 --> 00:42:03,843
just by saying new Object array,
and then in curly brackets,

727
00:42:03,843 --> 00:42:06,712
a comma-separated list of the values

728
00:42:06,712 --> 00:42:09,047
you want to go into the array.

729
00:42:09,047 --> 00:42:13,770
So for us that's going to
be the newBook's .getIsbn,

730
00:42:13,770 --> 00:42:17,353
followed by the newBook's
.getTitle method,

731
00:42:18,990 --> 00:42:21,823
and then the newBook's .getAuthor,

732
00:42:23,614 --> 00:42:26,907
I'm going to go off the end of the screen,

733
00:42:26,907 --> 00:42:31,411
I'll tidy it up in a
moment, there's the price.

734
00:42:31,411 --> 00:42:35,991
Now the reason we've got
this slightly ugly construct

735
00:42:35,991 --> 00:42:38,053
is that because until recently,

736
00:42:38,053 --> 00:42:42,220
Java didn't support
variable-length argument lists,

737
00:42:43,507 --> 00:42:45,154
so what we're effectively doing is

738
00:42:45,154 --> 00:42:47,664
we're taking these four parameters,

739
00:42:47,664 --> 00:42:51,069
and we're wrapping them up
into a single parameter.

740
00:42:51,069 --> 00:42:52,100
So if you think about it,

741
00:42:52,100 --> 00:42:54,586
Spring in advance doesn't know
whether we're going to have

742
00:42:54,586 --> 00:42:59,117
four arguments or 10
arguments or no arguments.

743
00:42:59,117 --> 00:43:01,506
I can suggest however a cleanup

744
00:43:01,506 --> 00:43:05,104
in later versions of Spring
and in later versions of Java,

745
00:43:05,104 --> 00:43:09,271
it is now possible to have
variable-length argument lists.

746
00:43:11,119 --> 00:43:12,765
You're going to see this used in a lot

747
00:43:12,765 --> 00:43:15,857
of existing Spring code,
but if you're lucky,

748
00:43:15,857 --> 00:43:18,840
and you're on a modern version of Spring

749
00:43:18,840 --> 00:43:22,136
and you're on a modern version of Java,

750
00:43:22,136 --> 00:43:24,808
you can in fact get
rid of the object array

751
00:43:24,808 --> 00:43:28,975
and simply pass the four arguments
in as regular parameters.

752
00:43:30,966 --> 00:43:34,558
Under the hood, Java automatically wraps

753
00:43:34,558 --> 00:43:37,840
these four values up into an object array.

754
00:43:37,840 --> 00:43:39,357
So you can try this for yourself,

755
00:43:39,357 --> 00:43:42,617
if it doesn't compile for you
then you will need to undo,

756
00:43:42,617 --> 00:43:43,958
you will have to go back to

757
00:43:43,958 --> 00:43:46,906
creating the object array for yourself.

758
00:43:46,906 --> 00:43:49,739
But hey, that's all that is needed

759
00:43:50,584 --> 00:43:52,917
to insert using Spring JDBC.

760
00:43:54,832 --> 00:43:57,407
What this template object will do,

761
00:43:57,407 --> 00:43:59,535
is before it issues the SQL

762
00:43:59,535 --> 00:44:02,943
it will automatically acquire
a database connection,

763
00:44:02,943 --> 00:44:05,088
it will prepare the statement,

764
00:44:05,088 --> 00:44:08,401
and then it will execute the
statement that I passed in,

765
00:44:08,401 --> 00:44:10,296
together with all of the values,

766
00:44:10,296 --> 00:44:13,318
correctly bound into that SQL.

767
00:44:13,318 --> 00:44:18,159
And then finally, it will clean
up the resources it's used.

768
00:44:18,159 --> 00:44:20,432
We might need to think
about exception handling

769
00:44:20,432 --> 00:44:23,796
but I'll come back onto
that in a later chapter.

770
00:44:23,796 --> 00:44:26,614
Now if you're thinking ahead,
you might have spotted,

771
00:44:26,614 --> 00:44:30,881
if I go back to these
hard-coded lines of SQL,

772
00:44:30,881 --> 00:44:32,773
you might have realized
that you could make

773
00:44:32,773 --> 00:44:37,403
these three strings be
properties of the class

774
00:44:37,403 --> 00:44:41,486
and you could inject the
values using Spring XML.

775
00:44:42,332 --> 00:44:43,631
And that's absolutely right,

776
00:44:43,631 --> 00:44:46,959
that would be a really
good use of the Spring XML.

777
00:44:46,959 --> 00:44:49,028
I'm not going to do
that here on the course,

778
00:44:49,028 --> 00:44:51,616
because this code is
now good enough to show

779
00:44:51,616 --> 00:44:55,199
how the Spring JdbcTemplate works,

780
00:44:55,199 --> 00:44:56,949
which is what this chapter's all about,

781
00:44:56,949 --> 00:45:00,295
but, if you want to make
the SQL be a property,

782
00:45:00,295 --> 00:45:02,405
then go ahead and do so.

783
00:45:02,405 --> 00:45:05,045
I think there's possibly
an argument that if the SQL

784
00:45:05,045 --> 00:45:08,610
needed to change, say
we've added a column,

785
00:45:08,610 --> 00:45:12,111
then we'd need to change all
of the code in here anyway,

786
00:45:12,111 --> 00:45:14,625
so I'm going to accept the hard-coding,

787
00:45:14,625 --> 00:45:17,073
but you might disagree, that's fine.

788
00:45:17,073 --> 00:45:20,938
I hope you will agree though,
that this create method

789
00:45:20,938 --> 00:45:24,220
is now very much cleaner
than it was before.

790
00:45:24,220 --> 00:45:28,267
Now we need to see how to
query using this template,

791
00:45:28,267 --> 00:45:31,808
so we have the allBooks method here.

792
00:45:31,808 --> 00:45:35,975
Now this is slightly more
complicated than inserting rows,

793
00:45:37,419 --> 00:45:39,823
but the process is, at
least on the face of it,

794
00:45:39,823 --> 00:45:42,359
very similar to what we had before.

795
00:45:42,359 --> 00:45:46,497
There's a method inside
the jdbcTemplate class

796
00:45:46,497 --> 00:45:47,580
called query.

797
00:45:48,778 --> 00:45:53,251
And well, again it's a
heavily overloaded method,

798
00:45:53,251 --> 00:45:56,662
there's what, at least 10 or 12

799
00:45:56,662 --> 00:45:58,849
different versions of the query method,

800
00:45:58,849 --> 00:46:01,820
but the process is pretty
much the same for all of them.

801
00:46:01,820 --> 00:46:05,649
We pass in the query
that we want to execute,

802
00:46:05,649 --> 00:46:09,437
so for this method that's
the GET_ALL_BOOKS_SQL,

803
00:46:09,437 --> 00:46:13,604
and what that will do, is it
will return a list of objects,

804
00:46:14,838 --> 00:46:17,180
it will return the objects that we wanted,

805
00:46:17,180 --> 00:46:20,430
in our case it will be a list of books.

806
00:46:21,437 --> 00:46:25,604
Well, not quite, because you
can see this isn't compiling,

807
00:46:26,527 --> 00:46:27,868
it's because there's a problem,

808
00:46:27,868 --> 00:46:31,334
and the problem is that Spring
doesn't know how to convert

809
00:46:31,334 --> 00:46:34,751
a result set from a database into a book,

810
00:46:35,873 --> 00:46:37,456
or a list of books.

811
00:46:38,752 --> 00:46:42,835
Now, other frameworks just
Hibernate and myBatis,

812
00:46:44,218 --> 00:46:47,892
are clever enough to convert a result set

813
00:46:47,892 --> 00:46:52,317
into a domain object, but Spring
doesn't really go that far.

814
00:46:52,317 --> 00:46:55,533
We are going to have to
do the work ourselves,

815
00:46:55,533 --> 00:46:59,617
but it's not really too bad,
what we have to do in here,

816
00:46:59,617 --> 00:47:02,761
is we have to pass in a
new instance of a class

817
00:47:02,761 --> 00:47:05,637
that in fact we're going to write,

818
00:47:05,637 --> 00:47:08,751
so I can call this class anything I like,

819
00:47:08,751 --> 00:47:11,533
it's called a mapper class.

820
00:47:11,533 --> 00:47:14,533
I'm going to call it the BookMapper.

821
00:47:16,358 --> 00:47:19,733
Now the idea of this class,
is this is going to be a class

822
00:47:19,733 --> 00:47:21,951
that we write that tells Spring

823
00:47:21,951 --> 00:47:24,886
how to take a result
set from the database,

824
00:47:24,886 --> 00:47:28,469
and how to convert it
into a list of books.

825
00:47:29,920 --> 00:47:32,963
Now it's a class, as I say,
that we're going to write,

826
00:47:32,963 --> 00:47:36,419
you could do the usual process
of going to File, New Class,

827
00:47:36,419 --> 00:47:40,419
but, as this class is
only ever going to be used

828
00:47:41,795 --> 00:47:45,962
inside this class, you might
find that it's quite common,

829
00:47:47,375 --> 00:47:50,271
you might not have even seen
this before in Java but,

830
00:47:50,271 --> 00:47:54,499
this is the end curly bracket,
at the end of the class,

831
00:47:54,499 --> 00:47:58,021
and I can here, it's
perfectly legal in Java,

832
00:47:58,021 --> 00:48:01,388
to declare another class in the same file,

833
00:48:01,388 --> 00:48:04,305
this is going to be our BookMapper.

834
00:48:06,175 --> 00:48:08,831
Notice there's no compile
errors, the rule in Java

835
00:48:08,831 --> 00:48:12,998
is you can only have one public
class within a single file,

836
00:48:14,240 --> 00:48:18,781
but you can have these
so-called inner classes.

837
00:48:18,781 --> 00:48:20,565
Now inner classes are a bit complicated,

838
00:48:20,565 --> 00:48:22,983
I'm certainly not going to
go into any detail on them

839
00:48:22,983 --> 00:48:25,520
or any depth, but the point is,

840
00:48:25,520 --> 00:48:28,071
because I'm only ever
going to use this class,

841
00:48:28,071 --> 00:48:30,336
in this class, there's no point

842
00:48:30,336 --> 00:48:32,351
creating a separate file for it.

843
00:48:32,351 --> 00:48:36,169
If you hate that, feel
free to go File, New Class,

844
00:48:36,169 --> 00:48:39,035
and just create a brand new file for it.

845
00:48:39,035 --> 00:48:41,523
The way this BookMapper class works,

846
00:48:41,523 --> 00:48:44,266
is you have to implement a class

847
00:48:44,266 --> 00:48:47,849
from the Spring Framework
called RowMapper.

848
00:48:49,534 --> 00:48:52,568
Now that will need to be imported,

849
00:48:52,568 --> 00:48:53,803
and you've got to be very careful

850
00:48:53,803 --> 00:48:58,169
because there's another
RowMapper in a different library.

851
00:48:58,169 --> 00:49:01,878
You want the Spring Framework RowMapper,

852
00:49:01,878 --> 00:49:06,217
and what that RowMapper is
there for, it's kind of a guide.

853
00:49:06,217 --> 00:49:08,878
If I click on the error here,

854
00:49:08,878 --> 00:49:12,407
and select Add unimplemented methods,

855
00:49:12,407 --> 00:49:15,228
it's rather helpfully guiding us here,

856
00:49:15,228 --> 00:49:19,395
it's showing us what we need
to do to implement a mapper.

857
00:49:20,247 --> 00:49:23,423
Now the idea is, if we
have a single method

858
00:49:23,423 --> 00:49:27,819
in there called mapRow,
and its got two parameters,

859
00:49:27,819 --> 00:49:31,986
its got a result set, I'm just
going to rename this to rs,

860
00:49:33,008 --> 00:49:37,011
and the second parameter is the rowNumber.

861
00:49:37,011 --> 00:49:41,092
Now the result set, I'm
assuming you know JDBC here,

862
00:49:41,092 --> 00:49:46,042
a result set is what you
get back from an SQL query.

863
00:49:46,042 --> 00:49:49,561
So if you like, what Spring
is asking us to do here,

864
00:49:49,561 --> 00:49:51,996
is it's asking us to tell it,

865
00:49:51,996 --> 00:49:55,079
given a single row from a result set,

866
00:49:56,198 --> 00:50:00,296
how do we convert that
into a domain object?

867
00:50:00,296 --> 00:50:01,798
So it's really quite simple

868
00:50:01,798 --> 00:50:04,567
we know that given a
single row for a book,

869
00:50:04,567 --> 00:50:07,777
we're going to have a string for the ISBN,

870
00:50:07,777 --> 00:50:11,164
and that will come from the result set,

871
00:50:11,164 --> 00:50:14,082
we call the getString method
on there, and we tell it

872
00:50:14,082 --> 00:50:18,190
which column we're
extracting that value from.

873
00:50:18,190 --> 00:50:21,357
And then we do the same for the title,

874
00:50:25,537 --> 00:50:28,287
and then the same for the author,

875
00:50:32,831 --> 00:50:36,081
and the price in this case is a double,

876
00:50:38,515 --> 00:50:41,341
so I need to call getDouble method

877
00:50:41,341 --> 00:50:42,174
for the price.

878
00:50:42,174 --> 00:50:45,101
Now, I'm sorry, I went a
little bit quickly there,

879
00:50:45,101 --> 00:50:47,387
and if any of that's confused you,

880
00:50:47,387 --> 00:50:52,112
just go back to our original
horrible implementation,

881
00:50:52,112 --> 00:50:56,279
and you can find the same query
method, here it is allBooks,

882
00:50:57,660 --> 00:51:01,827
we're effectively grabbing
these lines of code here,

883
00:51:03,288 --> 00:51:05,059
notice it's exactly the same thing

884
00:51:05,059 --> 00:51:07,753
where we're processing the result set.

885
00:51:07,753 --> 00:51:10,796
Now Spring doesn't know how
to do that automatically,

886
00:51:10,796 --> 00:51:14,193
so this is how we tell Spring what to do.

887
00:51:14,193 --> 00:51:16,535
So we need to at the end of this process,

888
00:51:16,535 --> 00:51:17,618
create a book

889
00:51:19,810 --> 00:51:21,977
from those pieces of data,

890
00:51:26,492 --> 00:51:30,990
and we return that book
at the end of the method.

891
00:51:30,990 --> 00:51:33,248
And then, it's all compiling.

892
00:51:33,248 --> 00:51:35,590
Because the RowMapper interface is generic

893
00:51:35,590 --> 00:51:38,580
it can return any type of object.

894
00:51:38,580 --> 00:51:42,100
The problem will be when we
use this BookMapper up here,

895
00:51:42,100 --> 00:51:44,192
we're going to have some mess around

896
00:51:44,192 --> 00:51:46,815
typecasting back into a book.

897
00:51:46,815 --> 00:51:50,365
So, if you're lucky enough
to be on Java 5 onwards,

898
00:51:50,365 --> 00:51:53,481
we can in fact use a generic here,

899
00:51:53,481 --> 00:51:56,556
using Book in angled brackets there,

900
00:51:56,556 --> 00:51:59,318
we can then, in fact
we're forced to do so,

901
00:51:59,318 --> 00:52:02,016
we can change the type there to a Book,

902
00:52:02,016 --> 00:52:04,903
and that cleans the code up later on.

903
00:52:04,903 --> 00:52:09,656
Now, I have to admit that that's
not terribly pleasant code,

904
00:52:09,656 --> 00:52:12,234
and it's certainly not as
easy to do a query method

905
00:52:12,234 --> 00:52:14,764
as it is to do an insert method.

906
00:52:14,764 --> 00:52:18,931
But if we go back now to our
original allBooks method,

907
00:52:20,579 --> 00:52:23,963
notice now, that code is compiling.

908
00:52:23,963 --> 00:52:25,913
And, if you kind of ignore

909
00:52:25,913 --> 00:52:28,692
the complicated stuff at the bottom,

910
00:52:28,692 --> 00:52:32,968
our query method now is
a single line of code.

911
00:52:32,968 --> 00:52:35,151
Now, I know I'm jumping
around a little bit here,

912
00:52:35,151 --> 00:52:39,318
but if I go down to the
findBooksByAuthor method down here,

913
00:52:40,851 --> 00:52:42,150
the great thing is it's so simple

914
00:52:42,150 --> 00:52:44,450
it's going to be a single line of code,

915
00:52:44,450 --> 00:52:48,117
I just return the
jdbcTemplate query method,

916
00:52:49,518 --> 00:52:51,412
Eclipse by the way used
to show me the first

917
00:52:51,412 --> 00:52:54,697
of the different versions
of the query method,

918
00:52:54,697 --> 00:52:57,566
I'm in fact using the one
where the first parameter

919
00:52:57,566 --> 00:52:59,339
is the SQL I'm executing.

920
00:52:59,339 --> 00:53:02,549
Now, because I didn't implement
this in my previous version

921
00:53:02,549 --> 00:53:06,369
I don't have the SQL created for this so,

922
00:53:06,369 --> 00:53:10,083
just for speed I'm going to
do this inline right here but,

923
00:53:10,083 --> 00:53:12,506
of course you could make this a variable.

924
00:53:12,506 --> 00:53:13,586
This is going to be

925
00:53:13,586 --> 00:53:16,919
"SELECT * FROM BOOK WHERE AUTHOR ="

926
00:53:18,972 --> 00:53:22,590
and again I'm going to use a
placeholder for the parameter.

927
00:53:22,590 --> 00:53:25,724
The second parameter to the
method is the same as before,

928
00:53:25,724 --> 00:53:29,891
we supply the BookRow
mapper, or BookMapper rather,

929
00:53:31,241 --> 00:53:33,703
because the process of
converting the results

930
00:53:33,703 --> 00:53:38,032
from this query into a book
is the same as it was before,

931
00:53:38,032 --> 00:53:41,186
and then the third parameter
is going to be the value

932
00:53:41,186 --> 00:53:43,964
I want Spring to put
into the question mark,

933
00:53:43,964 --> 00:53:46,814
in this case it's going to be the author.

934
00:53:46,814 --> 00:53:49,555
Now, if I did have more
than one question mark,

935
00:53:49,555 --> 00:53:52,367
I would just go ahead and list them here,

936
00:53:52,367 --> 00:53:55,397
but we just need the author in this case.

937
00:53:55,397 --> 00:53:57,839
Again if you're working on
earlier versions of Spring

938
00:53:57,839 --> 00:54:00,892
or earlier versions of the
Java Development Kit then,

939
00:54:00,892 --> 00:54:04,961
you would need to wrap
those into an object array.

940
00:54:04,961 --> 00:54:09,090
But that's compiling, it
was as simple as that.

941
00:54:09,090 --> 00:54:11,707
I'll now implement all
of the other methods,

942
00:54:11,707 --> 00:54:13,415
and I'll go quite quickly now.

943
00:54:13,415 --> 00:54:16,207
For findByIsbn it's going to be,

944
00:54:16,207 --> 00:54:19,222
again the query method, and it will be

945
00:54:19,222 --> 00:54:21,805
"SELECT * FROM BOOK WHERE ISBN"

946
00:54:25,296 --> 00:54:28,198
matches a particular value.

947
00:54:28,198 --> 00:54:30,365
We'll reuse the BookMapper

948
00:54:34,519 --> 00:54:37,436
and the parameter will be the ISBN.

949
00:54:38,893 --> 00:54:40,940
Now, we do have a difference here in fact,

950
00:54:40,940 --> 00:54:45,248
because findByIsbn is only
going to find a single book,

951
00:54:45,248 --> 00:54:48,806
it's not going to find a list of books.

952
00:54:48,806 --> 00:54:50,948
We need to tell Spring
that it's only expecting

953
00:54:50,948 --> 00:54:53,949
a single value back from here.

954
00:54:53,949 --> 00:54:56,604
That's really easy, instead
of using the query method,

955
00:54:56,604 --> 00:54:59,687
we can use the queryForObject method,

956
00:55:00,526 --> 00:55:04,693
now Spring knows there should
be only one result back.

957
00:55:05,779 --> 00:55:10,510
All that remains I think is to
implement the delete method.

958
00:55:10,510 --> 00:55:13,744
Now, something that I
didn't mention before,

959
00:55:13,744 --> 00:55:18,265
is that you might expect
there to be a delete method

960
00:55:18,265 --> 00:55:21,229
here in the template, but there isn't,

961
00:55:21,229 --> 00:55:24,682
and in fact there isn't
an insert method either.

962
00:55:24,682 --> 00:55:25,865
And that's because Spring

963
00:55:25,865 --> 00:55:28,948
is just reflecting the JDBC API here.

964
00:55:29,912 --> 00:55:33,732
All of inserts, updates and deletes,

965
00:55:33,732 --> 00:55:36,748
and in fact even creating
and dropping tables,

966
00:55:36,748 --> 00:55:40,150
is done through the update method.

967
00:55:40,150 --> 00:55:44,831
So, for deleting a particular
book, I just need to,

968
00:55:44,831 --> 00:55:49,400
well I'm not sure really,
"DELETE FROM BOOK WHERE"

969
00:55:49,400 --> 00:55:51,522
I'm going to assume for this system

970
00:55:51,522 --> 00:55:55,151
that the key for the
books is the ISBN number.

971
00:55:55,151 --> 00:55:58,518
I'm not sure that's exactly
right but, anyway in this case

972
00:55:58,518 --> 00:56:01,980
"DELETE FROM BOOK WHERE ISBN"
matches a particular value,

973
00:56:01,980 --> 00:56:03,318
and in this case it's going to be

974
00:56:03,318 --> 00:56:05,651
the redundantBook's .getIsbn

975
00:56:08,846 --> 00:56:10,595
I think it's worth removing

976
00:56:10,595 --> 00:56:13,753
this auto-generated comment as well.

977
00:56:13,753 --> 00:56:16,252
I think, this class is now complete.

978
00:56:16,252 --> 00:56:18,471
Now, I haven't tested any of this yet,

979
00:56:18,471 --> 00:56:21,469
so I don't know if it works,
but the point to take away

980
00:56:21,469 --> 00:56:25,188
from this is using this
Spring JdbcTemplate,

981
00:56:25,188 --> 00:56:28,621
it's got rid of all of that nasty code.

982
00:56:28,621 --> 00:56:31,489
It took me just a handful
of minutes to implement

983
00:56:31,489 --> 00:56:35,621
four or five different
database operations.

984
00:56:35,621 --> 00:56:39,408
And really for me the only ugly
part was having to implement

985
00:56:39,408 --> 00:56:43,573
this mapper down at the
bottom, and in any case,

986
00:56:43,573 --> 00:56:47,973
we can took that code away,
at the bottom of the class.

987
00:56:47,973 --> 00:56:49,562
Now something I nearly forgot to do,

988
00:56:49,562 --> 00:56:51,560
was that in our previous implementation

989
00:56:51,560 --> 00:56:54,937
we automatically created tables

990
00:56:54,937 --> 00:56:57,455
if they didn't already exist.

991
00:56:57,455 --> 00:57:00,045
So, I suggest that the
way that we do that,

992
00:57:00,045 --> 00:57:04,806
is in the constructor, once
the template has been set up,

993
00:57:04,806 --> 00:57:06,723
we can use the template

994
00:57:08,540 --> 00:57:12,182
to issue the CREATE_TABLE_SQL statement.

995
00:57:12,182 --> 00:57:15,708
Well as I mentioned, really
everything apart from querying

996
00:57:15,708 --> 00:57:18,455
is done via the update method,

997
00:57:18,455 --> 00:57:22,538
so I need to pass in the
CREATE_TABLE_SQL string,

998
00:57:24,600 --> 00:57:26,839
and because there's no
parameters into this,

999
00:57:26,839 --> 00:57:31,469
that's all I need to do that
particular table creation.

1000
00:57:31,469 --> 00:57:32,744
Well it's not quite as simple as that

1001
00:57:32,744 --> 00:57:35,522
because remember that might fail,

1002
00:57:35,522 --> 00:57:40,085
so I'm going to enclose
that in a try-catch block,

1003
00:57:40,085 --> 00:57:42,171
and if we get an exception,

1004
00:57:42,171 --> 00:57:45,856
I'm just going to use exception for now,

1005
00:57:45,856 --> 00:57:49,239
I'm going to work on the assumption

1006
00:57:49,239 --> 00:57:52,656
"Assuming that the table already exists".

1007
00:57:54,600 --> 00:57:58,117
Now that clearly needs some improvement,

1008
00:57:58,117 --> 00:58:02,284
so I'll leave a marker there
"TODO: improve this try block".

1009
00:58:04,325 --> 00:58:05,694
We'll come back to that when we've looked

1010
00:58:05,694 --> 00:58:08,763
at Spring's exception handling.

1011
00:58:08,763 --> 00:58:13,058
Well I'd love to run this code
now, just to see if it works,

1012
00:58:13,058 --> 00:58:16,376
but unfortunately we do
have a little bit more work

1013
00:58:16,376 --> 00:58:18,470
to do to get this working.

1014
00:58:18,470 --> 00:58:20,542
We need to configure Spring to tell it

1015
00:58:20,542 --> 00:58:24,094
how to manage the database connections.

1016
00:58:24,094 --> 00:58:26,480
Well that's quite a big job on its own,

1017
00:58:26,480 --> 00:58:28,213
and we've been working
for a long time now,

1018
00:58:28,213 --> 00:58:30,989
so, we're going to take a break here,

1019
00:58:30,989 --> 00:58:33,431
and at the end of the next chapter,

1020
00:58:33,431 --> 00:58:34,906
we'll be able to get this running,

1021
00:58:34,906 --> 00:58:37,239
and make sure that it works.

1022
00:58:38,565 --> 00:58:41,140
Well I'm sorry that we
can't run the code just yet,

1023
00:58:41,140 --> 00:58:43,807
we do have some work to do
relating to connections,

1024
00:58:43,807 --> 00:58:46,740
but I hope you can see how much nicer

1025
00:58:46,740 --> 00:58:49,657
a DAO coded using this template is.

1026
00:58:51,250 --> 00:58:54,700
Spring provides support for many of the

1027
00:58:54,700 --> 00:58:58,582
main database strategies
that you can use in Java.

1028
00:58:58,582 --> 00:59:01,614
We'll be studying all of them
on this course in detail,

1029
00:59:01,614 --> 00:59:04,281
but the fundamental one is JDBC.

1030
00:59:05,800 --> 00:59:08,398
We coded up a data access object

1031
00:59:08,398 --> 00:59:12,251
and injected it into a
production service class.

1032
00:59:12,251 --> 00:59:15,250
That was some good practice at wiring,

1033
00:59:15,250 --> 00:59:18,645
but then we brought in the
JDBCTemplate helper class,

1034
00:59:18,645 --> 00:59:21,163
I think it's a great class.

1035
00:59:21,163 --> 00:59:25,092
It hides all of the nasty
low-level JDBC code,

1036
00:59:25,092 --> 00:59:29,391
including opening and closing connections.

1037
00:59:29,391 --> 00:59:33,378
The only slight ugliness is
that we had to write a mapper,

1038
00:59:33,378 --> 00:59:36,586
but that was hardly hard work.

1039
00:59:36,586 --> 00:59:38,005
Well, in the next chapter,

1040
00:59:38,005 --> 00:59:40,482
we'll need to get this code
running, and to do that,

1041
00:59:40,482 --> 00:59:44,270
we'll learn how to
configure a connection pool.

1042
00:59:44,270 --> 00:59:46,970
So have a good break, I'll see you then.

1043
00:59:46,970 --> 00:59:50,053
(light techno music)

1
00:00:10,299 --> 00:00:11,132
- [Voiceover] In chapter ten, we are

2
00:00:11,132 --> 00:00:13,234
going to get our nice clean DAO

3
00:00:13,234 --> 00:00:15,581
that we wrote in the previous chapter,

4
00:00:15,581 --> 00:00:17,346
up and running.

5
00:00:17,346 --> 00:00:19,395
To do that, we will need to understand

6
00:00:19,395 --> 00:00:21,145
what a datasource is.

7
00:00:21,984 --> 00:00:25,639
It is standard Java, but you
might not have met it before

8
00:00:25,639 --> 00:00:28,293
so I will give you an overview.

9
00:00:28,293 --> 00:00:30,459
The real reason for using the DataSource

10
00:00:30,459 --> 00:00:32,306
is allow us to plug in

11
00:00:32,306 --> 00:00:36,096
production quality connection pools.

12
00:00:36,096 --> 00:00:38,715
So again an overview of what they are

13
00:00:38,715 --> 00:00:41,500
and how to use them in Spring.

14
00:00:41,500 --> 00:00:44,532
As we are getting a
little more serious now,

15
00:00:44,532 --> 00:00:46,666
we are going to have to
be careful to clean up

16
00:00:46,666 --> 00:00:48,600
our resources properly.

17
00:00:48,600 --> 00:00:51,149
So a little more spring theory

18
00:00:51,149 --> 00:00:53,243
will give us the very useful

19
00:00:53,243 --> 00:00:55,743
init and destroy methods.

20
00:00:59,183 --> 00:01:01,356
So here is the code as we left it

21
00:01:01,356 --> 00:01:04,072
at the end of the previous chapter.

22
00:01:04,072 --> 00:01:07,772
And we are currently still using our old

23
00:01:07,772 --> 00:01:10,963
book DAO which is this horrible

24
00:01:10,963 --> 00:01:14,593
JDBC implementation.

25
00:01:14,593 --> 00:01:18,926
Now I want to bring into play
my new DAO implementation

26
00:01:18,926 --> 00:01:21,570
that we wrote in the previous chapter.

27
00:01:21,570 --> 00:01:24,977
So I'm going to go into the XML wiring

28
00:01:24,977 --> 00:01:28,687
and if I just remind myself
of the name of our clusters.

29
00:01:28,687 --> 00:01:31,860
We've got the horrid JDBC implementation

30
00:01:31,860 --> 00:01:35,117
that we are now getting rid of,

31
00:01:35,117 --> 00:01:37,505
but I'm replacing it for the new one

32
00:01:37,505 --> 00:01:41,588
which I called book DAO cleaner

33
00:01:43,244 --> 00:01:46,077
JDBC implementation.

34
00:01:47,757 --> 00:01:49,353
Now I'm being a bit silly by calling it

35
00:01:49,353 --> 00:01:51,453
cleaner JDBC implementation.

36
00:01:51,453 --> 00:01:53,265
You probably wouldnt use a class name

37
00:01:53,265 --> 00:01:54,832
like that on a real project

38
00:01:54,832 --> 00:01:57,510
but I'm just emphasizing the role

39
00:01:57,510 --> 00:02:00,593
and purpose of this particular class.

40
00:02:01,635 --> 00:02:04,420
Now you might remember if I can go

41
00:02:04,420 --> 00:02:07,753
into that class just to remind ourselves

42
00:02:08,644 --> 00:02:12,932
that we have a property
in this new implementation

43
00:02:12,932 --> 00:02:14,400
of the DAO.

44
00:02:14,400 --> 00:02:17,276
And that property is being injected

45
00:02:17,276 --> 00:02:19,276
through the constructor.

46
00:02:20,409 --> 00:02:22,019
Yeah and there it is.

47
00:02:22,019 --> 00:02:25,019
We need to inject this JDBC template

48
00:02:26,187 --> 00:02:28,171
into the constructor.

49
00:02:28,171 --> 00:02:29,908
You will remember from
the previous chapter

50
00:02:29,908 --> 00:02:32,264
that this is the helper object

51
00:02:32,264 --> 00:02:35,528
that we are using to clean up the DAO code

52
00:02:35,528 --> 00:02:37,423
really quite beautifully.

53
00:02:37,423 --> 00:02:39,846
All of these DAO methods are just

54
00:02:39,846 --> 00:02:41,596
single lines of code.

55
00:02:42,443 --> 00:02:45,528
So we need to do that in the XML.

56
00:02:45,528 --> 00:02:47,831
Now this template isn't really a DAO

57
00:02:47,831 --> 00:02:49,786
and it's certainly not a service bean.

58
00:02:49,786 --> 00:02:52,361
So I'm going to create a new little area

59
00:02:52,361 --> 00:02:55,409
in the XML and I'm going to call this area

60
00:02:55,409 --> 00:02:58,615
template because we might be doing a few

61
00:02:58,615 --> 00:03:01,219
more templates later on in the course.

62
00:03:01,219 --> 00:03:03,805
We need to create a bean and give it an ID

63
00:03:03,805 --> 00:03:06,300
and we can call it anything we wish.

64
00:03:06,300 --> 00:03:09,383
So I'm going to go for JDBC template.

65
00:03:10,395 --> 00:03:12,926
The problem is what class
name do I need in here?

66
00:03:12,926 --> 00:03:16,076
Of course I will need
a package name as well.

67
00:03:16,076 --> 00:03:18,592
Now this is a Spring framework class.

68
00:03:18,592 --> 00:03:21,707
So we have made this name up.

69
00:03:21,707 --> 00:03:24,260
Now I don't carry these class names

70
00:03:24,260 --> 00:03:26,152
around in my head.

71
00:03:26,152 --> 00:03:27,492
Of course I'm going to tell you what

72
00:03:27,492 --> 00:03:29,971
the class name is in a minute,

73
00:03:29,971 --> 00:03:32,109
but I want to encourage you on this course

74
00:03:32,109 --> 00:03:36,730
to get used to working with
the Spring documentation.

75
00:03:36,730 --> 00:03:38,663
I've switched across now to the

76
00:03:38,663 --> 00:03:40,389
Spring framework website.

77
00:03:40,389 --> 00:03:43,451
At least at the time of this recording

78
00:03:43,451 --> 00:03:46,093
it is called Spring.IO,

79
00:03:46,093 --> 00:03:48,819
but remember that might have changed

80
00:03:48,819 --> 00:03:51,340
by the time you watch this.

81
00:03:51,340 --> 00:03:52,822
Of course there's masses of information

82
00:03:52,822 --> 00:03:55,549
about Spring framework on this site.

83
00:03:55,549 --> 00:03:56,444
At the time of recording,

84
00:03:56,444 --> 00:03:59,578
we go through the Docs link.

85
00:03:59,578 --> 00:04:02,011
The project you are
looking for on this list

86
00:04:02,011 --> 00:04:05,055
is the Spring framework of course

87
00:04:05,055 --> 00:04:08,083
and we are looking here at the API for,

88
00:04:08,083 --> 00:04:10,160
well you will need to
choose the correct version

89
00:04:10,160 --> 00:04:12,386
but just at the time I'm
recording this course,

90
00:04:12,386 --> 00:04:14,803
the current version is 4.0.1.

91
00:04:15,692 --> 00:04:17,664
As long as you choose a recent version,

92
00:04:17,664 --> 00:04:19,643
you should be okay.

93
00:04:19,643 --> 00:04:22,471
And there are pretty much literally

94
00:04:22,471 --> 00:04:25,931
thousands of classes in
the Spring framework.

95
00:04:25,931 --> 00:04:27,864
I know that the class I'm looking for

96
00:04:27,864 --> 00:04:31,773
is celled the JDBC template.

97
00:04:31,773 --> 00:04:35,231
So Ill do a Control F in my browser,

98
00:04:35,231 --> 00:04:38,120
and just type in JDBC template

99
00:04:38,120 --> 00:04:41,316
and that jumps me straight to

100
00:04:41,316 --> 00:04:43,329
the Java docs for this class.

101
00:04:43,329 --> 00:04:44,717
The first thing I need to know is

102
00:04:44,717 --> 00:04:47,816
the name of the package
from which it comes.

103
00:04:47,816 --> 00:04:50,129
And that's right here.

104
00:04:50,129 --> 00:04:52,027
So I'm going to copy that into the

105
00:04:52,027 --> 00:04:55,603
development environment so
the class is going to be

106
00:04:55,603 --> 00:04:59,770
that package followed by JDBC template,

107
00:05:01,569 --> 00:05:03,260
but the real reason we're using this

108
00:05:03,260 --> 00:05:05,735
documentation page is
we are going to need to

109
00:05:05,735 --> 00:05:08,121
find out what properties

110
00:05:08,121 --> 00:05:10,792
the JDBC template needs.

111
00:05:10,792 --> 00:05:13,184
Now there are two ways you can do that.

112
00:05:13,184 --> 00:05:16,146
First of all you could scroll down

113
00:05:16,146 --> 00:05:19,524
and have a look on the old methods tab

114
00:05:19,524 --> 00:05:22,191
and you can look for any methods

115
00:05:23,098 --> 00:05:26,148
starting with the word set.

116
00:05:26,148 --> 00:05:30,808
For example we have a method
here called set fetch size.

117
00:05:30,808 --> 00:05:33,942
So this is a property
that we can configure

118
00:05:33,942 --> 00:05:35,109
in XML wiring.

119
00:05:36,284 --> 00:05:38,510
If I click through to that link,

120
00:05:38,510 --> 00:05:41,478
it is talking about that this is important

121
00:05:41,478 --> 00:05:44,995
if you want to process large result sets.

122
00:05:44,995 --> 00:05:47,798
If you set it to a high value,

123
00:05:47,798 --> 00:05:50,186
it will increase the
processing speed across the

124
00:05:50,186 --> 00:05:52,905
memory consumption, blah-blah-blah.

125
00:05:52,905 --> 00:05:55,353
It really is Blah because the point is

126
00:05:55,353 --> 00:05:59,304
the defaults has already been set.

127
00:05:59,304 --> 00:06:01,529
The default is zero.

128
00:06:01,529 --> 00:06:05,279
Actually we don't have
to set the fetch size.

129
00:06:06,356 --> 00:06:08,710
If you have a good read
of this documentation,

130
00:06:08,710 --> 00:06:11,026
if you are interested you will find that

131
00:06:11,026 --> 00:06:15,193
all of the set methods have good defaults.

132
00:06:16,373 --> 00:06:19,374
I'm going for the set query timeout here

133
00:06:19,374 --> 00:06:21,310
the default is zero.

134
00:06:21,310 --> 00:06:24,634
So most of the properties in this class

135
00:06:24,634 --> 00:06:26,846
have a default already set,

136
00:06:26,846 --> 00:06:30,510
but there is one property
that is absolutely

137
00:06:30,510 --> 00:06:34,010
required and we will always need to set it

138
00:06:35,131 --> 00:06:38,206
and for that reason, the Spring team have

139
00:06:38,206 --> 00:06:42,373
made this property be injected
through the constructor.

140
00:06:43,766 --> 00:06:47,561
If we have a look at this
version of the constructor here,

141
00:06:47,561 --> 00:06:51,105
it is telling us that
it requires a property

142
00:06:51,105 --> 00:06:54,656
of type DataSource.

143
00:06:54,656 --> 00:06:57,040
So Spring is effectively telling us here

144
00:06:57,040 --> 00:07:00,799
that we need to create an
objective type DataSource

145
00:07:00,799 --> 00:07:04,517
and we need to inject
it into the template.

146
00:07:04,517 --> 00:07:08,710
If I follow the link
here to the DataSource,

147
00:07:08,710 --> 00:07:10,959
I dont know if you've
come across this DataSource

148
00:07:10,959 --> 00:07:14,834
before but it is a part of standard Java

149
00:07:14,834 --> 00:07:17,966
and not the Spring framework.

150
00:07:17,966 --> 00:07:20,530
Have a look at the package name here.

151
00:07:20,530 --> 00:07:24,030
You can see it is a standard Java package.

152
00:07:24,942 --> 00:07:29,176
Now the idea of this DataSource is that

153
00:07:29,176 --> 00:07:31,564
it is a kind of wrapper class.

154
00:07:31,564 --> 00:07:34,823
It only really has one
single interesting method.

155
00:07:34,823 --> 00:07:38,370
And that method is called get connection.

156
00:07:38,370 --> 00:07:42,445
It is overloaded for username
and password as well.

157
00:07:42,445 --> 00:07:45,492
Now the idea is that any
class that implements

158
00:07:45,492 --> 00:07:48,489
this interface is that that class is

159
00:07:48,489 --> 00:07:52,656
capable of returning here
a database connection

160
00:07:53,709 --> 00:07:56,256
using some kind of strategy.

161
00:07:56,256 --> 00:07:59,175
Usually on server based applications,

162
00:07:59,175 --> 00:08:04,126
the strategy in use is some
kind of a connection pool.

163
00:08:04,126 --> 00:08:06,739
We will talk about connection pools later.

164
00:08:06,739 --> 00:08:08,966
The problem with the DataSource interface

165
00:08:08,966 --> 00:08:10,693
and it is really the
thing that makes people

166
00:08:10,693 --> 00:08:14,684
think that this interface
is a complicated interface

167
00:08:14,684 --> 00:08:18,851
is that there are no implementing
classes of DataSource

168
00:08:20,083 --> 00:08:23,009
in the standard Java library.

169
00:08:23,009 --> 00:08:26,009
So it is kind of on its own useless.

170
00:08:27,413 --> 00:08:30,460
The idea of this
DataSource, the reason why

171
00:08:30,460 --> 00:08:34,043
Sun originally put this
interface into Java

172
00:08:34,959 --> 00:08:39,138
is that their intention was
and if I put a highlighter

173
00:08:39,138 --> 00:08:42,742
on this phrase here,
their intention was that

174
00:08:42,742 --> 00:08:46,738
vendors probably database vendors,

175
00:08:46,738 --> 00:08:49,742
would implement this interface.

176
00:08:49,742 --> 00:08:52,926
So if we wanted to use a
DataSource in our application,

177
00:08:52,926 --> 00:08:56,591
we might go off to I dont
know, a company like Oracle

178
00:08:56,591 --> 00:09:00,424
and buy a DataSource
implementation from them.

179
00:09:01,569 --> 00:09:03,764
Now I'll talk about that shortly,

180
00:09:03,764 --> 00:09:06,070
but don't worry you are
not going to need to go to

181
00:09:06,070 --> 00:09:08,320
Oracle to buy a DataSource.

182
00:09:09,201 --> 00:09:13,450
That's because since Spring 2.5,

183
00:09:13,450 --> 00:09:15,539
there is a class in the Spring framework

184
00:09:15,539 --> 00:09:19,706
called the simple driver DataSource.

185
00:09:20,746 --> 00:09:24,913
Let me just find that using my
usual Ctrl F in the browser.

186
00:09:26,581 --> 00:09:28,498
Here it is here.

187
00:09:28,498 --> 00:09:31,834
So here have the simple
driver DataSource class

188
00:09:31,834 --> 00:09:34,351
and crucially have a look here.

189
00:09:34,351 --> 00:09:37,601
It implements the DataSource interface.

190
00:09:39,461 --> 00:09:42,628
Now this is a very basic class.

191
00:09:44,072 --> 00:09:48,316
It is just really for
testing or development

192
00:09:48,316 --> 00:09:52,683
or just getting up and
running with your application.

193
00:09:52,683 --> 00:09:55,365
The reason it is not
production standard is

194
00:09:55,365 --> 00:09:58,369
what will happen is every time we work

195
00:09:58,369 --> 00:10:01,689
with a simple driver DataSource,

196
00:10:01,689 --> 00:10:05,405
every time we perform a database operation

197
00:10:05,405 --> 00:10:07,174
this class will go

198
00:10:07,174 --> 00:10:10,841
and acquire a brand new
database connection.

199
00:10:11,914 --> 00:10:13,475
So let's be clear about this.

200
00:10:13,475 --> 00:10:16,531
This is a terrible thing to do

201
00:10:16,531 --> 00:10:18,063
on a real application.

202
00:10:18,063 --> 00:10:20,730
It is going to perform horribly.

203
00:10:21,645 --> 00:10:23,379
Opening a database connection

204
00:10:23,379 --> 00:10:25,928
is a very slow operation.

205
00:10:25,928 --> 00:10:28,314
So you don't want to be doing that

206
00:10:28,314 --> 00:10:32,031
every time you make a
call to the database.

207
00:10:32,031 --> 00:10:35,261
And that giving advice here
on what we could use instead

208
00:10:35,261 --> 00:10:39,464
and Ill come back on to
that later in this course.

209
00:10:39,464 --> 00:10:40,912
Why is this class here?

210
00:10:40,912 --> 00:10:44,112
Well as I say it is intended
for testing your code

211
00:10:44,112 --> 00:10:45,043
when you are developing.

212
00:10:45,043 --> 00:10:48,100
It is a real quick and
dirty way of making sure

213
00:10:48,100 --> 00:10:50,576
your application is up and running,

214
00:10:50,576 --> 00:10:53,301
the wiring is working and so on.

215
00:10:53,301 --> 00:10:55,702
And then once your code is working,

216
00:10:55,702 --> 00:10:56,782
we will be able to change

217
00:10:56,782 --> 00:10:59,219
the implementation of the DataSource

218
00:10:59,219 --> 00:11:01,618
without needing to change any of the code

219
00:11:01,618 --> 00:11:04,236
for something a bit
more production quality.

220
00:11:04,236 --> 00:11:05,748
And of course I'm going to do that

221
00:11:05,748 --> 00:11:07,748
very soon on the course.

222
00:11:08,632 --> 00:11:11,273
I dont know if you know
what connection pools are.

223
00:11:11,273 --> 00:11:14,070
So I'd rather leave those
until a little later.

224
00:11:14,070 --> 00:11:17,055
It looks like we can use
the simple driver DataSource

225
00:11:17,055 --> 00:11:19,734
as a quick way of getting started.

226
00:11:19,734 --> 00:11:20,640
Now we will need to work out

227
00:11:20,640 --> 00:11:22,206
what properties are required

228
00:11:22,206 --> 00:11:24,710
for this simple driver DataSource.

229
00:11:24,710 --> 00:11:28,415
I must admit being honest
that one of the problems

230
00:11:28,415 --> 00:11:30,766
with the Spring API docs is that

231
00:11:30,766 --> 00:11:32,537
it can be a little awkward to work out

232
00:11:32,537 --> 00:11:35,169
what properties are required.

233
00:11:35,169 --> 00:11:38,677
I can see for instance there
were two set methods here.

234
00:11:38,677 --> 00:11:42,231
They both appear to be
relating to the driver,

235
00:11:42,231 --> 00:11:44,053
but actually there were
several more methods

236
00:11:44,053 --> 00:11:47,149
inherited from super classes

237
00:11:47,149 --> 00:11:50,116
such as set connection properties,

238
00:11:50,116 --> 00:11:53,537
set password, set URL and username.

239
00:11:53,537 --> 00:11:55,354
It can be a little to work out

240
00:11:55,354 --> 00:11:58,455
which of these do I need to set.

241
00:11:58,455 --> 00:12:01,427
I've already kind of
worked with this class

242
00:12:01,427 --> 00:12:03,732
and I can tell you that
the four properties

243
00:12:03,732 --> 00:12:07,036
we absolutely have to set are

244
00:12:07,036 --> 00:12:08,369
the driverClass,

245
00:12:09,979 --> 00:12:11,229
the URL,

246
00:12:12,448 --> 00:12:13,531
the username,

247
00:12:14,523 --> 00:12:16,647
and the password.

248
00:12:16,647 --> 00:12:18,396
Now none of these
properties are complicated

249
00:12:18,396 --> 00:12:20,253
because they are the usual properties

250
00:12:20,253 --> 00:12:22,581
that we always to have set up

251
00:12:22,581 --> 00:12:25,678
when opening a database in Java.

252
00:12:25,678 --> 00:12:29,134
Let's have a go at configuring
this DataSource then.

253
00:12:29,134 --> 00:12:31,856
Again let's have a block up here

254
00:12:31,856 --> 00:12:33,439
for my DataSources.

255
00:12:35,286 --> 00:12:37,204
So I need to configure a bean.

256
00:12:37,204 --> 00:12:39,473
I'm going to give it an ID of,

257
00:12:39,473 --> 00:12:41,453
well you can call it anything you like,

258
00:12:41,453 --> 00:12:43,925
but I'm going for DataSource.

259
00:12:43,925 --> 00:12:45,820
On the class, it is going to be

260
00:12:45,820 --> 00:12:49,285
once again we will use the documentation,

261
00:12:49,285 --> 00:12:52,702
so we can see it comes from this package.

262
00:12:56,291 --> 00:13:00,208
And the class name is
simple driver DataSource.

263
00:13:03,501 --> 00:13:05,083
As I mentioned on the caption,

264
00:13:05,083 --> 00:13:08,988
we've got four properties
that we need to set.

265
00:13:08,988 --> 00:13:12,599
The first of them is called driver class.

266
00:13:12,599 --> 00:13:14,236
Now again I'm having to assume your

267
00:13:14,236 --> 00:13:15,704
previous knowledge here.

268
00:13:15,704 --> 00:13:18,268
If you've worked with JDBC extensively,

269
00:13:18,268 --> 00:13:19,969
you will know that you always need

270
00:13:19,969 --> 00:13:24,055
a driver class in order to
connect to that database.

271
00:13:24,055 --> 00:13:25,502
If you need guidance here,

272
00:13:25,502 --> 00:13:28,177
you can look back to our old version

273
00:13:28,177 --> 00:13:32,617
of this DAO, the horrible
JDBC implementation

274
00:13:32,617 --> 00:13:35,201
and in there we have the driver name

275
00:13:35,201 --> 00:13:36,951
and the database URL.

276
00:13:38,115 --> 00:13:40,092
For the driver name, we just need to

277
00:13:40,092 --> 00:13:42,560
copy this string here

278
00:13:42,560 --> 00:13:46,281
and to pop that into the value

279
00:13:46,281 --> 00:13:48,556
for that property.

280
00:13:48,556 --> 00:13:51,223
And then, the next property name

281
00:13:53,072 --> 00:13:53,989
is the URL,

282
00:13:54,970 --> 00:13:57,163
which once again we can borrow

283
00:13:57,163 --> 00:14:00,251
from our old implementation.

284
00:14:00,251 --> 00:14:02,584
It's that long string there.

285
00:14:09,126 --> 00:14:10,438
Then we need the username,

286
00:14:10,438 --> 00:14:13,399
which for HSQLDB, the built-in username

287
00:14:13,399 --> 00:14:15,921
is a string assay.

288
00:14:15,921 --> 00:14:19,329
Just think stands for
system administrator.

289
00:14:19,329 --> 00:14:20,746
And the password

290
00:14:21,810 --> 00:14:26,156
Or you can just leave
that value as a blank.

291
00:14:26,156 --> 00:14:28,546
Now I have an error in my XML

292
00:14:28,546 --> 00:14:31,160
and that's because it looks
like on this line here

293
00:14:31,160 --> 00:14:35,064
I forgot to close the XML tag.

294
00:14:35,064 --> 00:14:37,329
Okay well that's looking okay now.

295
00:14:37,329 --> 00:14:39,981
So a DataSource then if
you want to think of it

296
00:14:39,981 --> 00:14:42,165
like the DataSource is
just a way of telling

297
00:14:42,165 --> 00:14:46,248
Spring how you wanted to
connect to the database.

298
00:14:47,165 --> 00:14:50,742
Once we've configured
this DataSource object,

299
00:14:50,742 --> 00:14:54,606
we need to inject it into the constructor

300
00:14:54,606 --> 00:14:57,083
of the JDBC template.

301
00:14:57,083 --> 00:15:00,144
This is the constructor argument

302
00:15:00,144 --> 00:15:04,313
and we are referring to our new object

303
00:15:04,313 --> 00:15:07,104
which we call DataSource.

304
00:15:07,104 --> 00:15:09,791
Now I know from my experience
of teaching live courses

305
00:15:09,791 --> 00:15:12,793
that at this point people tend to stop

306
00:15:12,793 --> 00:15:14,707
getting quite confused.

307
00:15:14,707 --> 00:15:16,527
It is certainly true that we've configured

308
00:15:16,527 --> 00:15:18,444
an awful lot of beans.

309
00:15:19,393 --> 00:15:22,436
And it can be very easy to lose

310
00:15:22,436 --> 00:15:24,580
sight of what's happening.

311
00:15:24,580 --> 00:15:25,933
So I'm going to stop for a moment

312
00:15:25,933 --> 00:15:29,022
and recap what we've done so far.

313
00:15:29,022 --> 00:15:31,731
I'm going to go to the Spring explorer,

314
00:15:31,731 --> 00:15:33,581
right click on the XML,

315
00:15:33,581 --> 00:15:37,062
and have a look at the dependency graph.

316
00:15:37,062 --> 00:15:39,125
Now I'm going to start by looking at this

317
00:15:39,125 --> 00:15:41,556
graph here on the right hand side.

318
00:15:41,556 --> 00:15:43,777
And we are interested
at the moment to know

319
00:15:43,777 --> 00:15:46,014
BookService.

320
00:15:46,014 --> 00:15:49,396
Now that is now the production standard

321
00:15:49,396 --> 00:15:52,433
BookService implementation, which you know

322
00:15:52,433 --> 00:15:55,021
from the previous chapter is calling

323
00:15:55,021 --> 00:15:58,714
a production standard DAO.

324
00:15:58,714 --> 00:16:01,847
Now what we want this
production standard DAO to do

325
00:16:01,847 --> 00:16:05,210
is to use the JDBC template

326
00:16:05,210 --> 00:16:08,068
to call the database for us.

327
00:16:08,068 --> 00:16:11,112
Now the obvious problem
I can see from this graph

328
00:16:11,112 --> 00:16:14,627
is that we've now got a JDBC template.

329
00:16:14,627 --> 00:16:16,976
That's the work that we've just done.

330
00:16:16,976 --> 00:16:20,356
And the JDBC template
is correctly connected

331
00:16:20,356 --> 00:16:23,079
to a DataSource but you can see that

332
00:16:23,079 --> 00:16:25,912
we haven't connected this template

333
00:16:26,954 --> 00:16:28,686
to the DAO.

334
00:16:28,686 --> 00:16:30,869
It'd be great if I could just drag a line

335
00:16:30,869 --> 00:16:33,742
from there to there but I can't.

336
00:16:33,742 --> 00:16:36,406
We need to do that in the XML.

337
00:16:36,406 --> 00:16:38,377
The one thing I've forgotten to do now

338
00:16:38,377 --> 00:16:41,334
is if I go back to my DAO bean,

339
00:16:41,334 --> 00:16:44,751
I need to inject this template

340
00:16:46,134 --> 00:16:49,320
into the constructor of the DAO.

341
00:16:49,320 --> 00:16:51,451
So you know how to do that by now.

342
00:16:51,451 --> 00:16:54,167
Even if this is feeling
a little complicated,

343
00:16:54,167 --> 00:16:56,878
it is still dependency injection again

344
00:16:56,878 --> 00:16:59,225
into the constructor.

345
00:16:59,225 --> 00:17:01,477
We want to pass in the argument

346
00:17:01,477 --> 00:17:03,702
which is the JDBC template

347
00:17:03,702 --> 00:17:06,460
that we've just created.

348
00:17:06,460 --> 00:17:10,460
Now just by doing that
if I go back to the graph

349
00:17:11,567 --> 00:17:13,994
everything looks a lot more connected now.

350
00:17:13,994 --> 00:17:16,426
As I say just feel like quite a deep stack

351
00:17:16,426 --> 00:17:19,133
of objects that we've set up here.

352
00:17:19,133 --> 00:17:20,578
A quick review.

353
00:17:20,578 --> 00:17:22,919
Our production standard service

354
00:17:22,919 --> 00:17:25,189
where we might be putting business logic

355
00:17:25,189 --> 00:17:28,622
is going to be delegating to DAO

356
00:17:28,622 --> 00:17:33,229
which is only going to have
database operations inside

357
00:17:33,229 --> 00:17:37,957
but we are using a JDBC
template to simplify

358
00:17:37,957 --> 00:17:41,773
the database operations turning
a whole screenful of code

359
00:17:41,773 --> 00:17:44,315
into a single line of code

360
00:17:44,315 --> 00:17:49,130
that the JDBC template needs
a reference to this final B

361
00:17:49,130 --> 00:17:52,229
which is the DataSource which
contains all the information

362
00:17:52,229 --> 00:17:56,465
that Spring needs to connect,
to physically connect

363
00:17:56,465 --> 00:17:58,653
to that database.

364
00:17:58,653 --> 00:18:02,820
I think now if we go back
to our client's application,

365
00:18:03,817 --> 00:18:05,982
at the moment the code
we have is going to try

366
00:18:05,982 --> 00:18:07,919
to register a new book

367
00:18:07,919 --> 00:18:10,915
and then list all of the
books in the catalog.

368
00:18:10,915 --> 00:18:12,998
Now we do have a database

369
00:18:13,912 --> 00:18:16,473
that we were using in
the previous chapter.

370
00:18:16,473 --> 00:18:21,016
If I open that up in the
standard Eclipse editor,

371
00:18:21,016 --> 00:18:23,252
I dont know what state
your database will be in

372
00:18:23,252 --> 00:18:25,851
but it looks like I just
have a single book in there

373
00:18:25,851 --> 00:18:30,718
at the moment called War
and Peace by Leo Tolstoy.

374
00:18:30,718 --> 00:18:33,742
So oh and that's exactly the
line of code we wrote there,

375
00:18:33,742 --> 00:18:37,082
so if this works we should probably see

376
00:18:37,082 --> 00:18:41,536
two copies of War and Peace in the system.

377
00:18:41,536 --> 00:18:45,119
Let's give this a run
and see what happens.

378
00:18:47,516 --> 00:18:50,146
Well I'm genuinely surprised
that that ran through

379
00:18:50,146 --> 00:18:52,573
correctly because we've done

380
00:18:52,573 --> 00:18:55,584
quite a lot of work here to
pull all of this together.

381
00:18:55,584 --> 00:18:57,808
If you've had any problems,
your first port of call

382
00:18:57,808 --> 00:19:00,367
I think should be the Spring Explorer

383
00:19:00,367 --> 00:19:04,683
and check that your graph is
hanging together correctly.

384
00:19:04,683 --> 00:19:06,693
And then if anything is going wrong,

385
00:19:06,693 --> 00:19:08,873
I'd probably check the values you've got

386
00:19:08,873 --> 00:19:10,706
inside your DataSource

387
00:19:11,555 --> 00:19:15,722
but the important thing is
I'm going to check it again.

388
00:19:16,736 --> 00:19:19,858
You should now see three
copies of War and Peace

389
00:19:19,858 --> 00:19:23,176
and that's good if I have a look in my

390
00:19:23,176 --> 00:19:25,885
JDBC DAO I dont know if you remember

391
00:19:25,885 --> 00:19:27,121
but in the constructor

392
00:19:27,121 --> 00:19:31,047
we create a table if it doesn't exist.

393
00:19:31,047 --> 00:19:33,023
I think it is worth checking that.

394
00:19:33,023 --> 00:19:36,523
If I delete the two database dot DAT files

395
00:19:37,963 --> 00:19:40,296
and then run the code again.

396
00:19:43,565 --> 00:19:46,034
Yeah it looks like you
are successfully able to

397
00:19:46,034 --> 00:19:48,096
recreate that tape.

398
00:19:48,096 --> 00:19:50,027
We've reached a really good point now.

399
00:19:50,027 --> 00:19:53,722
We've got this very clean
implementation of a DAO

400
00:19:53,722 --> 00:19:57,089
which is performing all of
our database operations.

401
00:19:57,089 --> 00:20:00,009
Just to remind you that's
replacing the class.

402
00:20:00,009 --> 00:20:02,850
This horrid JDBC implementation

403
00:20:02,850 --> 00:20:07,010
that didn't work but you
can compare the two now.

404
00:20:07,010 --> 00:20:09,233
For one thing, we've now taken out

405
00:20:09,233 --> 00:20:12,732
all of these driver names and URLs

406
00:20:12,732 --> 00:20:14,241
and passwords and usernames and

407
00:20:14,241 --> 00:20:16,915
put those into the Spring XML,

408
00:20:16,915 --> 00:20:18,603
and we've dramatically cleaned down

409
00:20:18,603 --> 00:20:20,597
how much code we need to write

410
00:20:20,597 --> 00:20:22,578
in these methods.

411
00:20:22,578 --> 00:20:26,721
And we also don't need the
try catch finally's anymore

412
00:20:26,721 --> 00:20:29,689
because Spring is going to diligently

413
00:20:29,689 --> 00:20:34,172
close connections if we have any problems.

414
00:20:34,172 --> 00:20:35,991
Now just to be absolutely clear

415
00:20:35,991 --> 00:20:38,840
that this horrid JDBC implementation

416
00:20:38,840 --> 00:20:41,555
is now not being used,

417
00:20:41,555 --> 00:20:45,143
I'm going to delete it from the project.

418
00:20:45,143 --> 00:20:47,933
Now I didn't do that on the
first edition of the course,

419
00:20:47,933 --> 00:20:50,167
but I think that caused a bit of a problem

420
00:20:50,167 --> 00:20:51,193
with some viewers.

421
00:20:51,193 --> 00:20:52,553
They kind of weren't sure

422
00:20:52,553 --> 00:20:54,272
which one was actually being in use,

423
00:20:54,272 --> 00:20:56,950
but now that I've deleted that horrible

424
00:20:56,950 --> 00:21:00,677
implementation, I can now
prove by running the clients

425
00:21:00,677 --> 00:21:03,306
again that our code is still running.

426
00:21:03,306 --> 00:21:07,664
So clearly it is using
this nice, clean, modern

427
00:21:07,664 --> 00:21:09,699
version of the DAO.

428
00:21:09,699 --> 00:21:11,562
Now going back to our XML

429
00:21:11,562 --> 00:21:15,059
the big problem that we
have with the code so far

430
00:21:15,059 --> 00:21:16,584
is that we are using this

431
00:21:16,584 --> 00:21:18,667
simple driver DataSource.

432
00:21:19,661 --> 00:21:21,273
Now to be clear about this, this is

433
00:21:21,273 --> 00:21:25,193
not intended to be a production quality

434
00:21:25,193 --> 00:21:27,054
implementation of a DataSource.

435
00:21:27,054 --> 00:21:30,358
It is a quick get you up and running.

436
00:21:30,358 --> 00:21:32,667
The reason it is problematic is that

437
00:21:32,667 --> 00:21:35,888
for every single database operation

438
00:21:35,888 --> 00:21:39,550
a new connection is required
and opening connections

439
00:21:39,550 --> 00:21:42,258
is a very slow operation.

440
00:21:42,258 --> 00:21:44,194
Now I have here a caption,

441
00:21:44,194 --> 00:21:45,841
which is showing you the process

442
00:21:45,841 --> 00:21:47,711
that's happening under the hood

443
00:21:47,711 --> 00:21:51,448
when we are using that
simple driver DataSource.

444
00:21:51,448 --> 00:21:54,068
We have in the left hand side our client,

445
00:21:54,068 --> 00:21:57,280
the right hand side
here is cliched graphic

446
00:21:57,280 --> 00:21:59,410
representing the database.

447
00:21:59,410 --> 00:22:01,925
Here is our server code in the middle.

448
00:22:01,925 --> 00:22:03,980
In there we would have our servers,

449
00:22:03,980 --> 00:22:06,704
our DAO, and so on.

450
00:22:06,704 --> 00:22:10,647
At present, the client is making a call

451
00:22:10,647 --> 00:22:12,989
maybe to register a new book.

452
00:22:12,989 --> 00:22:15,535
What the server is then having to do,

453
00:22:15,535 --> 00:22:19,164
and this is what's happening inside Spring

454
00:22:19,164 --> 00:22:22,676
is a new database connection

455
00:22:22,676 --> 00:22:24,594
is being opened.

456
00:22:24,594 --> 00:22:26,981
I'm representing the database connection

457
00:22:26,981 --> 00:22:30,287
with this yellow oval here.

458
00:22:30,287 --> 00:22:32,921
And that animation I just did there was

459
00:22:32,921 --> 00:22:35,145
really, really, slow.

460
00:22:35,145 --> 00:22:38,282
It took a few seconds
for that animation to run

461
00:22:38,282 --> 00:22:40,212
which is exaggerated.

462
00:22:40,212 --> 00:22:42,880
We are still talking about
fractions of a second,

463
00:22:42,880 --> 00:22:46,182
but that is still slow when you consider

464
00:22:46,182 --> 00:22:48,200
that our server is probably going to be

465
00:22:48,200 --> 00:22:51,004
having to handle lots of clients

466
00:22:51,004 --> 00:22:54,470
all accessing the system at the same time.

467
00:22:54,470 --> 00:22:58,444
The other problem is that
once this method is completed,

468
00:22:58,444 --> 00:23:00,330
so let's say that this connection is now

469
00:23:00,330 --> 00:23:04,699
successfully registered
a book on the database,

470
00:23:04,699 --> 00:23:08,121
before we return back to the client,

471
00:23:08,121 --> 00:23:12,198
the server is going to have
to close that connection.

472
00:23:12,198 --> 00:23:16,608
I'm doing another slow animation there

473
00:23:16,608 --> 00:23:18,581
and only when that has happened

474
00:23:18,581 --> 00:23:22,417
did the server return back to the client.

475
00:23:22,417 --> 00:23:25,840
That whole process was very, very slow.

476
00:23:25,840 --> 00:23:29,372
Production systems will typically use

477
00:23:29,372 --> 00:23:32,417
some kind of connection pool.

478
00:23:32,417 --> 00:23:35,552
Now just in case you haven't
seen connection pools before,

479
00:23:35,552 --> 00:23:37,523
I've now reworked the graphic to show you

480
00:23:37,523 --> 00:23:40,895
the kind of thing that a
connection pool will do.

481
00:23:40,895 --> 00:23:43,942
A connection pool is
something that we install

482
00:23:43,942 --> 00:23:45,359
on to our server.

483
00:23:46,452 --> 00:23:50,476
What will happen is when
we start the server up,

484
00:23:50,476 --> 00:23:55,362
the server will automatically create

485
00:23:55,362 --> 00:23:59,973
or acquire several database connections.

486
00:23:59,973 --> 00:24:01,902
Now I have on the graphic here

487
00:24:01,902 --> 00:24:04,152
five of those yellow ovals.

488
00:24:05,349 --> 00:24:07,695
On a real connection
pool, we could configure

489
00:24:07,695 --> 00:24:12,064
that to be as many connections
as we think we need.

490
00:24:12,064 --> 00:24:14,998
Now remember the server
is only just starting up.

491
00:24:14,998 --> 00:24:17,837
We haven't even done anything yet,

492
00:24:17,837 --> 00:24:20,283
but the server has gone ahead and sort of

493
00:24:20,283 --> 00:24:22,921
preemptively in advance

494
00:24:22,921 --> 00:24:25,882
opened those database connections.

495
00:24:25,882 --> 00:24:27,973
Now that process was slow.

496
00:24:27,973 --> 00:24:31,180
It was kind of like five times slower

497
00:24:31,180 --> 00:24:34,929
than the opening we had
on the previous caption.

498
00:24:34,929 --> 00:24:37,773
In fact let me run that animation again.

499
00:24:37,773 --> 00:24:41,007
This is really slow.

500
00:24:41,007 --> 00:24:43,063
But that's only happening

501
00:24:43,063 --> 00:24:45,462
when the server starts up.

502
00:24:45,462 --> 00:24:47,982
We don't mind that being slow

503
00:24:47,982 --> 00:24:51,120
because now when a client comes along

504
00:24:51,120 --> 00:24:53,464
and again we will go for the clients

505
00:24:53,464 --> 00:24:56,113
who is going to register a new book.

506
00:24:56,113 --> 00:24:59,549
The client makes that call to the server,

507
00:24:59,549 --> 00:25:02,361
but now the server because we've installed

508
00:25:02,361 --> 00:25:05,995
this connection pool,
what the connection pool

509
00:25:05,995 --> 00:25:08,870
will do is instead of
opening a new connection,

510
00:25:08,870 --> 00:25:10,640
I'm sure you can guess now,

511
00:25:10,640 --> 00:25:14,392
it will just find any of
those five connections

512
00:25:14,392 --> 00:25:16,943
that is currently not being used

513
00:25:16,943 --> 00:25:19,494
and it will kind of if you like

514
00:25:19,494 --> 00:25:24,267
connects the client to
that free connection.

515
00:25:24,267 --> 00:25:25,992
It hasn't have to open it.

516
00:25:25,992 --> 00:25:29,617
It's just had to borrow that
connection from the pool,

517
00:25:29,617 --> 00:25:32,694
which is a relatively fast process.

518
00:25:32,694 --> 00:25:35,326
Now we have a database connection.

519
00:25:35,326 --> 00:25:37,869
The database operation can be performed

520
00:25:37,869 --> 00:25:40,857
and then next speedup is now that we've

521
00:25:40,857 --> 00:25:43,123
finished with that connection

522
00:25:43,123 --> 00:25:45,382
we are not going to close it.

523
00:25:45,382 --> 00:25:47,102
We are going to leave it open

524
00:25:47,102 --> 00:25:50,761
in the pool, so the
server can very quickly

525
00:25:50,761 --> 00:25:52,829
return back to the client.

526
00:25:52,829 --> 00:25:56,739
This connection is now still open

527
00:25:56,739 --> 00:26:00,645
and can be used to
service future requests.

528
00:26:00,645 --> 00:26:03,777
So all of that magic was
done by this software

529
00:26:03,777 --> 00:26:07,519
that we put on a server
called a connection pool.

530
00:26:07,519 --> 00:26:09,621
Now a connection pool
is quite sophisticated

531
00:26:09,621 --> 00:26:11,063
because it has to be careful

532
00:26:11,063 --> 00:26:13,695
to make sure that only one client

533
00:26:13,695 --> 00:26:16,253
at a time can access any particular

534
00:26:16,253 --> 00:26:18,072
database connection but that's one of the

535
00:26:18,072 --> 00:26:22,113
requirements that we have
of connection pool software.

536
00:26:22,113 --> 00:26:24,123
Now in the first few years of Java,

537
00:26:24,123 --> 00:26:26,111
a problem was that the
only connection pools

538
00:26:26,111 --> 00:26:30,111
you could get were expensive
commercial products

539
00:26:30,968 --> 00:26:34,173
that you could only buy from vendors

540
00:26:34,173 --> 00:26:36,767
but soon the open source world

541
00:26:36,767 --> 00:26:40,151
produced a few different implementations

542
00:26:40,151 --> 00:26:42,121
of connection pools.

543
00:26:42,121 --> 00:26:46,931
Wonderfully to stay consistent
with the Java library

544
00:26:46,931 --> 00:26:49,199
all of the implementations

545
00:26:49,199 --> 00:26:51,712
or at least all of the
popular implementations

546
00:26:51,712 --> 00:26:56,232
in Java use the same DataSource interface

547
00:26:56,232 --> 00:26:57,795
that we saw earlier.

548
00:26:57,795 --> 00:26:59,523
So that you are familiar with the names,

549
00:26:59,523 --> 00:27:02,867
here are a few of the open
source implementations

550
00:27:02,867 --> 00:27:05,666
of connection pools that are available

551
00:27:05,666 --> 00:27:07,983
at the time of this recording.

552
00:27:07,983 --> 00:27:10,855
The first one is called DBCP

553
00:27:10,855 --> 00:27:13,777
and comes from the Apache project.

554
00:27:13,777 --> 00:27:18,041
We also one called C3PO.

555
00:27:18,041 --> 00:27:22,039
The C must stand for connection
and the P stand for pool.

556
00:27:22,039 --> 00:27:25,215
Obviously that's a Star Wars reference.

557
00:27:25,215 --> 00:27:27,100
There is one called Proxool

558
00:27:27,100 --> 00:27:29,317
and the other big one would be

559
00:27:29,317 --> 00:27:31,857
the Tomcat Connection Pool.

560
00:27:31,857 --> 00:27:34,856
Now on this course, we are going to use

561
00:27:34,856 --> 00:27:37,194
DBCP.

562
00:27:37,194 --> 00:27:40,439
But I hope you are getting
the flavor of this by now.

563
00:27:40,439 --> 00:27:42,817
All of these four products implement

564
00:27:42,817 --> 00:27:44,798
the same interface.

565
00:27:44,798 --> 00:27:47,185
You can switch from one to the other

566
00:27:47,185 --> 00:27:49,331
by just downloading a new Java file,

567
00:27:49,331 --> 00:27:52,479
then changing the class
name that you are using

568
00:27:52,479 --> 00:27:54,570
in the Spring XML.

569
00:27:54,570 --> 00:27:56,508
Then you would find out from the reference

570
00:27:56,508 --> 00:27:59,801
manual of your new
connection pool provider

571
00:27:59,801 --> 00:28:02,306
what properties it is going to need.

572
00:28:02,306 --> 00:28:05,769
And then you would add
those into the Spring XML.

573
00:28:05,769 --> 00:28:07,798
Now I must be careful here.

574
00:28:07,798 --> 00:28:10,136
Since we recorded the first edition

575
00:28:10,136 --> 00:28:12,313
of this course, there have been complaints

576
00:28:12,313 --> 00:28:15,217
in the Java community

577
00:28:15,217 --> 00:28:19,384
that DBCP doesn't perform
particularly well.

578
00:28:20,323 --> 00:28:22,490
It is a rather old product

579
00:28:23,354 --> 00:28:25,260
and a lot of people don't think

580
00:28:25,260 --> 00:28:27,821
it is of a very high quality.

581
00:28:27,821 --> 00:28:29,798
I'm using it here on this course,

582
00:28:29,798 --> 00:28:31,941
just to stay consistent with

583
00:28:31,941 --> 00:28:34,162
the first edition of the course,

584
00:28:34,162 --> 00:28:37,738
but having said that DBCP is used

585
00:28:37,738 --> 00:28:41,742
by 100s maybe 1000s of
projects around the world.

586
00:28:41,742 --> 00:28:44,959
In fact we at Virtual Pair Programmers

587
00:28:44,959 --> 00:28:47,495
do use it on our database

588
00:28:47,495 --> 00:28:50,794
on the Virtual Pair Programmers website.

589
00:28:50,794 --> 00:28:53,433
Now one of the things I know about DBCP

590
00:28:53,433 --> 00:28:57,600
is that its default
properties are really bad.

591
00:28:58,446 --> 00:29:01,113
You need to give it good values.

592
00:29:02,367 --> 00:29:04,877
Now I won't be worrying about
that here on the course,

593
00:29:04,877 --> 00:29:07,264
because it will work with the defaults,

594
00:29:07,264 --> 00:29:08,716
but I have written a blog post

595
00:29:08,716 --> 00:29:11,194
at the URL you can see here,

596
00:29:11,194 --> 00:29:13,294
talking about the properties, the values,

597
00:29:13,294 --> 00:29:17,445
that we use on our live Virtual
Pair Programmers website.

598
00:29:17,445 --> 00:29:21,121
Check out that post if you are interested.

599
00:29:21,121 --> 00:29:22,871
In our LIB directory,

600
00:29:23,727 --> 00:29:27,557
we've always had this
Java file here called

601
00:29:27,557 --> 00:29:29,882
commons DBCP.

602
00:29:29,882 --> 00:29:31,907
As long as you have that Java file

603
00:29:31,907 --> 00:29:36,337
together with this commons pool Java file,

604
00:29:36,337 --> 00:29:40,066
then you effectively
have a connection pool

605
00:29:40,066 --> 00:29:43,066
ready and available in your project.

606
00:29:44,359 --> 00:29:46,707
What we need to do now is to use this

607
00:29:46,707 --> 00:29:50,092
connection pool by configuring it

608
00:29:50,092 --> 00:29:52,572
in our XML.

609
00:29:52,572 --> 00:29:54,674
This is where we configured the

610
00:29:54,674 --> 00:29:57,479
simple driver DataSource earlier.

611
00:29:57,479 --> 00:29:59,007
All we have to do here is to

612
00:29:59,007 --> 00:30:02,420
change this class name and to switch it

613
00:30:02,420 --> 00:30:07,123
for the class name provided
by the DBCP project.

614
00:30:07,123 --> 00:30:08,278
Now of course we need to find out

615
00:30:08,278 --> 00:30:10,028
what that class name is.

616
00:30:10,028 --> 00:30:12,212
To do that, you really need
a little bit of knowledge

617
00:30:12,212 --> 00:30:14,482
about the DBCP project.

618
00:30:14,482 --> 00:30:17,207
Off camera, I've already gone to the

619
00:30:17,207 --> 00:30:20,489
commons.apache.org website,

620
00:30:20,489 --> 00:30:24,446
and I found here the Java doc for DBCP.

621
00:30:24,446 --> 00:30:27,420
I can tell you that the
class that implements

622
00:30:27,420 --> 00:30:30,941
a connection pool in DBCP

623
00:30:30,941 --> 00:30:32,898
is called the Basic DataSource,

624
00:30:32,898 --> 00:30:36,813
which isn't really a very
nice class name to be honest.

625
00:30:36,813 --> 00:30:40,025
It doesn't really
suggest what it is doing.

626
00:30:40,025 --> 00:30:41,381
Let me be clear about this.

627
00:30:41,381 --> 00:30:44,421
The Basic DataSource is really a

628
00:30:44,421 --> 00:30:45,754
connection pool.

629
00:30:47,306 --> 00:30:50,386
And you can read the Java
docs if you are interested.

630
00:30:50,386 --> 00:30:52,444
I think the important thing
is it is telling us here

631
00:30:52,444 --> 00:30:54,953
that we can figure this connection pool

632
00:30:54,953 --> 00:30:56,203
via properties.

633
00:30:57,158 --> 00:30:59,298
That means we can configure this

634
00:30:59,298 --> 00:31:01,481
in the Spring XML.

635
00:31:01,481 --> 00:31:02,641
The first thing I will do

636
00:31:02,641 --> 00:31:04,743
is copy the package name

637
00:31:04,743 --> 00:31:07,633
and transfer that into the class here

638
00:31:07,633 --> 00:31:10,062
and then I need the class name

639
00:31:10,062 --> 00:31:13,054
and Spring now knows
it needs to instantiate

640
00:31:13,054 --> 00:31:16,315
an instance of that connection pool.

641
00:31:16,315 --> 00:31:17,537
The next thing we need to do is

642
00:31:17,537 --> 00:31:19,762
to configure the properties.

643
00:31:19,762 --> 00:31:21,902
Now can you see if we have

644
00:31:21,902 --> 00:31:23,949
a look on the left hand side here,

645
00:31:23,949 --> 00:31:27,658
I'm getting an error in the Spring IDE.

646
00:31:27,658 --> 00:31:32,487
And that's probably because
on this connection pool

647
00:31:32,487 --> 00:31:36,677
there isn't a property
called driver class.

648
00:31:36,677 --> 00:31:39,490
We can check that by scrolling down

649
00:31:39,490 --> 00:31:41,240
to the method summary

650
00:31:42,537 --> 00:31:46,351
and we are looking for the sets methods.

651
00:31:46,351 --> 00:31:47,877
Can you see here?

652
00:31:47,877 --> 00:31:51,627
That method is called
sets driver class name.

653
00:31:52,491 --> 00:31:54,717
So it is just a simple case that

654
00:31:54,717 --> 00:31:56,489
because this is a different implementation

655
00:31:56,489 --> 00:32:00,361
of a connection pool, it can
have different property names,

656
00:32:00,361 --> 00:32:03,876
so I've just changed that
there to driver class name.

657
00:32:03,876 --> 00:32:06,056
We are actually quite lucky now.

658
00:32:06,056 --> 00:32:10,167
It is a coincidence really
that the basic DataSource

659
00:32:10,167 --> 00:32:13,959
also has a property called
URL, username, and password,

660
00:32:13,959 --> 00:32:16,689
exactly as the Spring version did,

661
00:32:16,689 --> 00:32:20,696
so in fact we can leave those
three properties in place.

662
00:32:20,696 --> 00:32:23,787
Now these four properties are enough

663
00:32:23,787 --> 00:32:27,169
to make the basic DataSource work.

664
00:32:27,169 --> 00:32:30,431
The rest of the properties
are there to configure

665
00:32:30,431 --> 00:32:32,570
things such as how many connections

666
00:32:32,570 --> 00:32:36,853
should this connection pool
have open at any one time?

667
00:32:36,853 --> 00:32:41,020
For example there is a
property there called MaxIdle.

668
00:32:41,943 --> 00:32:44,707
This configures how many
connections can remain

669
00:32:44,707 --> 00:32:45,540
idle in the pool.

670
00:32:45,540 --> 00:32:49,143
That means just how many
is out there doing nothing.

671
00:32:49,143 --> 00:32:52,517
If I click into that, it
is not telling me here

672
00:32:52,517 --> 00:32:55,570
because really the
documentation is not good.

673
00:32:55,570 --> 00:32:59,679
It is not telling me here
what the default value is.

674
00:32:59,679 --> 00:33:03,386
But I'm going to assume
that there is a good value.

675
00:33:03,386 --> 00:33:05,573
As I mentioned before,
if you are going to use

676
00:33:05,573 --> 00:33:08,169
this connection pool
in a production system,

677
00:33:08,169 --> 00:33:09,907
you want to put some good values

678
00:33:09,907 --> 00:33:11,884
in for those, and again you can check

679
00:33:11,884 --> 00:33:14,976
out my blog post for details on that

680
00:33:14,976 --> 00:33:17,081
but for our project these four values

681
00:33:17,081 --> 00:33:20,027
will be sufficient.

682
00:33:20,027 --> 00:33:21,829
Now I've only made a small change there

683
00:33:21,829 --> 00:33:23,574
but I still think it is worth

684
00:33:23,574 --> 00:33:26,241
checking out the Spring explorer

685
00:33:27,508 --> 00:33:30,091
and having a look at the graph.

686
00:33:31,417 --> 00:33:33,844
And that's looking good.

687
00:33:33,844 --> 00:33:37,582
The BookService is delegating to a DAO,

688
00:33:37,582 --> 00:33:41,330
which is using the Spring
template to simplify everything,

689
00:33:41,330 --> 00:33:43,001
but it is now using

690
00:33:43,001 --> 00:33:46,532
a production quality connection pool.

691
00:33:46,532 --> 00:33:49,011
So we would see better performance

692
00:33:49,011 --> 00:33:51,732
by using this DataSource.

693
00:33:51,732 --> 00:33:54,311
Now I'm going to run the client again.

694
00:33:54,311 --> 00:33:56,076
I think just to be safe,

695
00:33:56,076 --> 00:33:57,782
I've just refreshed the project there,

696
00:33:57,782 --> 00:34:01,115
so that I can see my two database files,

697
00:34:01,115 --> 00:34:04,151
and I'm going to delete them.

698
00:34:04,151 --> 00:34:07,766
So we are starting from a
completely clean, fresh project.

699
00:34:07,766 --> 00:34:09,609
And if you remember, the client is doing

700
00:34:09,609 --> 00:34:12,203
nothing more than registering a new book

701
00:34:12,203 --> 00:34:15,745
and then listing all of
the books in the catalog.

702
00:34:15,745 --> 00:34:17,578
Let's give this a run.

703
00:34:21,467 --> 00:34:22,800
That looks okay.

704
00:34:23,897 --> 00:34:27,352
We are seeing that book registered.

705
00:34:27,352 --> 00:34:30,102
I'm going to run it again though.

706
00:34:32,479 --> 00:34:35,529
And that doesn't look so good

707
00:34:35,529 --> 00:34:37,178
because I've run it a second time

708
00:34:37,178 --> 00:34:40,639
and I'm still only seeing
one book in the system.

709
00:34:40,639 --> 00:34:43,589
Now we are expecting persistence here

710
00:34:43,589 --> 00:34:46,176
so every time we run the application,

711
00:34:46,176 --> 00:34:50,765
we should be seeing an extra book added.

712
00:34:50,765 --> 00:34:53,399
What's going wrong here?

713
00:34:53,399 --> 00:34:56,981
Well if I go back to the package explorer,

714
00:34:56,981 --> 00:35:00,309
and once again refresh,

715
00:35:00,309 --> 00:35:01,750
we have a clue here.

716
00:35:01,750 --> 00:35:05,704
Can you see that there's
four database files

717
00:35:05,704 --> 00:35:08,605
now instead of two?

718
00:35:08,605 --> 00:35:10,793
One of them is a good clue.

719
00:35:10,793 --> 00:35:15,257
Database dot DAT dot LCK.

720
00:35:15,257 --> 00:35:18,588
That's a lock file and it is telling us

721
00:35:18,588 --> 00:35:21,755
that the database is still open

722
00:35:21,755 --> 00:35:24,306
and is not being closed down.

723
00:35:24,306 --> 00:35:27,302
Now because this is a file based database,

724
00:35:27,302 --> 00:35:29,595
when you finished working
with the database,

725
00:35:29,595 --> 00:35:31,762
you need to close it down.

726
00:35:32,607 --> 00:35:35,193
That's the only way that HSQLDB

727
00:35:35,193 --> 00:35:37,610
can close the files properly.

728
00:35:38,555 --> 00:35:42,061
This suggests that
something is going wrong.

729
00:35:42,061 --> 00:35:44,034
Now the reason that this isn't working

730
00:35:44,034 --> 00:35:45,892
is quite a subtle problem.

731
00:35:45,892 --> 00:35:48,581
I remember the first time
this ever happened to me

732
00:35:48,581 --> 00:35:51,081
years ago now and it took me a long time

733
00:35:51,081 --> 00:35:53,472
to work out the problem.

734
00:35:53,472 --> 00:35:55,340
The source of the problem is that the

735
00:35:55,340 --> 00:35:59,134
basic DataSource, the connection
pool that we are using

736
00:35:59,134 --> 00:36:01,717
needs to be told when to close.

737
00:36:03,180 --> 00:36:07,611
The basic DataSource has a method

738
00:36:07,611 --> 00:36:10,682
I'll need to scroll down quite a long way.

739
00:36:10,682 --> 00:36:12,435
Oh we are fine, here we are.

740
00:36:12,435 --> 00:36:15,234
It has a method called close.

741
00:36:15,234 --> 00:36:17,500
Now the intention of this close method

742
00:36:17,500 --> 00:36:19,645
is that you call it

743
00:36:19,645 --> 00:36:23,165
when the application
is completely finished.

744
00:36:23,165 --> 00:36:25,167
And that means not when you are finished

745
00:36:25,167 --> 00:36:26,669
with the database connection

746
00:36:26,669 --> 00:36:28,129
but when you are finished with

747
00:36:28,129 --> 00:36:30,486
all of the database connections

748
00:36:30,486 --> 00:36:34,429
and you want the entire
pool to close down.

749
00:36:34,429 --> 00:36:36,077
So if you were writing a web application

750
00:36:36,077 --> 00:36:39,205
for instance, you would
need to call this method

751
00:36:39,205 --> 00:36:41,836
when you are shutting the server down.

752
00:36:41,836 --> 00:36:45,317
Now what you could do in
your client's application

753
00:36:45,317 --> 00:36:48,107
is before we close the Spring container,

754
00:36:48,107 --> 00:36:52,100
we could write here look
up the DataSource bean

755
00:36:52,100 --> 00:36:54,858
from the container and then try to call

756
00:36:54,858 --> 00:36:56,710
its close method.

757
00:36:56,710 --> 00:37:00,500
Well I think that's going
to be a little bit laborious

758
00:37:00,500 --> 00:37:02,680
and we would have to remember to do it

759
00:37:02,680 --> 00:37:06,506
at the end of every
application that we wrote,

760
00:37:06,506 --> 00:37:09,558
but I have a better suggestion.

761
00:37:09,558 --> 00:37:11,043
It would be nice if we could get the

762
00:37:11,043 --> 00:37:15,503
close method to be called
automatically by Spring

763
00:37:15,503 --> 00:37:17,981
when we close Spring down,

764
00:37:17,981 --> 00:37:20,527
because remember this last line of code

765
00:37:20,527 --> 00:37:23,621
We've had that in our
client since the start,

766
00:37:23,621 --> 00:37:27,126
is the method telling
Spring to close down.

767
00:37:27,126 --> 00:37:28,943
In fact we can do that.

768
00:37:28,943 --> 00:37:32,608
This relies on a bit of Spring
that we haven't yet covered

769
00:37:32,608 --> 00:37:35,647
is that for any of these beans,

770
00:37:35,647 --> 00:37:39,230
we can specify here in the XML

771
00:37:39,230 --> 00:37:43,964
this is the line where I'm
defining the DataSource bean.

772
00:37:43,964 --> 00:37:47,964
We can specify a destroy method.

773
00:37:48,847 --> 00:37:50,561
We do it exactly like that

774
00:37:50,561 --> 00:37:53,118
with destroy hyphen method,

775
00:37:53,118 --> 00:37:56,583
you will notice that the IDE has made this

776
00:37:56,583 --> 00:38:00,750
a different color to emphasize
that it's recognized.

777
00:38:01,708 --> 00:38:03,858
And we can plug in here the name

778
00:38:03,858 --> 00:38:07,244
of any of the methods that exists

779
00:38:07,244 --> 00:38:09,327
inside this bean.

780
00:38:09,327 --> 00:38:12,108
The deal with that is when we call close

781
00:38:12,108 --> 00:38:15,193
on the container, Spring will make sure

782
00:38:15,193 --> 00:38:18,118
that this method is
coincidentally also called

783
00:38:18,118 --> 00:38:22,261
close is called on the DataSource.

784
00:38:22,261 --> 00:38:25,060
You don't often need to use this,

785
00:38:25,060 --> 00:38:27,845
but in some circumstances,

786
00:38:27,845 --> 00:38:29,944
when Spring is closing down,

787
00:38:29,944 --> 00:38:33,696
you do want some kind of
cleanup to take place.

788
00:38:33,696 --> 00:38:35,880
That's a really useful feature

789
00:38:35,880 --> 00:38:38,015
and it avoids us having to manually

790
00:38:38,015 --> 00:38:40,030
go through our beans calling methods

791
00:38:40,030 --> 00:38:42,251
at the end of the program.

792
00:38:42,251 --> 00:38:45,329
That's good only if it works.

793
00:38:45,329 --> 00:38:47,504
I think actually before I run it,

794
00:38:47,504 --> 00:38:52,120
I'm going to delete those
four database files.

795
00:38:52,120 --> 00:38:56,473
I might as well as start from
a completely clean system.

796
00:38:56,473 --> 00:38:59,189
Okay while we expected that
to work the first time,

797
00:38:59,189 --> 00:39:00,939
but if I now refresh,

798
00:39:03,265 --> 00:39:04,098
oh that looks good.

799
00:39:04,098 --> 00:39:07,071
We've only got two files now,

800
00:39:07,071 --> 00:39:10,374
which suggest if I run a second time

801
00:39:10,374 --> 00:39:13,541
great, two books in the system.

802
00:39:13,541 --> 00:39:15,972
A third time just to be sure.

803
00:39:15,972 --> 00:39:19,126
Yeah we've now got three books.

804
00:39:19,126 --> 00:39:20,926
That reminds me that there is a further

805
00:39:20,926 --> 00:39:23,274
improvement that we can make.

806
00:39:23,274 --> 00:39:27,330
Do you remember that in
our database access object,

807
00:39:27,330 --> 00:39:29,305
in the constructor,

808
00:39:29,305 --> 00:39:32,102
this is where we are
injecting the template.

809
00:39:32,102 --> 00:39:34,618
As soon as we've injected that template,

810
00:39:34,618 --> 00:39:37,948
I've put in a try catch block,

811
00:39:37,948 --> 00:39:40,054
and the idea there is that

812
00:39:40,054 --> 00:39:42,985
we will try to create the table

813
00:39:42,985 --> 00:39:44,585
but if that fails we will assume

814
00:39:44,585 --> 00:39:46,896
the table already exists.

815
00:39:46,896 --> 00:39:49,450
Well this works but it is

816
00:39:49,450 --> 00:39:51,950
perhaps not perfectly elegant.

817
00:39:54,381 --> 00:39:56,105
I'm not sure really.

818
00:39:56,105 --> 00:39:59,277
It is okay but sort of doing actions

819
00:39:59,277 --> 00:40:04,093
inside the constructor
is a little bit unusual.

820
00:40:04,093 --> 00:40:06,155
In the constructor, we
really just want to be

821
00:40:06,155 --> 00:40:08,168
setting properties.

822
00:40:08,168 --> 00:40:10,468
It would be much cleaner if I could

823
00:40:10,468 --> 00:40:11,885
cut that code out

824
00:40:13,826 --> 00:40:16,689
and place it in,

825
00:40:16,689 --> 00:40:19,563
it could be a public or a private method

826
00:40:19,563 --> 00:40:23,856
but a regular method called create tables.

827
00:40:23,856 --> 00:40:26,080
Ill just paste that code in.

828
00:40:26,080 --> 00:40:29,084
In Eclipse you can do Ctrl A to select all

829
00:40:29,084 --> 00:40:32,435
the code and Ctrl I to

830
00:40:32,435 --> 00:40:34,984
reindent all of the code.

831
00:40:34,984 --> 00:40:38,239
That kind of just looks
nice because it is now

832
00:40:38,239 --> 00:40:40,172
in its own method,

833
00:40:40,172 --> 00:40:42,608
but of course now this method

834
00:40:42,608 --> 00:40:44,935
is never going to be called.

835
00:40:44,935 --> 00:40:48,056
But you might've guessed
where I'm going with this now.

836
00:40:48,056 --> 00:40:50,364
Ill go to the XML file.

837
00:40:50,364 --> 00:40:53,320
You know that we have a destroy method

838
00:40:53,320 --> 00:40:57,488
that Spring automatically
calls when Spring is finishing,

839
00:40:57,488 --> 00:41:00,843
but we are also able to do the reverse.

840
00:41:00,843 --> 00:41:03,444
As we are working here on the book DAO,

841
00:41:03,444 --> 00:41:05,459
if I go into the book DAO definition,

842
00:41:05,459 --> 00:41:10,356
I can also supply an init method.

843
00:41:10,356 --> 00:41:13,950
Of course that stands for
initialization method.

844
00:41:13,950 --> 00:41:17,997
In our case, this is
going to be create tables

845
00:41:17,997 --> 00:41:21,751
and that's telling Spring
it needs to call that method

846
00:41:21,751 --> 00:41:25,305
once it is created this book DAO object

847
00:41:25,305 --> 00:41:29,458
i.e., at the start of the program's run.

848
00:41:29,458 --> 00:41:32,615
That's going to call this private method.

849
00:41:32,615 --> 00:41:35,339
By the way, Spring can
call a private method

850
00:41:35,339 --> 00:41:37,674
just uses reflection to do so.

851
00:41:37,674 --> 00:41:40,426
No problem there, so we don't need

852
00:41:40,426 --> 00:41:42,899
to manually call that method.

853
00:41:42,899 --> 00:41:45,438
I won't be using the
init and destroy methods

854
00:41:45,438 --> 00:41:47,542
very often on this course

855
00:41:47,542 --> 00:41:49,186
because you don't need them very often

856
00:41:49,186 --> 00:41:52,577
but they are very elegant
when you do need them.

857
00:41:52,577 --> 00:41:54,827
Let's check that that runs.

858
00:41:55,706 --> 00:41:59,706
I think again Ill refresh

859
00:42:00,629 --> 00:42:02,629
and delete the database.

860
00:42:05,165 --> 00:42:08,545
Of course this will crash
if the create tables

861
00:42:08,545 --> 00:42:10,280
method doesn't run, but yeah

862
00:42:10,280 --> 00:42:13,530
that's running well and if I run again,

863
00:42:15,671 --> 00:42:18,098
great, we now know that the create tables

864
00:42:18,098 --> 00:42:20,515
method is definitely running.

865
00:42:21,520 --> 00:42:23,374
Our DAO is now up and running

866
00:42:23,374 --> 00:42:26,002
and almost production quality.

867
00:42:26,002 --> 00:42:28,282
We've seen what a DataSource is.

868
00:42:28,282 --> 00:42:32,216
That is standard Java but
every leading connection pool

869
00:42:32,216 --> 00:42:35,628
implements the DataSource interface.

870
00:42:35,628 --> 00:42:38,401
That's why the JDBC template works

871
00:42:38,401 --> 00:42:41,318
with any DataSource implementation.

872
00:42:42,389 --> 00:42:44,242
There are several implementations

873
00:42:44,242 --> 00:42:46,874
and Ill leave you to choose your own.

874
00:42:46,874 --> 00:42:50,331
Be aware that the DBCP that
we are using on the course

875
00:42:50,331 --> 00:42:52,752
has a bad reputation these days,

876
00:42:52,752 --> 00:42:57,123
but I believe it is okay as
long as it is well configured.

877
00:42:57,123 --> 00:43:00,682
Do check out my blog post for details.

878
00:43:00,682 --> 00:43:04,032
We have to be careful to
clean up our resources.

879
00:43:04,032 --> 00:43:05,386
We need to destroy methods to make

880
00:43:05,386 --> 00:43:09,182
sure the connection
pool is properly closed.

881
00:43:09,182 --> 00:43:11,898
You'll find that even
in production projects

882
00:43:11,898 --> 00:43:15,440
that they often don't bother
with that destroy method.

883
00:43:15,440 --> 00:43:18,030
In a way you can get away with that

884
00:43:18,030 --> 00:43:20,172
on a normal database.

885
00:43:20,172 --> 00:43:23,013
We needed to close properly
because the database

886
00:43:23,013 --> 00:43:24,815
gets locked.

887
00:43:24,815 --> 00:43:28,648
Now that won't happen with Oracle or MySQL

888
00:43:28,648 --> 00:43:31,087
but without closing properly on those

889
00:43:31,087 --> 00:43:34,311
you might leak connections instead,

890
00:43:34,311 --> 00:43:36,792
which can be a problem
so you should always

891
00:43:36,792 --> 00:43:40,209
include a destroy method for DataSources.

892
00:43:41,410 --> 00:43:43,036
Well the next chapter is going to cover

893
00:43:43,036 --> 00:43:47,603
the rest of the basic support
in Spring for databases.

894
00:43:47,603 --> 00:43:50,154
We will be looking at
how to manage exceptions

895
00:43:50,154 --> 00:43:52,379
and only if you are
interested, we will be talking

896
00:43:52,379 --> 00:43:55,100
about JNDI.

897
00:43:55,100 --> 00:43:57,017
See you again for that.

1
00:00:00,000 --> 00:00:03,750
(lively synthesizer rhythms)

2
00:00:10,585 --> 00:00:12,344
- [Voiceover] Chapter 11 is
going to give me a chance

3
00:00:12,344 --> 00:00:17,211
to cover the things that I
didn't have time for previously.

4
00:00:17,211 --> 00:00:20,385
I've missed mentioning
how to handle Exceptions

5
00:00:20,385 --> 00:00:23,468
when you're using that JDBC template.

6
00:00:24,431 --> 00:00:29,284
I think that the way Spring
works here is superb.

7
00:00:29,284 --> 00:00:31,948
Another useful topic is JNDI.

8
00:00:31,948 --> 00:00:36,225
That's the Java Naming
and Directory Interface.

9
00:00:36,225 --> 00:00:39,047
This is optional because
you do need some knowledge

10
00:00:39,047 --> 00:00:42,777
of application service
to understand this fully.

11
00:00:42,777 --> 00:00:46,535
If you want to deploy your
application for some reason,

12
00:00:46,535 --> 00:00:50,740
to an application service
such as Glassfish, WebLogic,

13
00:00:50,740 --> 00:00:54,326
or Jboss, then you won't want
to use the connection pull

14
00:00:54,326 --> 00:00:56,573
from the previous chapter.

15
00:00:56,573 --> 00:00:58,559
You will want the built in data source

16
00:00:58,559 --> 00:01:01,187
from your apps server.

17
00:01:01,187 --> 00:01:04,278
In that case, Spring
supports the use of JNDI

18
00:01:04,278 --> 00:01:07,444
to inject the app service data source

19
00:01:07,444 --> 00:01:09,561
straight into your DAO.

20
00:01:09,561 --> 00:01:11,816
It's really elegant, and we cover that

21
00:01:11,816 --> 00:01:14,649
in the second half of the chapter.

22
00:01:16,102 --> 00:01:18,954
Well we've seen that the JDBC template

23
00:01:18,954 --> 00:01:22,329
can clean down our code dramatically.

24
00:01:22,329 --> 00:01:24,271
But, something that I've not mentioned

25
00:01:24,271 --> 00:01:28,438
is the enhanced exception
handling that Spring offers.

26
00:01:29,912 --> 00:01:33,448
To remind you what
standard JDBC looks like,

27
00:01:33,448 --> 00:01:37,615
I've got here my original,
horrible implementation of a DAO.

28
00:01:39,944 --> 00:01:43,720
Now, I did delete that from the
project in the last chapter.

29
00:01:43,720 --> 00:01:45,976
You might remember me doing that,

30
00:01:45,976 --> 00:01:47,432
because I hated it so much.

31
00:01:47,432 --> 00:01:50,696
But, I've recovered it temporarily here

32
00:01:50,696 --> 00:01:52,376
just so I can review it.

33
00:01:52,376 --> 00:01:54,056
And, I'm going to look at,

34
00:01:54,056 --> 00:01:57,576
well I can pick any of the
methods in here really,

35
00:01:57,576 --> 00:02:01,743
but I'll go with create
tables as a working example.

36
00:02:03,256 --> 00:02:05,960
Now, remember this is standard JDBC.

37
00:02:05,960 --> 00:02:08,824
I'm not using the Spring template here.

38
00:02:08,824 --> 00:02:11,657
One of the real problems with JDBC

39
00:02:12,552 --> 00:02:15,656
is that every single database operation

40
00:02:15,656 --> 00:02:20,168
has to be enclosed in
some kind of a tri-block,

41
00:02:20,168 --> 00:02:23,208
and that's because all of the operations,

42
00:02:23,208 --> 00:02:26,708
such as get connection, create statements,

43
00:02:27,816 --> 00:02:31,983
and execute updates, might
throw an SQL exception.

44
00:02:34,504 --> 00:02:37,368
And, it's a checked exception

45
00:02:37,368 --> 00:02:40,168
which you'll probably
know from standard Java

46
00:02:40,168 --> 00:02:44,648
means that we have to
provide a catch-block.

47
00:02:44,648 --> 00:02:48,152
Now, the problem with this, or
one of the problems at least,

48
00:02:48,152 --> 00:02:51,448
is that regardless of what's gone wrong,

49
00:02:51,448 --> 00:02:54,468
it could be that the
database is unavailable,

50
00:02:54,468 --> 00:02:57,595
or the table already exists,

51
00:02:57,595 --> 00:03:00,012
or the network could be down,

52
00:03:01,217 --> 00:03:05,174
and really any of 100
different things could be wrong

53
00:03:05,174 --> 00:03:08,366
with our environments, and unfortunately

54
00:03:08,366 --> 00:03:11,353
the SQL exception is basically saying,

55
00:03:11,353 --> 00:03:13,667
"Nyah, nyah, something's gone wrong."

56
00:03:13,667 --> 00:03:17,750
All of the problems are
handled by SQL exception.

57
00:03:19,716 --> 00:03:22,590
What I really want to
do in this catch-block

58
00:03:22,590 --> 00:03:26,173
is I want to say that
if the SQL has failed

59
00:03:27,630 --> 00:03:30,803
because the table already existed,

60
00:03:30,803 --> 00:03:33,081
then that's not a problem.

61
00:03:33,081 --> 00:03:35,470
So, we'll do nothing.

62
00:03:35,470 --> 00:03:38,534
But, if the error was
caused by something else,

63
00:03:38,534 --> 00:03:41,595
let's say the network is unavailable,

64
00:03:41,595 --> 00:03:43,686
then that really is a problem,

65
00:03:43,686 --> 00:03:46,916
so we want the program to crash.

66
00:03:46,916 --> 00:03:51,153
At the moment with this
code, if the network is down,

67
00:03:51,153 --> 00:03:55,166
then the problem will wrongly
go into this catch-block,

68
00:03:55,166 --> 00:03:59,333
and we'll print out, the table
has already been created,

69
00:04:00,467 --> 00:04:02,884
so the fault has been masked,

70
00:04:03,801 --> 00:04:08,277
and that could result in
really bad things happening.

71
00:04:08,277 --> 00:04:11,829
Now, there is a mechanism in JDBC

72
00:04:11,829 --> 00:04:13,685
to find out what went wrong,

73
00:04:13,685 --> 00:04:16,352
but it is very difficult to use.

74
00:04:17,474 --> 00:04:19,641
There is on the E Objects,

75
00:04:21,341 --> 00:04:24,439
that's the object thrown by the exception,

76
00:04:24,439 --> 00:04:27,772
there is a method called get error code,

77
00:04:28,760 --> 00:04:31,427
and that will return an integer.

78
00:04:33,141 --> 00:04:35,075
Now, unfortunately,

79
00:04:35,075 --> 00:04:38,825
the integer error codes
are vendor dependent,

80
00:04:40,225 --> 00:04:44,251
so it's going to be one
error code on HSQLDB,

81
00:04:44,251 --> 00:04:48,671
a completely different
error code on our code.

82
00:04:48,671 --> 00:04:52,854
So, I'd have to look in the
reference manual for HSQLDB,

83
00:04:52,854 --> 00:04:57,058
and let's say that the table
already existing is error 134,

84
00:04:57,058 --> 00:05:00,097
it isn't, I've just made
that up, but let's say it is,

85
00:05:00,097 --> 00:05:01,847
then I could do this.

86
00:05:04,399 --> 00:05:07,556
And, if it's any other
error code, then I could

87
00:05:07,556 --> 00:05:10,889
crash properly by raising another error,

88
00:05:12,923 --> 00:05:16,756
but this time an unchecked
run-time exception.

89
00:05:18,409 --> 00:05:19,909
Well, of course, for one thing,

90
00:05:19,909 --> 00:05:21,349
this is really quite tedious,

91
00:05:21,349 --> 00:05:24,309
but the real problem with
this is now I've destroyed

92
00:05:24,309 --> 00:05:27,289
any kind of database independence.

93
00:05:27,289 --> 00:05:30,071
If I now wanted to run this code on Oracle

94
00:05:30,071 --> 00:05:34,238
or any other database, this
code would simply not work.

95
00:05:35,221 --> 00:05:39,919
So, let's leave this
horrible JDBC implementation.

96
00:05:39,919 --> 00:05:41,793
I think I can promise
you this is the last time

97
00:05:41,793 --> 00:05:44,832
you're going to see this
class on this course.

98
00:05:44,832 --> 00:05:49,825
Let's go back to our much nicer,
cleaner JDBC implementation

99
00:05:49,825 --> 00:05:51,575
where we used Spring.

100
00:05:52,548 --> 00:05:56,631
And, here is the equivalent
create tables method.

101
00:05:57,738 --> 00:06:01,488
Now, a fantastic feature
of the JDBC template

102
00:06:02,393 --> 00:06:04,602
is that if something goes wrong

103
00:06:04,602 --> 00:06:07,683
when we call this update method,

104
00:06:07,683 --> 00:06:12,478
the templates will
internally and automatically,

105
00:06:12,478 --> 00:06:15,145
it will catch the SQL exception.

106
00:06:16,467 --> 00:06:18,409
And then what it does

107
00:06:18,409 --> 00:06:22,633
is it checks a known list of error codes,

108
00:06:22,633 --> 00:06:25,470
and built into the Spring
framework is a list of error codes

109
00:06:25,470 --> 00:06:28,137
for many of the major databases,

110
00:06:29,011 --> 00:06:32,190
and then Spring will endeavor to work out

111
00:06:32,190 --> 00:06:35,198
what went wrong from the error code,

112
00:06:35,198 --> 00:06:38,355
and then it re-throws the exception

113
00:06:38,355 --> 00:06:40,938
as a more meaningful exception.

114
00:06:42,067 --> 00:06:45,225
And, all of the exceptions
that Spring throws

115
00:06:45,225 --> 00:06:49,619
are unchecked, which means
that they extend the run-time

116
00:06:49,619 --> 00:06:53,369
exception rather than
just regular exception.

117
00:06:54,206 --> 00:06:56,638
Now, I'm having to assume
you're already familiar

118
00:06:56,638 --> 00:06:59,411
with the difference between checked

119
00:06:59,411 --> 00:07:01,801
and unchecked exceptions, but if not,

120
00:07:01,801 --> 00:07:05,342
I have a blog post at
the URL you can see here,

121
00:07:05,342 --> 00:07:09,246
talking about the differences
between the two types,

122
00:07:09,246 --> 00:07:11,678
and I'll quickly recap them.

123
00:07:11,678 --> 00:07:13,705
An unchecked exception

124
00:07:13,705 --> 00:07:16,798
is an exception that you optionally catch,

125
00:07:16,798 --> 00:07:19,934
so the control is down
to us as the programmer.

126
00:07:19,934 --> 00:07:22,601
Whereas, with a checked exception,

127
00:07:22,601 --> 00:07:25,651
you're forced to deal with the problem.

128
00:07:25,651 --> 00:07:29,363
So, if I just go down and have
a look at some other methods

129
00:07:29,363 --> 00:07:32,329
where we're calling the JDBC template,

130
00:07:32,329 --> 00:07:34,313
you'll notice that I haven't bothered

131
00:07:34,313 --> 00:07:36,510
with any kind of catch-block,

132
00:07:36,510 --> 00:07:39,240
and what I'm working on there is

133
00:07:39,240 --> 00:07:42,163
if Spring throws and exception from here,

134
00:07:42,163 --> 00:07:45,683
it's probably going to be
something catastrophic,

135
00:07:45,683 --> 00:07:48,329
something like the database being down,

136
00:07:48,329 --> 00:07:52,147
and there's nothing I could
do anyway in a catch-block.

137
00:07:52,147 --> 00:07:54,878
Now, going back to how to create tables,

138
00:07:54,878 --> 00:07:56,295
just as a starter

139
00:07:57,353 --> 00:08:00,809
earlier in the course I
put a catch exception.

140
00:08:00,809 --> 00:08:02,921
Now, that's going to catch all exceptions

141
00:08:02,921 --> 00:08:04,947
regardless of their type.

142
00:08:04,947 --> 00:08:07,550
But now because of this
wonderful feature of Spring,

143
00:08:07,550 --> 00:08:09,747
I can be specific.

144
00:08:09,747 --> 00:08:13,651
I only want this print line to happen

145
00:08:13,651 --> 00:08:17,818
if the update failed because
the table already exists.

146
00:08:19,177 --> 00:08:22,334
I can tell you now that if
the table already exists,

147
00:08:22,334 --> 00:08:26,129
Spring will throw an exception called

148
00:08:26,129 --> 00:08:28,296
Bad SUL Grammar Exception.

149
00:08:32,252 --> 00:08:35,388
Now, I will need to
import that, of course.

150
00:08:35,388 --> 00:08:38,225
I've just done a control shift O there,

151
00:08:38,225 --> 00:08:40,956
and I'm still not getting an in-port.

152
00:08:40,956 --> 00:08:43,793
I think it's because, oh, the Q and the L

153
00:08:43,793 --> 00:08:45,876
in SQL are in lower case.

154
00:08:47,462 --> 00:08:50,662
So, if I repeat the control shift and O,

155
00:08:50,662 --> 00:08:52,582
the error's gone away now,

156
00:08:52,582 --> 00:08:55,227
but I want to look at the
import list just to check.

157
00:08:55,227 --> 00:08:58,192
You can see there that
this ban SQL grammar

158
00:08:58,192 --> 00:09:00,902
does not come from the
standard Java library,

159
00:09:00,902 --> 00:09:03,485
it's from the Spring framework,

160
00:09:04,764 --> 00:09:06,470
and this is only going to happen

161
00:09:06,470 --> 00:09:08,796
if that table already exists.

162
00:09:08,796 --> 00:09:10,460
Of course, that's not quite true.

163
00:09:10,460 --> 00:09:14,428
The exceptions thrown by this template

164
00:09:14,428 --> 00:09:17,692
are not completely fine grained.

165
00:09:17,692 --> 00:09:19,142
Of course, this exception might happen

166
00:09:19,142 --> 00:09:23,494
if I have some bad grammar
in the SQL statement here,

167
00:09:23,494 --> 00:09:26,374
but frankly we know
that's not going to happen

168
00:09:26,374 --> 00:09:30,541
because I've already written
and tested that SQL statement.

169
00:09:31,537 --> 00:09:34,268
But, the point is, we know if
we go into this catch-block,

170
00:09:34,268 --> 00:09:37,233
nothing serious has happened,

171
00:09:37,233 --> 00:09:39,921
I'm assuming that my
SQL grammar is correct,

172
00:09:39,921 --> 00:09:43,078
so it must be because
the table already exists,

173
00:09:43,078 --> 00:09:45,852
so I can safely swallow the exception,

174
00:09:45,852 --> 00:09:48,284
and carry on with my code.

175
00:09:48,284 --> 00:09:51,569
But, now, if the database was unavailable,

176
00:09:51,569 --> 00:09:53,766
or the network was down

177
00:09:53,766 --> 00:09:57,308
or something completely
unpredictable had happened,

178
00:09:57,308 --> 00:10:00,998
then the exception would not be caught,

179
00:10:00,998 --> 00:10:03,366
and it would automatically be sent up

180
00:10:03,366 --> 00:10:07,760
to the higher levels of my
code creating a fatal error,

181
00:10:07,760 --> 00:10:10,876
which is probably what I want to happen.

182
00:10:10,876 --> 00:10:14,139
I'm not going to give you a
complete list of exceptions

183
00:10:14,139 --> 00:10:16,764
that Spring can throw because firstly,

184
00:10:16,764 --> 00:10:17,958
there's a lot of them,

185
00:10:17,958 --> 00:10:20,966
and secondly, I've found
they're so well-named

186
00:10:20,966 --> 00:10:25,133
that when they happen you tend
to know what's gone wrong.

187
00:10:26,726 --> 00:10:28,262
However, just to give you a flavor,

188
00:10:28,262 --> 00:10:30,460
here are some of the main
ones, and you'll find

189
00:10:30,460 --> 00:10:34,210
that they all extend a
common root exception,

190
00:10:35,132 --> 00:10:38,096
which is data access exception.

191
00:10:38,096 --> 00:10:41,105
If you look at the Java
doc for that class,

192
00:10:41,105 --> 00:10:45,272
you'll get a complete list of
all of the extending classes.

193
00:10:46,268 --> 00:10:49,979
For example, if there's a
problem getting the connection,

194
00:10:49,979 --> 00:10:51,430
then you're going to get

195
00:10:51,430 --> 00:10:54,680
a cannot get JDBC connection exception.

196
00:10:57,084 --> 00:10:59,814
If you failed to get the datatypes correct

197
00:10:59,814 --> 00:11:02,609
in one of your SQL statements then

198
00:11:02,609 --> 00:11:06,776
you're going to see the type
mismatch data access exception.

199
00:11:07,644 --> 00:11:11,811
If you try to insert a row,
and you've violated some kind

200
00:11:13,489 --> 00:11:16,348
of primary key constraint in the database,

201
00:11:16,348 --> 00:11:21,104
you'll get a data integrity
violation exception.

202
00:11:21,104 --> 00:11:25,158
Only when Spring really can't
work out what's gone wrong,

203
00:11:25,158 --> 00:11:29,745
will you get the
un-categorized SQL exception.

204
00:11:29,745 --> 00:11:33,912
You very rarely want to catch
any of these exceptions,

205
00:11:34,908 --> 00:11:38,684
only when you're absolutely
sure that something specific

206
00:11:38,684 --> 00:11:42,801
can go wrong and you
know you can handle it,

207
00:11:42,801 --> 00:11:44,956
as in the example we've just done.

208
00:11:44,956 --> 00:11:47,708
But, really the benefit is
when one of these exceptions

209
00:11:47,708 --> 00:11:51,825
happens, let's say there's a
problem acquiring a connection,

210
00:11:51,825 --> 00:11:55,878
then you're going to see on the
console or in the system log

211
00:11:55,878 --> 00:11:58,844
something like cannot get
JDBC connection exception

212
00:11:58,844 --> 00:12:01,617
and you immediately have a good clue

213
00:12:01,617 --> 00:12:04,134
as to what's gone wrong.

214
00:12:04,134 --> 00:12:08,892
A bit better than just
getting an Oracle error code.

215
00:12:08,892 --> 00:12:12,134
Now, I think I've now
improved that tri-catch-block,

216
00:12:12,134 --> 00:12:14,652
so I'll take out my to do there.

217
00:12:14,652 --> 00:12:16,614
Let's have a look at another example

218
00:12:16,614 --> 00:12:20,668
of the fine grain control
that this gives us.

219
00:12:20,668 --> 00:12:22,908
I'm going to go back to my clients,

220
00:12:22,908 --> 00:12:25,020
and I think I've already registered

221
00:12:25,020 --> 00:12:27,580
a few of these books into the system.

222
00:12:27,580 --> 00:12:31,747
What I'm going to do now
is I'm going to call the,

223
00:12:33,873 --> 00:12:37,372
I think we have a method called Find or

224
00:12:37,372 --> 00:12:39,789
rather it's Get Book by ISBN.

225
00:12:42,214 --> 00:12:45,201
Now, of course, if you
type in a valid ISBN number

226
00:12:45,201 --> 00:12:47,932
that is in the system
then we'll get a response

227
00:12:47,932 --> 00:12:49,404
from that method.

228
00:12:49,404 --> 00:12:53,777
But what happens if we type
in a nonsensical ISBN number?

229
00:12:53,777 --> 00:12:57,610
Now, clearly, this book
is not going to exist.

230
00:12:58,577 --> 00:13:00,910
What's going to happen here?

231
00:13:02,886 --> 00:13:05,053
Well, let's give it a run.

232
00:13:08,618 --> 00:13:12,186
And, you can see that
we're getting an exception.

233
00:13:12,186 --> 00:13:14,469
Now, the exception is one of these

234
00:13:14,469 --> 00:13:18,500
Spring framework data access exceptions

235
00:13:18,500 --> 00:13:19,717
and in this case,

236
00:13:19,717 --> 00:13:23,384
it's the empty result
data access exception.

237
00:13:24,794 --> 00:13:28,698
It's telling us that we have
an incorrect result size.

238
00:13:28,698 --> 00:13:32,837
One was expected, but the actual was zero.

239
00:13:32,837 --> 00:13:35,973
If I follow the hyperlink here,

240
00:13:35,973 --> 00:13:39,386
I can see that this is linking to my DAO,

241
00:13:39,386 --> 00:13:42,501
so it's probably the
source of the problem.

242
00:13:42,501 --> 00:13:46,042
Then, it's on this method call here.

243
00:13:46,042 --> 00:13:47,877
Now, I don't know if I mentioned this,

244
00:13:47,877 --> 00:13:51,162
but when you call query for objects,

245
00:13:51,162 --> 00:13:54,703
you are always assuming
there that you are expecting

246
00:13:54,703 --> 00:13:57,953
one and only one result to be returned.

247
00:14:00,378 --> 00:14:03,295
If you get zero, or more than zero,

248
00:14:05,228 --> 00:14:08,367
you'll get this unchecked exception.

249
00:14:08,367 --> 00:14:12,420
Well, that is a situation
that we can handle.

250
00:14:12,420 --> 00:14:14,980
We can handle that perfectly easily.

251
00:14:14,980 --> 00:14:16,737
So, what I'm going to do

252
00:14:16,737 --> 00:14:20,737
is I'm going to add this
query into a tri-block,

253
00:14:21,965 --> 00:14:26,125
and we know now that rather
than catching just SQL exception

254
00:14:26,125 --> 00:14:28,279
which would gobble up every other

255
00:14:28,279 --> 00:14:30,882
possible problem that might happen,

256
00:14:30,882 --> 00:14:33,442
we can specifically look for the

257
00:14:33,442 --> 00:14:36,359
empty result data access exception,

258
00:14:43,789 --> 00:14:45,372
and if that occurs,

259
00:14:46,754 --> 00:14:49,697
we can specifically
deal with that problem.

260
00:14:49,697 --> 00:14:52,279
Now, how would we deal with that problem?

261
00:14:52,279 --> 00:14:56,034
Well, my suggestion would
be the client needs to know

262
00:14:56,034 --> 00:14:58,534
that no results were returned.

263
00:14:59,489 --> 00:15:03,406
So, I'm going to throw
back to the client a new

264
00:15:04,482 --> 00:15:08,343
and well, I don't actually have
an exception for this case,

265
00:15:08,343 --> 00:15:10,242
so I can invent one,

266
00:15:10,242 --> 00:15:14,242
I'm going to call this
book not found exception.

267
00:15:16,173 --> 00:15:20,256
Now, you might have expected
me to possibly throw

268
00:15:21,506 --> 00:15:24,919
a database error or something like that,

269
00:15:24,919 --> 00:15:28,186
but the point of a DAO is
to wrap up the database

270
00:15:28,186 --> 00:15:31,728
and to handle the database completely.

271
00:15:31,728 --> 00:15:33,254
Now, whoever is called this method

272
00:15:33,254 --> 00:15:36,284
doesn't want to be
worrying about databases

273
00:15:36,284 --> 00:15:38,694
but what we do want to send
back to them is something

274
00:15:38,694 --> 00:15:42,640
that means something in terms
of the business requirements,

275
00:15:42,640 --> 00:15:45,884
in this case, a book has not been found.

276
00:15:45,884 --> 00:15:50,428
This exception doesn't exist,
so I'm going to create that.

277
00:15:50,428 --> 00:15:52,880
I can left click on the quick fix here,

278
00:15:52,880 --> 00:15:55,797
and select the create class option.

279
00:15:58,278 --> 00:16:01,734
I need to decide which
package it's going to go in,

280
00:16:01,734 --> 00:16:03,846
it's a bit debatable

281
00:16:03,846 --> 00:16:06,492
but I think I'll leave
it in the data package,

282
00:16:06,492 --> 00:16:08,198
at least for now.

283
00:16:08,198 --> 00:16:10,865
I can click finish, and believe it or not,

284
00:16:10,865 --> 00:16:14,321
that's all the work I need
to do for an exception.

285
00:16:14,321 --> 00:16:18,096
Sometimes you might want
to implement a constructor

286
00:16:18,096 --> 00:16:22,214
in your exception but it's
not actually necessary.

287
00:16:22,214 --> 00:16:23,547
So, that's fine.

288
00:16:25,265 --> 00:16:28,017
I'm just missing the
imports for the Spring

289
00:16:28,017 --> 00:16:31,068
empty result data access exception.

290
00:16:31,068 --> 00:16:33,862
So, I'll do a control shift and O there,

291
00:16:33,862 --> 00:16:36,828
and just to be clear, let's check,

292
00:16:36,828 --> 00:16:39,388
you can see that it comes
from the Spring framework,

293
00:16:39,388 --> 00:16:43,555
it's from the JDBC package
it's from the DAO package.

294
00:16:45,446 --> 00:16:46,790
I don't know why they've done that.

295
00:16:46,790 --> 00:16:49,350
We'll be looking at the DAO package later,

296
00:16:49,350 --> 00:16:50,929
and I guess they just borrowed it

297
00:16:50,929 --> 00:16:53,169
from another part of the framework.

298
00:16:53,169 --> 00:16:55,366
Now, I still have an error here,

299
00:16:55,366 --> 00:16:58,652
and that's because, oh I wish
I had thought this through,

300
00:16:58,652 --> 00:17:01,468
I'm throwing a book not found exception

301
00:17:01,468 --> 00:17:05,635
which is a checked exception
from my find by ISBN method.

302
00:17:06,865 --> 00:17:09,148
Well, that means I have to declare that

303
00:17:09,148 --> 00:17:10,854
as a throws clause

304
00:17:10,854 --> 00:17:12,354
on my method here.

305
00:17:14,545 --> 00:17:16,742
Book not found exception.

306
00:17:16,742 --> 00:17:17,958
Hope you're familiar with that,

307
00:17:17,958 --> 00:17:20,433
that's just from standard Java.

308
00:17:20,433 --> 00:17:22,844
I'm going to have to do a
bit of firefighting now.

309
00:17:22,844 --> 00:17:26,364
The trouble is now, I've
declared this on my class,

310
00:17:26,364 --> 00:17:27,364
but it's not

311
00:17:31,876 --> 00:17:35,025
declared in the interface
for the book DAO,

312
00:17:35,025 --> 00:17:37,585
I really should have
thought of this in advance.

313
00:17:37,585 --> 00:17:40,752
I need to put book not found exception

314
00:17:43,599 --> 00:17:46,219
on the interface as well.

315
00:17:46,219 --> 00:17:49,440
So, now that's compiling okay.

316
00:17:49,440 --> 00:17:51,690
The next problem is, again,

317
00:17:52,811 --> 00:17:54,475
quite a bit of fire fighting here.

318
00:17:54,475 --> 00:17:59,347
Remember that the DAO is
being called from our service

319
00:17:59,347 --> 00:18:00,680
and there it is.

320
00:18:02,581 --> 00:18:05,824
Similarly, if this is
thrown to the service,

321
00:18:05,824 --> 00:18:08,149
the service can't handle
this problem either,

322
00:18:08,149 --> 00:18:10,453
so it will need to re-throw the exception

323
00:18:10,453 --> 00:18:12,036
back to the client.

324
00:18:13,227 --> 00:18:16,363
And we do that by declaring
the exception on here,

325
00:18:16,363 --> 00:18:19,435
throws book not found exception,

326
00:18:19,435 --> 00:18:23,595
and we're going to have
exactly the same problem,

327
00:18:23,595 --> 00:18:25,494
that will need to be imported.

328
00:18:25,494 --> 00:18:28,629
That doesn't appear on the interface

329
00:18:28,629 --> 00:18:31,296
so I'll go into my book service.

330
00:18:32,363 --> 00:18:36,530
I'll need to add that to
the get book by ISBN method.

331
00:18:38,251 --> 00:18:40,918
Throws book not found exception.

332
00:18:43,456 --> 00:18:46,289
And that will need to be imported.

333
00:18:47,403 --> 00:18:49,472
I'm sorry, that was a
little bit of hard work

334
00:18:49,472 --> 00:18:52,928
but at least now the
code is compiling clean.

335
00:18:52,928 --> 00:18:55,318
Well, at least it is,
apart from the clients,

336
00:18:55,318 --> 00:18:57,472
but this is a good problem.

337
00:18:57,472 --> 00:19:00,778
We now have an error because on the client

338
00:19:00,778 --> 00:19:02,592
we're calling book by ISBN,

339
00:19:02,592 --> 00:19:06,092
but we haven't provided a tri-catch-block.

340
00:19:07,738 --> 00:19:11,238
This is the right place to do this because

341
00:19:16,753 --> 00:19:18,988
the client can handle this problem

342
00:19:18,988 --> 00:19:21,676
and the client would handle
this problem just by saying,

343
00:19:21,676 --> 00:19:24,426
"Sorry, that book doesn't exist."

344
00:19:28,140 --> 00:19:30,572
Presumably, it was the
client that got this

345
00:19:30,572 --> 00:19:33,708
bad data here in the first place.

346
00:19:33,708 --> 00:19:36,012
I'll need to import the exception.

347
00:19:36,012 --> 00:19:39,682
Before I run the code, I've
just spotted another error.

348
00:19:39,682 --> 00:19:41,388
This time in purchasing service,

349
00:19:41,388 --> 00:19:45,122
and of course in the buy book method

350
00:19:45,122 --> 00:19:47,362
of the purchasing service

351
00:19:47,362 --> 00:19:50,433
we called get book by ISBN there.

352
00:19:50,433 --> 00:19:53,335
Well, it would be the
same thing here really.

353
00:19:53,335 --> 00:19:55,084
If the book doesn't exist,

354
00:19:55,084 --> 00:19:57,666
then we would want to throw
that back to the client,

355
00:19:57,666 --> 00:20:01,833
so I'll add that to the
throws clause of that method

356
00:20:04,236 --> 00:20:06,744
and I've just imported it there.

357
00:20:06,744 --> 00:20:08,258
And finally, that would need

358
00:20:08,258 --> 00:20:11,675
to be reflected on the interface as well.

359
00:20:16,131 --> 00:20:18,498
I don't think we're using
the purchasing service

360
00:20:18,498 --> 00:20:21,827
anywhere else in the code
though, so I'm hoping,

361
00:20:21,827 --> 00:20:25,475
yeah, that looks like
that's now all clean.

362
00:20:25,475 --> 00:20:27,475
So, back to our clients.

363
00:20:30,062 --> 00:20:31,854
We should now be able to run this code,

364
00:20:31,854 --> 00:20:33,858
and we should see a friendly error message

365
00:20:33,858 --> 00:20:37,441
instead of that hideous
red exception text.

366
00:20:40,878 --> 00:20:42,094
Great!

367
00:20:42,094 --> 00:20:43,672
That's running through okay now,

368
00:20:43,672 --> 00:20:45,720
and to review what we've done there,

369
00:20:45,720 --> 00:20:48,280
we've now very cleanly

370
00:20:48,280 --> 00:20:52,447
said that we want to try
to find this specific book.

371
00:20:54,083 --> 00:20:57,539
We're only expecting one possible problem,

372
00:20:57,539 --> 00:21:00,824
and that's the empty result
data access exception.

373
00:21:00,824 --> 00:21:03,342
If that happens, we can deal with it.

374
00:21:03,342 --> 00:21:06,563
But, if anything else goes wrong,

375
00:21:06,563 --> 00:21:09,400
such as the connection
couldn't be acquired,

376
00:21:09,400 --> 00:21:13,965
then Spring will throw one of
those unchecked exceptions.

377
00:21:13,965 --> 00:21:18,510
So, there's a lot of magic
going on inside this template.

378
00:21:18,510 --> 00:21:20,664
When Spring catches an exception

379
00:21:20,664 --> 00:21:24,974
it needs to check the error
code returned by the database

380
00:21:24,974 --> 00:21:26,765
and depending on the database vendor

381
00:21:26,765 --> 00:21:31,139
it needs to work out what
that error code really means.

382
00:21:31,139 --> 00:21:32,526
A lot of magic going on there.

383
00:21:32,526 --> 00:21:34,958
Just in case you're interested,

384
00:21:34,958 --> 00:21:38,584
and I didn't do this on the
first edition of the course,

385
00:21:38,584 --> 00:21:41,592
but I think a lot of people
will be interested in this,

386
00:21:41,592 --> 00:21:45,944
if in Eclipse you open up
your reference libraries,

387
00:21:45,944 --> 00:21:47,843
of course, this is showing you

388
00:21:47,843 --> 00:21:50,531
all of the jar files on your class path,

389
00:21:50,531 --> 00:21:54,281
one of them will be the
Spring JDBC jar file.

390
00:21:56,248 --> 00:21:58,331
If you drop down that tab

391
00:22:00,515 --> 00:22:04,590
it is, I think I will
maximize the package explorer,

392
00:22:04,590 --> 00:22:08,770
it's showing you all of the
contents of that jar file,

393
00:22:08,770 --> 00:22:12,718
including all of the classes
that are inside there.

394
00:22:12,718 --> 00:22:15,320
I can tell you that if you drill down

395
00:22:15,320 --> 00:22:18,570
into this package here called supports,

396
00:22:19,736 --> 00:22:22,986
you'll find in there an EML file called

397
00:22:23,960 --> 00:22:25,210
SQL error codes

398
00:22:27,096 --> 00:22:29,763
and we can open that in Eclipse.

399
00:22:30,872 --> 00:22:34,456
And, feel free to have a good
look at what's inside here,

400
00:22:34,456 --> 00:22:37,251
but I'm sure you can see pretty quickly

401
00:22:37,251 --> 00:22:40,622
that what we've got in here
is a list of error codes

402
00:22:40,622 --> 00:22:43,789
for all of the major database vendors.

403
00:22:45,059 --> 00:22:48,707
For instance, we're running on HSQLDB.

404
00:22:48,707 --> 00:22:52,952
And, Spring have identified
that error codes 22 and 28

405
00:22:52,952 --> 00:22:55,299
are bad SQL grammar,

406
00:22:55,299 --> 00:22:59,466
error code 104 is a duplicate
key code, and so on.

407
00:23:00,376 --> 00:23:04,408
And, there must be
Oracle in here somewhere.

408
00:23:04,408 --> 00:23:08,142
There's Oracle; completely
different codes.

409
00:23:08,142 --> 00:23:11,022
There's My SQL, which I know a lot of you

410
00:23:11,022 --> 00:23:12,600
will be working with.

411
00:23:12,600 --> 00:23:15,544
If you have a database
that isn't supported,

412
00:23:15,544 --> 00:23:17,544
then you can extend this

413
00:23:18,616 --> 00:23:22,520
or perhaps, I'm just thinking
ahead here a little bit,

414
00:23:22,520 --> 00:23:24,035
we got back to HSQL,

415
00:23:24,035 --> 00:23:28,579
you could possibly set
up a special exception,

416
00:23:28,579 --> 00:23:30,243
an exception of your own

417
00:23:30,243 --> 00:23:33,656
to handle the case where
the table already exists.

418
00:23:33,656 --> 00:23:35,576
Now, I'm not going to
do that on this course

419
00:23:35,576 --> 00:23:37,560
because it is a little bit fiddly,

420
00:23:37,560 --> 00:23:40,206
and I guess a little bit advanced.

421
00:23:40,206 --> 00:23:42,680
If you check the reference
manual for details,

422
00:23:42,680 --> 00:23:44,387
you'll find full information

423
00:23:44,387 --> 00:23:48,888
on how you can provide
your own SQL error codes.

424
00:23:48,888 --> 00:23:51,896
What I wanted to show you
here that it isn't really

425
00:23:51,896 --> 00:23:54,584
a particularly magic process,

426
00:23:54,584 --> 00:23:58,894
but it's certainly very useful
that Spring is doing it.

427
00:23:58,894 --> 00:24:02,435
We're now going to discuss how to use JNDI

428
00:24:02,435 --> 00:24:05,144
to manage your database connections.

429
00:24:05,144 --> 00:24:08,003
Now, this part of the course is optional.

430
00:24:08,003 --> 00:24:09,859
You only need to study this

431
00:24:09,859 --> 00:24:12,824
if you're planning on
deploying your application

432
00:24:12,824 --> 00:24:14,907
to an application server.

433
00:24:16,238 --> 00:24:18,158
Now, I will be assuming that you are

434
00:24:18,158 --> 00:24:21,158
at least somewhat familiar with JNDI

435
00:24:22,424 --> 00:24:24,622
and application servers.

436
00:24:24,622 --> 00:24:27,736
If not, then we do have
a full course on that

437
00:24:27,736 --> 00:24:28,986
called Java EE.

438
00:24:30,659 --> 00:24:33,752
So far, we've been managing
our database connections

439
00:24:33,752 --> 00:24:37,252
via this apache commons basic data source.

440
00:24:39,320 --> 00:24:41,795
Now, this is a connection pool,

441
00:24:41,795 --> 00:24:43,800
and it is production standard.

442
00:24:43,800 --> 00:24:45,742
It's an excellent way of working

443
00:24:45,742 --> 00:24:48,664
when we're working in what we call in Java

444
00:24:48,664 --> 00:24:50,831
a non-managed environment.

445
00:24:52,654 --> 00:24:56,963
Now, that means we're not
using an application server.

446
00:24:56,963 --> 00:24:59,075
We just don't need one.

447
00:24:59,075 --> 00:25:03,242
However, what if you do want
to deploy your application

448
00:25:04,110 --> 00:25:06,627
to an application service

449
00:25:06,627 --> 00:25:09,877
such as Glassfish, WebSphere, or Jboss?

450
00:25:11,192 --> 00:25:14,350
Well, the usual pattern in Java EE

451
00:25:14,350 --> 00:25:18,254
is to use the Java naming
and directory interface,

452
00:25:18,254 --> 00:25:20,254
otherwise known as JNDI,

453
00:25:21,304 --> 00:25:24,675
to look up your database connections.

454
00:25:24,675 --> 00:25:27,512
And the idea is that
a system administrator

455
00:25:27,512 --> 00:25:30,776
will have created the
database connection pool

456
00:25:30,776 --> 00:25:34,104
and they will normally
do that through some kind

457
00:25:34,104 --> 00:25:37,390
of administration page on
the application server.

458
00:25:37,390 --> 00:25:38,776
And then as programmers,

459
00:25:38,776 --> 00:25:43,235
we access that connection
pool by using JNDI.

460
00:25:43,235 --> 00:25:46,606
The style of code that
you would need to use JNDI

461
00:25:46,606 --> 00:25:49,550
looks something like this.

462
00:25:49,550 --> 00:25:51,811
As I said, I'm assuming you are already

463
00:25:51,811 --> 00:25:54,222
somewhat familiar with JNDI.

464
00:25:54,222 --> 00:25:56,569
If not, then there are plenty of resources

465
00:25:56,569 --> 00:25:58,360
on the web about it, and as I mentioned,

466
00:25:58,360 --> 00:26:00,430
we do have a course on Java EE.

467
00:26:00,430 --> 00:26:03,928
Roughly the pattern is that
you open up what is called

468
00:26:03,928 --> 00:26:05,511
an initial context.

469
00:26:06,446 --> 00:26:11,032
Now that's really just a
directory on the JNDI server.

470
00:26:11,032 --> 00:26:14,659
Once you've opened up that directory,

471
00:26:14,659 --> 00:26:17,580
then you call this look up method followed

472
00:26:17,580 --> 00:26:22,059
by the name of the resource
that you want to access.

473
00:26:22,059 --> 00:26:24,691
In our case, it's the connection pool,

474
00:26:24,691 --> 00:26:26,718
and the connection pool
will have been given a name

475
00:26:26,718 --> 00:26:29,961
by the system administrator,
and it usually looks

476
00:26:29,961 --> 00:26:32,435
something like this.

477
00:26:32,435 --> 00:26:34,547
The give away is that it's always got

478
00:26:34,547 --> 00:26:38,714
JDBC forward slash followed
by some kind of a label.

479
00:26:39,881 --> 00:26:44,190
Now, if we were to use
JNDI directly in our DAO,

480
00:26:44,190 --> 00:26:46,217
our code would look something like this.

481
00:26:46,217 --> 00:26:50,274
So I've gone into the
constructor here of my book DAO,

482
00:26:50,274 --> 00:26:53,603
and I've added a call to look up in there.

483
00:26:53,603 --> 00:26:56,026
Well, it's rather sticky code

484
00:26:56,026 --> 00:26:58,714
because I have to have a tri-catch-block,

485
00:26:58,714 --> 00:27:02,574
and you'll see that I've got
a lot of hard coding in there.

486
00:27:02,574 --> 00:27:04,772
In general, this would
be a really bad idea

487
00:27:04,772 --> 00:27:07,162
to do this in our book DAO

488
00:27:07,162 --> 00:27:09,850
because we'd have to go into our DAO,

489
00:27:09,850 --> 00:27:11,877
we'd have to completely rework the DAO

490
00:27:11,877 --> 00:27:14,756
to include this code into the constructor.

491
00:27:14,756 --> 00:27:16,719
And crucially, once we've done that,

492
00:27:16,719 --> 00:27:20,886
our book DAO will only work
now if JNDI is available.

493
00:27:22,606 --> 00:27:24,517
In other words, if our code is running

494
00:27:24,517 --> 00:27:27,760
on an application server,
we'd no longer be able

495
00:27:27,760 --> 00:27:31,664
to run our code outside
of an application server.

496
00:27:31,664 --> 00:27:33,008
I'd much rather have it

497
00:27:33,008 --> 00:27:34,949
so that we could deploy our application

498
00:27:34,949 --> 00:27:39,259
to either a managed or a
non-managed environment,

499
00:27:39,259 --> 00:27:43,483
with minor changes to
the XML configuration.

500
00:27:43,483 --> 00:27:47,109
Now, one of the most
important features at Spring,

501
00:27:47,109 --> 00:27:51,013
for me, is that it can
run either on a full blown

502
00:27:51,013 --> 00:27:55,279
possibly expensive application
server like WebSphere,

503
00:27:55,279 --> 00:27:58,529
or we can run it on a basic desktop PC,

504
00:27:59,546 --> 00:28:02,256
with no special software involved.

505
00:28:02,256 --> 00:28:05,627
We might need to change some
XML configuration around,

506
00:28:05,627 --> 00:28:09,786
but the actual code won't need to change.

507
00:28:09,786 --> 00:28:11,899
Why would I want to do that?

508
00:28:11,899 --> 00:28:13,755
Well, it is a bit political,

509
00:28:13,755 --> 00:28:16,848
but some projects have to run their code

510
00:28:16,848 --> 00:28:20,432
on an application server
possibly because the project

511
00:28:20,432 --> 00:28:24,251
has bought an expensive support
contract or an insurance

512
00:28:24,251 --> 00:28:28,418
contract from one of the big
application server providers.

513
00:28:29,477 --> 00:28:32,741
Or, it's possible that your project relies

514
00:28:32,741 --> 00:28:37,413
on a particular feature provided
by an application server.

515
00:28:37,413 --> 00:28:39,397
Which is fine.

516
00:28:39,397 --> 00:28:42,043
And, because Spring integrates so well

517
00:28:42,043 --> 00:28:45,626
with application servers,
we can do just that.

518
00:28:45,626 --> 00:28:47,845
We can run our code on
an application server,

519
00:28:47,845 --> 00:28:50,213
but at the same time, if we wanted to,

520
00:28:50,213 --> 00:28:53,328
we could take our app away
from the application server,

521
00:28:53,328 --> 00:28:57,161
and you could still run
on a basic desktop pc.

522
00:28:58,256 --> 00:29:00,581
So, we know that the
code we've written so far

523
00:29:00,581 --> 00:29:04,805
runs perfectly well with no
application server in place.

524
00:29:04,805 --> 00:29:08,283
It's almost like we've plugged
in our own connection pool.

525
00:29:08,283 --> 00:29:11,632
But let's say we now
want to deploy this code

526
00:29:11,632 --> 00:29:15,515
on a project to an application server.

527
00:29:15,515 --> 00:29:17,563
One of the key features
of an application server

528
00:29:17,563 --> 00:29:21,730
is it will always have a
connection port built in.

529
00:29:22,597 --> 00:29:26,864
What we can do is change
the data source definition.

530
00:29:26,864 --> 00:29:29,552
I'm going to delete, only temporarily,

531
00:29:29,552 --> 00:29:31,706
I will undo these changes,

532
00:29:31,706 --> 00:29:35,675
I'm going to delete the class
definition and the properties,

533
00:29:35,675 --> 00:29:37,595
and I'm going to introduce you now

534
00:29:37,595 --> 00:29:40,304
to a wonderful class from
the Spring framework,

535
00:29:40,304 --> 00:29:43,483
I think it's my favorite
class in the whole of Spring,

536
00:29:43,483 --> 00:29:44,733
and it's called

537
00:29:45,637 --> 00:29:47,536
well it's got a long name

538
00:29:47,536 --> 00:29:52,016
it's from the org dot
Spring framework package.

539
00:29:52,016 --> 00:29:55,877
There's a sub-package
in there called JNDI,

540
00:29:55,877 --> 00:29:58,523
and the name of the bean,

541
00:29:58,523 --> 00:30:01,125
or the name of the class really, is

542
00:30:01,125 --> 00:30:03,292
JNDI Objects Factory Bean.

543
00:30:08,549 --> 00:30:13,264
Now, the role of this class
is it acts as a stand in

544
00:30:13,264 --> 00:30:16,997
from the class that we're
looking up from JNDI.

545
00:30:16,997 --> 00:30:21,157
In my case, this class is going to pretend

546
00:30:21,157 --> 00:30:24,657
to be a data source so I can still give it

547
00:30:25,744 --> 00:30:28,091
the ID of data source,

548
00:30:28,091 --> 00:30:32,208
and I can still inject
it into my template.

549
00:30:32,208 --> 00:30:35,408
But, it isn't really a data source.

550
00:30:35,408 --> 00:30:39,845
When the template first
uses this data source,

551
00:30:39,845 --> 00:30:42,939
Spring, or at least this class,

552
00:30:42,939 --> 00:30:46,992
will automatically with no
further code required from us,

553
00:30:46,992 --> 00:30:51,344
it will go to JNDI, and look
up the appropriate object

554
00:30:51,344 --> 00:30:53,989
from the application server.

555
00:30:53,989 --> 00:30:57,509
All we have to do is to specify the name

556
00:30:57,509 --> 00:31:02,074
of the JNDI resource that
we're using as a property.

557
00:31:02,074 --> 00:31:06,241
So we plug into here property
with the name JNDI name

558
00:31:09,861 --> 00:31:12,016
and for the value

559
00:31:12,016 --> 00:31:16,219
this will be the JNDI name
that the system administrator

560
00:31:16,219 --> 00:31:19,141
has given the connection pool.

561
00:31:19,141 --> 00:31:22,789
And it will usually be something
like JDBC forward slash,

562
00:31:22,789 --> 00:31:25,883
and then some kind of friendly name.

563
00:31:25,883 --> 00:31:27,050
And that's it.

564
00:31:28,805 --> 00:31:31,408
So, Spring will automatically get

565
00:31:31,408 --> 00:31:33,648
the connection pool from JNDI

566
00:31:33,648 --> 00:31:36,123
plug it into this bean, and then

567
00:31:36,123 --> 00:31:39,623
it will be used by the rest of our system.

568
00:31:40,559 --> 00:31:42,821
Now, I can't run this code here

569
00:31:42,821 --> 00:31:46,235
because I don't have an
application server running.

570
00:31:46,235 --> 00:31:48,560
But, if I had, then this code would run

571
00:31:48,560 --> 00:31:50,560
with no further changes.

572
00:31:51,675 --> 00:31:55,387
A very common pattern in Spring
when developing applications

573
00:31:55,387 --> 00:31:58,587
is to begin with that basic data source

574
00:31:58,587 --> 00:32:01,445
so that we can develop on our own desk top

575
00:32:01,445 --> 00:32:04,773
without the need for any
external dependencies.

576
00:32:04,773 --> 00:32:06,664
But, if in the future

577
00:32:06,664 --> 00:32:09,459
we decide to go to an application server,

578
00:32:09,459 --> 00:32:12,701
then we just make that XML change here.

579
00:32:12,701 --> 00:32:14,984
Now, I know I needed
to make a change there,

580
00:32:14,984 --> 00:32:16,861
but it would be trivial to have

581
00:32:16,861 --> 00:32:20,189
two alternative versions of this XML file.

582
00:32:20,189 --> 00:32:22,066
One for the app server,

583
00:32:22,066 --> 00:32:25,927
and one for the non-app server version.

584
00:32:25,927 --> 00:32:28,094
The choice would be yours.

585
00:32:29,000 --> 00:32:31,155
Now, as I say, this won't run for me.

586
00:32:31,155 --> 00:32:33,523
I don't know if you have
an application server

587
00:32:33,523 --> 00:32:35,314
that you want to try this out on,

588
00:32:35,314 --> 00:32:38,557
but for the purposes of the
practicals in code folder,

589
00:32:38,557 --> 00:32:41,057
I'm going to undo this change.

590
00:32:41,930 --> 00:32:46,582
And revert it back to our
common basic data source.

591
00:32:46,582 --> 00:32:48,928
And, I'm just going to leave
you with the final message

592
00:32:48,928 --> 00:32:51,830
that I don't want you to think
that this basic data source

593
00:32:51,830 --> 00:32:55,072
is some kind of half-baked solution.

594
00:32:55,072 --> 00:32:57,905
This is still production standard,

595
00:32:59,168 --> 00:33:02,518
and you could perfectly well
write a production quality

596
00:33:02,518 --> 00:33:05,227
Spring application without ever needing

597
00:33:05,227 --> 00:33:07,060
an application server.

598
00:33:07,958 --> 00:33:11,200
As I mentioned, the reason
for using application servers

599
00:33:11,200 --> 00:33:14,506
is often political, or there
might be that there's some

600
00:33:14,506 --> 00:33:17,707
advanced feature that you
want from that server.

601
00:33:17,707 --> 00:33:19,626
Certainly in terms of connection pools,

602
00:33:19,626 --> 00:33:21,959
this is production standard.

603
00:33:23,636 --> 00:33:28,156
So, exceptions thrown by the
JDBC template are unchecked,

604
00:33:28,156 --> 00:33:30,375
which means you don't have to handle them.

605
00:33:30,375 --> 00:33:33,639
And indeed, most of them are unrecoverable

606
00:33:33,639 --> 00:33:36,882
environmental problems such
as a faulty connection.

607
00:33:36,882 --> 00:33:40,647
In that case, the exception
will be un-handled,

608
00:33:40,647 --> 00:33:44,814
and will usually be caught by,
for example, your web server.

609
00:33:46,229 --> 00:33:48,832
But you can zero in on specific problems

610
00:33:48,832 --> 00:33:50,389
that you're expecting,

611
00:33:50,389 --> 00:33:52,821
such as the failure to create a table.

612
00:33:52,821 --> 00:33:55,658
That can be really useful,
although to be honest,

613
00:33:55,658 --> 00:33:59,392
you probably won't use
this feature very often.

614
00:33:59,392 --> 00:34:01,888
We then looked at JNDI.

615
00:34:01,888 --> 00:34:04,320
If you don't know about JNDI,

616
00:34:04,320 --> 00:34:07,050
and you're not interested
in application servers,

617
00:34:07,050 --> 00:34:09,610
then you can safely ignore that material.

618
00:34:09,610 --> 00:34:12,725
But, if you ever do want
to run your Spring app

619
00:34:12,725 --> 00:34:17,483
on an application server, then
you can do so quite easily.

620
00:34:17,483 --> 00:34:21,109
And, you can also integrate
into the app server's

621
00:34:21,109 --> 00:34:25,276
existing connection pool
rather than bringing your own.

622
00:34:26,762 --> 00:34:29,450
So, that's enough theory
on the JDBC template.

623
00:34:29,450 --> 00:34:31,925
In the next chapter,

624
00:34:31,925 --> 00:34:35,061
I'll set you up on another
practical exercise.

625
00:34:35,061 --> 00:34:38,811
(lively synthesizer rhythms)

1
00:00:00,000 --> 00:00:02,583
(upbeat music)

2
00:00:10,809 --> 00:00:13,134
- [Voiceover] So now it's
time to switch back to

3
00:00:13,134 --> 00:00:17,463
the CRM system where you
will get a chance to use

4
00:00:17,463 --> 00:00:20,046
the JDBC template for yourself.

5
00:00:22,689 --> 00:00:24,855
In this chapter, we're going to create

6
00:00:24,855 --> 00:00:29,569
a production implementation
of our service classes.

7
00:00:29,569 --> 00:00:31,799
But this time we'll be using proper

8
00:00:31,799 --> 00:00:34,132
data access objects or DAOs.

9
00:00:36,673 --> 00:00:40,545
By the way, you may have noticed
in the previous exercises

10
00:00:40,545 --> 00:00:43,980
that we have already
provided a package for you

11
00:00:43,980 --> 00:00:45,563
called data access.

12
00:00:46,817 --> 00:00:50,583
And in there you'll find two interfaces.

13
00:00:50,583 --> 00:00:53,484
One for the customer DAO.

14
00:00:53,484 --> 00:00:57,151
Notice it's really a
regular Java interface.

15
00:00:58,284 --> 00:01:01,868
And there's one for
the action DAO as well.

16
00:01:01,868 --> 00:01:04,929
To save some time, I've
already implemented

17
00:01:04,929 --> 00:01:06,846
the action DAO for you.

18
00:01:07,735 --> 00:01:09,902
This action DAO JDBC input

19
00:01:11,347 --> 00:01:14,409
because it's very similar
to the customer DAO

20
00:01:14,409 --> 00:01:16,915
that you'll be implementing.

21
00:01:16,915 --> 00:01:18,963
But if you want some clues

22
00:01:18,963 --> 00:01:21,235
you can look in this implementation

23
00:01:21,235 --> 00:01:23,187
and that should give you some inspiration

24
00:01:23,187 --> 00:01:26,718
for how to work on the customer DAO.

25
00:01:26,718 --> 00:01:30,801
So you won't be implementing
your DAO using JDBC.

26
00:01:32,339 --> 00:01:33,961
That's too hard.

27
00:01:33,961 --> 00:01:38,814
Instead, you're going to
use the Spring JDBCTemplate

28
00:01:38,814 --> 00:01:42,505
to make the DAO implementation simpler.

29
00:01:42,505 --> 00:01:44,062
And when you've done that,

30
00:01:44,062 --> 00:01:48,105
you'll then use the Commons
DBCP connection pool

31
00:01:48,105 --> 00:01:51,123
to connect to the database.

32
00:01:51,123 --> 00:01:54,515
The values for the database URL,

33
00:01:54,515 --> 00:01:57,555
the driver class name,
the username and password

34
00:01:57,555 --> 00:02:00,041
are exactly the same as they were

35
00:02:00,041 --> 00:02:01,918
when we worked though the book system

36
00:02:01,918 --> 00:02:04,030
on the previous videos.

37
00:02:04,030 --> 00:02:06,494
However, you can also find those values

38
00:02:06,494 --> 00:02:09,182
in the PDF Practicals Guide

39
00:02:09,182 --> 00:02:13,161
so you can copy them
from there if you prefer.

40
00:02:13,161 --> 00:02:16,148
Also, this isn't an SQL course,

41
00:02:16,148 --> 00:02:19,219
so the SQL you need to create the tables

42
00:02:19,219 --> 00:02:22,057
is also in that Practical Guide.

43
00:02:22,057 --> 00:02:23,497
I'm sure you'll be able to work out

44
00:02:23,497 --> 00:02:26,206
the inserts, updates, and deletes

45
00:02:26,206 --> 00:02:28,553
from the previous chapters.

46
00:02:28,553 --> 00:02:30,324
So one of the jobs will be to

47
00:02:30,324 --> 00:02:33,203
implement production
standard implementations of

48
00:02:33,203 --> 00:02:35,433
your service classes.

49
00:02:35,433 --> 00:02:39,283
Now one of them is the
customer management service.

50
00:02:39,283 --> 00:02:40,926
And most of the methods in there

51
00:02:40,926 --> 00:02:42,761
should be fairly routine.

52
00:02:42,761 --> 00:02:44,574
I just want to draw your attention to

53
00:02:44,574 --> 00:02:48,741
this method here which is
called getFullCustomerDetail.

54
00:02:50,430 --> 00:02:53,566
Now this is a little bit more complicated

55
00:02:53,566 --> 00:02:55,539
than the other methods.

56
00:02:55,539 --> 00:02:57,555
Because the aim of this method

57
00:02:57,555 --> 00:03:00,388
is to return not just the customer

58
00:03:01,225 --> 00:03:04,642
but also a collection of all of the calls

59
00:03:06,291 --> 00:03:08,094
for that customer.

60
00:03:08,094 --> 00:03:11,795
So you are going to need to
do a little bit more work

61
00:03:11,795 --> 00:03:14,045
in the DAO to do that work.

62
00:03:15,433 --> 00:03:20,105
Also, you might need to
upgrade some of these methods.

63
00:03:20,105 --> 00:03:24,254
For instance, there's a method
here called updateCustomer.

64
00:03:24,254 --> 00:03:26,793
Now I'm thinking that probably

65
00:03:26,793 --> 00:03:29,342
this method really ought to throw

66
00:03:29,342 --> 00:03:31,785
a customer not found exception

67
00:03:31,785 --> 00:03:35,774
if this customer doesn't
exist for any reason.

68
00:03:35,774 --> 00:03:37,961
Feel free to make any upgrades

69
00:03:37,961 --> 00:03:41,438
that you think are necessary
to these interfaces.

70
00:03:41,438 --> 00:03:43,646
Well as always, there's a solution code

71
00:03:43,646 --> 00:03:45,758
in the Practicals and Code folder

72
00:03:45,758 --> 00:03:50,633
and a full work solution
follows in just a few moments.

73
00:03:50,633 --> 00:03:52,659
Don't just watch that solution though

74
00:03:52,659 --> 00:03:54,515
without trying for yourself.

75
00:03:54,515 --> 00:03:56,287
Most of the work is very similar to

76
00:03:56,287 --> 00:03:58,452
what we did in the previous bookstore

77
00:03:58,452 --> 00:04:02,619
but this is a great chance
to practice for yourself.

78
00:04:06,047 --> 00:04:08,667
Hello and welcome to this walk through

79
00:04:08,667 --> 00:04:10,631
for the practical
exercise where we're using

80
00:04:10,631 --> 00:04:13,631
the JDBCTemplates on the CRM system.

81
00:04:15,175 --> 00:04:16,871
The first job I'll need to do

82
00:04:16,871 --> 00:04:19,674
is to close the bookstore project

83
00:04:19,674 --> 00:04:22,479
that I was working on
in the previous chapter.

84
00:04:22,479 --> 00:04:25,572
Also close any files
that you may have open

85
00:04:25,572 --> 00:04:27,311
in the editor here.

86
00:04:27,311 --> 00:04:30,811
And I'm going to open up the CRM projects.

87
00:04:31,791 --> 00:04:34,703
So just a very quick review.

88
00:04:34,703 --> 00:04:37,466
Just to remind ourselves where we were.

89
00:04:37,466 --> 00:04:39,549
We have a service package

90
00:04:41,637 --> 00:04:44,970
which has a customer management service.

91
00:04:45,914 --> 00:04:49,903
and currently we have
a mock implementation

92
00:04:49,903 --> 00:04:51,770
of that interface.

93
00:04:51,770 --> 00:04:55,823
And it's using a hashmap just
to store some data in memory.

94
00:04:55,823 --> 00:04:58,660
Now I'm going to retire this class now

95
00:04:58,660 --> 00:04:59,910
and upgrade it.

96
00:05:00,868 --> 00:05:03,492
Produce a new implementation, in fact,

97
00:05:03,492 --> 00:05:05,669
which is going to use a DAO

98
00:05:05,669 --> 00:05:07,759
to access the database.

99
00:05:07,759 --> 00:05:11,087
Now this is going to be quite a long job.

100
00:05:11,087 --> 00:05:14,010
There's a lot of tasks to do here.

101
00:05:14,010 --> 00:05:16,453
But most of it should be fairly routine.

102
00:05:16,453 --> 00:05:17,701
We could start anywhere

103
00:05:17,701 --> 00:05:20,303
but I'm going to begin by implementing

104
00:05:20,303 --> 00:05:22,553
the customer DAO interface.

105
00:05:23,642 --> 00:05:26,522
This is really the core of the Practical.

106
00:05:26,522 --> 00:05:28,804
So I'll need a new class.

107
00:05:28,804 --> 00:05:32,378
Now make sure this class is
in the data access package.

108
00:05:32,378 --> 00:05:34,468
We can call it anything we want.

109
00:05:34,468 --> 00:05:38,635
I'm going to go for
CustomerDaoJdbcTemplateImplementation.

110
00:05:41,967 --> 00:05:44,772
We want to implement the
customer DAO interface

111
00:05:44,772 --> 00:05:47,022
so I will add that in here.

112
00:05:47,962 --> 00:05:51,514
Make sure you chose the
DAO and not the service.

113
00:05:51,514 --> 00:05:55,503
And make sure this checkbox here is ticked

114
00:05:55,503 --> 00:05:57,828
so that when we click Finish,

115
00:05:57,828 --> 00:06:00,516
we get some skeleton implementations

116
00:06:00,516 --> 00:06:02,799
of all of the methods.

117
00:06:02,799 --> 00:06:04,932
And before we implement any of the methods

118
00:06:04,932 --> 00:06:06,906
I think the central think in this class is

119
00:06:06,906 --> 00:06:09,412
that it's going to hold a reference to

120
00:06:09,412 --> 00:06:13,162
that Spring helper class
called JDBCTemplate.

121
00:06:14,127 --> 00:06:16,847
I'm going to call the
attribute just Template.

122
00:06:16,847 --> 00:06:18,867
Of course, that's your choice.

123
00:06:18,867 --> 00:06:20,463
And when you've imported it

124
00:06:20,463 --> 00:06:23,660
always worth having a quick
double check of the import.

125
00:06:23,660 --> 00:06:27,628
And you're looking for
Spring framework JDBC core.

126
00:06:27,628 --> 00:06:30,209
Now we need to inject that template.

127
00:06:30,209 --> 00:06:33,014
And as in previous chapters,
the choice is yours.

128
00:06:33,014 --> 00:06:35,937
You could use setter injection here

129
00:06:35,937 --> 00:06:38,614
but I'm going to go for
constructor injection.

130
00:06:38,614 --> 00:06:41,531
So we're creating a constructor for

131
00:06:42,540 --> 00:06:45,623
the customer DAO JDBCTemplate import.

132
00:06:47,158 --> 00:06:51,325
So we'll be able pass in an
instance of this template

133
00:06:53,664 --> 00:06:55,747
which we will store away.

134
00:06:58,770 --> 00:06:59,719
So that's good.

135
00:06:59,719 --> 00:07:03,314
This template's going to
save us a lot of work.

136
00:07:03,314 --> 00:07:05,383
In fact, I'm going to start with

137
00:07:05,383 --> 00:07:09,550
a new method, a private
method called createTables.

138
00:07:10,749 --> 00:07:12,978
Pretty much the same as I did

139
00:07:12,978 --> 00:07:16,807
in the videos where we
worked on the bookstore.

140
00:07:16,807 --> 00:07:20,227
And I want Spring to call
this method automatically

141
00:07:20,227 --> 00:07:22,574
when this bin gets created.

142
00:07:22,574 --> 00:07:25,753
So I can use the template for that.

143
00:07:25,753 --> 00:07:27,801
And I know I said this in the videos

144
00:07:27,801 --> 00:07:30,371
but it's worth mentioning again that

145
00:07:30,371 --> 00:07:33,113
I think the thing most
people find confusing

146
00:07:33,113 --> 00:07:37,550
with this template is that
the method is called update

147
00:07:37,550 --> 00:07:40,717
to execute any SQL except for queries.

148
00:07:42,638 --> 00:07:45,145
So inserts, deletes, and updates

149
00:07:45,145 --> 00:07:47,140
but also created tables.

150
00:07:47,140 --> 00:07:49,859
And if you want to dropping tables

151
00:07:49,859 --> 00:07:52,782
is done via that update method.

152
00:07:52,782 --> 00:07:56,654
Okay then for the SQL, I'm
just going to copy and paste

153
00:07:56,654 --> 00:07:59,748
directly from the Practicals Guide.

154
00:07:59,748 --> 00:08:02,297
It's just a regular
create table statement.

155
00:08:02,297 --> 00:08:05,316
There's certainly nothing
very clever in there.

156
00:08:05,316 --> 00:08:08,387
I just gave you that SQL in the handout

157
00:08:08,387 --> 00:08:10,452
because I didn't want you to waste time

158
00:08:10,452 --> 00:08:13,332
worrying about the data
types for these fields

159
00:08:13,332 --> 00:08:15,188
but it looks like I've just gone for

160
00:08:15,188 --> 00:08:17,066
varchars for each of them.

161
00:08:17,066 --> 00:08:20,874
So they're all just going
to be basic strings.

162
00:08:20,874 --> 00:08:24,016
It looks like I just need a semicolon

163
00:08:24,016 --> 00:08:25,782
on the end of that line.

164
00:08:25,782 --> 00:08:28,876
Now there are no parameters
in this statement

165
00:08:28,876 --> 00:08:32,566
so it's just a simple
case of template.update.

166
00:08:32,566 --> 00:08:35,783
But exactly as on the theory sessions

167
00:08:35,783 --> 00:08:40,620
this might throw an exception
if the table already exists.

168
00:08:40,620 --> 00:08:44,409
Now some databases will allow you to

169
00:08:44,409 --> 00:08:46,542
cater for that in the SQL.

170
00:08:46,542 --> 00:08:50,627
But I want this to be as
database independent as possible.

171
00:08:50,627 --> 00:08:53,460
So it's the BadSqlGrammarException

172
00:08:57,066 --> 00:08:58,899
and if this is thrown,

173
00:09:00,394 --> 00:09:02,388
then I'm going to swallow the exception.

174
00:09:02,388 --> 00:09:05,546
I'm going to assume the
table already exists.

175
00:09:05,546 --> 00:09:07,029
Well rather than swallowing,

176
00:09:07,029 --> 00:09:10,772
I will output to the system console

177
00:09:10,772 --> 00:09:13,418
if you're using a logging
framework like Log4j

178
00:09:13,418 --> 00:09:17,738
you'd obviously output just a info message

179
00:09:17,738 --> 00:09:20,031
to the logging system.

180
00:09:20,031 --> 00:09:22,281
So I'm going to assume here

181
00:09:23,476 --> 00:09:27,059
assuming the customer
table already exists.

182
00:09:31,348 --> 00:09:35,431
Now we also need to create
a table for the calls.

183
00:09:36,799 --> 00:09:38,933
Now you might think that,
"Oh well, we'll need to

184
00:09:38,933 --> 00:09:43,274
"create another DAO just
to handle the calls."

185
00:09:43,274 --> 00:09:46,815
But it's a bit of a decision this really.

186
00:09:46,815 --> 00:09:49,002
On some projects you will indeed find that

187
00:09:49,002 --> 00:09:52,735
there's a separate DAO
for every single type of

188
00:09:52,735 --> 00:09:56,479
object that you have or
every class that you have.

189
00:09:56,479 --> 00:09:57,940
But there's also an argument that

190
00:09:57,940 --> 00:10:00,266
if you have two or more classes in

191
00:10:00,266 --> 00:10:02,836
a very tight relationship,

192
00:10:02,836 --> 00:10:06,922
then it makes sense to combine
them into a single DAO.

193
00:10:06,922 --> 00:10:09,460
And I think in this
case, customs and calls

194
00:10:09,460 --> 00:10:13,613
are so closely related
that it makes sense to

195
00:10:13,613 --> 00:10:16,674
deal with calls in here as well.

196
00:10:16,674 --> 00:10:20,280
And actually, I don't
know if you've noticed

197
00:10:20,280 --> 00:10:23,693
there is indeed a method
in the interface I gave you

198
00:10:23,693 --> 00:10:27,610
called addCall which adds
a call to a customer.

199
00:10:28,450 --> 00:10:31,234
So I think it makes absolute sense to

200
00:10:31,234 --> 00:10:33,880
handle the call table in here as well.

201
00:10:33,880 --> 00:10:37,880
So I'm going to do that with
a second try catch block.

202
00:10:37,880 --> 00:10:40,630
I'll do catch now be the bad SQL.

203
00:10:42,329 --> 00:10:44,163
I just did a control space there

204
00:10:44,163 --> 00:10:46,663
or command space on Macintosh.

205
00:10:48,919 --> 00:10:51,002
And let's copy and paste.

206
00:10:53,902 --> 00:10:56,643
The boring log message.

207
00:10:56,643 --> 00:10:57,987
This time we're assuming that

208
00:10:57,987 --> 00:11:00,487
the call table already exists.

209
00:11:01,721 --> 00:11:04,601
And for the SQL, same thing again.

210
00:11:04,601 --> 00:11:05,934
Template.updates

211
00:11:06,905 --> 00:11:10,158
And just off camera, I've
copied and pasted that

212
00:11:10,158 --> 00:11:12,325
from the Practicals Guide.

213
00:11:13,262 --> 00:11:14,361
All good.

214
00:11:14,361 --> 00:11:17,230
So the rest of this class,

215
00:11:17,230 --> 00:11:19,710
it's really now just a
case of plodding through

216
00:11:19,710 --> 00:11:21,742
all of the method implementations.

217
00:11:21,742 --> 00:11:23,962
We'll start with create.

218
00:11:23,962 --> 00:11:27,375
The job here is to create a customer.

219
00:11:27,375 --> 00:11:31,557
So this is going to be the
template method as before.

220
00:11:31,557 --> 00:11:33,829
We'll be calling updates.

221
00:11:33,829 --> 00:11:35,823
And the SQL I'm going to need here

222
00:11:35,823 --> 00:11:39,073
will be insert into the customer table.

223
00:11:39,909 --> 00:11:43,205
And then we specify the column names.

224
00:11:43,205 --> 00:11:46,202
And I can just read those off
the creating of the table.

225
00:11:46,202 --> 00:11:48,785
We've got the customerID first.

226
00:11:50,426 --> 00:11:53,343
Second up will be the company name.

227
00:11:54,191 --> 00:11:56,790
Then the email address.

228
00:11:56,790 --> 00:11:58,832
I've just gone off screen there.

229
00:11:58,832 --> 00:12:02,415
Then we've got the
telephone and the notes.

230
00:12:04,811 --> 00:12:06,251
And the values.

231
00:12:06,251 --> 00:12:10,080
What we're using here standard
JDBC prepared statement.

232
00:12:10,080 --> 00:12:12,960
So we just supply question marks

233
00:12:12,960 --> 00:12:14,585
and we're going to need
one, two, three, four,

234
00:12:14,585 --> 00:12:16,252
five question marks.

235
00:12:18,628 --> 00:12:22,990
And that's it I think
for the SQL statement.

236
00:12:22,990 --> 00:12:25,806
But then we follow up with
just a comma separated list

237
00:12:25,806 --> 00:12:29,337
of the actual values we want to plug in.

238
00:12:29,337 --> 00:12:32,537
So for customerID it's going
to be the customer object

239
00:12:32,537 --> 00:12:34,350
that we've been sent.

240
00:12:34,350 --> 00:12:37,273
And I can call getCustomerID.

241
00:12:37,273 --> 00:12:39,988
And while this gets very routine now.

242
00:12:39,988 --> 00:12:41,155
getCompanyName

243
00:12:43,263 --> 00:12:44,096
getEmail

244
00:12:47,167 --> 00:12:48,584
get the telephone

245
00:12:50,963 --> 00:12:52,463
and get the notes.

246
00:12:54,462 --> 00:12:56,510
If you for some reason you're working on

247
00:12:56,510 --> 00:12:58,548
an older version of Spring framework

248
00:12:58,548 --> 00:13:02,686
then you would need to
bundle these parameters up

249
00:13:02,686 --> 00:13:05,936
into a single value in an object array.

250
00:13:07,305 --> 00:13:09,044
Now I realize that as I've done this

251
00:13:09,044 --> 00:13:11,582
I really should be keeping this SQL

252
00:13:11,582 --> 00:13:13,598
separate from the methods.

253
00:13:13,598 --> 00:13:16,009
So I'm just going to back up a little bit.

254
00:13:16,009 --> 00:13:17,822
And I'm going to take first of all

255
00:13:17,822 --> 00:13:20,155
the create tables SQL string

256
00:13:22,355 --> 00:13:26,761
and I'm going to make this
be a constant in the class.

257
00:13:26,761 --> 00:13:28,830
And I'll do that by right-clicking.

258
00:13:28,830 --> 00:13:30,580
I'll select Refactor.

259
00:13:31,785 --> 00:13:34,868
And I'm looking for Extract Constant.

260
00:13:36,521 --> 00:13:40,033
Now the constant name
while it's giving me a

261
00:13:40,033 --> 00:13:41,791
suggested constant name

262
00:13:41,791 --> 00:13:45,034
but it's actually just
the value of the string.

263
00:13:45,034 --> 00:13:47,451
This is the create table SQL.

264
00:13:49,129 --> 00:13:51,519
And if I click on OK,

265
00:13:51,519 --> 00:13:53,866
it's really nice refactor that.

266
00:13:53,866 --> 00:13:55,956
It puts the variable name in there.

267
00:13:55,956 --> 00:13:57,791
The constant name in there

268
00:13:57,791 --> 00:14:01,844
and then puts it in the correct
place in my attribute list.

269
00:14:01,844 --> 00:14:04,127
Now I know that we could
go further than this.

270
00:14:04,127 --> 00:14:08,362
And we could inject this
value from the Spring XML.

271
00:14:08,362 --> 00:14:11,679
As on the videos, I'm not
going not bother doing that.

272
00:14:11,679 --> 00:14:13,983
But it certainly would
be an improvement that

273
00:14:13,983 --> 00:14:16,159
you could consider.

274
00:14:16,159 --> 00:14:19,326
I'm going to now do the same thing for

275
00:14:20,255 --> 00:14:22,255
the second create table.

276
00:14:23,220 --> 00:14:26,053
This is create the call table SQL.

277
00:14:29,442 --> 00:14:31,554
I've realized that I really
should have called this

278
00:14:31,554 --> 00:14:33,506
create customer table SQL.

279
00:14:33,506 --> 00:14:35,340
That first one.

280
00:14:35,340 --> 00:14:37,673
So I'll refactor and rename.

281
00:14:42,284 --> 00:14:43,309
That's good.

282
00:14:43,309 --> 00:14:45,476
And I'll do the same thing

283
00:14:47,319 --> 00:14:48,152
here.

284
00:14:53,591 --> 00:14:55,341
Inserts customer SQL.

285
00:14:57,655 --> 00:14:59,628
So that's a little bit tidier.

286
00:14:59,628 --> 00:15:02,946
Time now for our first query method.

287
00:15:02,946 --> 00:15:06,039
Now this one is going to
be the get by ID method

288
00:15:06,039 --> 00:15:10,060
which according to the
Java docs in the interface

289
00:15:10,060 --> 00:15:11,522
I just need the customer.

290
00:15:11,522 --> 00:15:15,170
I don't need to get the
calls for that customer.

291
00:15:15,170 --> 00:15:19,003
So it's going to be a
relatively simple query.

292
00:15:22,348 --> 00:15:24,887
And again I'll put the SQL in directly

293
00:15:24,887 --> 00:15:26,434
and then extract it out.

294
00:15:26,434 --> 00:15:30,936
So this is going to be a
select all columns from

295
00:15:30,936 --> 00:15:32,567
the customer table

296
00:15:32,567 --> 00:15:36,317
where the customer ID
matches whichever value

297
00:15:37,421 --> 00:15:39,629
has been passed into the method.

298
00:15:39,629 --> 00:15:42,295
Now the Eclipse help
here, the Intellisense

299
00:15:42,295 --> 00:15:43,714
isn't particularly helpful

300
00:15:43,714 --> 00:15:47,053
because this is in fact a
heavily overloaded method.

301
00:15:47,053 --> 00:15:48,531
And the version that we're using

302
00:15:48,531 --> 00:15:50,526
is as on the videos.

303
00:15:50,526 --> 00:15:52,296
The second parameter into here

304
00:15:52,296 --> 00:15:54,451
is going to be a rowmapper.

305
00:15:54,451 --> 00:15:56,030
Remember that's a class that's capable of

306
00:15:56,030 --> 00:16:00,197
turning a result set from
JDBC into a proper object.

307
00:16:01,525 --> 00:16:03,008
We're going to have to create that class

308
00:16:03,008 --> 00:16:04,864
but I'm going to call it

309
00:16:04,864 --> 00:16:07,781
well, customer rowmapper I suppose.

310
00:16:08,789 --> 00:16:10,645
We just create the new instance of that.

311
00:16:10,645 --> 00:16:14,784
And then the final parameter
or the final set of parameters

312
00:16:14,784 --> 00:16:18,357
are just the values we want to
pass in to the question mark.

313
00:16:18,357 --> 00:16:20,112
Well there's only one of them here

314
00:16:20,112 --> 00:16:22,523
and that's the customer ID.

315
00:16:22,523 --> 00:16:23,686
Now before I go any further,

316
00:16:23,686 --> 00:16:28,379
I'm going to need to create
this customer rowmapper class.

317
00:16:28,379 --> 00:16:29,506
And as I mentioned on the videos,

318
00:16:29,506 --> 00:16:31,597
it doesn't matter where you create it.

319
00:16:31,597 --> 00:16:34,039
You could have a file new class

320
00:16:34,039 --> 00:16:36,289
but it's just my personal practice.

321
00:16:36,289 --> 00:16:39,895
I very rarely use inner classes in Java

322
00:16:39,895 --> 00:16:41,260
of any description.

323
00:16:41,260 --> 00:16:43,927
But this is one kind of case where

324
00:16:43,927 --> 00:16:45,740
I've got no problems doing so.

325
00:16:45,740 --> 00:16:48,204
So this is my customer rowmapper.

326
00:16:48,204 --> 00:16:52,371
It's going to implement the
Spring rowmapper interface

327
00:16:53,612 --> 00:16:56,076
which will need to be imported.

328
00:16:56,076 --> 00:16:57,721
There's two of them in the a...

329
00:16:57,721 --> 00:16:59,107
on my class path.

330
00:16:59,107 --> 00:17:02,148
Make sure you chose the
Spring framework version.

331
00:17:02,148 --> 00:17:04,121
And I immediately get an error

332
00:17:04,121 --> 00:17:06,915
because I need to implement
all of the methods

333
00:17:06,915 --> 00:17:08,611
in that interface.

334
00:17:08,611 --> 00:17:10,979
And I can do a left-click here

335
00:17:10,979 --> 00:17:12,835
and that will do quickfix.

336
00:17:12,835 --> 00:17:16,366
I can add the unimplemented method

337
00:17:16,366 --> 00:17:18,222
almost for free.

338
00:17:18,222 --> 00:17:20,729
I'm going to tidy this up a little bit.

339
00:17:20,729 --> 00:17:22,585
The argument names aren't very nice

340
00:17:22,585 --> 00:17:25,347
so I'm going to call the result set RS.

341
00:17:25,347 --> 00:17:26,926
And the second parameter,

342
00:17:26,926 --> 00:17:29,315
I hope I mentioned this in the videos,

343
00:17:29,315 --> 00:17:32,014
is a reference to the row number.

344
00:17:32,014 --> 00:17:34,105
So as it's going through the result set,

345
00:17:34,105 --> 00:17:37,145
it will just give us the number.

346
00:17:37,145 --> 00:17:39,417
So it will be one for the first object

347
00:17:39,417 --> 00:17:40,718
and two and three.

348
00:17:40,718 --> 00:17:42,627
Now you don't often need it,

349
00:17:42,627 --> 00:17:47,171
but I guess there are some
cases where you might need it.

350
00:17:47,171 --> 00:17:50,425
I can't think of any examples right now.

351
00:17:50,425 --> 00:17:52,259
Also another improvement is that

352
00:17:52,259 --> 00:17:56,092
since Java 5, this
rowmapper now has a generic

353
00:17:57,465 --> 00:18:00,014
which will save any future typecasts.

354
00:18:00,014 --> 00:18:02,894
So it's well worth plugging in to here

355
00:18:02,894 --> 00:18:07,248
in angle brackets the type of
object that we're expecting.

356
00:18:07,248 --> 00:18:11,331
And that will force us to
be specific right here.

357
00:18:12,240 --> 00:18:17,189
Okay and the job of a rowmapper
is almost always routine.

358
00:18:17,189 --> 00:18:18,981
I just need to extract the values.

359
00:18:18,981 --> 00:18:22,064
So I'm going to need the customer ID.

360
00:18:22,064 --> 00:18:24,944
And I do that by calling the result set,

361
00:18:24,944 --> 00:18:26,874
the getString method,

362
00:18:26,874 --> 00:18:30,817
and I think on the first
edition of the course,

363
00:18:30,817 --> 00:18:32,984
I used the number version.

364
00:18:34,187 --> 00:18:35,698
You can do that.

365
00:18:35,698 --> 00:18:39,623
One means whichever
value was returned from

366
00:18:39,623 --> 00:18:41,040
the first column.

367
00:18:42,290 --> 00:18:44,711
But what will happen is
the values will come back

368
00:18:44,711 --> 00:18:47,325
in the order in which
the table was created.

369
00:18:47,325 --> 00:18:49,117
So customID will be first,

370
00:18:49,117 --> 00:18:51,186
company name second, and so on.

371
00:18:51,186 --> 00:18:53,116
But I don't really like that.

372
00:18:53,116 --> 00:18:54,130
It's not very readable,

373
00:18:54,130 --> 00:18:56,871
so I'm going to use
the alternative version

374
00:18:56,871 --> 00:19:00,476
which is we name the column explicitly.

375
00:19:00,476 --> 00:19:02,962
So that's the customer ID.

376
00:19:02,962 --> 00:19:06,295
The next field will be the company name.

377
00:19:20,429 --> 00:19:22,929
Now I think we have the email.

378
00:19:27,886 --> 00:19:29,719
Next is the telephone.

379
00:19:39,096 --> 00:19:42,096
And then we have some kind of notes.

380
00:19:48,312 --> 00:19:51,630
And in the mappers the last line of code

381
00:19:51,630 --> 00:19:53,955
is always creating a new object

382
00:19:53,955 --> 00:19:55,928
based on the results.

383
00:19:55,928 --> 00:19:58,019
That's going to be customer ID,

384
00:19:58,019 --> 00:19:59,835
company name,

385
00:19:59,835 --> 00:20:01,254
email,

386
00:20:01,254 --> 00:20:02,087
telephone,

387
00:20:03,781 --> 00:20:04,948
and the notes.

388
00:20:06,468 --> 00:20:07,301
Great.

389
00:20:07,301 --> 00:20:08,406
It's a little bit boring doing that

390
00:20:08,406 --> 00:20:12,118
but at least we can keep
reusing this rowmapper now.

391
00:20:12,118 --> 00:20:15,553
And our method is almost compiling.

392
00:20:15,553 --> 00:20:17,228
Of course, we have a problem now

393
00:20:17,228 --> 00:20:20,395
in that if this query returns no rows,

394
00:20:22,380 --> 00:20:26,209
then we need to throw a
record not found exception.

395
00:20:26,209 --> 00:20:27,884
Actually quite easy really

396
00:20:27,884 --> 00:20:30,273
because I can use an exception again

397
00:20:30,273 --> 00:20:33,023
like I did on the theory session.

398
00:20:34,081 --> 00:20:36,684
Now query won't quite work for us

399
00:20:36,684 --> 00:20:38,679
because if this returns no rows

400
00:20:38,679 --> 00:20:41,324
then the query method will simply return

401
00:20:41,324 --> 00:20:42,491
an empty list.

402
00:20:43,884 --> 00:20:48,225
But if we use the query
for object method instead

403
00:20:48,225 --> 00:20:50,198
then that's much better

404
00:20:50,198 --> 00:20:54,700
because we're expecting that
to return exactly one row.

405
00:20:54,700 --> 00:20:58,230
And if it doesn't, we will get...

406
00:20:58,230 --> 00:21:02,397
And I have in fact forgotten
what the exception is.

407
00:21:06,945 --> 00:21:11,255
Of course, I could look back
on the video to remind myself

408
00:21:11,255 --> 00:21:14,274
but I think this is a good opportunity to

409
00:21:14,274 --> 00:21:16,524
use these Spring Java docs.

410
00:21:17,462 --> 00:21:19,894
So I've just gone to the Java docs for

411
00:21:19,894 --> 00:21:21,292
any version will do really,

412
00:21:21,292 --> 00:21:23,191
but this is, at the time of recording,

413
00:21:23,191 --> 00:21:24,705
the latest version.

414
00:21:24,705 --> 00:21:26,743
And I'm going to do a control F to

415
00:21:26,743 --> 00:21:29,076
find the JDBCTemplate class.

416
00:21:31,436 --> 00:21:32,603
Which is here.

417
00:21:34,337 --> 00:21:36,385
And I'll do another control F to

418
00:21:36,385 --> 00:21:39,218
find the query for objects method.

419
00:21:40,865 --> 00:21:43,628
And if I have a look inside there,

420
00:21:43,628 --> 00:21:46,348
here's the full details of
the query for object method.

421
00:21:46,348 --> 00:21:49,240
And it's telling me
here the throws clause.

422
00:21:49,240 --> 00:21:52,814
So it's going to throw
an incorrect result size

423
00:21:52,814 --> 00:21:56,981
data access exception which
is exactly what we want.

424
00:21:58,093 --> 00:22:01,260
So I'll copy that into my catch block.

425
00:22:05,283 --> 00:22:08,611
Now if that happens then it's an easy job

426
00:22:08,611 --> 00:22:12,778
of just throwing a new
record not found exception.

427
00:22:16,387 --> 00:22:17,966
You can almost think of this as

428
00:22:17,966 --> 00:22:20,963
I'm converting the Spring exception into

429
00:22:20,963 --> 00:22:24,024
an exception that my
client will understand.

430
00:22:24,024 --> 00:22:26,467
Whoever is calling this class.

431
00:22:26,467 --> 00:22:28,131
I'll need to import that.

432
00:22:28,131 --> 00:22:30,179
Control shift and O.

433
00:22:30,179 --> 00:22:32,824
And that's now looking good.

434
00:22:32,824 --> 00:22:35,032
Now I'll still have an error here

435
00:22:35,032 --> 00:22:38,865
because I'm not actually
returning the results

436
00:22:39,981 --> 00:22:41,064
of that call.

437
00:22:42,211 --> 00:22:44,344
I've been forgetting that throughout

438
00:22:44,344 --> 00:22:46,158
the last five or 10 minutes.

439
00:22:46,158 --> 00:22:48,590
Of course, I need to
return whichever object

440
00:22:48,590 --> 00:22:51,331
is returned from that call.

441
00:22:51,331 --> 00:22:53,101
That's all compiling clean.

442
00:22:53,101 --> 00:22:56,739
Final cleanup on this is a refactor

443
00:22:56,739 --> 00:22:59,854
and I'll extract a constant.

444
00:22:59,854 --> 00:23:04,021
And this is going to be the
select customer by ID SQL.

445
00:23:07,448 --> 00:23:09,069
So I hope you'll agree.

446
00:23:09,069 --> 00:23:12,440
A fairly straightforward and clean

447
00:23:12,440 --> 00:23:15,043
implementation of get by ID.

448
00:23:15,043 --> 00:23:17,460
We just need to carry on now.

449
00:23:21,006 --> 00:23:23,821
This is going to be, in this case,

450
00:23:23,821 --> 00:23:26,925
we are expecting a list of customers here

451
00:23:26,925 --> 00:23:31,896
so this is just going to be
the regular query method.

452
00:23:31,896 --> 00:23:34,896
The SQL, it's going to be so similar

453
00:23:36,984 --> 00:23:38,817
to what we had before.

454
00:23:41,304 --> 00:23:43,203
I'll start by copying it.

455
00:23:43,203 --> 00:23:46,703
This is going to be where the company name

456
00:23:55,240 --> 00:23:59,082
equals whatever parameters
has been passed in.

457
00:23:59,082 --> 00:24:01,961
And then again we need
to pass in an instance of

458
00:24:01,961 --> 00:24:03,878
the customer rowmapper.

459
00:24:05,257 --> 00:24:09,737
Our final parameter will be
the name that was passed in.

460
00:24:09,737 --> 00:24:12,487
And that is all we need for that.

461
00:24:13,546 --> 00:24:17,713
Now this update method is perhaps
slightly more complicated.

462
00:24:21,535 --> 00:24:24,991
I think there are several
ways you can do this.

463
00:24:24,991 --> 00:24:27,946
The way I'm going to do is by,

464
00:24:27,946 --> 00:24:31,050
of course, we'll be using the templates.

465
00:24:31,050 --> 00:24:34,004
And we'll be calling the update method.

466
00:24:34,004 --> 00:24:37,004
Now I'm going to update the customer

467
00:24:39,092 --> 00:24:43,259
and I'm going to set the
company name to be a new value.

468
00:24:47,519 --> 00:24:50,602
The email will be set to a new value.

469
00:24:52,102 --> 00:24:56,035
The telephone will be set to a new value.

470
00:24:56,035 --> 00:24:59,726
And the notes will be set to a new value.

471
00:24:59,726 --> 00:25:02,723
And it's only going to be the row where

472
00:25:02,723 --> 00:25:05,806
the customer ID equals another value.

473
00:25:08,344 --> 00:25:10,990
And of course the values
I need to pass in here

474
00:25:10,990 --> 00:25:15,470
are all present in the
customer to update object.

475
00:25:15,470 --> 00:25:19,482
So the first question
mark is the company name.

476
00:25:19,482 --> 00:25:21,482
The second question mark

477
00:25:24,360 --> 00:25:25,443
is the email.

478
00:25:30,952 --> 00:25:33,202
Then we have the telephone.

479
00:25:36,872 --> 00:25:38,122
Then the notes.

480
00:25:39,357 --> 00:25:40,357
And finally,

481
00:25:44,606 --> 00:25:46,792
the customer ID comes last

482
00:25:46,792 --> 00:25:49,998
because it's in the where clause.

483
00:25:49,998 --> 00:25:54,222
Now I didn't cover this
on the theory session

484
00:25:54,222 --> 00:25:58,563
but we need to throw a
record not found exception

485
00:25:58,563 --> 00:26:01,980
if this particular customer didn't exist.

486
00:26:03,257 --> 00:26:06,062
Well you could have done
that by doing a query.

487
00:26:06,062 --> 00:26:09,006
I suppose, we could
query for the customers

488
00:26:09,006 --> 00:26:12,611
where the customer ID
matches a particular value.

489
00:26:12,611 --> 00:26:15,865
And if we get no rows back
then we throw the exception.

490
00:26:15,865 --> 00:26:18,158
But something I didn't tell you

491
00:26:18,158 --> 00:26:21,825
is the update method
will return an integer.

492
00:26:22,916 --> 00:26:27,083
And that integer will reflect
the number of rows updated.

493
00:26:29,187 --> 00:26:31,604
I'll just realign everything.

494
00:26:33,838 --> 00:26:37,921
Now what we're expecting
back is the rows updated

495
00:26:39,598 --> 00:26:40,598
must be one.

496
00:26:42,109 --> 00:26:44,218
So if that's not the case,

497
00:26:44,218 --> 00:26:48,051
we can throw a new record
not found exception.

498
00:26:51,344 --> 00:26:53,669
But if the rows updated was one,

499
00:26:53,669 --> 00:26:56,037
then we know this update was successful

500
00:26:56,037 --> 00:26:57,537
and we can return.

501
00:26:58,682 --> 00:27:00,954
That one was a little bit awkward.

502
00:27:00,954 --> 00:27:04,871
Before I move on, it's
time to do the refactor.

503
00:27:07,547 --> 00:27:09,047
Extract constants.

504
00:27:10,853 --> 00:27:13,853
And this is the update customer SQL.

505
00:27:18,277 --> 00:27:19,909
That's good.

506
00:27:19,909 --> 00:27:21,492
Now for the delete,

507
00:27:24,176 --> 00:27:28,383
this is going to be very
similar to the update really.

508
00:27:28,383 --> 00:27:29,633
The SQL will be

509
00:27:31,416 --> 00:27:33,083
delete from customer

510
00:27:34,414 --> 00:27:36,164
where the customer ID

511
00:27:38,497 --> 00:27:39,330
matches

512
00:27:43,587 --> 00:27:46,155
whatever was passed in.

513
00:27:46,155 --> 00:27:48,555
We get the customer ID from there.

514
00:27:48,555 --> 00:27:50,198
We can do the same thing again.

515
00:27:50,198 --> 00:27:53,781
We can find out the
number of rows affected

516
00:27:55,073 --> 00:27:57,073
and if the rows affected

517
00:27:59,147 --> 00:28:00,064
was not one

518
00:28:02,065 --> 00:28:03,815
then we'll do a throw

519
00:28:08,020 --> 00:28:10,974
of our record not found exception.

520
00:28:10,974 --> 00:28:14,751
Now get all customer should
be very straightforward indeed

521
00:28:14,751 --> 00:28:17,236
because remember that we don't need to

522
00:28:17,236 --> 00:28:19,069
include calls in this.

523
00:28:19,999 --> 00:28:23,332
So I can just return the template.query.

524
00:28:25,364 --> 00:28:29,940
And I believe we already have
the SQL we need for this.

525
00:28:29,940 --> 00:28:32,638
If we don't, we're going to need

526
00:28:32,638 --> 00:28:36,055
just to select all columns from customer.

527
00:28:40,553 --> 00:28:42,803
And we'll need a rowmapper.

528
00:28:49,332 --> 00:28:50,582
Just like that.

529
00:28:53,460 --> 00:28:55,543
And I'll want to extract.

530
00:28:59,892 --> 00:29:01,975
Select all customers SQL.

531
00:29:05,214 --> 00:29:08,575
Now we have the difficult method.

532
00:29:08,575 --> 00:29:11,433
I think this is hardest one in the DAO.

533
00:29:11,433 --> 00:29:14,590
This is the get full customer detail

534
00:29:14,590 --> 00:29:19,049
which means we also have to get
the calls for this customer.

535
00:29:19,049 --> 00:29:22,089
So the first step, I
think, is going to be easy.

536
00:29:22,089 --> 00:29:23,561
We can do a find.

537
00:29:23,561 --> 00:29:27,728
We want to get the customer
based on this customer ID.

538
00:29:28,799 --> 00:29:30,686
Well there's an easy way of doing that.

539
00:29:30,686 --> 00:29:32,073
We don't need to use the template

540
00:29:32,073 --> 00:29:33,940
because we already have a method here

541
00:29:33,940 --> 00:29:35,357
called get by ID.

542
00:29:36,212 --> 00:29:37,962
So we can reuse that.

543
00:29:38,814 --> 00:29:42,249
So that will give us the customer.

544
00:29:42,249 --> 00:29:45,172
I'll need to get that variable a name.

545
00:29:45,172 --> 00:29:46,010
And once we've done that,

546
00:29:46,010 --> 00:29:49,583
we need to find the
calls for this customer.

547
00:29:49,583 --> 00:29:53,018
Now I don't know how you
would have done this.

548
00:29:53,018 --> 00:29:55,290
You could possibly have done some kind of

549
00:29:55,290 --> 00:29:58,790
a join across the customer and call table.

550
00:30:00,239 --> 00:30:04,207
But I'm going to do this using
a separate select statement.

551
00:30:04,207 --> 00:30:08,040
We're going to get here
a collection of calls.

552
00:30:10,458 --> 00:30:14,125
And this will be all
calls for the customer.

553
00:30:15,567 --> 00:30:19,162
And it will be a template query again.

554
00:30:19,162 --> 00:30:20,932
The SQL here I think is going to be

555
00:30:20,932 --> 00:30:23,738
something like select from

556
00:30:23,738 --> 00:30:26,488
and the table is called tbl_call.

557
00:30:28,517 --> 00:30:29,350
Where

558
00:30:30,820 --> 00:30:34,746
and I should say select staff all columns.

559
00:30:34,746 --> 00:30:35,579
Where

560
00:30:36,580 --> 00:30:40,747
and the call table has a foreign
key in it called customerID

561
00:30:44,079 --> 00:30:46,996
and I'll need a parameter for that.

562
00:30:48,346 --> 00:30:52,513
Now I'm also going to need at
this parameter on a new line.

563
00:30:54,159 --> 00:30:57,992
I'm going to need a
mapper for the call table.

564
00:30:59,034 --> 00:31:02,784
So I'm going to call
this the call rowmapper.

565
00:31:05,274 --> 00:31:08,623
And finally the parameter
going in here is of course

566
00:31:08,623 --> 00:31:10,290
just the customerID.

567
00:31:11,567 --> 00:31:15,610
And I'll deal with the
error there in a moment.

568
00:31:15,610 --> 00:31:20,179
I will do a control shift
O to import the collection.

569
00:31:20,179 --> 00:31:21,787
Now that's going to give me a list of

570
00:31:21,787 --> 00:31:24,507
in fact, this is going
to return a list of calls

571
00:31:24,507 --> 00:31:26,150
not a collection of calls.

572
00:31:26,150 --> 00:31:30,129
I think it's important
that I be specific there.

573
00:31:30,129 --> 00:31:33,404
Now all I need to do at the end of this

574
00:31:33,404 --> 00:31:35,579
is call on the customer method.

575
00:31:35,579 --> 00:31:38,329
There is a method called setCalls

576
00:31:39,579 --> 00:31:41,137
that I can pass in

577
00:31:41,137 --> 00:31:43,895
all the calls for that customer.

578
00:31:43,895 --> 00:31:47,145
Then finally I can return the customer.

579
00:31:49,912 --> 00:31:52,419
As I say, there were--

580
00:31:52,419 --> 00:31:53,933
if I can spell customer correctly.

581
00:31:53,933 --> 00:31:56,717
As I say, there were
several different ways

582
00:31:56,717 --> 00:31:58,275
you could do this method

583
00:31:58,275 --> 00:32:01,549
but I think that's the easiest to

584
00:32:01,549 --> 00:32:05,059
have effectively two
separate select statements.

585
00:32:05,059 --> 00:32:08,459
Now I need to implement
this call rowmapper.

586
00:32:08,459 --> 00:32:10,432
And I'm going to once again do this by

587
00:32:10,432 --> 00:32:13,765
adding another class at the bottom here.

588
00:32:14,870 --> 00:32:18,287
But the details are going to be identical

589
00:32:20,259 --> 00:32:23,128
pretty much to the customer rowmapper.

590
00:32:23,128 --> 00:32:26,125
So I'm just going to type this in

591
00:32:26,125 --> 00:32:28,958
with relatively little commentary.

592
00:32:30,167 --> 00:32:33,917
Just make these parameter
names a bit better.

593
00:32:36,306 --> 00:32:39,191
And this time around, bit easier this one.

594
00:32:39,191 --> 00:32:41,274
We've just got the notes.

595
00:32:46,943 --> 00:32:48,943
We have a date and time.

596
00:32:49,961 --> 00:32:52,030
Now this might be a
little more complicated.

597
00:32:52,030 --> 00:32:54,613
This is going to return a date.

598
00:33:03,807 --> 00:33:05,974
Sorry, it's time and date.

599
00:33:08,756 --> 00:33:11,732
Now I need to do an import here.

600
00:33:11,732 --> 00:33:12,732
Now I think,

601
00:33:15,028 --> 00:33:18,251
I think I'm okay to use Java.util.Date

602
00:33:18,251 --> 00:33:21,251
I think this returns a Java.sql.Date

603
00:33:22,176 --> 00:33:25,515
but because one is a
superclass of the other

604
00:33:25,515 --> 00:33:28,373
it's okay to use them interchangeably.

605
00:33:28,373 --> 00:33:31,253
Now there's also a
customer ID in the table

606
00:33:31,253 --> 00:33:32,918
but that's a foreign key

607
00:33:32,918 --> 00:33:35,798
and our Java class doesn't
have a reference to

608
00:33:35,798 --> 00:33:38,166
the owning customer.

609
00:33:38,166 --> 00:33:40,491
So I don't think we need that.

610
00:33:40,491 --> 00:33:42,742
We just need to return a new call

611
00:33:42,742 --> 00:33:45,992
passing in notes and the date and time.

612
00:33:49,227 --> 00:33:52,502
Okay, I don't think that was too bad.

613
00:33:52,502 --> 00:33:55,659
So we've only got one method
remaining now in our DAO

614
00:33:55,659 --> 00:33:58,326
and this is the add call method.

615
00:34:00,533 --> 00:34:03,413
And this is going to be another insert

616
00:34:03,413 --> 00:34:06,413
so we are going to use the templates

617
00:34:07,797 --> 00:34:10,891
to update and the SQL
will be something like

618
00:34:10,891 --> 00:34:12,641
insert into tbl_call.

619
00:34:14,795 --> 00:34:18,805
By the way, the reason I've used tbl_call

620
00:34:18,805 --> 00:34:23,382
is that call is a reserved
word on the database.

621
00:34:23,382 --> 00:34:26,859
I think that's used for
calling stored procedures.

622
00:34:26,859 --> 00:34:30,976
So we need to mangle the
table name a little bit.

623
00:34:30,976 --> 00:34:33,805
And the column names are

624
00:34:33,805 --> 00:34:34,638
the notes,

625
00:34:35,834 --> 00:34:37,786
the time and date,

626
00:34:37,786 --> 00:34:39,369
and the customerID.

627
00:34:41,946 --> 00:34:43,446
The values will be

628
00:34:46,192 --> 00:34:48,025
three questions marks.

629
00:34:50,490 --> 00:34:54,657
And then as usual we just
specify the three parameters

630
00:34:55,578 --> 00:34:58,544
which will be from the new call.

631
00:34:58,544 --> 00:35:00,794
We've got get notes method,

632
00:35:02,535 --> 00:35:05,952
and we've also got the get time and date,

633
00:35:07,393 --> 00:35:10,390
and finally we have to
specify the customerID

634
00:35:10,390 --> 00:35:14,028
which in fact was passed in
by the client, helpfully.

635
00:35:14,028 --> 00:35:15,195
And that's it.

636
00:35:17,377 --> 00:35:19,794
I'll need to extract the SQL.

637
00:35:23,809 --> 00:35:26,559
This will be the insert call SQL.

638
00:35:28,427 --> 00:35:31,937
Okay so I think we are now there.

639
00:35:31,937 --> 00:35:36,486
We've got every single method
implemented in the DAO.

640
00:35:36,486 --> 00:35:37,319
I'm certainly going to need

641
00:35:37,319 --> 00:35:39,761
a good extensive integration test to

642
00:35:39,761 --> 00:35:42,033
make sure all of these work.

643
00:35:42,033 --> 00:35:43,612
We'll be talking about integration tests

644
00:35:43,612 --> 00:35:46,353
in a much later chapter.

645
00:35:46,353 --> 00:35:48,283
But I don't work from a script

646
00:35:48,283 --> 00:35:49,841
when I'm doing these walkthroughs

647
00:35:49,841 --> 00:35:53,510
so there may well be
some errors in the SQL

648
00:35:53,510 --> 00:35:55,803
and we'll basically just find out

649
00:35:55,803 --> 00:35:58,303
when we get to our first test.

650
00:35:59,579 --> 00:36:01,456
Now if you're working
through this with me,

651
00:36:01,456 --> 00:36:03,792
you might want to take
a break at this stage.

652
00:36:03,792 --> 00:36:05,978
That was quite a lot of work.

653
00:36:05,978 --> 00:36:07,196
But we do at least have now

654
00:36:07,196 --> 00:36:12,007
a production standard
implementation of our DAO.

655
00:36:12,007 --> 00:36:14,236
Now we're working our way up through

656
00:36:14,236 --> 00:36:17,255
the tiers of our application really.

657
00:36:17,255 --> 00:36:20,005
We also now have a service class.

658
00:36:21,010 --> 00:36:23,729
We have the customer management service

659
00:36:23,729 --> 00:36:25,916
that we need to implement.

660
00:36:25,916 --> 00:36:27,833
So a new class for that

661
00:36:28,743 --> 00:36:30,010
and I'm going to call this

662
00:36:30,010 --> 00:36:32,677
the customer management service.

663
00:36:34,251 --> 00:36:35,751
I'm going to be explicit.

664
00:36:35,751 --> 00:36:38,727
I'll call it production import.

665
00:36:38,727 --> 00:36:42,227
The interface will be the customer service

666
00:36:44,465 --> 00:36:47,463
or rather customer management service.

667
00:36:47,463 --> 00:36:50,983
And because we're working up
in a training course here,

668
00:36:50,983 --> 00:36:54,471
most of the implementations,
if not all of them,

669
00:36:54,471 --> 00:36:58,375
are going to be very simple
pass throughs to the DAO.

670
00:36:58,375 --> 00:37:00,764
But remember on a real project,

671
00:37:00,764 --> 00:37:02,652
you're almost certain to end it with

672
00:37:02,652 --> 00:37:06,485
some kind of logic
appearing on these methods.

673
00:37:07,548 --> 00:37:09,596
But most of them are
going to be delegating to

674
00:37:09,596 --> 00:37:10,596
our new DAO.

675
00:37:11,591 --> 00:37:13,924
So this is our customer DAO.

676
00:37:15,346 --> 00:37:17,319
And I'll just call it DAO.

677
00:37:17,319 --> 00:37:21,816
And I hope you're getting
the flavor of this by now.

678
00:37:21,816 --> 00:37:24,566
We're going to need a constructor

679
00:37:26,370 --> 00:37:28,120
so that we can inject

680
00:37:29,658 --> 00:37:31,575
an instance of that DAO

681
00:37:33,605 --> 00:37:35,045
into the constructor.

682
00:37:35,045 --> 00:37:38,784
If you prefer setter
injection that's fine.

683
00:37:38,784 --> 00:37:41,568
I'll need to import our customer DAO.

684
00:37:41,568 --> 00:37:43,360
But that's all clean.

685
00:37:43,360 --> 00:37:46,027
Now then, the job is to
implement the methods

686
00:37:46,027 --> 00:37:48,416
and this is going to be very boring.

687
00:37:48,416 --> 00:37:52,320
For the new customer
method, we can call the DAOs

688
00:37:52,320 --> 00:37:53,153
create

689
00:37:57,014 --> 00:37:58,181
and that's it.

690
00:37:59,073 --> 00:38:01,142
For the update customer method,

691
00:38:01,142 --> 00:38:02,816
I think we might have a problem here.

692
00:38:02,816 --> 00:38:04,754
And I think it kind of hints about this

693
00:38:04,754 --> 00:38:06,421
in the requirements.

694
00:38:07,794 --> 00:38:09,294
If I call my DAO's

695
00:38:11,396 --> 00:38:13,326
update method,

696
00:38:13,326 --> 00:38:15,321
I'm passing this changed customer.

697
00:38:15,321 --> 00:38:16,263
I think we'll have...

698
00:38:16,263 --> 00:38:17,789
Compile error there.

699
00:38:17,789 --> 00:38:22,547
Because that might throw a
record not found exception.

700
00:38:22,547 --> 00:38:24,964
So I'll need to try for that.

701
00:38:31,699 --> 00:38:32,532
What I'm going to do is

702
00:38:32,532 --> 00:38:36,699
I'm going to throw a new
customer not found exception.

703
00:38:38,736 --> 00:38:39,820
I don't know if you noticed

704
00:38:39,820 --> 00:38:44,556
but that's one of the exceptions
that's already available.

705
00:38:44,556 --> 00:38:48,723
It's already in the service
package for customers.

706
00:38:51,318 --> 00:38:53,010
It's a bit of a debatable point this.

707
00:38:53,010 --> 00:38:57,087
I like to have very
database specific exceptions

708
00:38:57,087 --> 00:38:59,273
coming from the DAO.

709
00:38:59,273 --> 00:39:02,097
Then I like to re-throw them

710
00:39:02,097 --> 00:39:05,327
as more specific, more
meaningful exceptions.

711
00:39:05,327 --> 00:39:07,578
Probably going a little
bit over the top really.

712
00:39:07,578 --> 00:39:08,725
If we'd have thrown back

713
00:39:08,725 --> 00:39:12,403
the record not found
exception back to the caller,

714
00:39:12,403 --> 00:39:15,451
I think that would have been
absolutely fine as well.

715
00:39:15,451 --> 00:39:18,578
But we'll need to import that exception.

716
00:39:18,578 --> 00:39:20,338
Now I have a problem here

717
00:39:20,338 --> 00:39:23,421
that the customer not found exception

718
00:39:24,445 --> 00:39:28,466
isn't on the throws clause of the method

719
00:39:28,466 --> 00:39:29,789
which of course I need.

720
00:39:29,789 --> 00:39:31,539
That's standard Java.

721
00:39:33,063 --> 00:39:35,944
But I'm going to see another error now.

722
00:39:35,944 --> 00:39:38,055
The whole method is now an error,

723
00:39:38,055 --> 00:39:41,352
and that's because we
haven't declared the throws

724
00:39:41,352 --> 00:39:43,186
on the interface.

725
00:39:43,186 --> 00:39:44,679
So that's entirely my fault

726
00:39:44,679 --> 00:39:45,906
when I wrote the interface,

727
00:39:45,906 --> 00:39:48,157
and it's kind of too late to go back

728
00:39:48,157 --> 00:39:50,504
because we've used it on previous videos.

729
00:39:50,504 --> 00:39:53,010
So all we need to do is

730
00:39:53,010 --> 00:39:54,962
if I use the quickfix on here,

731
00:39:54,962 --> 00:39:57,887
just clicking on the error there.

732
00:39:57,887 --> 00:40:02,054
Second option is to add the
exceptions to the interface.

733
00:40:03,724 --> 00:40:07,393
And now it's appearing on the interface.

734
00:40:07,393 --> 00:40:09,281
So it was a very simple change

735
00:40:09,281 --> 00:40:11,031
to put that in place.

736
00:40:12,043 --> 00:40:14,770
And I think if I go down to
the delete customer method,

737
00:40:14,770 --> 00:40:18,938
I reckon we're going to have
exactly the same problem there.

738
00:40:18,938 --> 00:40:22,271
We'll call the delete method on the DAO.

739
00:40:24,139 --> 00:40:26,389
Once again that might throw

740
00:40:30,315 --> 00:40:32,898
the record not found exception.

741
00:40:33,917 --> 00:40:35,745
In which case, we'll do
the same thing again.

742
00:40:35,745 --> 00:40:39,162
Throw a new customer not found exception.

743
00:40:40,673 --> 00:40:44,086
Again, I'll need to add that
to the method signature.

744
00:40:44,086 --> 00:40:46,901
I think I could probably
do that with a quickfix.

745
00:40:46,901 --> 00:40:49,014
Add throws declaration.

746
00:40:49,014 --> 00:40:50,357
That's good.

747
00:40:50,357 --> 00:40:52,640
And one further quickfix

748
00:40:52,640 --> 00:40:55,057
to add that to the interface.

749
00:40:56,768 --> 00:40:58,902
Okay, that was a little bit laborious

750
00:40:58,902 --> 00:41:01,462
but we've gotten there in the end.

751
00:41:01,462 --> 00:41:03,795
Now for find customer by ID,

752
00:41:05,472 --> 00:41:07,499
I think this one is
going to be quite easy.

753
00:41:07,499 --> 00:41:11,723
We've got the get by ID method on the DAO.

754
00:41:11,723 --> 00:41:13,723
Passing the customer ID.

755
00:41:16,291 --> 00:41:18,562
And on the arrow we have here.

756
00:41:18,562 --> 00:41:20,493
It's just the same again.

757
00:41:20,493 --> 00:41:21,826
This might throw

758
00:41:25,475 --> 00:41:27,892
a record not found exception.

759
00:41:30,013 --> 00:41:33,430
In which case, I just need to re-throw it

760
00:41:34,493 --> 00:41:37,660
as a new customer not found exception.

761
00:41:39,442 --> 00:41:42,109
And this error is because...

762
00:41:42,109 --> 00:41:44,178
Oh, I've just forgotten

763
00:41:44,178 --> 00:41:47,591
to return the results of that call.

764
00:41:47,591 --> 00:41:48,722
That's good.

765
00:41:48,722 --> 00:41:51,139
We must be getting close now.

766
00:41:53,576 --> 00:41:57,743
This time we'll return the
DAO get by name method.

767
00:41:59,907 --> 00:42:02,041
Not forgetting the return.

768
00:42:02,041 --> 00:42:03,541
That one was easy.

769
00:42:04,718 --> 00:42:08,014
I think get all customers
will be similarly easy.

770
00:42:08,014 --> 00:42:09,514
We'll be returning

771
00:42:10,873 --> 00:42:12,373
get all customers.

772
00:42:13,326 --> 00:42:14,326
That's good.

773
00:42:15,498 --> 00:42:16,331
And

774
00:42:23,423 --> 00:42:25,840
for get full customer detail,

775
00:42:28,371 --> 00:42:30,718
we have a method for that in the DAO.

776
00:42:30,718 --> 00:42:32,553
So that's easy work.

777
00:42:32,553 --> 00:42:34,636
And finally, record call.

778
00:42:41,331 --> 00:42:43,816
It's called at call in the DAO

779
00:42:43,816 --> 00:42:47,983
and interestingly the parameters
are the other way around.

780
00:42:50,421 --> 00:42:52,050
But that's okay.

781
00:42:52,050 --> 00:42:55,550
And again, we're going to need to try this

782
00:43:00,366 --> 00:43:04,943
and if there is a record
not found exception,

783
00:43:04,943 --> 00:43:06,276
we will re-throw

784
00:43:07,559 --> 00:43:10,943
as customer not found exception.

785
00:43:10,943 --> 00:43:12,311
Now...

786
00:43:12,311 --> 00:43:15,049
Oh, I have an error up here.

787
00:43:15,049 --> 00:43:17,966
It's the same thing again up there.

788
00:43:19,465 --> 00:43:22,132
I need to handle the possibility

789
00:43:24,243 --> 00:43:27,679
that there may be a record not found.

790
00:43:27,679 --> 00:43:30,096
In which case, I'll re-throw.

791
00:43:33,396 --> 00:43:37,481
Now I must be honest, that
was really quite tedious work

792
00:43:37,481 --> 00:43:40,435
and there's nothing of
interest in this class.

793
00:43:40,435 --> 00:43:43,614
Everything is just a
straight forward pass through

794
00:43:43,614 --> 00:43:44,531
to the DAO.

795
00:43:45,396 --> 00:43:47,327
And I'll say this several
times on the course

796
00:43:47,327 --> 00:43:49,183
until you're sick of hearing it.

797
00:43:49,183 --> 00:43:51,252
But I still think it's worthwhile to

798
00:43:51,252 --> 00:43:53,012
have this service class in place.

799
00:43:53,012 --> 00:43:54,431
Because before long,

800
00:43:54,431 --> 00:43:58,026
we will need some kind of logic in here.

801
00:43:58,026 --> 00:44:02,291
Examples of the type of
logic you might have would be

802
00:44:02,291 --> 00:44:05,343
this get full customer
detail for instance.

803
00:44:05,343 --> 00:44:07,594
We're lucky that we
have a method in the DAO

804
00:44:07,594 --> 00:44:09,055
that can do that for us.

805
00:44:09,055 --> 00:44:11,725
But if the DAOs were more basic,

806
00:44:11,725 --> 00:44:15,443
we might have a DAO for
customers, a DAO for calls.

807
00:44:15,443 --> 00:44:18,675
But in order to connect
the two things together,

808
00:44:18,675 --> 00:44:21,533
we might need to make
two calls to each DAO.

809
00:44:21,533 --> 00:44:23,567
And then run some kind of business logic

810
00:44:23,567 --> 00:44:26,148
to connect them together.

811
00:44:26,148 --> 00:44:27,097
I don't know.

812
00:44:27,097 --> 00:44:29,583
That's not really going
to happen on this course.

813
00:44:29,583 --> 00:44:32,975
There is an argument that
if the service class is

814
00:44:32,975 --> 00:44:37,359
doing kind of nothing then
there's no point having it.

815
00:44:37,359 --> 00:44:41,145
And you may as well let the
clients call the DAOs directly.

816
00:44:41,145 --> 00:44:44,793
That's a decision for your architecture.

817
00:44:44,793 --> 00:44:47,417
So that's the customer
management service implemented.

818
00:44:47,417 --> 00:44:48,687
It was quite tedious.

819
00:44:48,687 --> 00:44:51,225
Now I'm afraid we do have
another service to implement

820
00:44:51,225 --> 00:44:54,404
which is the diary management service.

821
00:44:54,404 --> 00:44:56,676
Well there's only two methods in there,

822
00:44:56,676 --> 00:44:58,554
and remember, we've already got

823
00:44:58,554 --> 00:45:02,319
an action DAO implementation set up.

824
00:45:02,319 --> 00:45:05,152
So this one shouldn't be too hard.

825
00:45:06,532 --> 00:45:08,865
So we'll create a new class.

826
00:45:09,749 --> 00:45:12,727
This is going to be the diary management

827
00:45:12,727 --> 00:45:15,560
service production implementation.

828
00:45:16,535 --> 00:45:19,575
It's going to implement the interface of

829
00:45:19,575 --> 00:45:22,412
diary management service.

830
00:45:22,412 --> 00:45:24,780
And I'll assume that

831
00:45:24,780 --> 00:45:27,468
if you've worked through customer by now,

832
00:45:27,468 --> 00:45:30,465
the details of this
are now fairly routine.

833
00:45:30,465 --> 00:45:32,183
So I'll go a bit quicker.

834
00:45:32,183 --> 00:45:34,529
We need an action DAO in here

835
00:45:34,529 --> 00:45:38,696
which we're going to pass
in through the constructor

836
00:45:45,975 --> 00:45:48,058
for dependency injection.

837
00:45:51,063 --> 00:45:53,708
I just put the imports in place there.

838
00:45:53,708 --> 00:45:54,593
Two methods.

839
00:45:54,593 --> 00:45:57,164
First of all we need to record an action.

840
00:45:57,164 --> 00:46:01,081
So on the DAO, there is
a method called create.

841
00:46:02,327 --> 00:46:03,788
That was easy.

842
00:46:03,788 --> 00:46:07,538
And we need to get all
the incomplete actions

843
00:46:08,793 --> 00:46:12,006
which I'm hoping while
I gave you this DAO...

844
00:46:12,006 --> 00:46:12,839
Good.

845
00:46:12,839 --> 00:46:15,901
There's a method in there
that will do that for us.

846
00:46:15,901 --> 00:46:18,354
We just need to pass in required user.

847
00:46:18,354 --> 00:46:22,194
So that service at least
was very easy to implement.

848
00:46:22,194 --> 00:46:25,021
Now remember, there is a third service

849
00:46:25,021 --> 00:46:28,157
and that's the call handling service

850
00:46:28,157 --> 00:46:30,210
from a previous chapter.

851
00:46:30,210 --> 00:46:32,158
But no problem here

852
00:46:32,158 --> 00:46:36,245
because this one doesn't
call the database directly.

853
00:46:36,245 --> 00:46:38,250
This one calls the customer service

854
00:46:38,250 --> 00:46:41,583
and the diary service in separate steps.

855
00:46:42,560 --> 00:46:45,674
So we've reached a good point now.

856
00:46:45,674 --> 00:46:48,629
We have our service class implemented.

857
00:46:48,629 --> 00:46:51,221
We have our DAO implemented.

858
00:46:51,221 --> 00:46:54,638
All that remains now is to do the wiring.

859
00:46:55,594 --> 00:46:58,282
So we'll bring up the XML file.

860
00:46:58,282 --> 00:47:00,928
And at the moment we've
got very basic wiring.

861
00:47:00,928 --> 00:47:05,095
All our two service classes
are currently the marks.

862
00:47:07,626 --> 00:47:10,111
So I'm going to work
through this backwards.

863
00:47:10,111 --> 00:47:14,278
I'll add in a comment here to
say these are my service bins.

864
00:47:15,146 --> 00:47:19,029
And I suppose the first
job is to change the class.

865
00:47:19,029 --> 00:47:20,789
We're looking for customer management.

866
00:47:20,789 --> 00:47:22,997
I just used control and space there

867
00:47:22,997 --> 00:47:26,497
and it will be command and space on a Mac.

868
00:47:27,552 --> 00:47:29,568
The Intellisense in the
plug-in is giving me

869
00:47:29,568 --> 00:47:31,705
all of the matches for that class name

870
00:47:31,705 --> 00:47:36,693
so I need to plug in the
production implementation

871
00:47:36,693 --> 00:47:41,066
and similarly for the
diary management service,

872
00:47:41,066 --> 00:47:45,152
I need to plug in the
production implementation there.

873
00:47:45,152 --> 00:47:48,075
Now I'm going to get errors immediately

874
00:47:48,075 --> 00:47:52,725
because each of these
services has a dependency.

875
00:47:52,725 --> 00:47:55,231
Which of course the DAO.

876
00:47:55,231 --> 00:47:58,481
So I need to open up both of these tags

877
00:48:02,869 --> 00:48:05,429
with a closing bin tag.

878
00:48:05,429 --> 00:48:07,978
And if you were using setter injection,

879
00:48:07,978 --> 00:48:10,497
you would use the property tag here.

880
00:48:10,497 --> 00:48:14,358
But for me it's the constructor-arg tag.

881
00:48:14,358 --> 00:48:18,525
And I'm going to refer to
my new customer DAO object.

882
00:48:19,744 --> 00:48:22,134
Well I haven't created that yet.

883
00:48:22,134 --> 00:48:24,051
So I will get an error.

884
00:48:24,896 --> 00:48:27,425
Well it's not actually an error.

885
00:48:27,425 --> 00:48:29,099
It seems to be a warning

886
00:48:29,099 --> 00:48:30,262
which is strange

887
00:48:30,262 --> 00:48:32,726
because that's definitely an error.

888
00:48:32,726 --> 00:48:33,910
Never mind.

889
00:48:33,910 --> 00:48:36,660
I need to do the same thing here.

890
00:48:38,405 --> 00:48:39,793
And that's going to go in

891
00:48:39,793 --> 00:48:42,555
similarly as a constructor argument

892
00:48:42,555 --> 00:48:44,731
and this bin is going to be called

893
00:48:44,731 --> 00:48:45,981
the action DAO.

894
00:48:49,953 --> 00:48:50,786
Okay.

895
00:48:51,670 --> 00:48:54,337
Now I need to create these DAOs,

896
00:48:56,406 --> 00:48:58,144
and I don't know why I do this.

897
00:48:58,144 --> 00:49:01,811
I tend to work in this
direction in the XML.

898
00:49:02,984 --> 00:49:05,849
Kind of the lower level
objects at the top.

899
00:49:05,849 --> 00:49:08,248
And confusingly when we look at the graph

900
00:49:08,248 --> 00:49:10,164
it's in the reverse direction.

901
00:49:10,164 --> 00:49:12,767
So I hope that's not too confusing for you

902
00:49:12,767 --> 00:49:15,120
but I need to remain consistent with

903
00:49:15,120 --> 00:49:16,954
the book system that I did earlier.

904
00:49:16,954 --> 00:49:19,653
And probably the first
version of this course.

905
00:49:19,653 --> 00:49:22,251
So here I'm instantiating
or asking Spring to

906
00:49:22,251 --> 00:49:25,361
instantiate the customer DAO

907
00:49:25,361 --> 00:49:27,004
and the class from which this comes

908
00:49:27,004 --> 00:49:29,671
is the virtual pair programmers.

909
00:49:31,345 --> 00:49:34,178
The package is called data access.

910
00:49:38,524 --> 00:49:42,002
I've forgotten the class name now.

911
00:49:42,002 --> 00:49:46,002
Data access and then it's
the customer DAO JDBC.

912
00:49:47,996 --> 00:49:49,458
Well I've used a long name there

913
00:49:49,458 --> 00:49:51,708
but if I use control space,

914
00:49:52,988 --> 00:49:55,943
I can select it from the Intellisense.

915
00:49:55,943 --> 00:49:57,724
Again we'll have an error

916
00:49:57,724 --> 00:50:01,159
and that's because there's
a dependency in this class.

917
00:50:01,159 --> 00:50:03,367
And that dependency
again is being passed in

918
00:50:03,367 --> 00:50:04,946
through the constructor

919
00:50:04,946 --> 00:50:08,615
and that's going to be the JDBCTemplates.

920
00:50:08,615 --> 00:50:11,431
Which we'll need to create in a moment.

921
00:50:11,431 --> 00:50:15,598
And I will need to do the
same thing for the action DAO.

922
00:50:28,306 --> 00:50:29,223
Looks good.

923
00:50:32,765 --> 00:50:34,515
And it will similarly

924
00:50:36,153 --> 00:50:38,260
be given the template as a parameter.

925
00:50:38,260 --> 00:50:42,324
I didn't emphasize this
in the previous chapters

926
00:50:42,324 --> 00:50:46,879
but you can use the same
templates in different DAOs

927
00:50:46,879 --> 00:50:48,362
and that's completely safe.

928
00:50:48,362 --> 00:50:52,522
It's part of the design
of the JDBCTemplate.

929
00:50:52,522 --> 00:50:55,855
So the next job is to create a template.

930
00:50:59,370 --> 00:51:01,834
This one should be easy.

931
00:51:01,834 --> 00:51:05,941
I've given it the ID of
template and the class.

932
00:51:05,941 --> 00:51:07,988
Well it's not that easy

933
00:51:07,988 --> 00:51:11,839
but we used the Java docs
earlier for JDBCTemplate

934
00:51:11,839 --> 00:51:15,589
so I can take the the
package name from there

935
00:51:18,377 --> 00:51:21,710
and I can type in JDBCTemplate directly.

936
00:51:25,508 --> 00:51:29,425
Now remember the template
has a single property

937
00:51:30,494 --> 00:51:33,327
and that's called the data source.

938
00:51:35,237 --> 00:51:36,574
And that's going to refer to

939
00:51:36,574 --> 00:51:38,812
a bin that we're going to create.

940
00:51:38,812 --> 00:51:40,422
I can call it anything I want

941
00:51:40,422 --> 00:51:44,251
but I'm going to go for data source again.

942
00:51:44,251 --> 00:51:45,531
Now I have a warning there

943
00:51:45,531 --> 00:51:47,963
and that's just because
this data source bin

944
00:51:47,963 --> 00:51:50,385
hasn't yet been created.

945
00:51:50,385 --> 00:51:52,468
So this is the final job.

946
00:51:55,185 --> 00:51:58,715
It's hard for me to tell when
I'm recording these sessions

947
00:51:58,715 --> 00:52:01,361
what you're reaction is
as you're watching it

948
00:52:01,361 --> 00:52:06,171
I'm imagining a lot of very
bored people right now.

949
00:52:06,171 --> 00:52:08,913
If you are bored, yeah,
it is a little bit tedious

950
00:52:08,913 --> 00:52:11,814
building this structure of
bins for the first time.

951
00:52:11,814 --> 00:52:14,459
But remember that creating this template

952
00:52:14,459 --> 00:52:17,016
and indeed the data
source is a one shot job

953
00:52:17,016 --> 00:52:19,511
for your entire project.

954
00:52:19,511 --> 00:52:21,037
So it's a bit tedious here

955
00:52:21,037 --> 00:52:24,364
but we're going to continually
reuse this definition.

956
00:52:24,364 --> 00:52:27,383
So it's not as bad as it might feel.

957
00:52:27,383 --> 00:52:32,098
So I've called this bin
data source and the class--

958
00:52:32,098 --> 00:52:33,651
Well I could use that simple one

959
00:52:33,651 --> 00:52:37,818
but I'm going straight for the
DBCP that we used previously.

960
00:52:39,890 --> 00:52:43,581
I'm here on the Java docs
for basic data source.

961
00:52:43,581 --> 00:52:44,701
I had to Google that

962
00:52:44,701 --> 00:52:48,413
but it's on the commons.apache.org site.

963
00:52:48,413 --> 00:52:50,941
There's the package name

964
00:52:50,941 --> 00:52:54,524
and the class we want
is basic data source.

965
00:52:58,376 --> 00:52:59,793
Okay then we have

966
00:53:03,112 --> 00:53:05,181
a few properties to set up.

967
00:53:05,181 --> 00:53:08,431
The first of them is driver class name.

968
00:53:09,309 --> 00:53:13,117
Well actually it's the
set method that we want.

969
00:53:13,117 --> 00:53:14,770
Just to check.

970
00:53:14,770 --> 00:53:18,103
There is a set driver class name method.

971
00:53:24,967 --> 00:53:27,822
And for the value, I'm just
copying and pasting here

972
00:53:27,822 --> 00:53:29,989
from the Practicals Guide.

973
00:53:31,054 --> 00:53:33,554
The driver class name is that.

974
00:53:35,971 --> 00:53:37,638
We then have the URL

975
00:53:43,150 --> 00:53:44,569
for which the value again

976
00:53:44,569 --> 00:53:48,069
we'll be copying from the Practical Guide.

977
00:53:50,883 --> 00:53:52,550
We have the username

978
00:53:56,270 --> 00:54:00,067
which is SA for system administrator.

979
00:54:00,067 --> 00:54:00,900
And

980
00:54:04,516 --> 00:54:07,705
we need to supply the password, I think.

981
00:54:07,705 --> 00:54:11,205
Even though we're going to supply a blank.

982
00:54:12,483 --> 00:54:13,742
So that's it for the XML.

983
00:54:13,742 --> 00:54:15,737
I know that was a little bit laborious

984
00:54:15,737 --> 00:54:19,427
but it's going to be worth
doing a check on this.

985
00:54:19,427 --> 00:54:21,774
If we go into the Spring explorer

986
00:54:21,774 --> 00:54:23,812
and open up the graph.

987
00:54:23,812 --> 00:54:24,931
This looks good.

988
00:54:24,931 --> 00:54:26,809
This is the kind of thing I expect to see.

989
00:54:26,809 --> 00:54:30,105
It's a well connected graph first of all.

990
00:54:30,105 --> 00:54:33,574
We've just completed our customer service

991
00:54:33,574 --> 00:54:36,208
and our diary service.

992
00:54:36,208 --> 00:54:39,973
And each of them is now delegating to

993
00:54:39,973 --> 00:54:42,672
a production standard DAO.

994
00:54:42,672 --> 00:54:46,505
Both of these bins are
working with a template

995
00:54:47,984 --> 00:54:50,683
and the template is calling the database

996
00:54:50,683 --> 00:54:52,350
via the data source.

997
00:54:53,328 --> 00:54:54,491
So that all looks good.

998
00:54:54,491 --> 00:54:56,432
Don't forget this is also a call service,

999
00:54:56,432 --> 00:54:58,437
call handling service

1000
00:54:58,437 --> 00:55:01,680
which delegates to our customer
service and diary service.

1001
00:55:01,680 --> 00:55:04,421
And therefore the call service does call

1002
00:55:04,421 --> 00:55:06,768
the database as well.

1003
00:55:06,768 --> 00:55:08,581
So I think we're there.

1004
00:55:08,581 --> 00:55:12,748
It's time now, at last, to
have a go at running this.

1005
00:55:13,733 --> 00:55:15,781
We have our simple client test that

1006
00:55:15,781 --> 00:55:18,405
we wrote in the previous practical.

1007
00:55:18,405 --> 00:55:20,326
Now I don't know what
you've got inside there

1008
00:55:20,326 --> 00:55:23,813
but at first glance this
looks like a fairly good test.

1009
00:55:23,813 --> 00:55:25,211
We're doing a few things.

1010
00:55:25,211 --> 00:55:28,592
We're creating a call
with a pair of actions

1011
00:55:28,592 --> 00:55:31,092
which were adding to the call.

1012
00:55:32,731 --> 00:55:34,309
We're recording that call

1013
00:55:34,309 --> 00:55:36,154
and then we're printing out all of

1014
00:55:36,154 --> 00:55:40,154
the incomplete actions
for this particular user.

1015
00:55:41,289 --> 00:55:43,518
So certainly a fair
few database operations

1016
00:55:43,518 --> 00:55:45,332
will be going on in there.

1017
00:55:45,332 --> 00:55:47,165
Let's give this a run.

1018
00:55:51,252 --> 00:55:53,811
Well it was almost no chance at all

1019
00:55:53,811 --> 00:55:56,055
of that running for the first time.

1020
00:55:56,055 --> 00:55:59,031
So when you did this if
you had lots of exceptions,

1021
00:55:59,031 --> 00:56:01,399
I certainly wouldn't be
too worried about it.

1022
00:56:01,399 --> 00:56:03,219
It's bound to happen.

1023
00:56:03,219 --> 00:56:07,386
Now the exception looks like
a horrible long exception

1024
00:56:08,307 --> 00:56:11,795
but I think we've got everything
we need to know right here.

1025
00:56:11,795 --> 00:56:16,510
User the lacks privilege or
objects not found tbl_call.

1026
00:56:16,510 --> 00:56:20,677
It's telling us that the
tbl_call table does not exist.

1027
00:56:22,430 --> 00:56:24,936
Well it does not exist.

1028
00:56:24,936 --> 00:56:28,769
We did, if we go into
our JDBC implementation,

1029
00:56:30,622 --> 00:56:33,064
we did write a method,
I hope we did anyway,

1030
00:56:33,064 --> 00:56:34,814
called create tables.

1031
00:56:35,666 --> 00:56:36,954
So that should have done the work

1032
00:56:36,954 --> 00:56:40,229
but of course, we haven't
called create tables.

1033
00:56:40,229 --> 00:56:44,229
The thing I've forgotten
to do is in my wiring.

1034
00:56:44,229 --> 00:56:46,831
You'll remember from the videos that

1035
00:56:46,831 --> 00:56:48,581
in the Spring wiring,

1036
00:56:49,733 --> 00:56:51,567
when we create a DAO

1037
00:56:51,567 --> 00:56:53,146
such as the customer DAO

1038
00:56:53,146 --> 00:56:55,563
we can specify an init method

1039
00:56:56,645 --> 00:56:57,903
and that init method can be

1040
00:56:57,903 --> 00:56:59,919
any of the methods in the bin.

1041
00:56:59,919 --> 00:57:01,477
I just did a control space there

1042
00:57:01,477 --> 00:57:03,013
and it was clever enough to work out

1043
00:57:03,013 --> 00:57:07,471
that the only matching method
is called create tables.

1044
00:57:07,471 --> 00:57:11,638
We'll need to do the same
thing in our action DAO class

1045
00:57:13,114 --> 00:57:14,531
which I assume...

1046
00:57:15,951 --> 00:57:18,970
Yeah, create tables in there as well.

1047
00:57:18,970 --> 00:57:20,687
That should create the tables

1048
00:57:20,687 --> 00:57:24,197
and while I'm here, I mustn't forget

1049
00:57:24,197 --> 00:57:26,821
that we need to close the
data source down properly.

1050
00:57:26,821 --> 00:57:29,711
So we will need a destroy method

1051
00:57:29,711 --> 00:57:33,615
of close when the system closes down.

1052
00:57:33,615 --> 00:57:36,880
And just to check in my client,

1053
00:57:36,880 --> 00:57:40,581
I've got a method called
close there on the container

1054
00:57:40,581 --> 00:57:42,206
and then the container will know

1055
00:57:42,206 --> 00:57:45,494
it needs to close the data source.

1056
00:57:45,494 --> 00:57:47,766
So that was the first attempt failed.

1057
00:57:47,766 --> 00:57:50,433
Let's go for attempt number two.

1058
00:57:54,112 --> 00:57:54,945
Wow.

1059
00:57:54,945 --> 00:57:57,141
Well I'm surprised at that really.

1060
00:57:57,141 --> 00:57:58,694
It ran through okay.

1061
00:57:58,694 --> 00:58:01,222
So we're seeing the two actions that

1062
00:58:01,222 --> 00:58:03,665
are still outstanding.

1063
00:58:03,665 --> 00:58:06,165
And if we refresh the project,

1064
00:58:08,070 --> 00:58:10,908
we've got the database
files in the right place.

1065
00:58:10,908 --> 00:58:14,408
And I can open scripts in the text editor.

1066
00:58:16,710 --> 00:58:18,705
And we should see...

1067
00:58:18,705 --> 00:58:21,052
Yeah that's the creating of the tables

1068
00:58:21,052 --> 00:58:24,070
and it certainly looks
like the right kind of data

1069
00:58:24,070 --> 00:58:26,320
is going into the database.

1070
00:58:28,316 --> 00:58:30,316
Now as the object of the exercise is

1071
00:58:30,316 --> 00:58:32,589
to get a template up and running

1072
00:58:32,589 --> 00:58:35,074
and to get it connected to a DAO.

1073
00:58:35,074 --> 00:58:38,461
I'm happy now that we've
got everything working.

1074
00:58:38,461 --> 00:58:41,337
However, just off camera I
did a little bit of a review

1075
00:58:41,337 --> 00:58:43,982
and I realized I have
made at least one mistake

1076
00:58:43,982 --> 00:58:46,563
in the implementation
code you've just seen.

1077
00:58:46,563 --> 00:58:48,558
I don't think it's serious or important

1078
00:58:48,558 --> 00:58:52,206
but if you want to get
everything correct then

1079
00:58:52,206 --> 00:58:54,756
you'll want to review this with me.

1080
00:58:54,756 --> 00:58:58,468
This client at the
moment is creating a call

1081
00:58:58,468 --> 00:58:59,885
and some actions.

1082
00:59:00,729 --> 00:59:02,671
And then we're trying to record a call

1083
00:59:02,671 --> 00:59:06,137
but in fact this is for a
customer that doesn't exist.

1084
00:59:06,137 --> 00:59:09,887
We've never created a
customer called CS0939.

1085
00:59:11,108 --> 00:59:14,148
In fact, we haven't created
any customers at all.

1086
00:59:14,148 --> 00:59:18,532
And yet, as you just saw the
code ran through successfully

1087
00:59:18,532 --> 00:59:20,783
and everything worked okay.

1088
00:59:20,783 --> 00:59:25,017
Well I've had a little bit
of a debug just off camera

1089
00:59:25,017 --> 00:59:27,471
and I've worked out that it's because,

1090
00:59:27,471 --> 00:59:30,265
if we go into the database operation,

1091
00:59:30,265 --> 00:59:32,932
this is the DAO for record call.

1092
00:59:34,905 --> 00:59:38,500
Can you see that this,
oh it's called at call,

1093
00:59:38,500 --> 00:59:42,052
at call just goes straight
into the call table

1094
00:59:42,052 --> 00:59:46,681
and inserts the data
including the customer ID

1095
00:59:46,681 --> 00:59:50,276
whether or not that customer ID exists

1096
00:59:50,276 --> 00:59:52,622
in the customer table.

1097
00:59:52,622 --> 00:59:56,110
So we effectively end up with
a foreign key in that table.

1098
00:59:56,110 --> 00:59:59,193
That is an invalid foreign key.

1099
00:59:59,193 --> 01:00:01,262
Not good database integrity.

1100
01:00:01,262 --> 01:00:03,509
What I've really should have done here

1101
01:00:03,509 --> 01:00:04,703
before anything else is

1102
01:00:04,703 --> 01:00:08,080
to find out if this customer exists.

1103
01:00:08,080 --> 01:00:09,399
Now that's quite easy to do.

1104
01:00:09,399 --> 01:00:13,566
I can just call the get by ID
method on that customer ID.

1105
01:00:20,311 --> 01:00:23,308
And I'm not actually going to
do anything with that record

1106
01:00:23,308 --> 01:00:24,808
but if it is no...

1107
01:00:28,695 --> 01:00:29,900
Oh, actually no.

1108
01:00:29,900 --> 01:00:31,735
It's not going to come back as no.

1109
01:00:31,735 --> 01:00:36,428
Get by ID will throw a
record not found exception

1110
01:00:36,428 --> 01:00:38,028
if it's not found.

1111
01:00:38,028 --> 01:00:41,815
And therefore, that will then
get thrown back to the client.

1112
01:00:41,815 --> 01:00:44,876
So this line of code will only execute

1113
01:00:44,876 --> 01:00:46,876
if that customer exists.

1114
01:00:47,756 --> 01:00:50,081
So if we go back to the client now

1115
01:00:50,081 --> 01:00:54,248
and I think I've got a database
which I will need to delete.

1116
01:00:55,393 --> 01:00:58,893
I'll start from a completely clean system.

1117
01:01:03,682 --> 01:01:05,765
And this time if I run...

1118
01:01:10,071 --> 01:01:12,887
Yeah, it's saying that
customer doesn't exist

1119
01:01:12,887 --> 01:01:16,417
and therefore, there are
not outstanding actions.

1120
01:01:16,417 --> 01:01:19,991
So what I can do now is at the top of here

1121
01:01:19,991 --> 01:01:23,908
I could create the customer
management service.

1122
01:01:28,140 --> 01:01:31,020
I'll call it customer service

1123
01:01:31,020 --> 01:01:32,520
and we'll get bin.

1124
01:01:43,116 --> 01:01:45,527
And then before we do anything else

1125
01:01:45,527 --> 01:01:47,860
we'll create a new customer.

1126
01:01:52,428 --> 01:01:55,928
And I'll make sure that the ID is correct.

1127
01:01:56,844 --> 01:02:00,972
And that the company name can be anything.

1128
01:02:00,972 --> 01:02:03,472
And the notes can be anything.

1129
01:02:04,567 --> 01:02:08,631
We don't have to supply an
email address and so on.

1130
01:02:08,631 --> 01:02:10,657
I'll make sure that's imported

1131
01:02:10,657 --> 01:02:14,860
and then I will call on
the customer service object

1132
01:02:14,860 --> 01:02:16,860
the new customer method.

1133
01:02:20,247 --> 01:02:24,414
Now this time around, the
integrity should be good.

1134
01:02:27,216 --> 01:02:28,812
That's looking good.

1135
01:02:28,812 --> 01:02:32,439
And it appears that those
actions were recorded.

1136
01:02:32,439 --> 01:02:34,711
Now if I check the database table,

1137
01:02:34,711 --> 01:02:36,481
I'll need to refresh,

1138
01:02:36,481 --> 01:02:38,775
and then open up the scripts.

1139
01:02:38,775 --> 01:02:39,674
That looks good.

1140
01:02:39,674 --> 01:02:41,219
We can see the customer in there,

1141
01:02:41,219 --> 01:02:43,534
the nulls of the email and the telephone

1142
01:02:43,534 --> 01:02:45,145
that I didn't supply.

1143
01:02:45,145 --> 01:02:48,373
And there's the call and the actions.

1144
01:02:48,373 --> 01:02:50,203
Now just off camera, I've checked that

1145
01:02:50,203 --> 01:02:53,435
the other SQL statements
are executing correctly.

1146
01:02:53,435 --> 01:02:56,315
Now I won't bore you
with the details of that.

1147
01:02:56,315 --> 01:02:58,448
Feel free to check out the
other methods for yourself

1148
01:02:58,448 --> 01:02:59,793
if you're interested.

1149
01:02:59,793 --> 01:03:02,822
But there is just one
little catch with HSQLDB

1150
01:03:02,822 --> 01:03:04,987
that I'd like to make you aware of.

1151
01:03:04,987 --> 01:03:07,003
I'm going to remove these two lines

1152
01:03:07,003 --> 01:03:10,342
because we have now created that customer.

1153
01:03:10,342 --> 01:03:13,251
And of course, the customer
is now safely in the database.

1154
01:03:13,251 --> 01:03:17,379
But remember the telephone
and email are both null.

1155
01:03:17,379 --> 01:03:21,817
Now I'd like to abate those
values in the database.

1156
01:03:21,817 --> 01:03:23,811
So to do that,

1157
01:03:23,811 --> 01:03:26,649
I'm going to need to
call the customer service

1158
01:03:26,649 --> 01:03:29,982
and call the find customer by ID method.

1159
01:03:32,195 --> 01:03:36,362
And I'm going to retrieve
that customer with that ID.

1160
01:03:38,371 --> 01:03:39,204
And

1161
01:03:41,556 --> 01:03:44,180
I'll need to store the results.

1162
01:03:44,180 --> 01:03:46,527
Now once we've found that customer,

1163
01:03:46,527 --> 01:03:49,151
I'm going to change some of
the values in this customer

1164
01:03:49,151 --> 01:03:52,191
and I'd like to give a
proper telephone number.

1165
01:03:52,191 --> 01:03:53,941
This will be 632 3003

1166
01:03:55,700 --> 01:03:57,360
and we might as well do the email address

1167
01:03:57,360 --> 01:03:59,450
while we're here as well.

1168
01:03:59,450 --> 01:04:00,783
Set the email to

1169
01:04:02,247 --> 01:04:03,497
larry@acme.com.

1170
01:04:08,956 --> 01:04:13,671
And then I'm going to
call the customer service

1171
01:04:13,671 --> 01:04:15,588
update customer method.

1172
01:04:16,860 --> 01:04:20,228
Now you know that that's
going to result in

1173
01:04:20,228 --> 01:04:22,311
an SQL update statements.

1174
01:04:24,249 --> 01:04:26,521
Let's see what actually happens.

1175
01:04:26,521 --> 01:04:31,257
Well all of this will
need to be in a try block

1176
01:04:31,257 --> 01:04:34,876
because if that customer doesn't exist,

1177
01:04:34,876 --> 01:04:38,293
we'll get a customer not found exception

1178
01:04:38,293 --> 01:04:40,778
and we'll need to handle it.

1179
01:04:40,778 --> 01:04:43,232
We're not expecting this
exception to be thrown

1180
01:04:43,232 --> 01:04:46,482
because we know that customer is there.

1181
01:04:52,661 --> 01:04:54,943
We need it anyway.

1182
01:04:54,943 --> 01:04:57,471
Okay now so just before I run this,

1183
01:04:57,471 --> 01:04:59,210
let me remind you that
the current state of

1184
01:04:59,210 --> 01:05:02,768
the database is we have
an insert statements

1185
01:05:02,768 --> 01:05:04,603
but there are two nulls in there for

1186
01:05:04,603 --> 01:05:06,854
that particular customer.

1187
01:05:06,854 --> 01:05:10,246
Now I'm going to run this program.

1188
01:05:10,246 --> 01:05:11,888
Now we can't see from here,

1189
01:05:11,888 --> 01:05:14,817
but there will have
been an update statement

1190
01:05:14,817 --> 01:05:17,206
issued to the database.

1191
01:05:17,206 --> 01:05:19,222
Now let's have a look
at at the difference.

1192
01:05:19,222 --> 01:05:21,555
If we open this script again

1193
01:05:22,487 --> 01:05:24,813
and have a look down at the bottom,

1194
01:05:24,813 --> 01:05:26,850
I'll put a highlighter on that line there.

1195
01:05:26,850 --> 01:05:29,250
Now this surprises many people.

1196
01:05:29,250 --> 01:05:31,309
You may have been expecting to see

1197
01:05:31,309 --> 01:05:35,476
an insert statement followed
by an update statement.

1198
01:05:36,418 --> 01:05:38,925
But that's not the way that file works.

1199
01:05:38,925 --> 01:05:41,186
The file isn't a kind of record of

1200
01:05:41,186 --> 01:05:43,778
all of the SQL that you've ever issued.

1201
01:05:43,778 --> 01:05:47,223
Instead, the SQL you can see here

1202
01:05:47,223 --> 01:05:49,556
is the SQL that HSQLDB needs

1203
01:05:50,932 --> 01:05:55,099
to recreate the database
next time the program runs.

1204
01:05:56,083 --> 01:05:59,485
So HSQLDB doesn't need
the original insert with

1205
01:05:59,485 --> 01:06:02,485
the nulls and the update statements.

1206
01:06:03,401 --> 01:06:07,625
Instead it's just recorded
that as a single insert

1207
01:06:07,625 --> 01:06:10,042
with our new values in place.

1208
01:06:11,443 --> 01:06:13,918
So don't be surprised if you see that.

1209
01:06:13,918 --> 01:06:17,758
And indeed if I go ahead
and just do one last thing.

1210
01:06:17,758 --> 01:06:21,925
I will call the customer
service's delete customer method

1211
01:06:23,049 --> 01:06:25,747
and I'll pass in that customer.

1212
01:06:25,747 --> 01:06:28,275
I think it's okay to do that in there.

1213
01:06:28,275 --> 01:06:30,608
If I run the code this time,

1214
01:06:35,710 --> 01:06:38,099
it's telling us the
customer didn't exist there

1215
01:06:38,099 --> 01:06:41,534
when it was trying to record
a call for that customer.

1216
01:06:41,534 --> 01:06:43,529
And if we look in the log,

1217
01:06:43,529 --> 01:06:47,571
think you'll know what we're
expecting to see here now.

1218
01:06:47,571 --> 01:06:51,571
There is now no reference to that customer

1219
01:06:51,571 --> 01:06:55,166
because it doesn't need
an insert statement for

1220
01:06:55,166 --> 01:06:56,788
that customer anymore.

1221
01:06:56,788 --> 01:07:01,321
So don't expect to see deletes
and updates in this script.

1222
01:07:01,321 --> 01:07:03,571
You'll only see inserts.

1223
01:07:03,571 --> 01:07:04,915
Well that's it for this practical.

1224
01:07:04,915 --> 01:07:06,153
That was a long practical.

1225
01:07:06,153 --> 01:07:07,983
Probably one of the
longest practicals that

1226
01:07:07,983 --> 01:07:09,519
we'll have on this course.

1227
01:07:09,519 --> 01:07:11,834
But I wanted to cover
everything in long detail

1228
01:07:11,834 --> 01:07:14,575
just in case you had any problems.

1229
01:07:14,575 --> 01:07:16,740
If you still have
problems, then of course,

1230
01:07:16,740 --> 01:07:20,271
drop us a contact on the
virtual pair programmer site

1231
01:07:20,271 --> 01:07:22,308
and we'll do our best to get you running.

1232
01:07:22,308 --> 01:07:24,303
But assuming you've done everything well,

1233
01:07:24,303 --> 01:07:27,162
then we've got object
relational mappers to come

1234
01:07:27,162 --> 01:07:30,276
and we've got exciting
things such as transactions

1235
01:07:30,276 --> 01:07:33,274
and aspect oriented programming
to add to the system

1236
01:07:33,274 --> 01:07:35,407
so you'll definitely need a good break

1237
01:07:35,407 --> 01:07:38,574
and I'll see you for the next chapter.

1
00:00:00,497 --> 00:00:04,164
(snappy instrumental music)

2
00:00:10,760 --> 00:00:13,230
- [Voiceover] It's time now for Chapter 13

3
00:00:13,230 --> 00:00:15,389
and a brand new topic.

4
00:00:15,389 --> 00:00:17,494
This is the first of several chapters

5
00:00:17,494 --> 00:00:20,992
covering one of the
central features of Spring.

6
00:00:20,992 --> 00:00:25,159
And that's called AOP, or
Aspect Oriented Programming.

7
00:00:26,887 --> 00:00:30,242
Spring uses AOP in lots of areas.

8
00:00:30,242 --> 00:00:31,356
Perhaps the biggest use of

9
00:00:31,356 --> 00:00:34,189
AOP in Spring is for transactions.

10
00:00:35,637 --> 00:00:38,367
We need to study transactions
later in the course,

11
00:00:38,367 --> 00:00:42,235
so you might need some
AOP knowledge first.

12
00:00:42,235 --> 00:00:44,933
I knew that many of
you will be new to AOP.

13
00:00:44,933 --> 00:00:49,529
So this chapter is aimed at
showing you the absolute basics.

14
00:00:49,529 --> 00:00:53,696
It's going to show you the
reason why we sometimes need AOP.

15
00:00:54,740 --> 00:00:57,197
It's because some requirements
don't affect a single

16
00:00:57,197 --> 00:01:01,238
class or method, they
affect multiple classes,

17
00:01:01,238 --> 00:01:05,163
sometimes entire layers
of our application.

18
00:01:05,163 --> 00:01:09,840
These types of requirements
are called aspects.

19
00:01:09,840 --> 00:01:13,021
In traditional object-oriented
programming just isn't

20
00:01:13,021 --> 00:01:15,421
good at handling aspects.

21
00:01:15,421 --> 00:01:18,714
So we use a new technique
for these requirements,

22
00:01:18,714 --> 00:01:20,381
and it's called AOP.

23
00:01:21,555 --> 00:01:24,715
One way of implementing
AOP is by using a standard

24
00:01:24,715 --> 00:01:27,624
design pattern called a proxy.

25
00:01:27,624 --> 00:01:29,623
I'll show you what that is and you'll be

26
00:01:29,623 --> 00:01:33,751
hearing the term proxy through
the rest of this course.

27
00:01:33,751 --> 00:01:37,729
I'll also show you the
concept of a dynamic proxy.

28
00:01:37,729 --> 00:01:40,661
This is part of the standard
Java development kit,

29
00:01:40,661 --> 00:01:42,944
but not many people use it.

30
00:01:42,944 --> 00:01:45,629
So, this chapter is just an overview.

31
00:01:45,629 --> 00:01:49,160
If you already know what
AOP and proxies are,

32
00:01:49,160 --> 00:01:51,288
then you can skip to the next chapter.

33
00:01:51,288 --> 00:01:55,205
And that's where we start
to use AOP in Spring.

34
00:01:57,542 --> 00:02:01,006
Let's return back to our book service.

35
00:02:01,006 --> 00:02:04,102
Recall that we have a
book service interface,

36
00:02:04,102 --> 00:02:07,102
with currently five methods defined,

37
00:02:08,129 --> 00:02:12,157
and we have a production
standard implementation

38
00:02:12,157 --> 00:02:15,574
that's delegating to a database via a DO.

39
00:02:16,964 --> 00:02:19,243
Now, imagine this scenario.

40
00:02:19,243 --> 00:02:21,470
A project manager has got
themselves very worried

41
00:02:21,470 --> 00:02:24,093
about the performance of the database.

42
00:02:24,093 --> 00:02:27,559
They're not convinced
that JDBC performs as well

43
00:02:27,559 --> 00:02:29,710
as one of these fancy frameworks

44
00:02:29,710 --> 00:02:32,960
that we'll be studying later, like JPA.

45
00:02:34,067 --> 00:02:37,817
So, we've offered to
time every single method

46
00:02:39,449 --> 00:02:42,342
invocation in our service.

47
00:02:42,342 --> 00:02:45,172
We're going to report
back that, for example,

48
00:02:45,172 --> 00:02:49,339
the get entire catalog method
took 47 milliseconds to run.

49
00:02:52,455 --> 00:02:56,449
Now, we've had to think about
how we can implement this.

50
00:02:56,449 --> 00:03:00,616
And there's an obvious simplistic
way of implementing it.

51
00:03:02,422 --> 00:03:05,645
That's to go into every
one of these five method

52
00:03:05,645 --> 00:03:09,812
implementations and to add
the timing code into there.

53
00:03:11,232 --> 00:03:16,031
Just off camera, I had a
try at doing exactly that.

54
00:03:16,031 --> 00:03:19,196
I've closed the CRM project for now,

55
00:03:19,196 --> 00:03:22,484
and reopened the bookstore,
and we're looking here

56
00:03:22,484 --> 00:03:26,633
at the production implementation
of the book service.

57
00:03:26,633 --> 00:03:28,885
Before I begin, I'm going
to tell you that this is

58
00:03:28,885 --> 00:03:30,958
really not a good way of doing it.

59
00:03:30,958 --> 00:03:32,564
I think you could probably guess

60
00:03:32,564 --> 00:03:35,187
where I was going with this.

61
00:03:35,187 --> 00:03:37,700
So, you can just watch the video here.

62
00:03:37,700 --> 00:03:40,332
If you really want this
code in your development

63
00:03:40,332 --> 00:03:42,201
environment, then you will find it

64
00:03:42,201 --> 00:03:45,828
in the starting code for this chapter.

65
00:03:45,828 --> 00:03:49,418
I'm going to skip a few
methods and go straight to

66
00:03:49,418 --> 00:03:51,918
the get entire catalog method.

67
00:03:53,056 --> 00:03:56,261
Now what Im doing is storing a local

68
00:03:56,261 --> 00:03:58,864
variable recording how many nanoseconds

69
00:03:58,864 --> 00:04:00,487
there are in a millisecond.

70
00:04:00,487 --> 00:04:03,201
That's just so I can
convert into something

71
00:04:03,201 --> 00:04:06,380
a little bit more readable
at the end of the method.

72
00:04:06,380 --> 00:04:08,922
And then before I do anything else,

73
00:04:08,922 --> 00:04:10,804
I'm starting a clock.

74
00:04:10,804 --> 00:04:14,387
I'm using the standard
JDK nano time method

75
00:04:15,329 --> 00:04:18,667
on the system class and
that just returns accounts

76
00:04:18,667 --> 00:04:22,289
of how many nano seconds have elapsed

77
00:04:22,289 --> 00:04:24,539
since a certain stop time.

78
00:04:26,056 --> 00:04:28,011
By the way I can't guarantee that

79
00:04:28,011 --> 00:04:30,844
this clock is accurate or precise.

80
00:04:31,834 --> 00:04:34,264
The Java docs for this method does state

81
00:04:34,264 --> 00:04:36,050
that are implementation dependence,

82
00:04:36,050 --> 00:04:39,384
is here so it really
depends on the precision

83
00:04:39,384 --> 00:04:42,528
or the accuracy of your system

84
00:04:42,528 --> 00:04:45,708
as to whether these clocks are accurate.

85
00:04:45,708 --> 00:04:48,162
Doesn't really matter for this system

86
00:04:48,162 --> 00:04:49,729
but it's worth mentioning cant

87
00:04:49,729 --> 00:04:52,907
consider this a correct benchmark.

88
00:04:52,907 --> 00:04:54,812
Once I've started at the clock,

89
00:04:54,812 --> 00:04:57,111
and then going on to do the work

90
00:04:57,111 --> 00:05:00,200
Here's the code that was there before

91
00:05:00,200 --> 00:05:03,862
I'm calling the DEOS old books method.

92
00:05:03,862 --> 00:05:05,902
Then once that's completed,

93
00:05:05,902 --> 00:05:09,227
the job is done so I can stop the clock,

94
00:05:09,227 --> 00:05:10,685
then I'm calculating how many

95
00:05:10,685 --> 00:05:13,696
nanoseconds that operation took.

96
00:05:13,696 --> 00:05:16,696
And then I'm reporting the results.

97
00:05:17,743 --> 00:05:19,848
I'm just converting the nanoseconds

98
00:05:19,848 --> 00:05:21,931
there into milliseconds.

99
00:05:23,578 --> 00:05:25,905
In real life, you probably use some kind

100
00:05:25,905 --> 00:05:27,947
of a logger to do that report,

101
00:05:27,947 --> 00:05:29,920
but just for speed on them

102
00:05:29,920 --> 00:05:32,087
to use the standard outs.

103
00:05:32,961 --> 00:05:36,643
I suppose its simple and straightforward

104
00:05:36,643 --> 00:05:39,128
I suppose you can see what

105
00:05:39,128 --> 00:05:40,334
problems going to be though.

106
00:05:40,334 --> 00:05:41,874
I also want this timing information

107
00:05:41,874 --> 00:05:44,811
for the other method, so I had to go

108
00:05:44,811 --> 00:05:46,779
to the register new book method

109
00:05:46,779 --> 00:05:49,196
to do exactly the same thing.

110
00:05:50,667 --> 00:05:54,041
I guess the only
differences in the reports

111
00:05:54,041 --> 00:05:57,032
Ive change the name of the method.

112
00:05:57,032 --> 00:05:59,282
So that was quite tedious.

113
00:06:00,252 --> 00:06:02,192
And I must admit that I couldn't be

114
00:06:02,192 --> 00:06:04,323
bothered to do all of the methods.

115
00:06:04,323 --> 00:06:06,171
We got two methods here

116
00:06:06,171 --> 00:06:08,364
which I havent bothered timing.

117
00:06:08,364 --> 00:06:10,018
I'm doing that because at the moment

118
00:06:10,018 --> 00:06:12,634
I'm not even calling them from the client,

119
00:06:12,634 --> 00:06:16,337
but I guess I should've done
the same things in here.

120
00:06:16,337 --> 00:06:17,768
But I just want to mention that the

121
00:06:17,768 --> 00:06:19,653
get book by ISBN method

122
00:06:19,653 --> 00:06:22,988
because it might throw an exception.

123
00:06:22,988 --> 00:06:25,204
Even if that exception is thrown,

124
00:06:25,204 --> 00:06:27,363
I still want to do the timing because

125
00:06:27,363 --> 00:06:29,717
I still want to know how long it took

126
00:06:29,717 --> 00:06:31,627
to find the word that was not a

127
00:06:31,627 --> 00:06:33,841
matching book in the database.

128
00:06:33,841 --> 00:06:37,145
So I'm using a try finally block here.

129
00:06:37,145 --> 00:06:40,413
I'm trying to find the book and return it,

130
00:06:40,413 --> 00:06:43,142
but regardless of what happened,

131
00:06:43,142 --> 00:06:45,674
if an exception was thrown or not,

132
00:06:45,674 --> 00:06:50,080
I want to stop the clock
and report the timings.

133
00:06:50,080 --> 00:06:52,337
I guess you're familiar
with the try finally block,

134
00:06:52,337 --> 00:06:56,512
but just in case, that's
why I've done that.

135
00:06:56,512 --> 00:06:59,876
Well it's laborious, but at
least it's straightforward.

136
00:06:59,876 --> 00:07:01,795
Just to remind you this
is the client exactly

137
00:07:01,795 --> 00:07:04,002
as we had it the last time

138
00:07:04,002 --> 00:07:06,187
we were working with the bookstore.

139
00:07:06,187 --> 00:07:08,205
And I'm not doing
anything very interesting.

140
00:07:08,205 --> 00:07:10,356
I'm calling register new book,

141
00:07:10,356 --> 00:07:15,135
then get entire catalog, then
I'm finding a book by ISBN

142
00:07:15,135 --> 00:07:16,682
and it looks like, well yeah,

143
00:07:16,682 --> 00:07:19,895
definitely, that's a nonexistent ISBN.

144
00:07:19,895 --> 00:07:23,279
So I expect to see the
exception handled here,

145
00:07:23,279 --> 00:07:26,196
but I still want to see the timing.

146
00:07:27,305 --> 00:07:29,305
Let's see if this runs.

147
00:07:31,266 --> 00:07:32,427
Looks okay.

148
00:07:32,427 --> 00:07:33,782
It's telling me that register new

149
00:07:33,782 --> 00:07:36,745
book took 73 milliseconds.

150
00:07:36,745 --> 00:07:40,047
Get entire catalog took 20 milliseconds.

151
00:07:40,047 --> 00:07:43,547
And get book by ISBN took 18 milliseconds.

152
00:07:45,102 --> 00:07:47,234
I don't know if that's a good result

153
00:07:47,234 --> 00:07:48,657
or not really I'm running on quite

154
00:07:48,657 --> 00:07:51,279
an old PC here, so I'm a little

155
00:07:51,279 --> 00:07:53,858
surprised it was as quick as that.

156
00:07:53,858 --> 00:07:55,748
I hope my conversion from nanoseconds

157
00:07:55,748 --> 00:07:58,855
to milliseconds was
correct, but either way

158
00:07:58,855 --> 00:08:02,630
we can see the timing is happening.

159
00:08:02,630 --> 00:08:04,707
So that's quite interesting.

160
00:08:04,707 --> 00:08:07,225
And I can show that to my project manager

161
00:08:07,225 --> 00:08:09,562
and when we get to use hibernate

162
00:08:09,562 --> 00:08:12,984
or maybe MIBATIS later on in the course,

163
00:08:12,984 --> 00:08:15,400
we could use the same information

164
00:08:15,400 --> 00:08:17,245
to see what a straightforward

165
00:08:17,245 --> 00:08:19,328
JDBC is faster or slower.

166
00:08:21,227 --> 00:08:23,388
So I guess I've met my requirements,

167
00:08:23,388 --> 00:08:26,308
and Ive made my project manager happy.

168
00:08:26,308 --> 00:08:28,647
I don't know about you, but I'm not happy

169
00:08:28,647 --> 00:08:33,095
with the way that I've
implemented this timer.

170
00:08:33,095 --> 00:08:37,173
The first problem back
to the service is that

171
00:08:37,173 --> 00:08:41,413
I've really wrecked this service class.

172
00:08:41,413 --> 00:08:43,913
What was very clean and simple

173
00:08:45,776 --> 00:08:49,648
and was only containing the code relevant

174
00:08:49,648 --> 00:08:53,565
to the servicing of books,
is now several pages

175
00:08:54,508 --> 00:08:57,327
of a routine code and, you know,

176
00:08:57,327 --> 00:09:00,769
at least 80% of the code
in this class is now

177
00:09:00,769 --> 00:09:04,299
dealing with starting
and stopping stop watches

178
00:09:04,299 --> 00:09:06,882
rather than dealing with books.

179
00:09:08,284 --> 00:09:10,648
Second thing I'm unhappy about

180
00:09:10,648 --> 00:09:13,927
is the sheer amount of
repetition in this code.

181
00:09:13,927 --> 00:09:16,284
You can see how much copying

182
00:09:16,284 --> 00:09:18,534
and pasting I've done here.

183
00:09:19,454 --> 00:09:21,080
Of course, if I decided that I wanted

184
00:09:21,080 --> 00:09:25,293
to output this in milliseconds
instead of nanoseconds, I

185
00:09:25,293 --> 00:09:27,718
went to change every single

186
00:09:27,718 --> 00:09:30,543
one of these systems out.

187
00:09:30,543 --> 00:09:32,938
Now of course I could probably factor

188
00:09:32,938 --> 00:09:37,105
the starting the clock into
a method or static function,

189
00:09:38,986 --> 00:09:41,505
and I could do the stop the clock

190
00:09:41,505 --> 00:09:44,429
in a separate function,
but nonetheless I'm going

191
00:09:44,429 --> 00:09:48,781
to have repetition
whichever way you do things.

192
00:09:48,781 --> 00:09:51,870
The other problem is that I'm going to

193
00:09:51,870 --> 00:09:53,988
of course add more methods to this class

194
00:09:53,988 --> 00:09:56,005
as time goes on I'm going to need

195
00:09:56,005 --> 00:09:58,195
other books service methods.

196
00:09:58,195 --> 00:10:02,168
And yet every time I add
a method to this class,

197
00:10:02,168 --> 00:10:04,592
I'm going to have to repeat

198
00:10:04,592 --> 00:10:08,053
the copying and pasting of the timing.

199
00:10:08,053 --> 00:10:09,444
And theres a fourth problem.

200
00:10:09,444 --> 00:10:11,187
This keeps going on.

201
00:10:11,187 --> 00:10:14,906
Now I have to see this timing information.

202
00:10:14,906 --> 00:10:17,032
I've kind of got no choice.

203
00:10:17,032 --> 00:10:19,782
The timing code will always run.

204
00:10:20,822 --> 00:10:25,264
It's not easy to switch
off the timing code once

205
00:10:25,264 --> 00:10:28,146
we got the information we need.

206
00:10:28,146 --> 00:10:29,683
Of course, I could go in and put some kind

207
00:10:29,683 --> 00:10:32,516
of if statements all I don't know.

208
00:10:33,651 --> 00:10:37,291
But that's simply not a good thing either.

209
00:10:37,291 --> 00:10:40,464
It's not enough this a final problem.

210
00:10:40,464 --> 00:10:42,275
We know that the project manager

211
00:10:42,275 --> 00:10:46,058
was worried about this book service class.

212
00:10:46,058 --> 00:10:49,977
But presumably, they would
want the same information

213
00:10:49,977 --> 00:10:54,144
about the account service
and the purchasing service,

214
00:10:55,875 --> 00:11:00,042
and every single service that
we ever add to these projects.

215
00:11:01,702 --> 00:11:03,259
So Im getting quite depressed now

216
00:11:03,259 --> 00:11:07,990
that it's not just this class
that I've had to destroy.

217
00:11:07,990 --> 00:11:10,201
I would have to go and do the same work

218
00:11:10,201 --> 00:11:12,951
in lots of other classes as well.

219
00:11:13,814 --> 00:11:17,515
What's really happening
here is the requirement

220
00:11:17,515 --> 00:11:20,866
that I have this timing requirement

221
00:11:20,866 --> 00:11:25,033
is not really a requirement
against a particular class.

222
00:11:26,842 --> 00:11:29,671
And it's not even a requirement

223
00:11:29,671 --> 00:11:32,809
against a particular method.

224
00:11:32,809 --> 00:11:35,509
That's what OO is good at.

225
00:11:35,509 --> 00:11:37,643
OO, or object-oriented programming

226
00:11:37,643 --> 00:11:40,981
is all about defining
classes and the behavior

227
00:11:40,981 --> 00:11:44,731
that each class performs
at the method level.

228
00:11:45,601 --> 00:11:49,768
This requirement is much
bigger than a single class.

229
00:11:50,787 --> 00:11:53,681
I'm saying here that this
requirement cuts across

230
00:11:53,681 --> 00:11:56,514
my entire application or at least

231
00:11:58,038 --> 00:12:01,689
an entire layer of my application.

232
00:12:01,689 --> 00:12:05,147
I somehow want this start the clock

233
00:12:05,147 --> 00:12:08,397
and stop the clock code to be present

234
00:12:08,397 --> 00:12:12,564
in every single service class,
both now and in the future.

235
00:12:15,489 --> 00:12:17,242
I guess you could probably come up

236
00:12:17,242 --> 00:12:19,801
with some clever scheme
maybe using inheritance,

237
00:12:19,801 --> 00:12:24,172
where we put the timing
code in a superclass,

238
00:12:24,172 --> 00:12:26,005
and inherit from that.

239
00:12:27,586 --> 00:12:29,776
I think really what ever you do

240
00:12:29,776 --> 00:12:32,443
just using the normal OO tools,

241
00:12:33,946 --> 00:12:38,124
youre going to end up
in a pretty sticky mess.

242
00:12:38,124 --> 00:12:40,820
But in fact there is some standard

243
00:12:40,820 --> 00:12:43,995
object-oriented theory that we can use

244
00:12:43,995 --> 00:12:46,995
to get towards an elegant solution.

245
00:12:48,504 --> 00:12:50,511
What I'm going to do now

246
00:12:50,511 --> 00:12:53,118
is take you through one improvement

247
00:12:53,118 --> 00:12:54,913
to the previous solution.

248
00:12:54,913 --> 00:12:57,680
Now it won't yet be perfect,

249
00:12:57,680 --> 00:13:00,568
but it will be a step
in the right direction.

250
00:13:00,568 --> 00:13:03,171
And it's going to allow me to introduce

251
00:13:03,171 --> 00:13:06,136
some of the terms, and
some of the techniques

252
00:13:06,136 --> 00:13:08,055
that you're going to meet

253
00:13:08,055 --> 00:13:10,253
when you go onto aspect-oriented

254
00:13:10,253 --> 00:13:13,475
programming in the next chapter.

255
00:13:13,475 --> 00:13:15,548
The improvement is I'm going to use

256
00:13:15,548 --> 00:13:18,465
one of the standard design patterns

257
00:13:19,951 --> 00:13:22,368
from the famous gang of four.

258
00:13:24,016 --> 00:13:25,409
I don't know if you studied

259
00:13:25,409 --> 00:13:27,755
design patterns before.

260
00:13:27,755 --> 00:13:29,613
Youll certainly find a lot of information

261
00:13:29,613 --> 00:13:31,571
on the web about it.

262
00:13:31,571 --> 00:13:34,488
Now this pattern is called a proxy.

263
00:13:36,977 --> 00:13:38,971
Let's have a look at how a proxy

264
00:13:38,971 --> 00:13:41,054
would work in our system.

265
00:13:42,121 --> 00:13:43,654
We're back at the design here

266
00:13:43,654 --> 00:13:47,821
and recall we have interface
and an implementation.

267
00:13:50,412 --> 00:13:53,101
Im now going to add the requirement that

268
00:13:53,101 --> 00:13:55,768
when I implement my timing code,

269
00:13:56,717 --> 00:13:59,967
I must not affect my original service.

270
00:14:01,124 --> 00:14:04,207
This book service in pool is perfect.

271
00:14:06,297 --> 00:14:08,929
Well, it's working at least.

272
00:14:08,929 --> 00:14:12,365
It's completely tested
and I don't want to be

273
00:14:12,365 --> 00:14:15,473
changing that class at all.

274
00:14:15,473 --> 00:14:17,505
So how can I do that?

275
00:14:17,505 --> 00:14:21,763
The way that the proxy
pattern works is that

276
00:14:21,763 --> 00:14:25,930
we create a second
implementation of the interface.

277
00:14:27,470 --> 00:14:29,220
This one I have here.

278
00:14:31,001 --> 00:14:35,150
I'm going to call it
the book service proxy

279
00:14:35,150 --> 00:14:38,358
to remind myself that
this is a special class

280
00:14:38,358 --> 00:14:43,286
and you going to see why
it's special in a moment.

281
00:14:43,286 --> 00:14:45,908
Now the first thing to say is of course

282
00:14:45,908 --> 00:14:49,031
it's implementing the same interface.

283
00:14:49,031 --> 00:14:52,547
Therefore, we know that this proxy class

284
00:14:52,547 --> 00:14:55,714
is going to have the same five methods

285
00:14:57,410 --> 00:14:59,909
appearing in the class.

286
00:14:59,909 --> 00:15:02,191
Were going to have, for example,

287
00:15:02,191 --> 00:15:05,293
a method called get entire catalog

288
00:15:05,293 --> 00:15:07,427
in the proxy class.

289
00:15:07,427 --> 00:15:09,776
It will have the same parameters

290
00:15:09,776 --> 00:15:12,156
as our production version will have

291
00:15:12,156 --> 00:15:13,989
the same return type.

292
00:15:14,982 --> 00:15:16,836
Now this is the plan.

293
00:15:16,836 --> 00:15:21,003
I'm going to put the timing
code into this proxy.

294
00:15:22,143 --> 00:15:24,976
But I'm also going to allow the proxy

295
00:15:24,976 --> 00:15:28,976
to call my original book
service implementation

296
00:15:30,894 --> 00:15:34,894
to call the normal business
code, so the proxies

297
00:15:35,969 --> 00:15:39,969
going to contain the
timing and the timing only

298
00:15:40,882 --> 00:15:44,005
whereas the book service implementation

299
00:15:44,005 --> 00:15:47,762
will contain the regular business logic

300
00:15:47,762 --> 00:15:50,469
that we don't want to change.

301
00:15:50,469 --> 00:15:53,650
I hope that doesn't sound too complicated.

302
00:15:53,650 --> 00:15:55,496
I'm going to switch across the clips

303
00:15:55,496 --> 00:15:59,711
and I'll show you how
this might be implemented.

304
00:15:59,711 --> 00:16:02,412
Off-camera, I've taken my book service

305
00:16:02,412 --> 00:16:06,218
production implementation
and I've restored

306
00:16:06,218 --> 00:16:08,531
it back to how it was.

307
00:16:08,531 --> 00:16:11,882
A lovely clean and single class

308
00:16:11,882 --> 00:16:15,879
possibly containing some business logic.

309
00:16:15,879 --> 00:16:20,432
Ive got rid of all of
that horrible timing stuff.

310
00:16:20,432 --> 00:16:22,612
So Im going to follow the plan suggested

311
00:16:22,612 --> 00:16:26,779
by the proxy pattern, and I'm
going to create a new class.

312
00:16:29,749 --> 00:16:31,168
And just for now, Ill keep it in the same

313
00:16:31,168 --> 00:16:34,240
package, this services package.

314
00:16:34,240 --> 00:16:37,561
And I'm going to call this, as on caption,

315
00:16:37,561 --> 00:16:39,228
book service proxy.

316
00:16:41,953 --> 00:16:44,339
Actually Im going to
give it a better name.

317
00:16:44,339 --> 00:16:48,506
I'm going to call it the
book's service timing proxy.

318
00:16:50,148 --> 00:16:52,117
Because that's what this class is going

319
00:16:52,117 --> 00:16:54,700
to do it's going to do timing.

320
00:16:56,297 --> 00:17:00,591
Now crucially this
class needs to implement

321
00:17:00,591 --> 00:17:03,343
the same interface as the class

322
00:17:03,343 --> 00:17:06,027
that we're going to be working with.

323
00:17:06,027 --> 00:17:09,194
So thats the book service interface.

324
00:17:11,537 --> 00:17:13,250
I'll make sure that the checkbox

325
00:17:13,250 --> 00:17:16,583
is ticked here, and thats created me a

326
00:17:17,664 --> 00:17:20,252
good starting point with stop

327
00:17:20,252 --> 00:17:24,070
implementations of all of the methods.

328
00:17:24,070 --> 00:17:26,756
My plan is in each of the methods

329
00:17:26,756 --> 00:17:29,101
I'm going to put the timing code

330
00:17:29,101 --> 00:17:32,421
and nothing but the timing code.

331
00:17:32,421 --> 00:17:36,156
So Im going to start
with get entire catalog.

332
00:17:36,156 --> 00:17:39,112
Now these lines of code are the routine

333
00:17:39,112 --> 00:17:40,926
lines of code that I had before

334
00:17:40,926 --> 00:17:44,328
with the stop the clock and
stop the clock and so on.

335
00:17:44,328 --> 00:17:47,571
So let's take advantage of the fact that

336
00:17:47,571 --> 00:17:50,728
this is a video I'm
going to fast-forward to

337
00:17:50,728 --> 00:17:53,311
what this code would look like.

338
00:17:54,460 --> 00:17:57,213
So here's my first attempt at implementing

339
00:17:57,213 --> 00:18:01,380
the timing code in this
get entire catalog method.

340
00:18:02,273 --> 00:18:05,389
It's pretty much the
same as it was before.

341
00:18:05,389 --> 00:18:07,399
Im going to start the clock then I'm

342
00:18:07,399 --> 00:18:09,393
going to do the work,

343
00:18:09,393 --> 00:18:11,915
and I'll come back to that in a moment.

344
00:18:11,915 --> 00:18:16,106
And then I stop the clock
and report the results.

345
00:18:16,106 --> 00:18:18,837
Now remember where in the timing proxy

346
00:18:18,837 --> 00:18:22,473
here just going back to my
production implementation

347
00:18:22,473 --> 00:18:24,830
of the book service, get entire catalog

348
00:18:24,830 --> 00:18:27,247
there has not changed at all.

349
00:18:29,399 --> 00:18:32,899
But the problem is how do we do the work?

350
00:18:34,109 --> 00:18:35,680
Well of course we've already

351
00:18:35,680 --> 00:18:38,670
implemented the work in another class,

352
00:18:38,670 --> 00:18:42,834
in the book service
production implementation.

353
00:18:42,834 --> 00:18:44,929
My plan is, what Im going to do is,

354
00:18:44,929 --> 00:18:47,820
Im going to hold, as an attribute,

355
00:18:47,820 --> 00:18:50,777
Im going to hold an instance

356
00:18:50,777 --> 00:18:54,661
of that books service
production end pole.

357
00:18:54,661 --> 00:18:58,047
So Im going to do something
like, Im going to call,

358
00:18:58,047 --> 00:19:00,016
Im going to be explicit here.

359
00:19:00,016 --> 00:19:01,485
Im going to call the variable

360
00:19:01,485 --> 00:19:04,910
the original book service
and Im going to call

361
00:19:04,910 --> 00:19:08,660
on that object the get
entire catalog method.

362
00:19:14,671 --> 00:19:17,294
I havent created this variable yet.

363
00:19:17,294 --> 00:19:20,627
Im going to hold that as an attribute,

364
00:19:22,021 --> 00:19:26,040
and its type, again Im
programming to the interface

365
00:19:26,040 --> 00:19:30,065
the type of that object is book service.

366
00:19:30,065 --> 00:19:34,232
Im going to call that
the original book service.

367
00:19:36,609 --> 00:19:38,963
Because original book service has the same

368
00:19:38,963 --> 00:19:42,380
interface as our proxy, then we know that

369
00:19:43,851 --> 00:19:46,238
when were in the get
entire catalog method

370
00:19:46,238 --> 00:19:49,960
in the proxy, we can call the original

371
00:19:49,960 --> 00:19:52,498
get entire catalog method because

372
00:19:52,498 --> 00:19:55,083
theyve got the same interface.

373
00:19:55,083 --> 00:19:58,339
And if I go ahead now, I
need to do some copying

374
00:19:58,339 --> 00:20:01,896
and pasting here, which wont be good.

375
00:20:01,896 --> 00:20:04,008
Since this isn't perfect yet,

376
00:20:04,008 --> 00:20:05,230
I want to do the same thing

377
00:20:05,230 --> 00:20:07,147
for register new book.

378
00:20:08,190 --> 00:20:11,642
Start the clock, but then to do the work,

379
00:20:11,642 --> 00:20:15,059
I need to call the original book service

380
00:20:16,260 --> 00:20:19,020
and because it's the same interface,

381
00:20:19,020 --> 00:20:21,813
all of the methods are
available, including

382
00:20:21,813 --> 00:20:23,481
the one we want to call,

383
00:20:23,481 --> 00:20:25,731
which is register new book.

384
00:20:26,867 --> 00:20:30,098
Then, it's going to be a routine case

385
00:20:30,098 --> 00:20:34,265
of stopping the clock and
sending out the reports.

386
00:20:35,868 --> 00:20:39,120
I will need to change the
name of the method there.

387
00:20:39,120 --> 00:20:41,787
Took however many milliseconds.

388
00:20:43,441 --> 00:20:45,025
Now risk being very boring I'm going

389
00:20:45,025 --> 00:20:47,452
to also do the get book by ISBN method

390
00:20:47,452 --> 00:20:51,207
because we are calling
out from the clients,

391
00:20:51,207 --> 00:20:54,040
so if you can stand watching this,

392
00:20:55,236 --> 00:20:58,736
I'm going to do the starting of the clock,

393
00:21:04,161 --> 00:21:08,328
and I'm going to call the
original service ISBN method

394
00:21:13,303 --> 00:21:16,553
and then same as before, stop the clock

395
00:21:19,237 --> 00:21:21,404
and return the found book.

396
00:21:24,457 --> 00:21:26,807
I change the name of the method there.

397
00:21:26,807 --> 00:21:29,122
As I mentioned earlier, because this might

398
00:21:29,122 --> 00:21:32,078
throw an exception on this line here,

399
00:21:32,078 --> 00:21:34,903
but I would still like
the timing to happen,

400
00:21:34,903 --> 00:21:38,051
I'm going to make this a try block,

401
00:21:38,051 --> 00:21:40,663
where Im going to try to find the book

402
00:21:40,663 --> 00:21:44,163
and indeed I'm going to try to return it.

403
00:21:45,660 --> 00:21:47,971
But finally regardless of whether

404
00:21:47,971 --> 00:21:52,054
that works or not, just
before we do the return,

405
00:21:53,561 --> 00:21:57,226
I want to help with
the timing information.

406
00:21:57,226 --> 00:21:59,294
Obviously it's not good that I'm copying

407
00:21:59,294 --> 00:22:01,090
and pasting here in this proxy

408
00:22:01,090 --> 00:22:04,436
class does not look good at all.

409
00:22:04,436 --> 00:22:06,138
But I want to remind you that the

410
00:22:06,138 --> 00:22:08,450
big benefit now is that the

411
00:22:08,450 --> 00:22:11,200
production service is untouched.

412
00:22:12,740 --> 00:22:16,209
So this is a better
approach than last time.

413
00:22:16,209 --> 00:22:18,555
Still not perfect, I'm afraid.

414
00:22:18,555 --> 00:22:20,522
I'm still going to have to do lot

415
00:22:20,522 --> 00:22:22,589
of copying and pasting.

416
00:22:22,589 --> 00:22:26,491
We'll see how we can
improve that in a moment.

417
00:22:26,491 --> 00:22:28,236
Let's get this running.

418
00:22:28,236 --> 00:22:31,195
Were going to need to do
some Spring framework here.

419
00:22:31,195 --> 00:22:33,209
At the moment, the client is looking

420
00:22:33,209 --> 00:22:35,869
up the book service, which is configured

421
00:22:35,869 --> 00:22:38,600
in the Spring XML to be the production

422
00:22:38,600 --> 00:22:40,757
implementation of the book service,

423
00:22:40,757 --> 00:22:44,976
which at present, has
no timing information.

424
00:22:44,976 --> 00:22:47,726
So we'll need to go into the XML.

425
00:22:49,969 --> 00:22:53,494
I want to make sure that
the client is calling

426
00:22:53,494 --> 00:22:57,782
the proxy instead of calling
the book service directly.

427
00:22:57,782 --> 00:23:01,236
So what I'm going to do here in the XML.

428
00:23:01,236 --> 00:23:05,226
Im going to add a new
section here because

429
00:23:05,226 --> 00:23:08,666
really this isn't the service beam.

430
00:23:08,666 --> 00:23:11,960
I'll call this the timing beam.

431
00:23:11,960 --> 00:23:14,574
And we need to give it an ID.

432
00:23:14,574 --> 00:23:18,491
Ill call this the timing
proxy, and the class

433
00:23:21,951 --> 00:23:25,951
is call it virtual
programmers.Avalon.services.

434
00:23:33,848 --> 00:23:37,265
And I need the book service timing proxy.

435
00:23:39,950 --> 00:23:42,037
Now the important thing about this proxy

436
00:23:42,037 --> 00:23:46,919
is it's going to be calling
the original book service.

437
00:23:46,919 --> 00:23:48,608
Remember the original book service

438
00:23:48,608 --> 00:23:51,878
is a dependency of this proxy.

439
00:23:51,878 --> 00:23:53,776
So we're going to need to pass it in

440
00:23:53,776 --> 00:23:56,919
using dependency injection.

441
00:23:56,919 --> 00:24:00,182
Now at the moment in the proxy,

442
00:24:00,182 --> 00:24:03,713
I just declared the
attribute, but I haven't

443
00:24:03,713 --> 00:24:06,523
provided a way of injecting it.

444
00:24:06,523 --> 00:24:08,708
Now up until now, I've been using

445
00:24:08,708 --> 00:24:11,755
constructs an injection throughout.

446
00:24:11,755 --> 00:24:15,271
But I just feel in this
case I want to be sort

447
00:24:15,271 --> 00:24:18,725
of descriptive in the Spring XML.

448
00:24:18,725 --> 00:24:20,754
So I'm going to change a little bit here

449
00:24:20,754 --> 00:24:23,486
and I'm going to provide a setter method

450
00:24:23,486 --> 00:24:28,279
and I'm going to call this
the set original book service.

451
00:24:28,279 --> 00:24:32,446
This is going to take in any
instance of a book service,

452
00:24:34,070 --> 00:24:37,737
call this original and
all we need to do is

453
00:24:41,920 --> 00:24:46,087
store away whatever has been
injected in that attribute.

454
00:24:48,424 --> 00:24:52,507
So now, that becomes the
property of this proxy,

455
00:24:53,483 --> 00:24:56,983
the name of the property will be not set,

456
00:24:58,544 --> 00:25:02,377
but original book service
with a lowercase O.

457
00:25:08,389 --> 00:25:11,361
And were referring to an existing beam,

458
00:25:11,361 --> 00:25:15,393
and that's going to be the book service,

459
00:25:15,393 --> 00:25:18,093
the original book service.

460
00:25:18,093 --> 00:25:20,821
Now Ive said several times on the course

461
00:25:20,821 --> 00:25:24,303
that I preferred constructing
injection these days,

462
00:25:24,303 --> 00:25:28,000
one advantage of the
slightly more old-fashioned

463
00:25:28,000 --> 00:25:32,571
setter injection is that
when you're reading this,

464
00:25:32,571 --> 00:25:34,990
you can see what the
name of the property is,

465
00:25:34,990 --> 00:25:37,960
and just kind of I think
it makes it a little

466
00:25:37,960 --> 00:25:40,701
bit more obvious what's going on.

467
00:25:40,701 --> 00:25:42,703
Well I hope it's fairly
obvious to you this is quite

468
00:25:42,703 --> 00:25:45,765
complicated but we got all these beams

469
00:25:45,765 --> 00:25:48,647
calling each other in long chains.

470
00:25:48,647 --> 00:25:52,500
Of course we can look
at the Spring Explorer

471
00:25:52,500 --> 00:25:55,278
and get the dependency graph.

472
00:25:55,278 --> 00:25:58,038
Might look little bit
complicated but what were saying

473
00:25:58,038 --> 00:26:02,205
is now the client is going
to access the timing proxy

474
00:26:03,310 --> 00:26:05,794
which is going to the timing code,

475
00:26:05,794 --> 00:26:09,450
but the timing proxy
delegates to the book service,

476
00:26:09,450 --> 00:26:12,085
which delegates down
to all the other layers

477
00:26:12,085 --> 00:26:15,606
that we configured earlier in the course.

478
00:26:15,606 --> 00:26:18,787
Looks like this is well-connected,
of course when we go

479
00:26:18,787 --> 00:26:22,192
a little further with this, we
also want purchasing service

480
00:26:22,192 --> 00:26:25,091
and the account service to have a proxy.

481
00:26:25,091 --> 00:26:29,091
But well worry about
that in the next chapter.

482
00:26:30,713 --> 00:26:33,635
We have a little bit of a
problem because at the moment

483
00:26:33,635 --> 00:26:37,099
the client is looking up when using

484
00:26:37,099 --> 00:26:39,466
this version of the gapping method.

485
00:26:39,466 --> 00:26:42,141
This was present in the
original version of Spring,

486
00:26:42,141 --> 00:26:44,688
and I didn't do this on the
first edition of course,

487
00:26:44,688 --> 00:26:48,425
but I'm just saying get
the book service class.

488
00:26:48,425 --> 00:26:51,482
The problem is now we've
got two implementations

489
00:26:51,482 --> 00:26:54,952
of the book service interface,
so you're find now that

490
00:26:54,952 --> 00:26:58,869
when we run the client,
yeah we get a crash and

491
00:27:01,825 --> 00:27:04,492
its because no qualifying beam

492
00:27:05,760 --> 00:27:08,578
of type book service is defined.

493
00:27:08,578 --> 00:27:12,959
We expected a single matching
beam, but two were found.

494
00:27:12,959 --> 00:27:15,040
So Spring is saying well
I don't know if the client

495
00:27:15,040 --> 00:27:18,873
wants the timing or the
original book service.

496
00:27:20,951 --> 00:27:23,793
So I'll come back to that in
a moment, but it strikes me

497
00:27:23,793 --> 00:27:26,565
that this does give us a
little bit of flexibility

498
00:27:26,565 --> 00:27:28,693
that if we switch to the alternative

499
00:27:28,693 --> 00:27:31,327
version of the get beam method.

500
00:27:31,327 --> 00:27:34,334
This is one where we can specify the ID

501
00:27:34,334 --> 00:27:36,326
that we want to work with.

502
00:27:36,326 --> 00:27:38,993
We could use the book service ID

503
00:27:41,069 --> 00:27:45,350
if we want to run the
client with no timing.

504
00:27:45,350 --> 00:27:48,176
This version does need to second parameter

505
00:27:48,176 --> 00:27:51,155
and that's the name or a reference

506
00:27:51,155 --> 00:27:54,938
to the interface that
the class implements.

507
00:27:54,938 --> 00:27:58,735
That's just so we don't
have to do a typecast.

508
00:27:58,735 --> 00:28:01,276
So I quite like this
because it means if we

509
00:28:01,276 --> 00:28:05,443
were a client like this,
we're going to get no timing,

510
00:28:08,870 --> 00:28:12,203
but now if we want to, we can switch it,

511
00:28:13,954 --> 00:28:18,014
we can use this alternative idea instead,

512
00:28:18,014 --> 00:28:21,764
the timing proxy, and
if we run this version,

513
00:28:27,671 --> 00:28:31,135
very nice, we now get
the timing information.

514
00:28:31,135 --> 00:28:33,500
Now thats OK, you might
be a little disappointed

515
00:28:33,500 --> 00:28:35,711
that for the first time on this course

516
00:28:35,711 --> 00:28:38,770
we had to change the client code.

517
00:28:38,770 --> 00:28:41,861
And I'm going to need to
change the client code

518
00:28:41,861 --> 00:28:45,444
every time we switch
the timing on and off.

519
00:28:48,145 --> 00:28:51,012
Now there is an alternative
way of doing this,

520
00:28:51,012 --> 00:28:54,196
and this is what I did on the
first edition of the course.

521
00:28:54,196 --> 00:28:56,373
It does mean we always have to use

522
00:28:56,373 --> 00:28:59,540
the ID rather than the old just get us

523
00:29:00,533 --> 00:29:03,107
any book service implementation.

524
00:29:03,107 --> 00:29:05,082
So Ive changed the client code now

525
00:29:05,082 --> 00:29:07,158
to just look up book service book.

526
00:29:07,158 --> 00:29:11,106
But I'm not going to
change the code again.

527
00:29:11,106 --> 00:29:15,273
Moments of course it's
going to give us no timing,

528
00:29:17,318 --> 00:29:19,438
but what we could do if we want to switch

529
00:29:19,438 --> 00:29:22,309
the timing gone, but
we don't want to change

530
00:29:22,309 --> 00:29:25,073
the clients, we could just do some

531
00:29:25,073 --> 00:29:27,656
nifty rewiring here in the XML.

532
00:29:29,073 --> 00:29:31,094
It's not too difficult.

533
00:29:31,094 --> 00:29:34,393
Going to change the IDs of the beams.

534
00:29:34,393 --> 00:29:38,560
Our timing beam I'm going
to rename as book service.

535
00:29:39,774 --> 00:29:43,021
So now the client will get this beam,

536
00:29:43,021 --> 00:29:45,034
but I'm going to change the name

537
00:29:45,034 --> 00:29:49,631
of the other beam to book
service I don't know,

538
00:29:49,631 --> 00:29:51,348
well call it original.

539
00:29:51,348 --> 00:29:53,996
Actually you'll find some projects

540
00:29:53,996 --> 00:29:56,746
like to call these beams targets.

541
00:29:58,206 --> 00:30:00,195
So Im going to go with that.

542
00:30:00,195 --> 00:30:03,268
I quite like that terminology
because it suggests

543
00:30:03,268 --> 00:30:06,942
that this is the ultimate
target of the clients call

544
00:30:06,942 --> 00:30:11,109
but it's not beam that the
client directly looks up.

545
00:30:12,349 --> 00:30:16,057
Now for this timing beam, the object that

546
00:30:16,057 --> 00:30:19,974
were injecting is now
this is this beam here.

547
00:30:21,189 --> 00:30:25,338
Has a different ID, so I
need to change the ID there.

548
00:30:25,338 --> 00:30:27,391
Now what I've done there is Ive just

549
00:30:27,391 --> 00:30:29,984
changed the configuration file.

550
00:30:29,984 --> 00:30:32,707
I don't need to do a re-compilation.

551
00:30:32,707 --> 00:30:35,503
I don't have to change the clients.

552
00:30:35,503 --> 00:30:38,670
But now, the timing information is on.

553
00:30:41,451 --> 00:30:43,452
I think that's quite powerful.

554
00:30:43,452 --> 00:30:47,581
The fact that I can
figuratively switch the timing

555
00:30:47,581 --> 00:30:51,873
on and off with no
compilations of the code.

556
00:30:51,873 --> 00:30:56,066
That's a great payoff
from using a container.

557
00:30:56,066 --> 00:30:59,512
Thats all very well, but I'm
still feeling some pain here

558
00:30:59,512 --> 00:31:02,195
and I hope you are as well.

559
00:31:02,195 --> 00:31:06,217
If I go to my proxy, I'm still not happy

560
00:31:06,217 --> 00:31:09,776
with this of course
because as I've mentioned,

561
00:31:09,776 --> 00:31:12,828
I've got to do the same
thing time and time

562
00:31:12,828 --> 00:31:17,207
and time again, lots of
copy and paste coding here,

563
00:31:17,207 --> 00:31:19,957
and every time I add a new method

564
00:31:21,040 --> 00:31:24,582
to the book service
interface, I'm going to have

565
00:31:24,582 --> 00:31:29,517
to add a new method implementation
to the timing proxy.

566
00:31:29,517 --> 00:31:33,074
That's not ideal but
also because I'm going

567
00:31:33,074 --> 00:31:36,265
to have to do this for every single one

568
00:31:36,265 --> 00:31:38,425
of the service classes that I

569
00:31:38,425 --> 00:31:40,425
want to apply timing to.

570
00:31:41,498 --> 00:31:44,165
It would be wonderful if somehow

571
00:31:45,969 --> 00:31:49,808
I didn't have to write this proxy class.

572
00:31:49,808 --> 00:31:53,725
I could ask Java to
automatically generate it.

573
00:31:55,761 --> 00:31:58,559
That might sound quite fanciful

574
00:31:58,559 --> 00:32:00,481
I don't know if you know this,

575
00:32:00,481 --> 00:32:03,716
but there is a way in standard Java.

576
00:32:03,716 --> 00:32:07,194
Since Java one point three, so many many

577
00:32:07,194 --> 00:32:09,624
years ago this was added.

578
00:32:09,624 --> 00:32:13,715
It's called a dynamic
proxy, and a dynamic proxy

579
00:32:13,715 --> 00:32:16,567
can indeed automatically generate

580
00:32:16,567 --> 00:32:19,131
a proxy class for you.

581
00:32:19,131 --> 00:32:20,676
Now, if you're interested in this,

582
00:32:20,676 --> 00:32:23,285
you can check on the web,
you can do a Google search,

583
00:32:23,285 --> 00:32:25,870
of course, for dynamic proxy classes.

584
00:32:25,870 --> 00:32:28,112
The URL you can see here, I guess,

585
00:32:28,112 --> 00:32:31,195
it is part of the official Java docs,

586
00:32:32,160 --> 00:32:34,386
and on the first edition of the course,

587
00:32:34,386 --> 00:32:37,440
I showed you this page, and it was

588
00:32:37,440 --> 00:32:39,152
one of the Java.sun pages.

589
00:32:39,152 --> 00:32:42,479
And unfortunately Oracle
changed all of the URLs,

590
00:32:42,479 --> 00:32:44,611
so I can't guarantee that this page

591
00:32:44,611 --> 00:32:48,152
will still even exist when
you watch this course.

592
00:32:48,152 --> 00:32:49,817
But there are lots of good tutorials

593
00:32:49,817 --> 00:32:53,082
available on the web, and the idea behind

594
00:32:53,082 --> 00:32:55,982
the dominant dynamic process that Java

595
00:32:55,982 --> 00:32:59,377
will implement the
complete interface for you.

596
00:32:59,377 --> 00:33:03,809
So even if you have 127
methods in your interface,

597
00:33:03,809 --> 00:33:07,726
Java will generate 127
implementation methods.

598
00:33:08,934 --> 00:33:12,142
All you have to do is
give Java the payload,

599
00:33:12,142 --> 00:33:14,809
and by payload I mean the start

600
00:33:16,353 --> 00:33:18,937
the clock and stop the clock.

601
00:33:18,937 --> 00:33:21,453
And Java will go ahead
and automatically wrap

602
00:33:21,453 --> 00:33:25,620
that around all 120, however
many I said, methods.

603
00:33:26,836 --> 00:33:28,850
Now we could do this right now,

604
00:33:28,850 --> 00:33:31,396
and we could do all of
this in standard Java

605
00:33:31,396 --> 00:33:34,104
without using any Spring.

606
00:33:34,104 --> 00:33:36,501
But I must admit that dynamic processing

607
00:33:36,501 --> 00:33:39,631
Java are a little bit
difficult to work with.

608
00:33:39,631 --> 00:33:42,464
I would call them an advanced technique.

609
00:33:42,464 --> 00:33:44,948
Don't let me put you off
it is a good technique

610
00:33:44,948 --> 00:33:48,118
for automatically
generating that proxy class.

611
00:33:48,118 --> 00:33:52,956
But I just wanted you to
be aware that this exists,

612
00:33:52,956 --> 00:33:55,869
because in the next chapter we're going to

613
00:33:55,869 --> 00:33:58,732
see that Spring has already used

614
00:33:58,732 --> 00:34:01,732
these dynamic proxy classes for us.

615
00:34:02,927 --> 00:34:04,681
Spring will hide them away.

616
00:34:04,681 --> 00:34:06,992
We don't really need to worry about

617
00:34:06,992 --> 00:34:09,726
the details of how they work.

618
00:34:09,726 --> 00:34:12,649
Spring will generate
the proxy for us using

619
00:34:12,649 --> 00:34:16,156
some fairly simple configuration.

620
00:34:16,156 --> 00:34:19,556
However, I believe as
a Spring professional,

621
00:34:19,556 --> 00:34:21,874
you need to understand that it's these

622
00:34:21,874 --> 00:34:25,374
dynamic proxies that Spring is generating.

623
00:34:26,946 --> 00:34:31,539
And I also wanted you to
be aware of the term proxy.

624
00:34:31,539 --> 00:34:36,178
Proxy is a very standard
common design pattern.

625
00:34:36,178 --> 00:34:38,511
And it's called the proxy, by the way,

626
00:34:38,511 --> 00:34:40,755
because this proxy we've written,

627
00:34:40,755 --> 00:34:44,422
its timing is a stand-in
for the real class

628
00:34:45,644 --> 00:34:47,792
that we're really working with.

629
00:34:47,792 --> 00:34:51,679
And a proxy in regular
English means exactly that.

630
00:34:51,679 --> 00:34:53,484
It means a stand-in.

631
00:34:53,484 --> 00:34:55,529
A class thats pretending to be

632
00:34:55,529 --> 00:34:58,779
the target class, but it isn't really.

633
00:34:59,663 --> 00:35:01,727
So the important thing
is that you understand

634
00:35:01,727 --> 00:35:04,906
the term proxy, you know
they can't be generated

635
00:35:04,906 --> 00:35:07,645
using standard Java, and that Spring is

636
00:35:07,645 --> 00:35:11,620
going to do that for
us in the next chapter.

637
00:35:11,620 --> 00:35:13,851
That was just an overview.

638
00:35:13,851 --> 00:35:16,333
We haven't done any real AOP yet,

639
00:35:16,333 --> 00:35:19,908
but I have shown you the
fundamental concepts.

640
00:35:19,908 --> 00:35:23,644
Some requirements, such as
our timing requirements,

641
00:35:23,644 --> 00:35:27,923
can't be handled by changing
a single method in a class.

642
00:35:27,923 --> 00:35:31,303
A requirement cuts across an entire layer

643
00:35:31,303 --> 00:35:33,464
a service layer in this case,

644
00:35:33,464 --> 00:35:36,645
and we need a technique to handle it.

645
00:35:36,645 --> 00:35:40,368
The proxy pattern gets
some of the way there.

646
00:35:40,368 --> 00:35:43,090
The proxy enabled us to
put all of our timing

647
00:35:43,090 --> 00:35:45,590
into a single class, a proxy.

648
00:35:46,565 --> 00:35:48,002
And because the proxy has the same

649
00:35:48,002 --> 00:35:51,233
interface as the target,
we can switch between

650
00:35:51,233 --> 00:35:53,460
the proxy and the target without

651
00:35:53,460 --> 00:35:57,082
changing the client, and thats elegant.

652
00:35:57,082 --> 00:35:59,829
One area of ugliness remains.

653
00:35:59,829 --> 00:36:02,715
A proxy is hard to write.

654
00:36:02,715 --> 00:36:04,985
But Java has a solution.

655
00:36:04,985 --> 00:36:08,174
Dynamic proxies can be
generated at runtime.

656
00:36:08,174 --> 00:36:10,798
And even if you have hundreds of methods,

657
00:36:10,798 --> 00:36:13,232
you only have to supply the payload,

658
00:36:13,232 --> 00:36:17,785
and Java generates those
hundreds of proxy methods.

659
00:36:17,785 --> 00:36:19,985
However, were not going to use a dynamic

660
00:36:19,985 --> 00:36:22,729
proxy directly on this
course because Spring

661
00:36:22,729 --> 00:36:24,973
already does that for us.

662
00:36:24,973 --> 00:36:28,890
Spring features an AOP
framework ready to use.

663
00:36:29,900 --> 00:36:34,340
And it uses this framework
for lots of other features.

664
00:36:34,340 --> 00:36:38,007
Most importantly, would
be for transactions.

665
00:36:38,902 --> 00:36:42,217
As well see later, transactions
are another requirement

666
00:36:42,217 --> 00:36:45,217
that cuts across our entire system.

667
00:36:46,486 --> 00:36:48,508
So join me in the next chapter,

668
00:36:48,508 --> 00:36:52,341
where well see Spring
AOP in action for real.

1
00:00:10,160 --> 00:00:11,550
- [Voiceover] Welcome back.

2
00:00:11,550 --> 00:00:13,729
We've got the basics of AOP.

3
00:00:13,729 --> 00:00:17,428
Now we'll see how to do it in Spring.

4
00:00:17,428 --> 00:00:18,863
I'll start by showing you

5
00:00:18,863 --> 00:00:20,983
three different types of advice

6
00:00:20,983 --> 00:00:25,351
called before, after, and around.

7
00:00:25,351 --> 00:00:29,531
There are two ways of
making Spring AOP work.

8
00:00:29,531 --> 00:00:31,709
There's the old-fashioned way.

9
00:00:31,709 --> 00:00:34,449
I'm calling it the "Old School" way,

10
00:00:34,449 --> 00:00:36,589
which is to write some XML

11
00:00:36,589 --> 00:00:39,969
to ask Spring to generate a proxy.

12
00:00:39,969 --> 00:00:41,969
It's quite easy to do it,

13
00:00:41,969 --> 00:00:44,649
but it isn't very flexible.

14
00:00:44,649 --> 00:00:47,709
For that reason, this XML
approach is considered

15
00:00:47,709 --> 00:00:50,089
a legacy approach.

16
00:00:50,089 --> 00:00:53,369
It's still worth studying it though

17
00:00:53,369 --> 00:00:56,849
because it helps you to
understand what's going on.

18
00:00:56,849 --> 00:00:59,029
And some projects still use it

19
00:00:59,029 --> 00:01:02,289
so it is worth looking at.

20
00:01:02,289 --> 00:01:05,069
But the second of making it work

21
00:01:05,069 --> 00:01:06,529
is much more powerful,

22
00:01:06,529 --> 00:01:09,577
but we'll wait until the
next chapter for that.

23
00:01:12,327 --> 00:01:14,207
So we saw in the previous chapter

24
00:01:14,207 --> 00:01:16,567
that sometimes we have requirements

25
00:01:16,567 --> 00:01:20,027
that impact more than one method

26
00:01:20,027 --> 00:01:23,367
on more than one class.

27
00:01:23,367 --> 00:01:25,767
Now we're currently using the example

28
00:01:25,767 --> 00:01:27,828
of a performance timer.

29
00:01:27,828 --> 00:01:29,927
But we're going to see later

30
00:01:29,927 --> 00:01:31,227
as we go through the course,

31
00:01:31,227 --> 00:01:35,265
that there are lots of
these kinds of requirements.

32
00:01:35,265 --> 00:01:38,804
Transactions for instance are one of them.

33
00:01:38,804 --> 00:01:40,665
Now, for course, Spring needs to support

34
00:01:40,665 --> 00:01:42,265
these requirements.

35
00:01:42,265 --> 00:01:45,665
So we need an elegant way to solve them.

36
00:01:45,665 --> 00:01:47,165
And we saw previously that

37
00:01:47,165 --> 00:01:49,685
using regular object orientation,

38
00:01:49,685 --> 00:01:53,825
just classes and objects and methods,

39
00:01:53,825 --> 00:01:58,145
really leads to lots of
copying and pasting of code

40
00:01:58,145 --> 00:02:00,105
when we have these requirements

41
00:02:00,105 --> 00:02:02,966
that cut across more than one class.

42
00:02:02,966 --> 00:02:06,826
So we saw the proxy design pattern,

43
00:02:06,826 --> 00:02:09,526
that certainly helped.

44
00:02:09,526 --> 00:02:11,145
But the problem that we hit

45
00:02:11,145 --> 00:02:13,926
was that writing the proxy manually

46
00:02:13,926 --> 00:02:16,845
is very, very tedious.

47
00:02:16,845 --> 00:02:19,646
It is possible to use dynamic proxies

48
00:02:19,646 --> 00:02:22,106
from the Java library.

49
00:02:22,106 --> 00:02:25,625
But these are kind of difficult to use.

50
00:02:25,625 --> 00:02:27,945
But we don't need to go that far.

51
00:02:27,945 --> 00:02:29,945
Spring has support for this kind of

52
00:02:29,945 --> 00:02:32,845
requirement built in,
and the main thing that

53
00:02:32,845 --> 00:02:34,873
we're going to see in this chapter,

54
00:02:34,873 --> 00:02:37,533
is that Spring can automatically

55
00:02:37,533 --> 00:02:41,948
generate proxies with
just a little bit of XML.

56
00:02:43,099 --> 00:02:45,819
Now there is a lot of jargon in AOP

57
00:02:45,819 --> 00:02:47,158
but don't worry.

58
00:02:47,158 --> 00:02:48,218
Throughout this chapter,

59
00:02:48,218 --> 00:02:50,411
I'll explain enough of these terms

60
00:02:50,411 --> 00:02:54,312
to make you sound like an expert in AOP.

61
00:02:54,312 --> 00:02:55,972
And we'll begin by looking at how

62
00:02:55,972 --> 00:02:58,512
we could implement our performance timer

63
00:02:58,512 --> 00:03:00,872
using Spring AOP.

64
00:03:00,872 --> 00:03:03,652
Now the example that we're looking at

65
00:03:03,652 --> 00:03:05,592
with performance timing

66
00:03:05,592 --> 00:03:08,672
is not the only kind of requirement

67
00:03:08,672 --> 00:03:11,092
that tends to impact more than one class

68
00:03:11,092 --> 00:03:13,371
in your application.

69
00:03:13,371 --> 00:03:16,692
If we're to look at
transactions, for instance,

70
00:03:16,692 --> 00:03:19,012
and that's coming up
very soon in the course,

71
00:03:19,012 --> 00:03:22,392
it's something we really
need to deal with soon,

72
00:03:22,392 --> 00:03:25,891
it is an essential feature of Spring.

73
00:03:25,891 --> 00:03:29,550
Now we often want to take entire classes

74
00:03:29,550 --> 00:03:32,311
and apply transaction management to them

75
00:03:32,311 --> 00:03:33,790
without needing to put in

76
00:03:33,790 --> 00:03:37,491
commits and rollbacks manually.

77
00:03:37,491 --> 00:03:40,350
Similarly security.

78
00:03:40,350 --> 00:03:42,061
What if you want to make sure that

79
00:03:42,061 --> 00:03:44,251
somebody is logged in

80
00:03:44,251 --> 00:03:48,981
before they can call any of
the service level methods?

81
00:03:48,981 --> 00:03:52,281
Well, without AOP, we would have

82
00:03:52,281 --> 00:03:56,521
the tedious job of having to
go into every service class,

83
00:03:56,521 --> 00:03:58,561
looking inside every method,

84
00:03:58,561 --> 00:04:02,281
and putting security checks in them.

85
00:04:02,281 --> 00:04:03,860
Now the performance timing advice

86
00:04:03,860 --> 00:04:06,460
that we're working on in this chapter

87
00:04:06,460 --> 00:04:08,797
is really just a special case of

88
00:04:08,797 --> 00:04:11,678
the general requirements of auditing,

89
00:04:11,678 --> 00:04:15,538
and that's another good use of AOP.

90
00:04:15,538 --> 00:04:18,677
And also some forms of logging

91
00:04:18,677 --> 00:04:20,498
fall into this banner.

92
00:04:20,498 --> 00:04:22,078
Not all logging.

93
00:04:22,078 --> 00:04:23,717
We often need to do

94
00:04:23,717 --> 00:04:25,178
logging for debugging.

95
00:04:25,178 --> 00:04:26,878
But there are some forms of logging

96
00:04:26,878 --> 00:04:30,357
that cut across the entire system.

97
00:04:30,357 --> 00:04:33,138
So that's what AOP is for.

98
00:04:33,138 --> 00:04:35,998
It handles any type of requirement,

99
00:04:35,998 --> 00:04:37,557
which are going to cut across

100
00:04:37,557 --> 00:04:39,397
more than one class,

101
00:04:39,397 --> 00:04:43,637
and potentially, might cut
across your entire system.

102
00:04:43,637 --> 00:04:45,678
In the example we've been looking at,

103
00:04:45,678 --> 00:04:48,375
we've had a variety of services.

104
00:04:48,375 --> 00:04:51,395
Our BookService, our Purchasing Service,

105
00:04:51,395 --> 00:04:53,755
and our Ordering Service.

106
00:04:53,755 --> 00:04:55,654
Now, I've been trying to add

107
00:04:55,654 --> 00:04:59,434
performance monitoring into one

108
00:04:59,434 --> 00:05:02,834
or more of those services.

109
00:05:02,834 --> 00:05:05,514
Now I certainly do not want to have to go

110
00:05:05,514 --> 00:05:09,274
into any of these three service classes

111
00:05:09,274 --> 00:05:13,093
and modify any of the
code that I have in there

112
00:05:13,093 --> 00:05:14,914
because that's all working.

113
00:05:14,914 --> 00:05:17,934
It's tested and it's fine.

114
00:05:17,934 --> 00:05:20,133
I need somehow to be able to write

115
00:05:20,133 --> 00:05:22,394
my performance monitoring code

116
00:05:22,394 --> 00:05:24,693
in one single class,

117
00:05:24,693 --> 00:05:28,834
and to only have to do it once.

118
00:05:28,834 --> 00:05:31,554
I'd then like, somehow,

119
00:05:31,554 --> 00:05:35,294
to be able to take that
performance monitoring code

120
00:05:35,294 --> 00:05:38,214
and to apply it to one

121
00:05:38,214 --> 00:05:42,894
or potentially more than one service

122
00:05:42,894 --> 00:05:47,483
without any of those service
classes being affected.

123
00:05:47,483 --> 00:05:51,343
And then in the future,
there will be other aspects

124
00:05:51,343 --> 00:05:55,444
of the system, such as security

125
00:05:55,444 --> 00:05:58,724
that I might need to apply as well.

126
00:05:58,724 --> 00:06:01,144
As I've said many times now,

127
00:06:01,144 --> 00:06:05,404
in object orientation with
just classes and methods,

128
00:06:05,404 --> 00:06:09,103
this kind of requirement
isn't well supported.

129
00:06:09,103 --> 00:06:11,662
So what can we do when we have behavior

130
00:06:11,662 --> 00:06:14,362
spreading across more than one method

131
00:06:14,362 --> 00:06:16,781
and more than one class?

132
00:06:16,781 --> 00:06:18,481
Now I showed you in the previous chapter

133
00:06:18,481 --> 00:06:20,462
that we could do that using a proxy

134
00:06:20,462 --> 00:06:23,361
but I stalled a little bit when I realized

135
00:06:23,361 --> 00:06:26,062
we needed some advanced Java

136
00:06:26,062 --> 00:06:29,722
to automatically generate proxies.

137
00:06:29,722 --> 00:06:32,640
This is where AOP

138
00:06:32,640 --> 00:06:35,501
or aspect oriented programming

139
00:06:35,501 --> 00:06:37,560
comes in.

140
00:06:37,560 --> 00:06:39,200
It's important to remember that

141
00:06:39,200 --> 00:06:43,000
aspect oriented programming
does not, in any way,

142
00:06:43,000 --> 00:06:46,259
replace object oriented programming.

143
00:06:46,259 --> 00:06:48,139
We'd still write our BookSevice,

144
00:06:48,139 --> 00:06:49,278
our Publishing Service,

145
00:06:49,278 --> 00:06:51,259
our Ordering Service,

146
00:06:51,259 --> 00:06:53,879
and all of the related domain models

147
00:06:53,879 --> 00:06:56,999
and data access objects, and so on,

148
00:06:56,999 --> 00:07:00,179
using the standard object
oriented programming

149
00:07:00,179 --> 00:07:02,459
that we know and love.

150
00:07:02,459 --> 00:07:05,959
AOP is a layer on top,

151
00:07:05,959 --> 00:07:08,239
which enables us to somehow do this

152
00:07:08,239 --> 00:07:11,439
weaving that we've seen here,

153
00:07:11,439 --> 00:07:13,539
where we've introduced

154
00:07:13,539 --> 00:07:17,479
performance monitoring security and so on.

155
00:07:17,479 --> 00:07:19,299
And we can't do it in standard Java,

156
00:07:19,299 --> 00:07:22,218
or at least, without getting
into some advanced topics

157
00:07:22,218 --> 00:07:24,559
such as dynamic proxies.

158
00:07:24,559 --> 00:07:26,499
Now what happened over the last few years

159
00:07:26,499 --> 00:07:28,378
of the Java industry is that

160
00:07:28,378 --> 00:07:31,479
frameworks have emerged to allow us

161
00:07:31,479 --> 00:07:33,818
to do this style of programming.

162
00:07:33,818 --> 00:07:37,679
The market leader in
aspect oriented programming

163
00:07:37,679 --> 00:07:40,439
would probably be the framework called

164
00:07:40,439 --> 00:07:42,839
AspectJ.

165
00:07:42,839 --> 00:07:45,679
This one has been around
for a long time now

166
00:07:45,679 --> 00:07:49,418
and really, anything that you can think of

167
00:07:49,418 --> 00:07:53,338
in AOP, you can do it in AspectJ.

168
00:07:53,338 --> 00:07:56,999
It's a really deep framework.

169
00:07:56,999 --> 00:07:59,438
It's a little bit complicated.

170
00:07:59,438 --> 00:08:02,999
In AspectJ, they use a special compiler,

171
00:08:02,999 --> 00:08:07,039
and you have to effectively
recompile your code

172
00:08:07,039 --> 00:08:08,719
with the extra code for

173
00:08:08,719 --> 00:08:12,559
the aspect you're working with added in.

174
00:08:12,559 --> 00:08:15,539
So AspectJ's really quite sophisticated

175
00:08:15,539 --> 00:08:18,559
but perhaps a little bit complicated.

176
00:08:18,559 --> 00:08:20,358
Another AOP framework,

177
00:08:20,358 --> 00:08:22,619
which has also been
around for a long time,

178
00:08:22,619 --> 00:08:25,019
is called JBoss AOP.

179
00:08:25,019 --> 00:08:28,559
Now that's part of the
JBoss Middleware Suite,

180
00:08:28,559 --> 00:08:30,539
and it is very, very good

181
00:08:30,539 --> 00:08:32,438
but it's specific to JBoss

182
00:08:32,438 --> 00:08:34,619
so I won't be talking about it anymore

183
00:08:34,619 --> 00:08:36,159
on this course.

184
00:08:36,159 --> 00:08:39,999
But it's interesting
to know that it exists.

185
00:08:39,999 --> 00:08:42,818
But Spring decided to add

186
00:08:42,818 --> 00:08:46,518
its own AOP library as well.

187
00:08:46,518 --> 00:08:48,838
Now why did they do that?

188
00:08:48,838 --> 00:08:50,238
Well, they've done it because

189
00:08:50,238 --> 00:08:53,618
so many things that they want to support

190
00:08:53,618 --> 00:08:56,217
such as transactions,

191
00:08:56,217 --> 00:08:59,397
security, and quite a few other things,

192
00:08:59,397 --> 00:09:02,796
really rely on AOP.

193
00:09:02,796 --> 00:09:04,197
They decided that,

194
00:09:04,197 --> 00:09:06,496
with AspectJ being a
little bit complicated,

195
00:09:06,496 --> 00:09:09,276
it would make sense if Spring had its own

196
00:09:09,276 --> 00:09:13,015
kind of simplified AOP library,

197
00:09:13,015 --> 00:09:15,556
one that's really easy to work with.

198
00:09:15,556 --> 00:09:16,576
It might not have all of

199
00:09:16,576 --> 00:09:19,636
the sophisticated features of AspectJ

200
00:09:19,636 --> 00:09:22,535
but it's simpler to use.

201
00:09:22,535 --> 00:09:25,555
There is quite a bit of jargon in AOP.

202
00:09:25,555 --> 00:09:26,636
Over the next few minutes,

203
00:09:26,636 --> 00:09:30,116
I'm going to introduce
you to the main AOP jargon

204
00:09:30,116 --> 00:09:31,316
that you're going find, really,

205
00:09:31,316 --> 00:09:34,496
in all of those AOP frameworks.

206
00:09:34,496 --> 00:09:36,596
And the first item of jargon

207
00:09:36,596 --> 00:09:40,836
would have to be the word "aspect."

208
00:09:40,836 --> 00:09:45,256
Now I have actually been using this jargon

209
00:09:45,256 --> 00:09:47,956
in the early parts of this chapter.

210
00:09:47,956 --> 00:09:50,856
And I've been using it,
the term, informally,

211
00:09:50,856 --> 00:09:54,196
just to describe, really literally,

212
00:09:54,196 --> 00:09:58,616
the aspects of the system
that we're talking about.

213
00:09:58,616 --> 00:10:01,476
So for the example that
we're working with,

214
00:10:01,476 --> 00:10:04,136
we want to introduce performance timing

215
00:10:04,136 --> 00:10:05,675
to our system.

216
00:10:05,675 --> 00:10:08,856
Well, that's the aspect.

217
00:10:08,856 --> 00:10:11,536
And so the other aspects
that we could deal with

218
00:10:11,536 --> 00:10:15,294
would be logging, transactions, security,

219
00:10:15,294 --> 00:10:18,034
auditing, and so on.

220
00:10:18,034 --> 00:10:20,594
The next item of jargon would be

221
00:10:20,594 --> 00:10:22,771
"advice."

222
00:10:22,771 --> 00:10:25,091
This is nothing more than the code

223
00:10:25,091 --> 00:10:29,071
that we want to run across
more than one class.

224
00:10:29,071 --> 00:10:32,811
In our example so far, the advice has been

225
00:10:32,811 --> 00:10:34,971
the performance timing.

226
00:10:34,971 --> 00:10:38,291
The starting and the
stopping of the clock.

227
00:10:38,291 --> 00:10:40,791
So in the jargon I would typically say,

228
00:10:40,791 --> 00:10:44,891
"I want to apply the
performance timing advice

229
00:10:44,891 --> 00:10:47,791
"to all of my service classes."

230
00:10:47,791 --> 00:10:52,270
The third item of jargon is "weaving."

231
00:10:52,270 --> 00:10:54,950
Alright, I really like this term.

232
00:10:54,950 --> 00:10:58,830
This is the process of taking that advice

233
00:10:58,830 --> 00:11:02,490
and mixing it in with the target code.

234
00:11:02,490 --> 00:11:04,929
Now we know that Java can't really do this

235
00:11:04,929 --> 00:11:07,429
out of the box, for free.

236
00:11:07,429 --> 00:11:11,609
So what we're looking for,
with any AOP framework,

237
00:11:11,609 --> 00:11:14,849
is the ability to mix together

238
00:11:14,849 --> 00:11:19,249
our advice with our original target code.

239
00:11:19,249 --> 00:11:20,888
As I've mentioned,

240
00:11:20,888 --> 00:11:23,888
AspectJ uses a special compiler

241
00:11:23,888 --> 00:11:25,688
to achieve the weaving,

242
00:11:25,688 --> 00:11:28,448
whereas Spring AOP uses

243
00:11:28,448 --> 00:11:32,527
regular Java dynamic proxies

244
00:11:32,527 --> 00:11:34,396
to achieve the weaving.

245
00:11:35,686 --> 00:11:39,105
Now, really, this animation
that I had before,

246
00:11:39,105 --> 00:11:42,885
where I took the
performance monitoring code

247
00:11:42,885 --> 00:11:45,625
and then I mixed it in with

248
00:11:45,625 --> 00:11:48,245
firstly, one of my service classes

249
00:11:48,245 --> 00:11:51,785
and then all of my service classes,

250
00:11:51,785 --> 00:11:55,125
that is the weaving.

251
00:11:55,125 --> 00:11:57,565
Now thinking of the advice,

252
00:11:57,565 --> 00:12:00,645
in Spring, there are three
or four different ways

253
00:12:00,645 --> 00:12:03,305
that we can apply the advice.

254
00:12:03,305 --> 00:12:05,325
Here's some more jargon.

255
00:12:05,325 --> 00:12:07,805
First of all, we have the concept of

256
00:12:07,805 --> 00:12:10,665
before advice.

257
00:12:10,665 --> 00:12:13,485
Now this would tell Spring

258
00:12:13,485 --> 00:12:15,660
to run the advice

259
00:12:15,660 --> 00:12:20,020
before the target code is invoked.

260
00:12:20,020 --> 00:12:21,779
And there are some requirements

261
00:12:21,779 --> 00:12:24,899
where we will only need to run the advice

262
00:12:24,899 --> 00:12:26,899
before the target code.

263
00:12:26,899 --> 00:12:30,819
For example, in security advice,

264
00:12:30,819 --> 00:12:32,199
you would want to,

265
00:12:32,199 --> 00:12:34,759
before the target code runs,

266
00:12:34,759 --> 00:12:37,639
check that the user is logged in.

267
00:12:37,639 --> 00:12:39,699
And only if they're logged in,

268
00:12:39,699 --> 00:12:42,519
would we let the target code run.

269
00:12:42,519 --> 00:12:45,399
So that's before advice.

270
00:12:45,399 --> 00:12:48,899
You can probably guess
that the other style

271
00:12:48,899 --> 00:12:52,518
is called after advice.

272
00:12:52,518 --> 00:12:55,278
Now in this case, the advice will run

273
00:12:55,278 --> 00:12:58,009
after the target code.

274
00:12:58,009 --> 00:12:59,329
I'm sure you can think of

275
00:12:59,329 --> 00:13:02,008
a few uses for that.

276
00:13:02,008 --> 00:13:04,568
The third type of advice,

277
00:13:04,568 --> 00:13:06,429
perhaps the most useful,

278
00:13:06,429 --> 00:13:09,649
is really, a mix of the two.

279
00:13:09,649 --> 00:13:12,789
It's called around advice.

280
00:13:12,789 --> 00:13:15,089
And this means that some advice will run

281
00:13:15,089 --> 00:13:18,489
before the target method runs.

282
00:13:18,489 --> 00:13:21,629
Then the target method will run.

283
00:13:21,629 --> 00:13:25,169
And then some more advice will run

284
00:13:25,169 --> 00:13:27,608
at the end of the process.

285
00:13:27,608 --> 00:13:29,848
Now this is exactly what we need

286
00:13:29,848 --> 00:13:32,549
for our performance monitoring.

287
00:13:32,549 --> 00:13:35,029
We need to start the clock,

288
00:13:35,029 --> 00:13:37,329
then do the target code,

289
00:13:37,329 --> 00:13:41,528
and then stop the clock and report back.

290
00:13:41,528 --> 00:13:45,769
So what we're looking
for is around advice.

291
00:13:45,769 --> 00:13:47,291
Now it's just that

292
00:13:47,291 --> 00:13:50,671
around advice is slightly
more complicated to do

293
00:13:50,671 --> 00:13:52,871
than before and after.

294
00:13:52,871 --> 00:13:55,011
So when we go to the code,

295
00:13:55,011 --> 00:13:58,591
I'll start off by writing
some before advice.

296
00:13:58,591 --> 00:14:00,731
Then we'll have a quick
look at after advice

297
00:14:00,731 --> 00:14:04,441
before we then move on to around advice.

298
00:14:05,350 --> 00:14:09,171
Now the big benefit of
working with Spring AOP

299
00:14:09,171 --> 00:14:12,731
is that Spring AOP will generate

300
00:14:12,731 --> 00:14:15,131
the proxy for us.

301
00:14:15,131 --> 00:14:17,890
Well, really, Spring is using

302
00:14:17,890 --> 00:14:20,791
the standard Java development kit,

303
00:14:20,791 --> 00:14:22,831
the standard Java library,

304
00:14:22,831 --> 00:14:25,111
to generate the proxy.

305
00:14:25,111 --> 00:14:28,711
But Spring is kind of
making it so easy to do

306
00:14:28,711 --> 00:14:31,751
that you hardly feel any pain at all

307
00:14:31,751 --> 00:14:34,671
in generating the proxy.

308
00:14:34,671 --> 00:14:36,910
So the proxy class here,

309
00:14:36,910 --> 00:14:38,908
we don't have to write at all.

310
00:14:38,908 --> 00:14:41,928
We don't even see it.

311
00:14:41,928 --> 00:14:44,208
What we do have to do

312
00:14:44,208 --> 00:14:45,509
is we will write a class

313
00:14:45,509 --> 00:14:48,890
containing just the advice.

314
00:14:48,890 --> 00:14:50,909
So remember in our
case, that's going to be

315
00:14:50,909 --> 00:14:53,008
the performance monitoring code

316
00:14:53,008 --> 00:14:56,950
of starting a clock
and stopping the clock.

317
00:14:56,950 --> 00:14:59,008
And the general pattern is,

318
00:14:59,008 --> 00:15:01,888
when the client calls the service,

319
00:15:01,888 --> 00:15:04,368
the client will, in fact, be handed

320
00:15:04,368 --> 00:15:07,088
a reference to the proxy.

321
00:15:07,088 --> 00:15:10,987
The proxy will invoke the advice,

322
00:15:10,987 --> 00:15:14,308
whether it's before or around advice,

323
00:15:14,308 --> 00:15:16,827
then the proxy will call the target,

324
00:15:16,827 --> 00:15:18,928
the original service,

325
00:15:18,928 --> 00:15:21,828
and then the proxy will return.

326
00:15:21,828 --> 00:15:24,667
Oh, and if there's any after advice,

327
00:15:24,667 --> 00:15:28,068
it will run the advice
after the method call.

328
00:15:28,068 --> 00:15:32,068
So we just have to
write this advice class,

329
00:15:32,068 --> 00:15:33,828
which is to say it's going to contain

330
00:15:33,828 --> 00:15:36,368
the starting of the clock
and stopping the clock

331
00:15:36,368 --> 00:15:39,528
but we only need to do that once.

332
00:15:39,528 --> 00:15:42,488
And then Spring will weave that advice

333
00:15:42,488 --> 00:15:45,867
into however many methods there are

334
00:15:45,867 --> 00:15:47,988
in our service class.

335
00:15:47,988 --> 00:15:50,628
So what does this advice class look like?

336
00:15:50,628 --> 00:15:54,228
Well, it really is just a simple class.

337
00:15:54,228 --> 00:15:59,228
That's to say, I'm starting
here with before advice.

338
00:15:59,308 --> 00:16:01,368
Let's say we have a requirement

339
00:16:01,368 --> 00:16:03,048
that we just want to log

340
00:16:03,048 --> 00:16:05,508
the start of every method.

341
00:16:05,508 --> 00:16:07,688
We just want to say, on the console,

342
00:16:07,688 --> 00:16:11,348
"Hey, we're now in the" whatever method.

343
00:16:11,348 --> 00:16:14,748
What you have to do is write a class,

344
00:16:14,748 --> 00:16:18,868
I've called this class
just SimpleLoggingAdvice,

345
00:16:18,868 --> 00:16:22,668
and it must implement an interface.

346
00:16:22,668 --> 00:16:27,108
The interface is called
MethodBeforeAdvice.

347
00:16:27,108 --> 00:16:30,708
The interface contains just one method

348
00:16:30,708 --> 00:16:32,847
and this is the method

349
00:16:32,847 --> 00:16:35,788
that Spring is going
to automatically invoke

350
00:16:35,788 --> 00:16:38,568
before it goes on to the target code.

351
00:16:38,568 --> 00:16:41,178
And that method is called before,

352
00:16:41,178 --> 00:16:42,997
and inside the method,

353
00:16:42,997 --> 00:16:45,828
you just put in whatever
code you want to run

354
00:16:45,828 --> 00:16:47,536
before the target method.

355
00:16:47,536 --> 00:16:49,496
As you can see, all I'm doing here

356
00:16:49,496 --> 00:16:51,946
is a System.out.println,

357
00:16:51,946 --> 00:16:53,526
reporting to the user that

358
00:16:53,526 --> 00:16:57,846
we are now about to call
a particular method.

359
00:16:57,846 --> 00:17:00,286
Now remember that this advice

360
00:17:00,286 --> 00:17:03,086
is going to be applied by Spring

361
00:17:03,086 --> 00:17:06,326
to lots of different methods.

362
00:17:06,326 --> 00:17:08,886
I have seven or eight different methods

363
00:17:08,886 --> 00:17:11,185
in my BookService class.

364
00:17:11,185 --> 00:17:13,886
All this advice is going be run

365
00:17:13,886 --> 00:17:17,846
before all of those different methods.

366
00:17:17,846 --> 00:17:19,845
Now the other useful thing

367
00:17:19,845 --> 00:17:23,665
is that we're passed three parameters.

368
00:17:23,665 --> 00:17:26,362
The first parameter here is a reference

369
00:17:26,362 --> 00:17:29,243
to the method that is being called.

370
00:17:29,243 --> 00:17:31,302
Now I don't know if
you're familiar with this,

371
00:17:31,302 --> 00:17:34,943
the method class is standard Java.

372
00:17:34,943 --> 00:17:37,862
It's part of the Reflection API,

373
00:17:37,862 --> 00:17:40,622
and the method class represents

374
00:17:40,622 --> 00:17:42,722
the structure of a method.

375
00:17:42,722 --> 00:17:44,601
So I can do things like finding out

376
00:17:44,601 --> 00:17:48,422
what the name of the method
that is being called is.

377
00:17:48,422 --> 00:17:51,761
Now remember that this
advice can be applied to

378
00:17:51,761 --> 00:17:54,402
many different methods

379
00:17:54,402 --> 00:17:56,962
in many different classes.

380
00:17:56,962 --> 00:17:59,062
So in the code here,

381
00:17:59,062 --> 00:18:01,021
I don't know exactly

382
00:18:01,021 --> 00:18:03,241
what the name of the method is,

383
00:18:03,241 --> 00:18:05,881
but I can find it out.

384
00:18:05,881 --> 00:18:08,601
One of the methods, in the method class,

385
00:18:08,601 --> 00:18:11,321
is the getName method,

386
00:18:11,321 --> 00:18:12,341
and that will tell me

387
00:18:12,341 --> 00:18:15,401
the name of the target method.

388
00:18:15,401 --> 00:18:17,381
Now if you want any further information

389
00:18:17,381 --> 00:18:19,302
about this method class, just check in

390
00:18:19,302 --> 00:18:21,982
the standard Java API,

391
00:18:21,982 --> 00:18:25,021
and I'll also explore that
in a little bit more detail

392
00:18:25,021 --> 00:18:28,321
when we switch across to Eclipse.

393
00:18:28,321 --> 00:18:31,301
Now we're also given a list
of all of the arguments

394
00:18:31,301 --> 00:18:34,382
that have been passed
to the target method.

395
00:18:34,382 --> 00:18:37,922
We're given those in the
form of an object array.

396
00:18:37,922 --> 00:18:39,062
Now you might want to do this

397
00:18:39,062 --> 00:18:41,562
if you want to inspect the parameters

398
00:18:41,562 --> 00:18:43,642
that have been sent in.

399
00:18:43,642 --> 00:18:44,981
And you're limited there, really,

400
00:18:44,981 --> 00:18:48,042
by your own imagination.

401
00:18:48,042 --> 00:18:51,982
Finally, and you possibility
won't need to use this object,

402
00:18:51,982 --> 00:18:55,010
but we're also passed in a reference

403
00:18:55,010 --> 00:18:58,069
to the target object.

404
00:18:58,069 --> 00:19:01,269
So we could do things such as finding out

405
00:19:01,269 --> 00:19:05,828
what the type of the target object is.

406
00:19:05,828 --> 00:19:08,468
Now in many cases, you don't need

407
00:19:08,468 --> 00:19:10,548
to use these parameters,

408
00:19:10,548 --> 00:19:13,829
but they're there if you
want to find out more

409
00:19:13,829 --> 00:19:16,149
about what's going on.

410
00:19:16,149 --> 00:19:17,308
Now I hope you can see then

411
00:19:17,308 --> 00:19:19,829
that this before advice
is really nothing more

412
00:19:19,829 --> 00:19:21,548
than a simple wrapper

413
00:19:21,548 --> 00:19:24,288
for the behavior that you want to run

414
00:19:24,288 --> 00:19:26,568
across an entire class.

415
00:19:26,568 --> 00:19:27,928
Well, I think I've talked enough.

416
00:19:27,928 --> 00:19:30,088
It's time now to switch across to Eclipse

417
00:19:30,088 --> 00:19:32,839
and we'll get this implemented.

418
00:19:32,839 --> 00:19:33,938
Here we go then.

419
00:19:33,938 --> 00:19:37,568
We're still in the BookStore project,

420
00:19:37,568 --> 00:19:40,508
and remember that previously,

421
00:19:40,508 --> 00:19:43,308
we tried to write our advice

422
00:19:43,308 --> 00:19:46,588
by writing a proxy by hand.

423
00:19:46,588 --> 00:19:51,187
Here's the BookService timing proxy,

424
00:19:51,187 --> 00:19:54,908
and it was really tedious

425
00:19:54,908 --> 00:19:57,787
because I had to write the advice

426
00:19:57,787 --> 00:20:01,676
in every single one of the methods.

427
00:20:03,006 --> 00:20:04,767
Now I'm going to delete that class

428
00:20:04,767 --> 00:20:06,967
because that was just

429
00:20:06,967 --> 00:20:10,307
far too tedious.

430
00:20:10,307 --> 00:20:14,466
Now I'll also go into the application.xml.

431
00:20:14,466 --> 00:20:17,706
Remember I created a bean in the xml

432
00:20:17,706 --> 00:20:19,587
for the proxy.

433
00:20:19,587 --> 00:20:23,747
I'm going to delete that bean now.

434
00:20:23,747 --> 00:20:26,044
And you might remember that

435
00:20:26,044 --> 00:20:29,345
I also renamed my target BookService,

436
00:20:29,345 --> 00:20:31,319
the real BookService,

437
00:20:31,319 --> 00:20:34,377
I renamed that to BookServiceTarget.

438
00:20:34,377 --> 00:20:36,638
So let's switch that back

439
00:20:36,638 --> 00:20:39,858
to being called BookService again.

440
00:20:39,858 --> 00:20:41,315
So before I go any further,

441
00:20:41,315 --> 00:20:42,973
I'd just like to check that

442
00:20:42,973 --> 00:20:46,414
my client application is running okay.

443
00:20:49,514 --> 00:20:52,272
And I think it is.

444
00:20:52,272 --> 00:20:54,212
And it's say, sorry,
the book doesn't exist,

445
00:20:54,212 --> 00:20:56,590
because I'm deliberately looking up a book

446
00:20:56,590 --> 00:20:58,730
that's not in our database.

447
00:20:58,730 --> 00:21:00,650
And now we're going to
implement the advice,

448
00:21:00,650 --> 00:21:03,369
using proper Spring AOP.

449
00:21:03,369 --> 00:21:06,870
So, as on the caption, I'm
going to create a new class,

450
00:21:06,870 --> 00:21:08,410
and it would make really good sense

451
00:21:08,410 --> 00:21:10,630
if the advice that we're writing

452
00:21:10,630 --> 00:21:12,549
has its own package.

453
00:21:12,549 --> 00:21:15,230
So I'm going to call this package,

454
00:21:15,230 --> 00:21:19,229
well, I'll just call
it the advice package.

455
00:21:19,229 --> 00:21:21,748
The name of the class,
as on the caption you saw

456
00:21:21,748 --> 00:21:26,268
a few moments ago, was SimpleLoggingAdvice

457
00:21:26,268 --> 00:21:29,389
and the interface that
we're implement, remember,

458
00:21:29,389 --> 00:21:33,959
is called MethodBeforeAdvice.

459
00:21:33,959 --> 00:21:38,809
And that's from the
org.springframework.aop package.

460
00:21:38,809 --> 00:21:41,128
So I just typed MethodBefore in there.

461
00:21:41,128 --> 00:21:44,609
The only matching item is listed there.

462
00:21:44,609 --> 00:21:46,479
And I'm going to make sure that

463
00:21:46,479 --> 00:21:49,947
the inherited abstract methods is ticked,

464
00:21:50,947 --> 00:21:54,425
and then Eclipse has created
a skeleton implementation

465
00:21:54,425 --> 00:21:56,946
of that before method.

466
00:21:56,946 --> 00:21:59,286
Now because I haven't
installed the Javadoc,

467
00:21:59,286 --> 00:22:02,206
it's put in really bad names

468
00:22:02,206 --> 00:22:03,625
for the three parameters.

469
00:22:03,625 --> 00:22:04,926
So just to remind you,

470
00:22:04,926 --> 00:22:07,366
the first parameter is details of

471
00:22:07,366 --> 00:22:10,265
the method that is being called.

472
00:22:10,265 --> 00:22:12,446
The second parameter

473
00:22:12,446 --> 00:22:15,145
is a list of all of the arguments

474
00:22:15,145 --> 00:22:17,326
that are being passed to the method.

475
00:22:17,326 --> 00:22:19,366
So I'll call that arguments.

476
00:22:19,366 --> 00:22:21,365
And the third parameter here

477
00:22:21,365 --> 00:22:24,736
is a reference to the target objects.

478
00:22:25,746 --> 00:22:29,546
Now for our advice, all we want to do here

479
00:22:29,546 --> 00:22:32,035
is a system.out.println

480
00:22:34,005 --> 00:22:38,126
saying, we are now about call the,

481
00:22:38,126 --> 00:22:41,166
we can find out from the method object,

482
00:22:41,166 --> 00:22:44,176
we can call the getName method.

483
00:22:47,766 --> 00:22:50,206
If you're new to the Reflection API,

484
00:22:50,206 --> 00:22:53,425
then the methods that are available

485
00:22:53,425 --> 00:22:56,406
on this method object

486
00:22:56,406 --> 00:22:58,625
are things like,

487
00:22:58,625 --> 00:23:02,366
you can find out, for example,

488
00:23:02,366 --> 00:23:06,106
what exceptions

489
00:23:06,106 --> 00:23:09,425
the target method can throw.

490
00:23:09,425 --> 00:23:10,926
You can find out

491
00:23:10,926 --> 00:23:13,686
what the modifiers

492
00:23:13,686 --> 00:23:15,526
of the method are,

493
00:23:15,526 --> 00:23:17,285
and that means, is it public?

494
00:23:17,285 --> 00:23:18,624
Is it private?

495
00:23:18,624 --> 00:23:20,745
Or is it protected?

496
00:23:20,745 --> 00:23:24,925
You can get the parameter types.

497
00:23:24,925 --> 00:23:27,445
The return type of the method

498
00:23:27,445 --> 00:23:29,105
and so on.

499
00:23:29,105 --> 00:23:31,034
Now you don't need to, usually,

500
00:23:31,034 --> 00:23:34,584
do very much with the method objects,

501
00:23:34,584 --> 00:23:36,444
but it's there if you need it.

502
00:23:36,444 --> 00:23:37,484
Now I'm just going to

503
00:23:37,484 --> 00:23:40,143
switch off the folding here

504
00:23:40,143 --> 00:23:42,183
to point out that

505
00:23:42,183 --> 00:23:45,603
the MethodBeforeAdvice class or interface,

506
00:23:45,603 --> 00:23:47,783
comes from the Spring framework.

507
00:23:47,783 --> 00:23:50,762
But remember that that method class

508
00:23:50,762 --> 00:23:54,602
comes from the standard Java library.

509
00:23:54,602 --> 00:23:57,722
Now if you are importing method,

510
00:23:57,722 --> 00:23:59,562
if you're doing control shift O, in fact,

511
00:23:59,562 --> 00:24:01,762
I'll just demonstrate that.

512
00:24:01,762 --> 00:24:05,220
I'll remove the import
and do control shift O.

513
00:24:05,220 --> 00:24:06,600
You'll find there are,

514
00:24:06,600 --> 00:24:11,100
I think it's seven or eight
different method classes

515
00:24:11,100 --> 00:24:12,438
on your class path.

516
00:24:12,438 --> 00:24:13,968
You've got to be really careful

517
00:24:13,968 --> 00:24:15,979
to choose the right one,

518
00:24:15,979 --> 00:24:19,568
which is java.lang.reflect.

519
00:24:20,898 --> 00:24:23,338
So that's the advice written

520
00:24:23,338 --> 00:24:25,778
but perhaps the most complicated thing

521
00:24:25,778 --> 00:24:28,119
is how to tell Spring

522
00:24:28,119 --> 00:24:30,479
to invoke this advice.

523
00:24:30,479 --> 00:24:33,339
In other words, we want to make sure

524
00:24:33,339 --> 00:24:36,939
that the advice runs
before every invocation

525
00:24:36,939 --> 00:24:39,317
of our BookService.

526
00:24:39,317 --> 00:24:42,038
That process is called weaving.

527
00:24:42,038 --> 00:24:43,958
That's what we'll do next.

528
00:24:43,958 --> 00:24:44,937
Now recall then that

529
00:24:44,937 --> 00:24:46,516
the structure that we have is

530
00:24:46,516 --> 00:24:50,474
we have our BookService interface

531
00:24:50,474 --> 00:24:54,263
with an implementation that
we are not going to modify.

532
00:24:55,454 --> 00:24:57,943
We've written the advice class,

533
00:24:59,033 --> 00:25:01,733
down here at the bottom of the screen,

534
00:25:01,733 --> 00:25:04,033
and the whole thing hangs together

535
00:25:04,033 --> 00:25:07,273
by the magic of this proxy.

536
00:25:07,273 --> 00:25:08,493
Now in a previous chapter,

537
00:25:08,493 --> 00:25:10,574
we tried to write that by hand.

538
00:25:10,574 --> 00:25:11,952
It was really tedious.

539
00:25:11,952 --> 00:25:13,832
But we know now that Spring

540
00:25:13,832 --> 00:25:16,432
is going to generate this proxy for us,

541
00:25:16,432 --> 00:25:17,892
which is great.

542
00:25:17,892 --> 00:25:20,452
But we do, however, have to declare

543
00:25:20,452 --> 00:25:23,711
the proxy in the XML.

544
00:25:23,711 --> 00:25:26,831
Now the XML does look a
little bit complicated

545
00:25:26,831 --> 00:25:30,291
and this is perhaps the most
significant block of XML

546
00:25:30,291 --> 00:25:33,031
we've had so far on this course.

547
00:25:33,031 --> 00:25:34,231
Now I want to tell you that

548
00:25:34,231 --> 00:25:36,912
this is really old school,

549
00:25:36,912 --> 00:25:39,870
old-fashioned Spring XML.

550
00:25:39,870 --> 00:25:43,451
This is the way that we
had to configure Spring AOP

551
00:25:43,451 --> 00:25:46,790
in the very earliest days of Spring.

552
00:25:46,790 --> 00:25:49,190
But remember that we are going to simplify

553
00:25:49,190 --> 00:25:51,830
this XML in the next chapter.

554
00:25:51,830 --> 00:25:54,911
But I think before we
do that simplification,

555
00:25:54,911 --> 00:25:58,310
it is worth following this
slightly long-winded process

556
00:25:58,310 --> 00:26:00,589
because it is a good way of understanding

557
00:26:00,589 --> 00:26:03,489
how Spring AOP works.

558
00:26:03,489 --> 00:26:05,839
And really, this XML is nothing more

559
00:26:05,839 --> 00:26:07,407
than saying to Spring,

560
00:26:07,407 --> 00:26:10,647
"Hey, Spring, would you
please generate me a proxy?"

561
00:26:10,647 --> 00:26:13,968
And I'm also telling it what the advice is

562
00:26:13,968 --> 00:26:16,606
that I want that proxy to call.

563
00:26:16,606 --> 00:26:19,386
So let's look at it step-by-step.

564
00:26:19,386 --> 00:26:22,066
The first thing I'm doing here at the top

565
00:26:22,066 --> 00:26:24,426
is I'm telling Spring to create

566
00:26:24,426 --> 00:26:27,986
our SimpleLoggingAdvice bean.

567
00:26:27,986 --> 00:26:31,445
I'm giving it an ID of loggingAdvice,

568
00:26:31,445 --> 00:26:34,165
and I think that's relatively simple.

569
00:26:34,165 --> 00:26:36,365
There's no properties here

570
00:26:36,365 --> 00:26:38,385
but of course, if you needed to,

571
00:26:38,385 --> 00:26:41,605
you could do some
dependency injection here

572
00:26:41,605 --> 00:26:44,985
and add collaborators to the advice.

573
00:26:44,985 --> 00:26:47,985
I don't need to do that here.

574
00:26:47,985 --> 00:26:51,165
Now the main thing here is

575
00:26:51,165 --> 00:26:54,286
I'm declaring the proxy.

576
00:26:54,286 --> 00:26:58,135
Now remember, I haven't
written the proxy class.

577
00:26:58,135 --> 00:27:00,380
But Spring is capable of

578
00:27:00,380 --> 00:27:03,340
generating it for us.

579
00:27:03,340 --> 00:27:07,021
Now to do that, to ask Spring to generate

580
00:27:07,021 --> 00:27:11,800
a proxy with the same
interface as my BookService,

581
00:27:11,800 --> 00:27:14,340
I'm using a class from
the Spring framework

582
00:27:14,340 --> 00:27:18,640
called the ProxyFactoryBean.

583
00:27:18,640 --> 00:27:20,950
Now this is a class that is capable of

584
00:27:20,950 --> 00:27:24,190
automatically generating a proxy.

585
00:27:24,190 --> 00:27:25,970
All we have to do

586
00:27:25,970 --> 00:27:29,000
is specify three properties.

587
00:27:30,570 --> 00:27:32,190
The first property,

588
00:27:32,190 --> 00:27:34,289
that I'm highlighting here,

589
00:27:34,289 --> 00:27:37,329
is called proxyInterfaces.

590
00:27:37,329 --> 00:27:41,290
And the value is just
the name of the interface

591
00:27:41,290 --> 00:27:44,010
that we want the proxy to implement.

592
00:27:44,010 --> 00:27:48,110
So for me, that's the BookService.

593
00:27:48,110 --> 00:27:50,970
This will tell Spring that
the advice needs to be applied

594
00:27:50,970 --> 00:27:53,050
to all of the methods

595
00:27:53,050 --> 00:27:57,409
that are declared in the
BookService interface.

596
00:27:57,409 --> 00:27:59,329
The second property

597
00:27:59,329 --> 00:28:01,409
is a list of all of the advice

598
00:28:01,409 --> 00:28:03,370
that we want to apply

599
00:28:03,370 --> 00:28:05,969
for this particular service.

600
00:28:05,969 --> 00:28:07,329
Now they've called this property,

601
00:28:07,329 --> 00:28:11,788
rather confusingly, interceptorNames.

602
00:28:11,788 --> 00:28:15,309
Now just think of
interceptors as just being

603
00:28:15,309 --> 00:28:19,209
an alternative name for advice.

604
00:28:19,209 --> 00:28:20,869
The reason it's a list is because

605
00:28:20,869 --> 00:28:23,289
we could potentially add seven or eight

606
00:28:23,289 --> 00:28:25,549
or as many as we'd like,

607
00:28:25,549 --> 00:28:30,288
different pieces of
advice to a single object.

608
00:28:30,288 --> 00:28:32,067
We only have one but

609
00:28:32,067 --> 00:28:35,308
I'm still going to specify it as a list.

610
00:28:35,308 --> 00:28:38,387
The value in here is just the ID

611
00:28:38,387 --> 00:28:41,347
of the advice that we're applying.

612
00:28:41,347 --> 00:28:43,048
The final property,

613
00:28:43,048 --> 00:28:44,488
nice and easy this one,

614
00:28:44,488 --> 00:28:46,547
it's called target.

615
00:28:46,547 --> 00:28:49,728
And this is a reference to the bean

616
00:28:49,728 --> 00:28:52,488
that it's going to be the target object.

617
00:28:52,488 --> 00:28:55,468
Of course, for us, that's the BookService

618
00:28:55,468 --> 00:28:57,228
that I declared earlier.

619
00:28:58,578 --> 00:29:01,326
So it's slightly long-winded XML

620
00:29:01,326 --> 00:29:04,667
but I hope you're finding
it reasonably simple

621
00:29:04,667 --> 00:29:05,767
and easy to understand.

622
00:29:05,767 --> 00:29:07,607
Let's switch across to Eclipse,

623
00:29:07,607 --> 00:29:09,586
and we'll get it coded up.

624
00:29:09,586 --> 00:29:11,547
So, at the risk of boring you,

625
00:29:11,547 --> 00:29:15,927
I'm going to add this to the XML longhand.

626
00:29:15,927 --> 00:29:18,226
Of course, if you find this tedious,

627
00:29:18,226 --> 00:29:20,226
you can forward wind a few minutes

628
00:29:20,226 --> 00:29:22,626
to where I've completed the XML.

629
00:29:22,626 --> 00:29:24,327
Now, as always with the BookService,

630
00:29:24,327 --> 00:29:26,107
you don't need to follow along

631
00:29:26,107 --> 00:29:28,686
because you will be
putting this into practice

632
00:29:28,686 --> 00:29:29,706
when we switch across to

633
00:29:29,706 --> 00:29:31,546
the contact management system

634
00:29:31,546 --> 00:29:33,426
but of course, it won't hurt,

635
00:29:33,426 --> 00:29:34,886
if you do want to follow along.

636
00:29:34,886 --> 00:29:37,446
So the first bean that we need to create

637
00:29:37,446 --> 00:29:40,026
is the advice.

638
00:29:40,026 --> 00:29:42,765
Now, on the caption, I call this

639
00:29:42,765 --> 00:29:46,426
LoggingAdvice and the class is,

640
00:29:46,426 --> 00:29:47,885
this is just the name of the class

641
00:29:47,885 --> 00:29:49,764
that we just wrote on

642
00:29:49,764 --> 00:29:53,604
the previous part of the exercise,

643
00:29:53,604 --> 00:29:56,185
so that was in a package called advice

644
00:29:56,185 --> 00:30:00,685
and I called it SimpleLoggingAdvice.

645
00:30:00,685 --> 00:30:02,145
So that's really easy.

646
00:30:02,145 --> 00:30:05,885
I don't need to pass in
any properties into there.

647
00:30:05,885 --> 00:30:07,444
I think I will just add

648
00:30:07,444 --> 00:30:09,304
a comment in here though.

649
00:30:09,304 --> 00:30:12,715
This is just some advice.

650
00:30:13,945 --> 00:30:15,605
Now I'm going to ask Spring

651
00:30:15,605 --> 00:30:18,454
to generate a proxy.

652
00:30:21,905 --> 00:30:24,095
And I'm going to do
that by creating a bean,

653
00:30:24,095 --> 00:30:26,634
which I call the BookServiceProxy.

654
00:30:28,244 --> 00:30:30,224
I'll have more to say
about that in a moment

655
00:30:30,224 --> 00:30:32,224
and the class, well,

656
00:30:32,224 --> 00:30:33,865
this is something you
would have to look up

657
00:30:33,865 --> 00:30:35,865
in the Spring reference manual.

658
00:30:35,865 --> 00:30:39,895
This is the org.springframework,

659
00:30:40,835 --> 00:30:42,185
that's a bit long-winded this,

660
00:30:42,185 --> 00:30:45,515
it's dot aop.framework

661
00:30:45,515 --> 00:30:47,714
dot

662
00:30:47,714 --> 00:30:51,314
ProxyFactoryBean.

663
00:30:52,254 --> 00:30:55,854
Now this one does have properties.

664
00:30:55,854 --> 00:30:58,104
There are three properties.

665
00:30:59,444 --> 00:31:01,004
The first property is called

666
00:31:01,004 --> 00:31:05,114
the proxyInterfaces,

667
00:31:07,160 --> 00:31:10,872
and it takes the value
of whatever interface

668
00:31:10,872 --> 00:31:14,572
that we want to generate proxy code for.

669
00:31:14,572 --> 00:31:17,392
So that's virtualpairprogrammers

670
00:31:17,392 --> 00:31:19,401
dot, I think it's

671
00:31:19,401 --> 00:31:24,202
avalon.services.BookService.

672
00:31:26,172 --> 00:31:29,772
Then we need the property called

673
00:31:29,772 --> 00:31:33,721
interceptorNames,

674
00:31:35,031 --> 00:31:36,931
always found that a little bit confusing

675
00:31:36,931 --> 00:31:39,820
but this is going to be a list.

676
00:31:39,820 --> 00:31:41,759
We only have one value in the list

677
00:31:41,759 --> 00:31:44,840
and it's the ID of the bean here.

678
00:31:44,840 --> 00:31:46,180
And later on, I could add in

679
00:31:46,180 --> 00:31:48,220
more advice if it were needed.

680
00:31:48,220 --> 00:31:50,589
And the final property

681
00:31:54,739 --> 00:31:56,879
is called target.

682
00:31:56,879 --> 00:31:58,139
Really simple, this one.

683
00:31:58,139 --> 00:32:00,419
This is a reference to

684
00:32:00,419 --> 00:32:02,759
whatever our target service is.

685
00:32:02,759 --> 00:32:05,479
And for us, this is the BookService

686
00:32:05,479 --> 00:32:09,139
so I'll just copy that into there.

687
00:32:09,139 --> 00:32:10,858
And without doing any more thinking,

688
00:32:10,858 --> 00:32:13,279
I'm going to go into my client class,

689
00:32:13,279 --> 00:32:15,119
and run the code,

690
00:32:15,119 --> 00:32:16,807
and see if it runs.

691
00:32:18,039 --> 00:32:19,539
Well, as you can see,

692
00:32:19,539 --> 00:32:23,037
it certainly is not running,

693
00:32:23,037 --> 00:32:26,295
which might be a little
bit disappointing at first

694
00:32:26,295 --> 00:32:29,036
but I don't know if
you've spotted the reason.

695
00:32:29,036 --> 00:32:32,375
If we return back to our client code,

696
00:32:32,375 --> 00:32:35,934
I haven't changed this client code at all

697
00:32:35,934 --> 00:32:38,435
and all I'm doing is I'm looking up

698
00:32:38,435 --> 00:32:40,235
the BookService.

699
00:32:40,235 --> 00:32:43,545
Now that's the target object.

700
00:32:43,545 --> 00:32:45,635
So I'm effectively, in the client, going

701
00:32:45,635 --> 00:32:48,615
straight to the target code,

702
00:32:48,615 --> 00:32:52,945
and the proxy is being completely ignored.

703
00:32:52,945 --> 00:32:54,055
So what can I do?

704
00:32:54,055 --> 00:32:56,995
Well, the easy fix

705
00:32:56,995 --> 00:32:58,815
would be, in the client,

706
00:32:58,815 --> 00:33:02,195
to look up the proxy.

707
00:33:02,195 --> 00:33:04,615
Then we're going to run the proxy code,

708
00:33:04,615 --> 00:33:08,394
which will, in turn, call the target code.

709
00:33:08,394 --> 00:33:10,815
Now I'm not really that
happy with that idea

710
00:33:10,815 --> 00:33:13,455
because I don't think my client code

711
00:33:13,455 --> 00:33:17,135
really cares that they're
looking up a proxy.

712
00:33:17,135 --> 00:33:20,234
As far as the client code is concerned,

713
00:33:20,234 --> 00:33:23,534
it's wanting to get
access to the BookService

714
00:33:23,534 --> 00:33:24,775
and the fact that a little bit of

715
00:33:24,775 --> 00:33:27,415
performance timing is going to be

716
00:33:27,415 --> 00:33:29,475
injected into there,

717
00:33:29,475 --> 00:33:33,035
is not really of interest to the client.

718
00:33:33,035 --> 00:33:35,095
So I think that would work

719
00:33:35,095 --> 00:33:37,815
but I'm going to undo that change.

720
00:33:37,815 --> 00:33:39,155
Instead I'm going to show you

721
00:33:39,155 --> 00:33:40,935
the more common pattern

722
00:33:40,935 --> 00:33:43,435
for working with proxies in Spring.

723
00:33:43,435 --> 00:33:44,835
And I think you might be able to guess

724
00:33:44,835 --> 00:33:46,455
what I'm going to do now.

725
00:33:46,455 --> 00:33:49,135
I've gone back into the XML wiring

726
00:33:49,135 --> 00:33:52,735
and I'm going to shuffle
things around a little bit.

727
00:33:52,735 --> 00:33:54,055
Now the first step is I'm going to

728
00:33:54,055 --> 00:33:55,975
find my service.

729
00:33:55,975 --> 00:33:57,615
Here it is.

730
00:33:57,615 --> 00:33:59,675
And I'm going to give it a different name,

731
00:33:59,675 --> 00:34:02,075
and the convention that we often use

732
00:34:02,075 --> 00:34:05,555
is to call that the target object.

733
00:34:05,555 --> 00:34:08,655
Now a warning has flashed up here

734
00:34:08,655 --> 00:34:11,495
by the Spring IDE because we are injecting

735
00:34:11,495 --> 00:34:14,175
that object into the Purchasing Service.

736
00:34:14,175 --> 00:34:16,815
So I will need to make the same change

737
00:34:16,815 --> 00:34:19,255
here as well.

738
00:34:19,255 --> 00:34:20,725
Now as things stand,

739
00:34:20,725 --> 00:34:22,135
the client now won't run

740
00:34:22,135 --> 00:34:23,895
because there's now no longer a bean

741
00:34:23,895 --> 00:34:26,435
called BookService.

742
00:34:26,435 --> 00:34:29,255
But, you can see what I'm going to do now,

743
00:34:29,255 --> 00:34:31,975
I'm going to give the proxy

744
00:34:31,975 --> 00:34:33,945
the name of BookService.

745
00:34:33,945 --> 00:34:37,624
So now, almost unwittingly,

746
00:34:37,624 --> 00:34:41,724
the client is going to
be accessing the proxy

747
00:34:41,724 --> 00:34:43,484
even though it thinks

748
00:34:43,484 --> 00:34:47,024
it's accessing the BookService directly.

749
00:34:47,024 --> 00:34:49,224
I will need to make one further change

750
00:34:49,224 --> 00:34:51,304
and that's this target here,

751
00:34:51,304 --> 00:34:55,524
of course, is the BookServiceTarget.

752
00:34:56,734 --> 00:34:57,864
Now I want to remind you,

753
00:34:57,864 --> 00:35:01,124
if we go back to the client code,

754
00:35:01,124 --> 00:35:02,844
you know now and,

755
00:35:02,844 --> 00:35:04,384
we all know that,

756
00:35:04,384 --> 00:35:08,044
we're looking at a proxy here.

757
00:35:08,044 --> 00:35:10,724
But the proxy, the key feature of a proxy,

758
00:35:10,724 --> 00:35:14,384
is that it implements the same interface

759
00:35:14,384 --> 00:35:16,364
as the target.

760
00:35:16,364 --> 00:35:19,284
So the old principle of
programming to an interface

761
00:35:19,284 --> 00:35:21,404
means that because we're referring to

762
00:35:21,404 --> 00:35:23,144
the interface here,

763
00:35:23,144 --> 00:35:24,604
it really doesn't matter that

764
00:35:24,604 --> 00:35:27,504
the client's getting a
different type of object

765
00:35:27,504 --> 00:35:30,724
from the one it was originally getting.

766
00:35:30,724 --> 00:35:33,404
All of the methods still
appear on the proxy

767
00:35:33,404 --> 00:35:35,744
so all of the code from this point onwards

768
00:35:35,744 --> 00:35:38,474
will still compile and run.

769
00:35:38,474 --> 00:35:39,604
Well, will it run?

770
00:35:39,604 --> 00:35:40,713
That's the big question

771
00:35:40,713 --> 00:35:43,523
so I'll give this one more run.

772
00:35:46,673 --> 00:35:48,393
And that's looking good now.

773
00:35:48,393 --> 00:35:49,733
You can see here

774
00:35:49,733 --> 00:35:50,913
that we're being told

775
00:35:50,913 --> 00:35:54,313
that we're about to call
the registerNewBook method.

776
00:35:54,313 --> 00:35:56,253
And here, we're able to call

777
00:35:56,253 --> 00:35:59,013
the getEntireCatalog method.

778
00:35:59,013 --> 00:36:01,013
This is just where we're outputting

779
00:36:01,013 --> 00:36:02,632
all of the books in the system,

780
00:36:02,632 --> 00:36:05,493
and of course, the reason
this list is getting longer

781
00:36:05,493 --> 00:36:08,653
every time is because I
keep calling registerNewBook

782
00:36:08,653 --> 00:36:12,452
on "War and Peace" every
time I run this client.

783
00:36:12,452 --> 00:36:14,173
And then finally, we're calling

784
00:36:14,173 --> 00:36:16,653
the getBookByIsbn method,

785
00:36:16,653 --> 00:36:20,413
which is reporting that
that book doesn't exist.

786
00:36:20,413 --> 00:36:22,853
Okay, well, the client's
starting to look a bit messy now

787
00:36:22,853 --> 00:36:24,753
but I hope you understand the point,

788
00:36:24,753 --> 00:36:26,213
which is that by writing

789
00:36:26,213 --> 00:36:29,212
a simple, lightweight class,

790
00:36:29,212 --> 00:36:32,993
with just the logging inside,

791
00:36:32,993 --> 00:36:36,273
and then by doing a relatively small piece

792
00:36:36,273 --> 00:36:39,573
of XML configuration, all of a sudden,

793
00:36:39,573 --> 00:36:42,753
the behavior of the
application has changed

794
00:36:42,753 --> 00:36:46,373
and very importantly,
if I were now to go into

795
00:36:46,373 --> 00:36:49,153
our BookService interface

796
00:36:49,153 --> 00:36:51,411
and add more methods,

797
00:36:51,411 --> 00:36:54,912
then these new methods will
automatically get wrapped

798
00:36:54,912 --> 00:36:56,031
with this advice

799
00:36:56,031 --> 00:36:59,411
without me having to do any further work.

800
00:36:59,411 --> 00:37:02,351
Let's have a look now at how
to write some after advice,

801
00:37:02,351 --> 00:37:05,962
and the process is very similar
to writing before advice.

802
00:37:06,951 --> 00:37:08,322
The main difference is that

803
00:37:08,322 --> 00:37:11,882
we're implementing a different interface.

804
00:37:11,882 --> 00:37:13,542
This time it's called

805
00:37:13,542 --> 00:37:15,981
AfterReturningAdvice.

806
00:37:15,981 --> 00:37:18,962
And that interface contains
a single method again

807
00:37:18,962 --> 00:37:22,902
but this time called afterReturning.

808
00:37:22,902 --> 00:37:25,202
The idea is the same.

809
00:37:25,202 --> 00:37:27,341
We're going to add what I'm calling here

810
00:37:27,341 --> 00:37:30,242
my payload code.

811
00:37:30,242 --> 00:37:32,602
That's, of course, the
code that I want to run

812
00:37:32,602 --> 00:37:36,221
after the target method has run.

813
00:37:36,221 --> 00:37:38,141
Now the other difference is that

814
00:37:38,141 --> 00:37:40,241
the signature of the method

815
00:37:40,241 --> 00:37:43,021
is very similar to the before method

816
00:37:43,021 --> 00:37:44,481
that we saw before,

817
00:37:44,481 --> 00:37:46,061
in that we have the method,

818
00:37:46,061 --> 00:37:48,961
the arguments and the target,

819
00:37:48,961 --> 00:37:52,500
but there is an extra parameter in here,

820
00:37:52,500 --> 00:37:54,780
and that's that we can now inspect

821
00:37:54,780 --> 00:37:57,220
the returnValue.

822
00:37:57,220 --> 00:37:59,101
Now I'll talk a little bit more detail

823
00:37:59,101 --> 00:38:02,081
about that in a few moments.

824
00:38:02,081 --> 00:38:04,241
But let's try this out.

825
00:38:04,241 --> 00:38:05,861
It won't take long to get this coded up

826
00:38:05,861 --> 00:38:08,521
so let's switch across.

827
00:38:08,521 --> 00:38:10,420
So here's our before advice

828
00:38:10,420 --> 00:38:12,521
that we coded before

829
00:38:12,521 --> 00:38:14,481
and I'm, just as an experiment, going to

830
00:38:14,481 --> 00:38:19,181
try to change this into after advice.

831
00:38:19,181 --> 00:38:22,190
So I'm going to change the interface here

832
00:38:22,190 --> 00:38:26,751
to AfterReturningAdvice,

833
00:38:26,751 --> 00:38:28,841
and that, of course, will
need to be implemented

834
00:38:28,841 --> 00:38:33,360
so I've done a control shift and O there.

835
00:38:33,360 --> 00:38:34,960
Now, as I mentioned on the caption,

836
00:38:34,960 --> 00:38:36,800
this method will need to change.

837
00:38:36,800 --> 00:38:40,441
It's now called afterReturning,

838
00:38:40,441 --> 00:38:42,121
and it has a difference in that

839
00:38:42,121 --> 00:38:45,021
the first parameter into the list

840
00:38:45,021 --> 00:38:49,001
is an object and it's the returnValue

841
00:38:49,001 --> 00:38:52,720
that has been passed back
from the target object,

842
00:38:52,720 --> 00:38:54,741
Now, as you can see, once I've added that

843
00:38:54,741 --> 00:38:57,280
everything is now compiling.

844
00:38:57,280 --> 00:38:59,280
Now I'll need to change
the payload a little bit

845
00:38:59,280 --> 00:39:02,000
because we're not able to call the method,

846
00:39:02,000 --> 00:39:04,421
we have called the method.

847
00:39:04,421 --> 00:39:07,421
So we have now finished

848
00:39:07,421 --> 00:39:10,180
calling the

849
00:39:10,180 --> 00:39:13,039
whatever the target method was.

850
00:39:13,039 --> 00:39:16,440
And I can do one further

851
00:39:16,440 --> 00:39:17,859
piece of payload,

852
00:39:17,859 --> 00:39:19,889
just if you're interested.

853
00:39:21,459 --> 00:39:24,088
You can say that the target method

854
00:39:24,088 --> 00:39:26,767
returned the value

855
00:39:26,767 --> 00:39:30,566
and we'll output this returnValue here.

856
00:39:33,916 --> 00:39:35,974
Now one nice thing about switching from

857
00:39:35,974 --> 00:39:39,014
before to after advice is that

858
00:39:39,014 --> 00:39:43,384
there's no further XML to configure.

859
00:39:43,384 --> 00:39:44,553
There's nothing to change

860
00:39:44,553 --> 00:39:48,123
because we're still
instantiating the logging advice

861
00:39:48,123 --> 00:39:50,763
and we're still applying it as advice

862
00:39:50,763 --> 00:39:52,482
to the BookService.

863
00:39:52,482 --> 00:39:54,983
And the fact that it's now after advice

864
00:39:54,983 --> 00:39:58,203
is really of no interest to the XML.

865
00:39:58,203 --> 00:40:00,402
So with that simple change in place,

866
00:40:00,402 --> 00:40:02,543
we can now run the client again.

867
00:40:05,852 --> 00:40:07,193
Now that's looking good.

868
00:40:07,193 --> 00:40:08,393
We can see here

869
00:40:08,393 --> 00:40:10,333
that we have finished calling

870
00:40:10,333 --> 00:40:12,433
the registerNewBook method

871
00:40:12,433 --> 00:40:15,213
and that method, this is interesting,

872
00:40:15,213 --> 00:40:17,753
has returned the value of null.

873
00:40:17,753 --> 00:40:19,593
Well, it's saying that because

874
00:40:19,593 --> 00:40:23,193
the registerNewBook
method is a void method

875
00:40:23,193 --> 00:40:24,972
and with a void method,

876
00:40:24,972 --> 00:40:28,773
we're always going to get a null return.

877
00:40:28,773 --> 00:40:33,292
However, for the getEntireCatalog method,

878
00:40:33,292 --> 00:40:35,353
once that was finished,

879
00:40:35,353 --> 00:40:37,393
it's telling us that the target method

880
00:40:37,393 --> 00:40:39,213
has returned the value,

881
00:40:39,213 --> 00:40:40,873
and this just happens to be

882
00:40:40,873 --> 00:40:44,393
how a Java list is reported

883
00:40:44,393 --> 00:40:47,083
if you add it to the system.out.println

884
00:40:47,083 --> 00:40:49,902
so it's showing us the
contents of that list

885
00:40:49,902 --> 00:40:51,333
that's being returned.

886
00:40:52,553 --> 00:40:55,482
Now, a commonly asked question,

887
00:40:55,482 --> 00:40:59,192
whenever we cover AOP on the course, is,

888
00:40:59,192 --> 00:41:01,011
"Hey, isn't this really dangerous?

889
00:41:01,011 --> 00:41:05,051
"We could create real havoc here.

890
00:41:05,991 --> 00:41:08,561
"We could take this return value,

891
00:41:08,561 --> 00:41:10,761
"and we could call methods on it

892
00:41:10,761 --> 00:41:14,502
"and we could change the object's values."

893
00:41:14,502 --> 00:41:16,600
Well, let's try that just for fun.

894
00:41:16,600 --> 00:41:19,320
Well, I can't really do anything with

895
00:41:19,320 --> 00:41:22,951
the return value at first because

896
00:41:22,951 --> 00:41:26,609
we're only handed a reference to object.

897
00:41:26,609 --> 00:41:29,149
Here, in this code, a compile time,

898
00:41:29,149 --> 00:41:33,049
we don't know what the
returnValue type is.

899
00:41:33,049 --> 00:41:36,130
Therefore, we can't see
any of the specific methods

900
00:41:36,130 --> 00:41:38,489
that that object might have.

901
00:41:38,489 --> 00:41:39,669
So we only have in here

902
00:41:39,669 --> 00:41:43,679
the boring methods that
are in the object class.

903
00:41:44,770 --> 00:41:46,910
So what I could do

904
00:41:46,910 --> 00:41:49,450
and I'll do something silly here is

905
00:41:49,450 --> 00:41:51,109
I'm going to say,

906
00:41:51,109 --> 00:41:53,470
if the returnValue

907
00:41:53,470 --> 00:41:56,530
is an instance of,

908
00:41:56,530 --> 00:41:58,329
now, I might be going into some Java

909
00:41:58,329 --> 00:41:59,890
that you've not seen before,

910
00:41:59,890 --> 00:42:00,910
just in case you haven't,

911
00:42:00,910 --> 00:42:02,691
the instance of keyword allows us

912
00:42:02,691 --> 00:42:04,829
to interrogate an object

913
00:42:04,829 --> 00:42:07,649
and find out what its class is.

914
00:42:07,649 --> 00:42:12,138
So I can say that if the
returnValue is an instance of

915
00:42:12,138 --> 00:42:16,716
the java.util.list interface,

916
00:42:16,716 --> 00:42:18,385
for example,

917
00:42:18,385 --> 00:42:21,985
we now know that the returnValue is a list

918
00:42:21,985 --> 00:42:24,806
so we can cast it.

919
00:42:24,806 --> 00:42:28,286
So we can say that this is now a list.

920
00:42:28,286 --> 00:42:30,795
I'll call it returnList.

921
00:42:32,786 --> 00:42:37,455
And I will cast the
returnValue into a list.

922
00:42:37,455 --> 00:42:39,623
I think I'll need to import a list.

923
00:42:41,924 --> 00:42:43,414
That's okay.

924
00:42:43,414 --> 00:42:47,054
Now once we've cast it to
the correct type, of course,

925
00:42:47,054 --> 00:42:49,433
I can now interrogate that object again

926
00:42:49,433 --> 00:42:51,913
and this time, I can see

927
00:42:51,913 --> 00:42:55,673
all of the methods that
are inside the list class.

928
00:42:55,673 --> 00:42:57,254
And I could do things like

929
00:42:57,254 --> 00:42:59,874
adding some elements into the list.

930
00:42:59,874 --> 00:43:02,514
Or well, let's be a bit violent.

931
00:43:02,514 --> 00:43:05,294
I'm going to clear the list.

932
00:43:05,294 --> 00:43:06,914
So that means, from now on,

933
00:43:06,914 --> 00:43:09,054
any calls to the BookService,

934
00:43:09,054 --> 00:43:11,554
even though I've not
changed the BookService,

935
00:43:11,554 --> 00:43:14,514
any calls to the BookService
are going to return

936
00:43:14,514 --> 00:43:16,844
empty lists of books.

937
00:43:18,124 --> 00:43:21,453
Let's see if that runs.

938
00:43:23,544 --> 00:43:26,284
And yeah, you can see the
output's very different.

939
00:43:26,284 --> 00:43:30,064
We've now finished calling
the getEntireCatalog method

940
00:43:30,064 --> 00:43:32,384
but the target method has
now returned the value

941
00:43:32,384 --> 00:43:34,882
of an empty list.

942
00:43:34,882 --> 00:43:36,303
And that's why we're not seeing

943
00:43:36,303 --> 00:43:38,922
any output on the screen.

944
00:43:38,922 --> 00:43:41,643
Well, as I say, a really
common question here is that,

945
00:43:41,643 --> 00:43:45,053
"Hey, this AOP stuff
looks really dangerous.

946
00:43:45,053 --> 00:43:49,863
"We can modify the way that
our service objects work."

947
00:43:49,863 --> 00:43:51,803
And the answer is a definite yes.

948
00:43:51,803 --> 00:43:53,721
This is dangerous

949
00:43:53,721 --> 00:43:56,361
in that we have a lot of power here.

950
00:43:56,361 --> 00:43:59,321
AOP is a powerful tool.

951
00:43:59,321 --> 00:44:01,640
So if you are going to
use this on a project

952
00:44:01,640 --> 00:44:05,260
then with that power comes responsibility.

953
00:44:05,260 --> 00:44:07,660
We need to use AOP wisely.

954
00:44:07,660 --> 00:44:09,921
We need to use it thoughtfully

955
00:44:09,921 --> 00:44:11,601
and just in the situations

956
00:44:11,601 --> 00:44:14,021
where we really need it.

957
00:44:14,021 --> 00:44:16,001
But I can imagine this kind of process

958
00:44:16,001 --> 00:44:19,180
could be really useful to some projects.

959
00:44:19,180 --> 00:44:20,441
Now I don't know about

960
00:44:20,441 --> 00:44:22,121
clearing lists.

961
00:44:22,121 --> 00:44:24,300
That was a little bit
of an extreme example

962
00:44:24,300 --> 00:44:26,060
but I don't know,

963
00:44:26,060 --> 00:44:29,060
maybe in future, you might
have a big application

964
00:44:29,060 --> 00:44:33,000
with some legacy code
in one of your services,

965
00:44:33,000 --> 00:44:35,461
and maybe you need to make that service

966
00:44:35,461 --> 00:44:37,321
return empty lists,

967
00:44:37,321 --> 00:44:39,201
maybe just temporarily,

968
00:44:39,201 --> 00:44:42,380
because you want to
close that service down

969
00:44:42,380 --> 00:44:44,860
or maybe you want to force the service

970
00:44:44,860 --> 00:44:46,540
to return some lists that

971
00:44:46,540 --> 00:44:49,681
we're hard-coding into the advice,

972
00:44:49,681 --> 00:44:51,521
regardless of what's in the database

973
00:44:51,521 --> 00:44:54,661
because you want to do
some kind of testing.

974
00:44:54,661 --> 00:44:57,161
Well, the possibilities are endless.

975
00:44:57,161 --> 00:44:58,780
But remember that we're switching

976
00:44:58,780 --> 00:45:03,321
on and off the AOP via
a configuration file

977
00:45:03,321 --> 00:45:06,760
so we have a lot of power
and flexibility there.

978
00:45:06,760 --> 00:45:08,720
So that's before and after advice

979
00:45:08,720 --> 00:45:11,821
but we really need around advice

980
00:45:11,821 --> 00:45:14,651
for our performance timing requirements.

981
00:45:14,651 --> 00:45:16,580
As I mentioned before, you can think of

982
00:45:16,580 --> 00:45:19,079
around advice as being a combination of

983
00:45:19,079 --> 00:45:22,479
before and after advice

984
00:45:22,479 --> 00:45:26,719
but all in one method in the advice.

985
00:45:26,719 --> 00:45:28,350
Now the pattern is pretty much

986
00:45:28,350 --> 00:45:30,670
the same as we've done before.

987
00:45:30,670 --> 00:45:32,689
We'll write an advice class.

988
00:45:32,689 --> 00:45:36,810
This time I've called it
PerformanceTimingAdvice

989
00:45:36,810 --> 00:45:40,730
and we're going to implement
an interface again.

990
00:45:40,730 --> 00:45:42,331
This is a little bit different.

991
00:45:42,331 --> 00:45:46,931
The interface is called MethodInterceptor.

992
00:45:46,931 --> 00:45:49,091
Now you might have expected that interface

993
00:45:49,091 --> 00:45:51,929
to be called AroundAdvice.

994
00:45:51,929 --> 00:45:54,810
I'll say in a few moments,
when we get into Eclipse,

995
00:45:54,810 --> 00:45:58,960
the reason why it has a
slightly strange name.

996
00:45:58,960 --> 00:46:02,770
Anyway, the interface
only contains one method

997
00:46:02,770 --> 00:46:06,510
and that method is called invoke.

998
00:46:06,510 --> 00:46:09,930
This method is going to called by Spring

999
00:46:09,930 --> 00:46:13,010
when the client calls any of the methods

1000
00:46:13,010 --> 00:46:15,989
on our target objects.

1001
00:46:15,989 --> 00:46:18,709
Now what we do inside invoke is,

1002
00:46:18,709 --> 00:46:21,390
well, it's pretty much up to you.

1003
00:46:21,390 --> 00:46:25,149
We need to decide what the
payload is going to be.

1004
00:46:25,149 --> 00:46:28,170
Now in this example, I just have comments

1005
00:46:28,170 --> 00:46:31,870
where I'm going to have
my actual payload code.

1006
00:46:31,870 --> 00:46:33,470
The pattern is,

1007
00:46:33,470 --> 00:46:35,690
here I have the comment where we would do

1008
00:46:35,690 --> 00:46:37,770
the stuff that we want to happen

1009
00:46:37,770 --> 00:46:41,530
before the target method runs.

1010
00:46:41,530 --> 00:46:44,949
And then at some point in this code,

1011
00:46:44,949 --> 00:46:46,970
we have to remember to call

1012
00:46:46,970 --> 00:46:50,230
the proceed method.

1013
00:46:50,230 --> 00:46:51,569
Now what we're doing here is

1014
00:46:51,569 --> 00:46:54,628
we're calling proceed on the object

1015
00:46:54,628 --> 00:46:57,209
that's passed into invoke.

1016
00:46:57,209 --> 00:46:58,889
Now that is perhaps a bit of

1017
00:46:58,889 --> 00:47:01,008
a downside of around advice.

1018
00:47:01,008 --> 00:47:03,308
We have to remember

1019
00:47:03,308 --> 00:47:06,069
to call the target method.

1020
00:47:06,069 --> 00:47:08,709
Now remember that, with
before and after advice,

1021
00:47:08,709 --> 00:47:10,769
that was done for free.

1022
00:47:10,769 --> 00:47:14,028
We never saw the proceed happen.

1023
00:47:14,028 --> 00:47:16,268
But you think about
it, with around advice,

1024
00:47:16,268 --> 00:47:17,929
Spring would have no way of knowing

1025
00:47:17,929 --> 00:47:22,629
at what point we want to
call the target method.

1026
00:47:22,629 --> 00:47:26,189
Anyway, once the target
method has returned,

1027
00:47:26,189 --> 00:47:28,549
and we have a return value,

1028
00:47:28,549 --> 00:47:30,688
we can then do whatever payload

1029
00:47:30,688 --> 00:47:34,389
we want to happen after the method is run,

1030
00:47:34,389 --> 00:47:37,148
Again, I just have comments here.

1031
00:47:37,148 --> 00:47:39,309
And finally, you have to remember

1032
00:47:39,309 --> 00:47:42,448
to have a return statement at the end,

1033
00:47:42,448 --> 00:47:46,349
returning whatever value was
returned from the target.

1034
00:47:46,349 --> 00:47:48,349
Now this is important, of course,

1035
00:47:48,349 --> 00:47:50,269
because without doing that,

1036
00:47:50,269 --> 00:47:53,209
the client won't get the value back

1037
00:47:53,209 --> 00:47:56,789
that came from the target method.

1038
00:47:56,789 --> 00:47:58,948
So it's time now to implement

1039
00:47:58,948 --> 00:48:01,728
our performance timing properly.

1040
00:48:01,728 --> 00:48:02,928
So I think to do that

1041
00:48:02,928 --> 00:48:06,809
I'm going to take our
existing SimpleLoggingAdvice

1042
00:48:06,809 --> 00:48:09,484
and I'm going to right-click on it,

1043
00:48:09,484 --> 00:48:12,554
refactor and rename,

1044
00:48:12,554 --> 00:48:16,294
and now we're going to call this

1045
00:48:16,294 --> 00:48:20,433
PerformanceTimingAdvice.

1046
00:48:20,433 --> 00:48:21,974
Now I need to change the interface

1047
00:48:21,974 --> 00:48:23,054
that we're implementing.

1048
00:48:23,054 --> 00:48:25,332
Remember this one is called

1049
00:48:25,332 --> 00:48:28,713
MethodInterceptor.

1050
00:48:28,713 --> 00:48:31,993
And I will need to import that.

1051
00:48:31,993 --> 00:48:33,932
Now notice here that

1052
00:48:33,932 --> 00:48:36,893
the MethodInterceptor
class, be careful here,

1053
00:48:36,893 --> 00:48:38,893
very careful, in fact,

1054
00:48:38,893 --> 00:48:40,973
you want the one from the package called

1055
00:48:40,973 --> 00:48:45,313
org.aopalliance.

1056
00:48:45,313 --> 00:48:47,113
Now I know that's really strange

1057
00:48:47,113 --> 00:48:48,871
that it doesn't appear to come from

1058
00:48:48,871 --> 00:48:50,951
the Spring framework,

1059
00:48:50,951 --> 00:48:53,011
but what's happened is

1060
00:48:53,011 --> 00:48:56,771
is this interface is from
a third-party project

1061
00:48:56,771 --> 00:48:59,852
called the AOP Alliance.

1062
00:48:59,852 --> 00:49:02,731
Now the AOP Alliance is
a kind of standards body

1063
00:49:02,731 --> 00:49:05,191
who were trying to put together

1064
00:49:05,191 --> 00:49:09,251
a common, unified interface for AOP.

1065
00:49:09,251 --> 00:49:11,852
And the Spring framework
people wisely thought,

1066
00:49:11,852 --> 00:49:15,252
"Well, we're not going to
re-implement this interface.

1067
00:49:15,252 --> 00:49:17,692
"We'll use the one that already exists

1068
00:49:17,692 --> 00:49:20,231
"and we can fit in with."

1069
00:49:20,231 --> 00:49:21,851
And that is, by the way,

1070
00:49:21,851 --> 00:49:25,091
the reason why the
structure of the method,

1071
00:49:25,091 --> 00:49:27,621
inside that interface,
also looks a bit different

1072
00:49:27,621 --> 00:49:30,681
to the before and after advice.

1073
00:49:30,681 --> 00:49:32,720
Now it is confusing that

1074
00:49:32,720 --> 00:49:34,881
there is also a MethodInterceptor

1075
00:49:34,881 --> 00:49:37,440
in a Spring framework package

1076
00:49:37,440 --> 00:49:40,020
but that, in fact, is something different,

1077
00:49:40,020 --> 00:49:42,161
that we're not working with.

1078
00:49:42,161 --> 00:49:43,860
So please be careful to choose

1079
00:49:43,860 --> 00:49:48,120
the org.aopalliance interface,

1080
00:49:48,120 --> 00:49:51,240
and just need to click on Finish.

1081
00:49:51,240 --> 00:49:53,260
Now, of course, this code isn't compiling

1082
00:49:53,260 --> 00:49:56,141
because the method inside isn't called

1083
00:49:56,141 --> 00:49:58,741
afterReturning, so I think for speed,

1084
00:49:58,741 --> 00:50:00,640
I'm going to delete the code

1085
00:50:00,640 --> 00:50:03,359
I already had,

1086
00:50:03,359 --> 00:50:06,959
and then I can left-click
on the error here,

1087
00:50:06,959 --> 00:50:09,059
and it will give me a quick fix of

1088
00:50:09,059 --> 00:50:12,499
adding unimplemented methods.

1089
00:50:12,499 --> 00:50:15,519
Now, on the caption,
I called this argument

1090
00:50:15,519 --> 00:50:17,838
just method.

1091
00:50:17,838 --> 00:50:19,718
And really what this method object is

1092
00:50:19,718 --> 00:50:21,637
is it's really a combination of

1093
00:50:21,637 --> 00:50:25,237
the four parameters we
saw in the after advice.

1094
00:50:25,237 --> 00:50:26,677
I can interrogate that object

1095
00:50:26,677 --> 00:50:29,036
to find out the name of the method,

1096
00:50:29,036 --> 00:50:31,496
any parameters that have
been sent to the method,

1097
00:50:31,496 --> 00:50:35,717
and also, a reference to
the target objects as well.

1098
00:50:35,717 --> 00:50:37,296
So what I need to do in here, is

1099
00:50:37,296 --> 00:50:41,135
I need to plug in my
before and after code.

1100
00:50:41,135 --> 00:50:42,696
Now the before code is going to be

1101
00:50:42,696 --> 00:50:46,194
the old, get the start time

1102
00:50:46,194 --> 00:50:48,775
from the system class

1103
00:50:48,775 --> 00:50:53,021
and I think I called the nanotime method.

1104
00:50:54,691 --> 00:50:57,951
Then we need to proceed
to the target method

1105
00:50:57,951 --> 00:51:01,951
so we do that by calling
on the method object.

1106
00:51:01,951 --> 00:51:03,562
The proceed method.

1107
00:51:03,562 --> 00:51:05,800
Now remember that's
going to return a value.

1108
00:51:05,800 --> 00:51:07,770
We don't know what type of object

1109
00:51:07,770 --> 00:51:08,999
will be returned by it

1110
00:51:08,999 --> 00:51:11,398
but it will be some object,

1111
00:51:11,398 --> 00:51:13,966
and I'll call that the returnValue.

1112
00:51:16,016 --> 00:51:17,536
In fact, I'll put the comments in here

1113
00:51:17,536 --> 00:51:20,356
to say that's the before,

1114
00:51:20,356 --> 00:51:23,696
that's the proceed to target,

1115
00:51:23,696 --> 00:51:26,006
and then, once we've
run the target method,

1116
00:51:26,006 --> 00:51:28,074
we can do our after advice,

1117
00:51:28,074 --> 00:51:31,062
which is to take the end time.

1118
00:51:34,581 --> 00:51:37,591
And then I'm going to
calculate the time taken

1119
00:51:41,111 --> 00:51:44,420
by subtracting the start
time from the end time.

1120
00:51:44,420 --> 00:51:46,760
Now I should convert
this into milliseconds

1121
00:51:46,760 --> 00:51:48,760
to make it a little bit more readable

1122
00:51:48,760 --> 00:51:53,579
but just for speed, I'll
stick to the nanoseconds

1123
00:51:53,579 --> 00:51:56,380
and you can convert it, if you wish.

1124
00:51:56,380 --> 00:51:59,200
The method and,

1125
00:51:59,200 --> 00:52:02,099
let's output the name of the method,

1126
00:52:02,099 --> 00:52:03,480
and you can do that by calling,

1127
00:52:03,480 --> 00:52:06,579
on this method invocation object,

1128
00:52:06,579 --> 00:52:08,579
there is a method in there,

1129
00:52:08,579 --> 00:52:10,249
called getMethod.

1130
00:52:12,519 --> 00:52:14,759
Far too many uses of
the word "method" there

1131
00:52:14,759 --> 00:52:16,298
but that will return as

1132
00:52:16,298 --> 00:52:20,346
the standard Java
Reflection method instance,

1133
00:52:20,346 --> 00:52:24,187
which has the getName inside it,

1134
00:52:24,187 --> 00:52:27,277
and then I can say that that took,

1135
00:52:29,107 --> 00:52:31,846
the timeTaken,

1136
00:52:31,846 --> 00:52:34,876
number of nanoseconds.

1137
00:52:36,806 --> 00:52:39,006
So that will be output to the console

1138
00:52:39,006 --> 00:52:41,347
and I mustn't forget at the end of here

1139
00:52:41,347 --> 00:52:44,486
to return the returnValue

1140
00:52:44,486 --> 00:52:47,226
that came back from the target object.

1141
00:52:47,226 --> 00:52:50,546
Make sure that gets back to the client.

1142
00:52:50,546 --> 00:52:52,866
Now that's not particularly exciting code

1143
00:52:52,866 --> 00:52:55,826
but compare what we have here

1144
00:52:55,826 --> 00:52:58,706
with the code that we had
in the previous chapter,

1145
00:52:58,706 --> 00:53:00,426
where I had to copy and paste

1146
00:53:00,426 --> 00:53:02,766
this before and after code

1147
00:53:02,766 --> 00:53:06,405
into every single method

1148
00:53:06,405 --> 00:53:08,625
that appeared in our proxy.

1149
00:53:08,625 --> 00:53:11,835
Well, now the proxy's being
automatically generated

1150
00:53:11,835 --> 00:53:15,554
using just this single method.

1151
00:53:15,554 --> 00:53:17,255
Now I have,

1152
00:53:17,255 --> 00:53:20,795
at the moment, five methods
in my service class.

1153
00:53:20,795 --> 00:53:23,935
So this performance
timing advice should now

1154
00:53:23,935 --> 00:53:26,434
be wrapped around all five methods

1155
00:53:26,434 --> 00:53:28,914
in my BookService.

1156
00:53:28,914 --> 00:53:31,274
Well, that's only good if it works.

1157
00:53:31,274 --> 00:53:34,364
Once again, I don't need to change the XML

1158
00:53:34,364 --> 00:53:35,872
because the XML doesn't care whether

1159
00:53:35,872 --> 00:53:39,551
it's before, after, or around advice.

1160
00:53:39,551 --> 00:53:40,820
And...

1161
00:53:42,511 --> 00:53:43,940
And this looks good!

1162
00:53:43,940 --> 00:53:46,330
It's reporting that registerNewBook took

1163
00:53:46,330 --> 00:53:48,209
a certain number of nanoseconds,

1164
00:53:48,209 --> 00:53:51,709
and getEntireCatalog took

1165
00:53:51,709 --> 00:53:54,668
maybe slightly fewer nanoseconds?

1166
00:53:54,668 --> 00:53:56,468
This is interesting however.

1167
00:53:56,468 --> 00:53:59,468
If we go down towards
the bottom of the output,

1168
00:53:59,468 --> 00:54:01,869
remember that the very last method called,

1169
00:54:01,869 --> 00:54:04,188
that we're making in the client,

1170
00:54:04,188 --> 00:54:05,526
is a call to the

1171
00:54:05,526 --> 00:54:09,406
getBookByIsbn method.

1172
00:54:09,406 --> 00:54:10,546
That method should have had

1173
00:54:10,546 --> 00:54:13,207
the timing advice applied to it.

1174
00:54:13,207 --> 00:54:15,166
But the reason it's not
reporting is because

1175
00:54:15,166 --> 00:54:17,466
an exception was thrown

1176
00:54:17,466 --> 00:54:20,307
by that method.

1177
00:54:20,307 --> 00:54:23,146
So if we go into the advice,

1178
00:54:23,146 --> 00:54:26,886
the exception is being
thrown on this line here,

1179
00:54:26,886 --> 00:54:29,427
when we called the target method.

1180
00:54:29,427 --> 00:54:34,306
And therefore, the rest of
the advice is not occurring.

1181
00:54:34,306 --> 00:54:36,545
Now, to fix that problem,

1182
00:54:36,545 --> 00:54:39,386
we're really in standard Java.

1183
00:54:39,386 --> 00:54:42,424
I will need to add in a try block,

1184
00:54:43,624 --> 00:54:47,924
where we try to call the target method,

1185
00:54:49,434 --> 00:54:52,493
and then finally,

1186
00:54:52,493 --> 00:54:54,963
regardless of what happened,

1187
00:54:54,963 --> 00:54:59,603
I need to do the reporting of the timing.

1188
00:54:59,603 --> 00:55:01,123
Now I'm going to be a bit careful here

1189
00:55:01,123 --> 00:55:04,253
because I've declared the
start time inside the try block

1190
00:55:04,253 --> 00:55:06,473
so it's not visible in the finally block.

1191
00:55:06,473 --> 00:55:08,413
Well, in fact,

1192
00:55:08,413 --> 00:55:10,863
the before doesn't need to be in the try

1193
00:55:10,863 --> 00:55:13,343
because we know that will always work,

1194
00:55:13,343 --> 00:55:16,363
there will be no exception thrown there.

1195
00:55:16,363 --> 00:55:20,193
Actually, the return, I
don't know how you are with

1196
00:55:21,423 --> 00:55:24,703
try-finally blocks but the
return needs to go in here

1197
00:55:24,703 --> 00:55:26,763
because the return only needs to happen

1198
00:55:26,763 --> 00:55:29,663
if the try was successful.

1199
00:55:29,663 --> 00:55:32,933
But remember, if there
was an exception here,

1200
00:55:33,943 --> 00:55:37,323
then the finally will still run,

1201
00:55:37,323 --> 00:55:40,953
and it will run before the return happens.

1202
00:55:41,943 --> 00:55:45,263
And of course, if an
exception doesn't happen,

1203
00:55:45,263 --> 00:55:46,823
then the same thing will happen.

1204
00:55:46,823 --> 00:55:49,043
The finally block will run.

1205
00:55:50,533 --> 00:55:52,333
I always get a little bit confused

1206
00:55:52,333 --> 00:55:54,452
when I work on try-finally blocks

1207
00:55:54,452 --> 00:55:56,482
so I hope you're okay with that.

1208
00:55:56,482 --> 00:55:59,343
It is just standard Java.

1209
00:55:59,343 --> 00:56:01,753
And with change in place...

1210
00:56:04,923 --> 00:56:07,083
Yeah, now we're getting

1211
00:56:07,083 --> 00:56:09,403
a report on the registerNewBook

1212
00:56:09,403 --> 00:56:11,303
and getEntire Catalog method,

1213
00:56:11,303 --> 00:56:15,323
and the getBookByIsbn method
is correctly reporting

1214
00:56:15,323 --> 00:56:18,683
the time it took as well.

1215
00:56:18,683 --> 00:56:20,863
Now I hope you found that useful.

1216
00:56:20,863 --> 00:56:23,223
The key magic here

1217
00:56:23,223 --> 00:56:25,963
is really in the XML

1218
00:56:25,963 --> 00:56:29,063
on this block here.

1219
00:56:29,063 --> 00:56:31,343
We're effectively asking Spring to use

1220
00:56:31,343 --> 00:56:34,222
the standard Java development kit

1221
00:56:34,222 --> 00:56:37,603
to generate a dynamic proxy for us.

1222
00:56:37,603 --> 00:56:41,043
So at runtime, Java is
generating that class

1223
00:56:41,043 --> 00:56:44,062
that we wrote manually and tediously

1224
00:56:44,062 --> 00:56:46,442
in the previous chapter.

1225
00:56:46,442 --> 00:56:50,042
Now what people really
loved about Spring AOP,

1226
00:56:50,042 --> 00:56:53,542
when it was first released,
was how simple it is.

1227
00:56:53,542 --> 00:56:54,922
And I can certainly say that

1228
00:56:54,922 --> 00:56:57,242
it is much, much simpler

1229
00:56:57,242 --> 00:57:01,762
than the approach used by
the rival framework, AspectJ.

1230
00:57:01,762 --> 00:57:03,342
In AspectJ, we would have had to use

1231
00:57:03,342 --> 00:57:05,152
a special compiler,

1232
00:57:05,152 --> 00:57:07,732
to make all of this work.

1233
00:57:07,732 --> 00:57:09,632
But there is a problem.

1234
00:57:09,632 --> 00:57:12,132
At the moment, we've applied our advice to

1235
00:57:12,132 --> 00:57:14,312
one service class.

1236
00:57:14,312 --> 00:57:16,712
That's the BookService.

1237
00:57:16,712 --> 00:57:20,132
But, of course, we want
to apply this advice to

1238
00:57:20,132 --> 00:57:22,472
all of our service classes,

1239
00:57:22,472 --> 00:57:24,052
and we've got three of them

1240
00:57:24,052 --> 00:57:25,672
at the moment.

1241
00:57:25,672 --> 00:57:28,432
So we'd have to do this block of XML

1242
00:57:28,432 --> 00:57:30,932
another two times

1243
00:57:30,932 --> 00:57:33,552
to make it work for all
of our service classes.

1244
00:57:33,552 --> 00:57:35,172
Now maybe that's not too bad

1245
00:57:35,172 --> 00:57:37,512
but of course, on a real project,

1246
00:57:37,512 --> 00:57:40,032
where we might have
tens of service classes

1247
00:57:40,032 --> 00:57:42,492
that would get tedious.

1248
00:57:42,492 --> 00:57:44,852
Now there was a way to do that

1249
00:57:44,852 --> 00:57:47,732
using the basic XML technique

1250
00:57:47,732 --> 00:57:51,272
but I can tell you that
continuing like this,

1251
00:57:51,272 --> 00:57:54,312
by declaring the proxies in the XML,

1252
00:57:54,312 --> 00:57:56,572
the XML does, I'm afraid, start to get

1253
00:57:56,572 --> 00:58:00,041
really unwieldy and complicated,

1254
00:58:00,041 --> 00:58:03,160
and that was the big weakness of the AOP

1255
00:58:03,160 --> 00:58:05,180
that was in Spring from the start.

1256
00:58:05,180 --> 00:58:09,390
However, in Spring2 they
added a new technique

1257
00:58:09,390 --> 00:58:11,850
for applying AOP.

1258
00:58:11,850 --> 00:58:13,480
Now it is a bit more complicated

1259
00:58:13,480 --> 00:58:14,480
than what we've seen here

1260
00:58:14,480 --> 00:58:16,729
but it's much more flexible

1261
00:58:16,729 --> 00:58:20,919
and it uses something from AspectJ

1262
00:58:20,919 --> 00:58:24,469
called the pointcut syntax.

1263
00:58:24,469 --> 00:58:26,929
And all is going to be revealed about

1264
00:58:26,929 --> 00:58:30,490
how the AspectJ pointcut syntax works

1265
00:58:30,490 --> 00:58:32,750
after the break.

1266
00:58:32,750 --> 00:58:34,769
So you've seen before,

1267
00:58:34,769 --> 00:58:37,409
after, and around advice.

1268
00:58:37,409 --> 00:58:40,329
And there's not a lot of
difference in how they work,

1269
00:58:40,329 --> 00:58:44,539
just different interfaces to implement.

1270
00:58:44,539 --> 00:58:48,139
We've now studied the
"Old School" approach,

1271
00:58:48,139 --> 00:58:50,388
which is to write that block of XML

1272
00:58:50,388 --> 00:58:53,108
to tell Spring that we want it to weave

1273
00:58:53,108 --> 00:58:56,967
a piece of advice with our target class.

1274
00:58:56,967 --> 00:58:59,588
But it isn't very flexible.

1275
00:58:59,588 --> 00:59:02,207
We want to weave with
three service classes

1276
00:59:02,207 --> 00:59:03,887
so we'd have to repeat that

1277
00:59:03,887 --> 00:59:08,317
ugly block of XML three times.

1278
00:59:08,317 --> 00:59:12,676
Using XML for AOP is considered legacy,

1279
00:59:12,676 --> 00:59:16,136
and I would avoid it if you possibly can.

1280
00:59:16,136 --> 00:59:18,575
It's been there in Spring since the start

1281
00:59:18,575 --> 00:59:21,315
but there is now a much better alternative

1282
00:59:21,315 --> 00:59:25,275
called the AspectJ pointcut syntax.

1283
00:59:25,275 --> 00:59:26,755
And we'll be doing that

1284
00:59:26,755 --> 00:59:29,155
in my favorite chapter in the course,

1285
00:59:29,155 --> 00:59:31,224
which is coming up next.

1
00:00:00,040 --> 00:00:02,873
(energetic music)

2
00:00:10,360 --> 00:00:11,740
- [Voiceover] This is Chapter 15!

3
00:00:11,740 --> 00:00:13,680
Where we'll use a much better technique

4
00:00:13,680 --> 00:00:16,216
for configuring your AOP.

5
00:00:16,216 --> 00:00:18,549
The AspectJ Pointcut Syntax.

6
00:00:20,560 --> 00:00:23,920
I'll need to tell you
what a pointcut is first.

7
00:00:23,920 --> 00:00:26,520
And then we'll see that,
using this new technique,

8
00:00:26,520 --> 00:00:30,299
our advice class can be a plain java class

9
00:00:30,299 --> 00:00:34,060
rather than needing to
implement a special interface.

10
00:00:34,060 --> 00:00:38,352
That's not a great big deal,
but it is a bit more elegant.

11
00:00:38,352 --> 00:00:40,499
Then, for the first time on the course,

12
00:00:40,499 --> 00:00:44,460
we'll use something called
a namespace in the XML.

13
00:00:44,460 --> 00:00:48,320
This is an additional
set of powerful tags.

14
00:00:48,320 --> 00:00:51,539
The AOP:Namespace lets
you configure the proxies

15
00:00:51,539 --> 00:00:54,785
in a really straightforward way.

16
00:00:54,785 --> 00:00:57,303
This is quite a long chapter
because I've included

17
00:00:57,303 --> 00:01:01,042
yet another alternative configuration.

18
00:01:01,042 --> 00:01:04,870
You can use Annotations instead of XML.

19
00:01:04,870 --> 00:01:08,736
I don't like this and I'll
tell you why when we get there.

20
00:01:08,736 --> 00:01:12,890
But in case you like it or
need to use it on your project,

21
00:01:12,890 --> 00:01:17,057
we'll spend the last 10
minutes of the chapter on that.

22
00:01:18,210 --> 00:01:21,610
The AOP that we studied
in the previous chapter

23
00:01:21,610 --> 00:01:25,777
is the most basic form of
AOP that Spring supports.

24
00:01:26,850 --> 00:01:31,017
But so far, we've only applied
advice to a single class.

25
00:01:32,873 --> 00:01:35,930
Now usually, we'll want to apply advice

26
00:01:35,930 --> 00:01:38,651
to more than one class.

27
00:01:38,651 --> 00:01:41,606
In our PerformanceTimingAdvice,
for example,

28
00:01:41,606 --> 00:01:43,610
we would want to apply the advice

29
00:01:43,610 --> 00:01:46,811
to all of our service classes.

30
00:01:46,811 --> 00:01:51,591
And this means, using the
approach that we've used so far,

31
00:01:51,591 --> 00:01:55,731
we would have to repeat
this block of XML here

32
00:01:55,731 --> 00:01:58,231
for every one of our services.

33
00:01:59,651 --> 00:02:02,210
Also not good is that we
would have to remember

34
00:02:02,210 --> 00:02:04,291
to do that as well.

35
00:02:04,291 --> 00:02:06,686
Imagine that if we write
a new service class

36
00:02:06,686 --> 00:02:11,230
but then we forget to set
up one of these proxies,

37
00:02:11,230 --> 00:02:16,130
then that service class will
now not get the advice applied.

38
00:02:16,130 --> 00:02:17,970
Now that's maybe not a big problem

39
00:02:17,970 --> 00:02:20,791
if it's just this timing advice,

40
00:02:20,791 --> 00:02:23,689
but if the aspect was
something more serious,

41
00:02:23,689 --> 00:02:28,023
such as security, then we
would have a real problem.

42
00:02:28,023 --> 00:02:30,944
We'd have an unsecure system.

43
00:02:30,944 --> 00:02:35,096
Now in version one of Spring,
you could fix this problem

44
00:02:35,096 --> 00:02:38,096
using something called an AutoProxy.

45
00:02:39,156 --> 00:02:43,056
It worked okay, but it was
a little bit complicated

46
00:02:43,056 --> 00:02:46,889
and it did still result
in quite a lot of XML.

47
00:02:47,816 --> 00:02:52,198
I did cover this in the
first edition of the course.

48
00:02:52,198 --> 00:02:56,577
But these days, most projects,
probably all projects,

49
00:02:56,577 --> 00:03:00,144
avoid using the method of auto proxies.

50
00:03:00,144 --> 00:03:03,595
So, I'm going to call
that the old-fashioned way

51
00:03:03,595 --> 00:03:05,595
of doing things.

52
00:03:05,595 --> 00:03:09,915
In this chapter, we're going
to replace the work we've done

53
00:03:09,915 --> 00:03:11,936
and we're going to switch
to the new features

54
00:03:11,936 --> 00:03:15,216
that were added back in Spring 2.

55
00:03:15,216 --> 00:03:18,975
And these new features really do make AOP

56
00:03:18,975 --> 00:03:22,316
much simpler and more powerful.

57
00:03:22,316 --> 00:03:24,632
And the biggest of these new features

58
00:03:24,632 --> 00:03:27,799
is something called a pointcut syntax.

59
00:03:29,674 --> 00:03:32,900
Now this allows you to declare to Spring

60
00:03:32,900 --> 00:03:34,460
that we want the advice applying

61
00:03:34,460 --> 00:03:38,600
to more than one service
class really easily.

62
00:03:38,600 --> 00:03:40,880
And we can go even further.

63
00:03:40,880 --> 00:03:43,085
We can make the advice only apply

64
00:03:43,085 --> 00:03:46,418
to some of the methods in those classes.

65
00:03:47,584 --> 00:03:49,684
It gets really powerful.

66
00:03:49,684 --> 00:03:53,064
So we're studying this
new pointcut syntax.

67
00:03:53,064 --> 00:03:56,805
Well, pointcut is an
interesting jargon term.

68
00:03:56,805 --> 00:03:58,644
What does it mean?

69
00:03:58,644 --> 00:04:01,477
Well, a pointcut is a set of rules

70
00:04:03,245 --> 00:04:08,165
determining to which
methods, and in which classes

71
00:04:08,165 --> 00:04:11,165
a piece of advice should be applied.

72
00:04:12,345 --> 00:04:16,345
So, for example, we might
have a piece of advice

73
00:04:17,755 --> 00:04:21,338
that we want to apply
to all of the methods

74
00:04:22,205 --> 00:04:24,362
beginning with the word 'get'

75
00:04:24,362 --> 00:04:26,862
in all of our service classes.

76
00:04:28,302 --> 00:04:30,321
So, in other words, this piece of advice,

77
00:04:30,321 --> 00:04:34,019
I want to apply to all querying methods

78
00:04:34,019 --> 00:04:36,341
in my service classes.

79
00:04:36,341 --> 00:04:38,881
As I've mentioned, using
Spring XML to do this

80
00:04:38,881 --> 00:04:40,872
would be really difficult.

81
00:04:40,872 --> 00:04:45,039
But this new pointcut syntax
makes it really quite easy.

82
00:04:46,721 --> 00:04:50,242
In Spring 2, the people
behind Spring decided

83
00:04:50,242 --> 00:04:54,409
that they would borrow a
syntax invented by AspectJ.

84
00:04:57,201 --> 00:04:59,361
Now I briefly mentioned AspectJ

85
00:04:59,361 --> 00:05:02,001
in some of the previous chapters.

86
00:05:02,001 --> 00:05:05,918
Here's their website,
the URL you can see here.

87
00:05:07,382 --> 00:05:10,262
It happens to be hosted
by the Eclipse Project,

88
00:05:10,262 --> 00:05:12,282
but, is in fact, independent

89
00:05:12,282 --> 00:05:15,482
of the development environment.

90
00:05:15,482 --> 00:05:18,489
So this is another open source project

91
00:05:18,489 --> 00:05:21,682
which is completely independent of Spring.

92
00:05:21,682 --> 00:05:25,849
This is a dedicated Aspect
Oriented Programming Framework.

93
00:05:26,908 --> 00:05:29,603
And its and incredibly powerful framework.

94
00:05:29,603 --> 00:05:33,770
It goes far further than the
AOP that we can do in Spring.

95
00:05:35,043 --> 00:05:39,383
But it does have a much
steeper learning curve.

96
00:05:39,383 --> 00:05:43,550
One thing that AspectJ have
always had is a pointcut syntax.

97
00:05:45,444 --> 00:05:50,003
And this syntax will allow you
to express your requirements

98
00:05:50,003 --> 00:05:54,596
in the form of what essentially
looks like a wildcard.

99
00:05:54,596 --> 00:05:57,612
Now Spring have borrowed this syntax

100
00:05:57,612 --> 00:06:00,449
and absorbed it into Spring AOP.

101
00:06:00,449 --> 00:06:02,855
Let's have a look at a few examples

102
00:06:02,855 --> 00:06:06,309
of what this pointcut syntax looks like.

103
00:06:06,309 --> 00:06:09,809
Let's assume that we've
written some kind of advice.

104
00:06:09,809 --> 00:06:13,909
It might be performanceTiming
like we did previously

105
00:06:13,909 --> 00:06:18,869
or it could be something like
security or transactions.

106
00:06:18,869 --> 00:06:20,949
And let's assume, for some reason,

107
00:06:20,949 --> 00:06:24,069
that we want to set up the advice

108
00:06:24,069 --> 00:06:26,199
so that it's going to apply

109
00:06:26,199 --> 00:06:29,866
to all methods in all
of our service classes

110
00:06:31,179 --> 00:06:34,258
that begin with the word 'get'.

111
00:06:34,258 --> 00:06:35,717
A bit ambiguous there.

112
00:06:35,717 --> 00:06:39,884
I mean the methods need to
begin with the word 'get'.

113
00:06:41,312 --> 00:06:45,018
Now what we can do using
this AspectJ syntax

114
00:06:45,018 --> 00:06:49,185
is we can specify our
requirement in a single string.

115
00:06:50,712 --> 00:06:53,462
And it looks something like this.

116
00:06:54,593 --> 00:06:56,212
Now be a little bit careful,

117
00:06:56,212 --> 00:06:58,161
this isn't complete yet.

118
00:06:58,161 --> 00:06:59,333
It's not correct.

119
00:06:59,333 --> 00:07:02,083
It wouldn't actually compile.

120
00:07:02,083 --> 00:07:03,831
But I'm going to build it up

121
00:07:03,831 --> 00:07:07,572
and add more elements as we
go through further examples.

122
00:07:07,572 --> 00:07:11,232
And it will give me a chance
to explain the concepts.

123
00:07:11,232 --> 00:07:13,632
The key thing about the pointcut

124
00:07:13,632 --> 00:07:17,752
is it's really nothing
more than a wildcard.

125
00:07:17,752 --> 00:07:21,274
I'm saying here I want
to look for all classes

126
00:07:21,274 --> 00:07:23,941
with the word 'Service' in them.

127
00:07:24,813 --> 00:07:27,472
So I'm beginning with an *

128
00:07:27,472 --> 00:07:30,722
and I'm ending my class name with an *.

129
00:07:31,792 --> 00:07:34,992
And then I'm saying, with the . ,

130
00:07:34,992 --> 00:07:37,575
that the advice must only apply

131
00:07:38,552 --> 00:07:42,692
to methods beginning with the word 'get'.

132
00:07:42,692 --> 00:07:45,812
And then, of course, with the * here,

133
00:07:45,812 --> 00:07:50,451
we can have any characters in
the rest of the method name.

134
00:07:50,451 --> 00:07:54,773
So that's the core of an AspectJ pointcut.

135
00:07:54,773 --> 00:07:58,312
And if we were to use
this syntax in AspectJ,

136
00:07:58,312 --> 00:08:02,073
AspectJ would look for all
of the matching classes

137
00:08:02,073 --> 00:08:03,500
and then it will focus

138
00:08:03,500 --> 00:08:06,423
on the matching methods in those classes

139
00:08:06,423 --> 00:08:10,503
and it will weave the
advice into those methods.

140
00:08:10,503 --> 00:08:14,083
Well, this isn't an AspectJ
course, it is a Spring course.

141
00:08:14,083 --> 00:08:18,250
And from Spring 2 onwards,
they've absorbed the same syntax.

142
00:08:19,720 --> 00:08:23,923
They've borrowed this
pointcut syntax from AspectJ,

143
00:08:23,923 --> 00:08:25,563
included it into Spring.

144
00:08:25,563 --> 00:08:26,883
Please don't get confused.

145
00:08:26,883 --> 00:08:30,861
We are not using AspectJ in this chapter.

146
00:08:30,861 --> 00:08:33,503
We're still using Spring AOP.

147
00:08:33,503 --> 00:08:37,123
And that means we're still
using the same dynamic proxies

148
00:08:37,123 --> 00:08:40,283
that we've been working with throughout.

149
00:08:40,283 --> 00:08:44,535
It's just this syntax for
declaring the advice in the XML

150
00:08:44,535 --> 00:08:47,396
will be a lot cleaner than before.

151
00:08:47,396 --> 00:08:50,183
Now, the syntax can get
really quite sophisticated.

152
00:08:50,183 --> 00:08:52,523
I'm going to build this example up

153
00:08:52,523 --> 00:08:55,583
and show you some alternatives.

154
00:08:55,583 --> 00:08:58,603
For example, we could
change the requirements

155
00:08:58,603 --> 00:09:00,704
and we could say that, "Well, actually,

156
00:09:00,704 --> 00:09:03,823
"we now want the advice to only apply

157
00:09:03,823 --> 00:09:07,268
"to methods in the service classes

158
00:09:07,268 --> 00:09:10,884
"but they must begin with the word 'get'."

159
00:09:10,884 --> 00:09:13,483
And that's the same as we had before.

160
00:09:13,483 --> 00:09:16,564
But we only want the
advice to apply to methods

161
00:09:16,564 --> 00:09:19,981
that take a String as the first parameter

162
00:09:21,264 --> 00:09:23,944
and then for the second parameter,

163
00:09:23,944 --> 00:09:27,583
well, we don't care what
that type of parameter is.

164
00:09:27,583 --> 00:09:31,750
It could be an int, a boolean,
a float, a long, and so on.

165
00:09:32,954 --> 00:09:36,585
But it must have a second parameter.

166
00:09:36,585 --> 00:09:38,385
Now this is really quite useful,

167
00:09:38,385 --> 00:09:40,485
because you might have some advice

168
00:09:40,485 --> 00:09:42,985
that's very specific advice

169
00:09:42,985 --> 00:09:47,184
and only needs to target a
certain class of methods.

170
00:09:47,184 --> 00:09:50,285
Well, by being specific
about the types of parameters

171
00:09:50,285 --> 00:09:54,263
the target methods are
accepting, you can really focus

172
00:09:54,263 --> 00:09:57,756
on the method that you're looking for.

173
00:09:57,756 --> 00:10:02,026
Well, I would say its quite
unusual to be so specific

174
00:10:02,026 --> 00:10:05,886
about the types of the
parameters that you want.

175
00:10:05,886 --> 00:10:08,493
So I'll change the example again

176
00:10:08,493 --> 00:10:10,160
and we can, instead,

177
00:10:11,250 --> 00:10:13,000
use this .. notation.

178
00:10:14,626 --> 00:10:18,914
And the .. notation means
we really don't care

179
00:10:18,914 --> 00:10:23,206
about what types of
parameters are accepted

180
00:10:23,206 --> 00:10:25,226
by the target methods.

181
00:10:25,226 --> 00:10:27,786
So this really does mean all methods

182
00:10:27,786 --> 00:10:30,126
beginning with the word 'get'.

183
00:10:30,126 --> 00:10:31,912
And it could have no parameters

184
00:10:31,912 --> 00:10:34,829
or one parameter or 115 parameters.

185
00:10:36,638 --> 00:10:39,318
Now that was my intention
with the very first example

186
00:10:39,318 --> 00:10:41,592
I showed you, but I need to point out

187
00:10:41,592 --> 00:10:44,891
that you do always need the ().

188
00:10:44,891 --> 00:10:48,932
And you've got say something
about the parameters.

189
00:10:48,932 --> 00:10:51,515
So this .. means we don't care.

190
00:10:53,219 --> 00:10:55,732
Now it's not just the input parameters

191
00:10:55,732 --> 00:10:58,072
that we need to consider.

192
00:10:58,072 --> 00:11:00,651
We can also discriminate our advice

193
00:11:00,651 --> 00:11:05,077
based on the return types
of the target methods.

194
00:11:05,077 --> 00:11:08,952
Let's be more specific and
say that, "Well, this advice

195
00:11:08,952 --> 00:11:13,364
"only needs to be applied to
methods in service classes

196
00:11:13,364 --> 00:11:18,287
"beginning with the word 'get',
but they must return Lists."

197
00:11:18,287 --> 00:11:20,237
So I've made the change here.

198
00:11:20,237 --> 00:11:22,270
At the front of the pointcut,

199
00:11:22,270 --> 00:11:26,437
we're specifying the return
type of the matching method.

200
00:11:27,587 --> 00:11:31,712
So in this case, if a target
method in a service class

201
00:11:31,712 --> 00:11:35,041
is a void method or returns an integer,

202
00:11:35,041 --> 00:11:37,652
then the advice would not be applied.

203
00:11:37,652 --> 00:11:40,932
We're only going to apply
the advice to methods

204
00:11:40,932 --> 00:11:42,432
that return Lists.

205
00:11:43,535 --> 00:11:46,872
Now, often, probably most of the time,

206
00:11:46,872 --> 00:11:51,854
you don't care what the return
type of the target method is.

207
00:11:51,854 --> 00:11:55,132
In which case, once again,
you would use a wildcard

208
00:11:55,132 --> 00:11:57,112
for the return type.

209
00:11:57,112 --> 00:12:00,632
So, I'm going to change the example again.

210
00:12:00,632 --> 00:12:05,125
Now, I'm saying I don't care
what the return type is.

211
00:12:05,125 --> 00:12:08,052
Now you must always have a reference

212
00:12:08,052 --> 00:12:11,412
to the return type in the pointcut syntax.

213
00:12:11,412 --> 00:12:14,032
That's why my earlier
examples wouldn't work

214
00:12:14,032 --> 00:12:15,409
and wouldn't compile.

215
00:12:15,409 --> 00:12:19,032
You've got to have some thing here.

216
00:12:19,032 --> 00:12:22,032
Either an * or a specific type name.

217
00:12:23,573 --> 00:12:25,759
Well, I have to admit that the expressions

218
00:12:25,759 --> 00:12:28,982
I've showed you over the last few minutes

219
00:12:28,982 --> 00:12:33,149
haven't actually been full
AspectJ pointcut expressions.

220
00:12:34,159 --> 00:12:36,739
They wouldn't have compiled,

221
00:12:36,739 --> 00:12:40,906
because we always have to
specify the phrase 'execution'

222
00:12:42,234 --> 00:12:45,984
at the front followed by ().

223
00:12:47,339 --> 00:12:49,984
That's because we're applying this advice

224
00:12:49,984 --> 00:12:52,817
to all of these method executions.

225
00:12:54,519 --> 00:12:58,079
Now that's a bit strange
because in Spring AOP,

226
00:12:58,079 --> 00:13:02,246
really, all of the advice is
applied to method executions.

227
00:13:05,166 --> 00:13:07,174
It's just that in AspectJ,

228
00:13:07,174 --> 00:13:10,613
in the true, full AspectJ framework,

229
00:13:10,613 --> 00:13:13,938
you can do lots of other types of AOP.

230
00:13:13,938 --> 00:13:16,860
Such as, for example, you can apply advice

231
00:13:16,860 --> 00:13:20,833
to whenever you read an attribute's value

232
00:13:20,833 --> 00:13:24,380
and not just when you call methods.

233
00:13:24,380 --> 00:13:28,120
So in the full AspectJ syntax,
there are other phrases

234
00:13:28,120 --> 00:13:31,537
that you can put in place of execution.

235
00:13:31,537 --> 00:13:33,920
But to be honest, in Spring AOP

236
00:13:33,920 --> 00:13:36,420
not much of that is supported.

237
00:13:36,420 --> 00:13:40,800
You're almost always going
to see the phrase 'execution'

238
00:13:40,800 --> 00:13:43,780
here at the front of the expression.

239
00:13:43,780 --> 00:13:46,667
There are some alternatives
and I'll show you those

240
00:13:46,667 --> 00:13:50,958
in the Spring reference
manual later in this chapter.

241
00:13:50,958 --> 00:13:52,925
I hope that gives you the general idea

242
00:13:52,925 --> 00:13:56,408
of how to write these
pointcut expressions.

243
00:13:56,408 --> 00:14:00,058
We're going to be practicing
writing a few shortly.

244
00:14:00,058 --> 00:14:01,760
But before we can do that, we need to see

245
00:14:01,760 --> 00:14:05,940
how to actually apply
these pointcut expressions

246
00:14:05,940 --> 00:14:08,260
in the Spring XML.

247
00:14:08,260 --> 00:14:11,520
So just to remind ourselves
of where we've left things,

248
00:14:11,520 --> 00:14:16,260
here is the application.xml
file for our bookstore.

249
00:14:16,260 --> 00:14:18,700
And remember, in the previous chapters,

250
00:14:18,700 --> 00:14:21,533
that we have taken our bookService

251
00:14:23,420 --> 00:14:26,670
and we've renamed it bookServiceTarget.

252
00:14:27,560 --> 00:14:30,501
And we've created a new class,

253
00:14:30,501 --> 00:14:33,765
a new bean, rather, called bookService.

254
00:14:33,765 --> 00:14:36,173
Which is one of these proxies.

255
00:14:36,173 --> 00:14:39,590
And it's this proxy which adds the advice

256
00:14:40,913 --> 00:14:45,075
when we created a separate
bean for the actual advice.

257
00:14:45,075 --> 00:14:46,991
Well, I've already indicated

258
00:14:46,991 --> 00:14:50,141
that this is a kind of a
simplistic way of working

259
00:14:50,141 --> 00:14:52,901
and I think it's fairly understandable,

260
00:14:52,901 --> 00:14:57,096
but it does get very unwieldy in the XML.

261
00:14:57,096 --> 00:14:58,816
So, if you're following along with me,

262
00:14:58,816 --> 00:15:01,377
we're going to undo the proxy.

263
00:15:01,377 --> 00:15:05,458
I'm going to delete the entire proxy bean.

264
00:15:05,458 --> 00:15:07,111
We're going to leave the advice in place

265
00:15:07,111 --> 00:15:09,714
because we're still going to need that.

266
00:15:09,714 --> 00:15:13,115
And I'm going to go up to
the point where we created

267
00:15:13,115 --> 00:15:16,959
the bookServiceTarget and
I'm going to revert it back

268
00:15:16,959 --> 00:15:19,746
to being called bookService.

269
00:15:19,746 --> 00:15:23,318
I think I referred to
bookServiceTarget here,

270
00:15:23,318 --> 00:15:27,156
so I'll need to make sure
that has been changed back.

271
00:15:27,156 --> 00:15:30,007
Just to make sure I
haven't broken anything,

272
00:15:30,007 --> 00:15:32,757
I'm going to run the client again

273
00:15:36,409 --> 00:15:39,544
and I just want to check
that the system is running

274
00:15:39,544 --> 00:15:41,444
without any advice applied.

275
00:15:41,444 --> 00:15:44,978
Yes, it looks like
everything is running okay.

276
00:15:44,978 --> 00:15:49,139
Now before I show you this
improved support for XML,

277
00:15:49,139 --> 00:15:51,526
I also want to mention
another big improvement

278
00:15:51,526 --> 00:15:54,782
that was introduced in Spring 2.

279
00:15:54,782 --> 00:15:56,872
Let's find our advice class.

280
00:15:56,872 --> 00:16:00,224
This is the PerformanceTimingAdvice

281
00:16:00,224 --> 00:16:03,465
that we've been working
with through the course.

282
00:16:03,465 --> 00:16:06,144
And recall that we had,

283
00:16:06,144 --> 00:16:08,030
we were absolutely forced,

284
00:16:08,030 --> 00:16:12,696
to implement this interface
called MethodInterceptor

285
00:16:12,696 --> 00:16:15,858
that contains a single
method called invoke

286
00:16:15,858 --> 00:16:19,275
which contains the payload of our advice.

287
00:16:20,133 --> 00:16:24,683
Well in Spring 2, they
dropped that requirement.

288
00:16:24,683 --> 00:16:27,483
And the advice that we write can be stored

289
00:16:27,483 --> 00:16:29,316
in a plain java class.

290
00:16:30,681 --> 00:16:35,350
Now this has two, I think,
really big advantages.

291
00:16:35,350 --> 00:16:37,887
Well, the first easy advantage is

292
00:16:37,887 --> 00:16:41,820
we don't have to remember
to implement the interface

293
00:16:41,820 --> 00:16:44,860
and we don't have to
remember the interface name.

294
00:16:44,860 --> 00:16:46,570
But for me, the big improvement is,

295
00:16:46,570 --> 00:16:49,876
that means that the method that we write,

296
00:16:49,876 --> 00:16:52,170
we can call anything we want.

297
00:16:52,170 --> 00:16:56,463
Whereas, before it had the
rather unpleasant name of

298
00:16:56,463 --> 00:17:01,014
'invoke', now we can give
it a meaningful name.

299
00:17:01,014 --> 00:17:05,181
I've called my performance
timing method here timeMethod

300
00:17:06,980 --> 00:17:09,374
which, just by looking at it,

301
00:17:09,374 --> 00:17:12,015
I can tell what this method is doing.

302
00:17:12,015 --> 00:17:16,727
Whereas the old version, it
wasn't immediately obvious.

303
00:17:16,727 --> 00:17:17,772
Now the other advantage is

304
00:17:17,772 --> 00:17:20,489
that using this old-fashioned
way of the doing things,

305
00:17:20,489 --> 00:17:24,656
you were only allowed one
piece of advice in that class.

306
00:17:26,306 --> 00:17:28,643
So if we were working on a complex project

307
00:17:28,643 --> 00:17:31,942
and we had maybe, I'm making this up,

308
00:17:31,942 --> 00:17:35,740
but if we had different
ways of doing the timing,

309
00:17:35,740 --> 00:17:39,591
we might have five or six
different versions of timing.

310
00:17:39,591 --> 00:17:42,439
We would have to create a separate class

311
00:17:42,439 --> 00:17:45,579
for each of those pieces of advice.

312
00:17:45,579 --> 00:17:47,232
In the new way of doing things,

313
00:17:47,232 --> 00:17:49,436
because this is just a plain java class

314
00:17:49,436 --> 00:17:51,982
and we won't have this interface here,

315
00:17:51,982 --> 00:17:55,269
we can have those 17 methods inside here

316
00:17:55,269 --> 00:17:58,691
all with different meaningful names.

317
00:17:58,691 --> 00:18:00,318
I think that's really valuable

318
00:18:00,318 --> 00:18:04,997
so we can group related
advice methods together

319
00:18:04,997 --> 00:18:06,664
into a single class.

320
00:18:07,657 --> 00:18:10,209
Now there is just one requirement

321
00:18:10,209 --> 00:18:12,711
on the method that we write here.

322
00:18:12,711 --> 00:18:15,903
So I've written a method
here called timeMethod.

323
00:18:15,903 --> 00:18:18,477
If we are writing Around advice

324
00:18:18,477 --> 00:18:23,370
and, therefore, we need to
proceed somewhere in that code,

325
00:18:23,370 --> 00:18:27,537
we are forced to have one
single parameter in the method.

326
00:18:29,241 --> 00:18:33,324
And that parameter is
called ProceedingJoinPoint.

327
00:18:34,240 --> 00:18:37,962
Now that's a little bit jargony
and for that I apologize.

328
00:18:37,962 --> 00:18:39,805
It's a bit awkward.

329
00:18:39,805 --> 00:18:42,957
This is really a replacement

330
00:18:42,957 --> 00:18:47,718
for this MethodInvocation
parameter that we had before.

331
00:18:47,718 --> 00:18:50,625
Now I do not know why they changed it

332
00:18:50,625 --> 00:18:52,868
for a completely different class,

333
00:18:52,868 --> 00:18:56,288
but they did and we've
got to work with it.

334
00:18:56,288 --> 00:18:58,111
So if you're following along with me,

335
00:18:58,111 --> 00:19:00,144
we need to make some changes to this class

336
00:19:00,144 --> 00:19:03,089
to make it a plain java class.

337
00:19:03,089 --> 00:19:05,616
And the first thing we can
do, and this feels good,

338
00:19:05,616 --> 00:19:09,699
is we can remove the
MethodInterceptor interface.

339
00:19:11,336 --> 00:19:13,919
And then we can change the method name.

340
00:19:13,919 --> 00:19:16,104
It can be anything we want now.

341
00:19:16,104 --> 00:19:18,175
Well, you could call it invoke, of course.

342
00:19:18,175 --> 00:19:21,664
But I much prefer
something meaningful here.

343
00:19:21,664 --> 00:19:24,099
And, in fact I'm going to
change what was on the caption

344
00:19:24,099 --> 00:19:26,360
just to prove that it can be anything,

345
00:19:26,360 --> 00:19:30,360
I'm going to call this
performTimingMeasurement.

346
00:19:33,656 --> 00:19:35,290
Remember, though, the awkward thing is

347
00:19:35,290 --> 00:19:39,220
that we are going to have
to change the parameter here

348
00:19:39,220 --> 00:19:44,098
and it's going to be this class
called ProceedingJoinPoint.

349
00:19:44,098 --> 00:19:47,032
Well, if you're like me, you
won't want to type that in,

350
00:19:47,032 --> 00:19:49,312
so once you've typed the first part,

351
00:19:49,312 --> 00:19:53,511
a Control + Space or
Command + Space on a Mac

352
00:19:53,511 --> 00:19:56,594
and that's the only matching
class and it's filled it in.

353
00:19:56,594 --> 00:19:57,814
And if you have a look here,

354
00:19:57,814 --> 00:19:59,600
you'll see that that class does come

355
00:19:59,600 --> 00:20:01,850
from the AspectJ framework.

356
00:20:03,472 --> 00:20:04,654
Now be careful when you're typing that,

357
00:20:04,654 --> 00:20:08,663
that is pro-ceeding and not pre-ceding.

358
00:20:08,663 --> 00:20:11,950
So make sure you're careful
with the spelling there.

359
00:20:11,950 --> 00:20:14,800
Now, I have a compiler here at the moment

360
00:20:14,800 --> 00:20:18,799
purely because I've still
go the override annotation.

361
00:20:18,799 --> 00:20:21,673
Now that was useful when we
were implementing an interface,

362
00:20:21,673 --> 00:20:25,967
but we're not extending or
implementing an interface

363
00:20:25,967 --> 00:20:28,817
or super-class here, so
the override annotation

364
00:20:28,817 --> 00:20:30,150
must be removed.

365
00:20:32,066 --> 00:20:33,738
Now, that's compiling there,

366
00:20:33,738 --> 00:20:36,949
but I do have a compiler error here.

367
00:20:36,949 --> 00:20:41,566
And that's simply because
with this ProceedingJoinPoint,

368
00:20:41,566 --> 00:20:43,979
the method names have changed.

369
00:20:43,979 --> 00:20:48,026
There is a method in there
called proceed, and that's okay.

370
00:20:48,026 --> 00:20:49,926
But if we want to get details

371
00:20:49,926 --> 00:20:52,491
of the method that we've called,

372
00:20:52,491 --> 00:20:54,240
it's slightly different.

373
00:20:54,240 --> 00:20:57,073
They've changed it to getSignature

374
00:20:58,482 --> 00:21:00,232
instead of getMethod.

375
00:21:01,241 --> 00:21:02,647
If you just make that change there,

376
00:21:02,647 --> 00:21:06,219
you can see that everything else compiles.

377
00:21:06,219 --> 00:21:08,271
So I know it seems a little bit awkward

378
00:21:08,271 --> 00:21:10,589
having to make these little changes,

379
00:21:10,589 --> 00:21:13,629
you do have to make these
changes because, I'm afraid,

380
00:21:13,629 --> 00:21:17,068
the advice that we had
before would not have worked

381
00:21:17,068 --> 00:21:20,628
using the AspectJ pointcut syntax.

382
00:21:20,628 --> 00:21:22,540
So we need to look now at how

383
00:21:22,540 --> 00:21:26,707
to actually declare this
pointcut syntax in our XML.

384
00:21:28,314 --> 00:21:30,881
Well this is a big change for the course,

385
00:21:30,881 --> 00:21:33,693
this is a big leap forward for us.

386
00:21:33,693 --> 00:21:37,379
Up until now, we've
been using the bean tag

387
00:21:37,379 --> 00:21:40,039
and the property tag in our XML

388
00:21:40,039 --> 00:21:43,036
and that's been pretty much it.

389
00:21:43,036 --> 00:21:47,203
Well, in Spring 2 they changed
the XML quite dramatically.

390
00:21:49,767 --> 00:21:53,934
And they brought a whole
raft of new tags into Spring.

391
00:21:55,372 --> 00:21:57,728
And these new tags are much more powerful

392
00:21:57,728 --> 00:21:59,609
than the old bean tag.

393
00:21:59,609 --> 00:22:02,026
They can do a lot more stuff.

394
00:22:03,200 --> 00:22:05,233
Now what I'm showing you
here on this slide is,

395
00:22:05,233 --> 00:22:08,482
well, first of all, I'm
declaring my advice bean

396
00:22:08,482 --> 00:22:11,427
exactly the same as I did before.

397
00:22:11,427 --> 00:22:15,094
But here in this block, I
have a completely new block

398
00:22:15,094 --> 00:22:17,863
of Spring configuration.

399
00:22:17,863 --> 00:22:21,030
The aop:config tag allows me to define

400
00:22:23,069 --> 00:22:26,319
the configuration of all of my aspects.

401
00:22:27,648 --> 00:22:30,973
Now, I much stress, this is
quite an important point,

402
00:22:30,973 --> 00:22:33,329
that the end result of using these tags

403
00:22:33,329 --> 00:22:37,984
is exactly the same as we
had in the previous chapters.

404
00:22:37,984 --> 00:22:39,675
Spring is going to go away

405
00:22:39,675 --> 00:22:43,758
and create some dynamic
proxies for our services.

406
00:22:45,907 --> 00:22:48,681
It's just that we don't have to manually

407
00:22:48,681 --> 00:22:52,514
and laboriously declare
those proxies anymore.

408
00:22:53,412 --> 00:22:57,468
The block of code you can see
here that I'm highlighting,

409
00:22:57,468 --> 00:22:59,634
is doing all of the work

410
00:22:59,634 --> 00:23:04,100
that we had in lots more
lines of XML previously.

411
00:23:04,100 --> 00:23:05,791
Let's go through it all.

412
00:23:05,791 --> 00:23:09,249
First of all, I'm telling
Spring that I have an aspect

413
00:23:09,249 --> 00:23:12,460
and the ref is pointing
to the device class

414
00:23:12,460 --> 00:23:14,341
that I'm talking about.

415
00:23:14,341 --> 00:23:18,386
In my case, it's this
bean called loggingAdvice.

416
00:23:18,386 --> 00:23:22,089
I've always had that loggingAdvice bean.

417
00:23:22,089 --> 00:23:24,905
And then, inside that tag,

418
00:23:24,905 --> 00:23:29,072
I'm telling Spring that I
want this to be around advice.

419
00:23:30,225 --> 00:23:32,581
So notice, now, that it's in the XML

420
00:23:32,581 --> 00:23:36,742
that we say whether it's
before, after, or around advice.

421
00:23:36,742 --> 00:23:38,015
And that's one of the reasons

422
00:23:38,015 --> 00:23:42,993
why we didn't need that
interface anymore in our code.

423
00:23:42,993 --> 00:23:45,786
And it's really simple, this tag.

424
00:23:45,786 --> 00:23:47,894
All I need to do is tell Spring

425
00:23:47,894 --> 00:23:50,394
what method I want it to weave

426
00:23:51,406 --> 00:23:53,320
and here I would simply refer

427
00:23:53,320 --> 00:23:55,994
to the method that I
have in the advice class.

428
00:23:55,994 --> 00:23:57,970
On the captions it's timeMethod.

429
00:23:57,970 --> 00:24:01,200
I think I gave it a different
name in my code in Eclipse,

430
00:24:01,200 --> 00:24:04,031
but we'll look at that in a few moments.

431
00:24:04,031 --> 00:24:07,451
And then the second parameter
here is the pointcut.

432
00:24:07,451 --> 00:24:10,396
Now, you know what the pointcut is by now

433
00:24:10,396 --> 00:24:14,554
that's that big, heavy
wildcard that tells Spring

434
00:24:14,554 --> 00:24:18,192
which classes we want
to apply this advice to,

435
00:24:18,192 --> 00:24:19,859
and then we're done.

436
00:24:20,700 --> 00:24:24,443
Spring will automatically
create all of the proxies

437
00:24:24,443 --> 00:24:28,338
that we need to match
that particular pointcut.

438
00:24:28,338 --> 00:24:32,100
Let's switch across to
Eclipse and give this a try.

439
00:24:32,100 --> 00:24:35,292
So we've already go our
advice bean created,

440
00:24:35,292 --> 00:24:38,123
this is the PerformanceTimingAdvice.

441
00:24:38,123 --> 00:24:41,823
I called the bean
loggingAdvice for some reason.

442
00:24:41,823 --> 00:24:43,384
In fact, if you don't mind,

443
00:24:43,384 --> 00:24:45,455
while I'm here I'll just
give this a better name.

444
00:24:45,455 --> 00:24:48,788
Let's call this performanceTimingAdvice.

445
00:24:50,623 --> 00:24:53,300
That won't break anything
because, at the moment,

446
00:24:53,300 --> 00:24:55,102
I'm not referring to it.

447
00:24:55,102 --> 00:24:56,831
Now, I'm going to add in, then,

448
00:24:56,831 --> 00:25:00,042
the tag that you saw on the slide.

449
00:25:00,042 --> 00:25:01,875
Now that's aop:config.

450
00:25:03,177 --> 00:25:05,192
I want you to notice that I'm not getting

451
00:25:05,192 --> 00:25:08,573
any auto completion in here right now.

452
00:25:08,573 --> 00:25:09,884
Now there is a reason for that

453
00:25:09,884 --> 00:25:12,639
and I'll tell you about
that in a few moments.

454
00:25:12,639 --> 00:25:14,008
If you're following along with me,

455
00:25:14,008 --> 00:25:17,750
you will have to type
this in long hand for now.

456
00:25:17,750 --> 00:25:21,917
So inside there, we're declaring
that we have an aop:aspect

457
00:25:23,280 --> 00:25:25,749
and this particular aspect
is going to be using

458
00:25:25,749 --> 00:25:28,638
the performanceTimingAdvice.

459
00:25:28,638 --> 00:25:32,388
So I need ref="performanceTimingAdvice".

460
00:25:35,705 --> 00:25:38,346
Now that's going to be an outer tag

461
00:25:38,346 --> 00:25:42,090
for what is really the
important tag in all of this.

462
00:25:42,090 --> 00:25:44,673
This is going to be aop:around.

463
00:25:47,257 --> 00:25:51,152
And of course I could specify
before or after, here,

464
00:25:51,152 --> 00:25:53,869
if it was a different type of advice.

465
00:25:53,869 --> 00:25:56,548
And we've two parameters here.

466
00:25:56,548 --> 00:25:58,650
The first parameter is a reference

467
00:25:58,650 --> 00:26:01,545
to the method that I want to call.

468
00:26:01,545 --> 00:26:03,996
Now the method in performanceTimingAdvice,

469
00:26:03,996 --> 00:26:07,079
I've called performTimingMeasurement.

470
00:26:09,382 --> 00:26:11,212
And that's the reason, by the way,

471
00:26:11,212 --> 00:26:15,050
that you can have lots of
different advice methods

472
00:26:15,050 --> 00:26:16,019
in this class.

473
00:26:16,019 --> 00:26:19,534
Because we refer to the one we want here.

474
00:26:19,534 --> 00:26:21,597
And the second parameter in here

475
00:26:21,597 --> 00:26:24,680
is the pointcut that we are applying.

476
00:26:27,366 --> 00:26:29,779
Now we haven't practiced
using these pointcuts yet,

477
00:26:29,779 --> 00:26:33,693
but I did show you them
on the previous slides.

478
00:26:33,693 --> 00:26:36,524
So it's going to be something like,

479
00:26:36,524 --> 00:26:39,659
we need that execution first of all,

480
00:26:39,659 --> 00:26:42,224
and then some ().

481
00:26:42,224 --> 00:26:45,435
And inside the () we use the wildcard

482
00:26:45,435 --> 00:26:47,449
to specify the class of methods

483
00:26:47,449 --> 00:26:50,299
that we want this advice to apply to.

484
00:26:50,299 --> 00:26:54,518
Well, I don't care what the
return types of the methods are.

485
00:26:54,518 --> 00:26:55,924
Regardless of what they return,

486
00:26:55,924 --> 00:26:57,880
I want the advice to be applied.

487
00:26:57,880 --> 00:26:59,713
So I begin with the *.

488
00:27:01,054 --> 00:27:05,784
Now I want the advice to apply
to all of my service classes.

489
00:27:05,784 --> 00:27:08,919
Now I could kind of use a clunky wildcard

490
00:27:08,919 --> 00:27:12,911
along the lines that I did on the captions

491
00:27:12,911 --> 00:27:16,367
which was something like *Service*.

492
00:27:16,367 --> 00:27:18,134
But, in fact, there is a better way.

493
00:27:18,134 --> 00:27:20,699
Something I didn't tell you in the theory,

494
00:27:20,699 --> 00:27:23,207
is that we also need the package name

495
00:27:23,207 --> 00:27:27,083
that we're interested in at
the front of the class name.

496
00:27:27,083 --> 00:27:30,447
So I can be explicit and
say that I want the advice

497
00:27:30,447 --> 00:27:32,555
to apply to all classes

498
00:27:32,555 --> 00:27:36,722
in the
com.virtualpairprogrammers.avalon.services
package.

499
00:27:41,485 --> 00:27:42,985
And then with a .*

500
00:27:43,880 --> 00:27:47,380
I mean all of the classes in that package.

501
00:27:48,800 --> 00:27:52,810
Now you can use a wildcard
based on the class name,

502
00:27:52,810 --> 00:27:55,477
but you would actually need an *

503
00:27:56,552 --> 00:27:58,908
for the package name if you didn't care

504
00:27:58,908 --> 00:28:01,435
what the package name is.

505
00:28:01,435 --> 00:28:04,722
So this asterisk here is
referring to the classes

506
00:28:04,722 --> 00:28:07,648
that we're interested in
and that's going to be

507
00:28:07,648 --> 00:28:10,004
all of them in that package,

508
00:28:10,004 --> 00:28:13,405
but then we need another
. followed by the names

509
00:28:13,405 --> 00:28:16,483
of the methods that we're interested in.

510
00:28:16,483 --> 00:28:21,195
Well, I want to time all
methods in those classes

511
00:28:21,195 --> 00:28:24,195
so I'm going to have another * here.

512
00:28:25,171 --> 00:28:28,588
Now I admit, I agree that these pointcuts

513
00:28:29,745 --> 00:28:33,013
do get quite complicated
and difficult to read.

514
00:28:33,013 --> 00:28:36,775
It's just the nature of the way they are.

515
00:28:36,775 --> 00:28:38,827
They're very powerful and flexible

516
00:28:38,827 --> 00:28:43,121
and therefore there are a lot
of elements to the syntax.

517
00:28:43,121 --> 00:28:45,420
You'll get used to them over time.

518
00:28:45,420 --> 00:28:48,485
We're not finished yet so this means

519
00:28:48,485 --> 00:28:51,818
all methods in the classes that we found

520
00:28:52,788 --> 00:28:56,588
but I also need to put in ()

521
00:28:56,588 --> 00:29:00,755
and then declare what input
parameters am I interested in.

522
00:29:01,661 --> 00:29:05,100
So if I said, for instance, String here,

523
00:29:05,100 --> 00:29:07,418
then this advice would only be applied

524
00:29:07,418 --> 00:29:10,268
to methods in the service classes

525
00:29:10,268 --> 00:29:14,268
that accept one single
parameter of type string.

526
00:29:17,006 --> 00:29:20,103
Alternatively, I could put an * in there,

527
00:29:20,103 --> 00:29:24,176
now be careful that might not
be quite what you think it is.

528
00:29:24,176 --> 00:29:28,343
That means that the methods
must have one single parameter

529
00:29:30,605 --> 00:29:34,265
but the parameter can be of any type.

530
00:29:34,265 --> 00:29:36,412
Now that's not what we want,

531
00:29:36,412 --> 00:29:39,829
we don't care about the input parameters.

532
00:29:40,970 --> 00:29:45,245
It could be none, it could be
100, it can be of any type.

533
00:29:45,245 --> 00:29:47,412
So we need that .. syntax.

534
00:29:49,849 --> 00:29:53,247
Now that was absolutely exhausting.

535
00:29:53,247 --> 00:29:56,008
And I'm not guaranteeing
that I've got that correct,

536
00:29:56,008 --> 00:29:58,250
there could well be a typo in there.

537
00:29:58,250 --> 00:30:00,622
But really the only way to check these out

538
00:30:00,622 --> 00:30:02,539
is to try them and see.

539
00:30:03,643 --> 00:30:06,569
So that's the end of that tag

540
00:30:06,569 --> 00:30:11,224
and that's the end of
configuring that advice.

541
00:30:11,224 --> 00:30:14,307
So even if I had 100 service classes,

542
00:30:15,543 --> 00:30:17,361
this advice would now be applied

543
00:30:17,361 --> 00:30:21,598
to those 100 service classes
with no further work.

544
00:30:21,598 --> 00:30:25,987
Well, you may notice that
I've got an error here

545
00:30:25,987 --> 00:30:29,141
and well the error might not
be particularly readable.

546
00:30:29,141 --> 00:30:31,391
It's saying "the prefix aop

547
00:30:31,391 --> 00:30:35,848
"for the element
'aop:config' is not bound."

548
00:30:35,848 --> 00:30:37,710
I can tell you now that
that was the reason

549
00:30:37,710 --> 00:30:41,605
that we weren't getting the
AutoComplete working either.

550
00:30:41,605 --> 00:30:45,522
There is one catch with
these new AOP commands.

551
00:30:46,754 --> 00:30:49,374
These commands were, as you now know,

552
00:30:49,374 --> 00:30:51,791
added to Spring in version 2.

553
00:30:52,718 --> 00:30:55,504
And at the same time
in version 2 of Spring,

554
00:30:55,504 --> 00:30:59,671
they brought in a new way
of validating the XML file.

555
00:31:01,133 --> 00:31:03,774
Right here at the top, and it's been there

556
00:31:03,774 --> 00:31:06,358
since the start of the course,

557
00:31:06,358 --> 00:31:10,538
we've been using this tag called DOCTYPE.

558
00:31:10,538 --> 00:31:13,629
Now I don't know if you know what this is.

559
00:31:13,629 --> 00:31:17,217
If you don't, it's from standard XML,

560
00:31:17,217 --> 00:31:20,797
it's called a document type definition.

561
00:31:20,797 --> 00:31:24,049
And it's basically pointing to a file,

562
00:31:24,049 --> 00:31:26,549
this file here ending in .dtd.

563
00:31:29,043 --> 00:31:33,210
And that file defines what
is valid in this document.

564
00:31:34,915 --> 00:31:36,853
So Spring have provided this file

565
00:31:36,853 --> 00:31:39,186
called spring-beans-2.0.dtd.

566
00:31:41,033 --> 00:31:43,427
It's actually stored
in one of the jar files

567
00:31:43,427 --> 00:31:46,244
that you have in your lib directory.

568
00:31:46,244 --> 00:31:49,487
And it's telling the
development environment,

569
00:31:49,487 --> 00:31:52,737
really, what is legal in this document.

570
00:31:54,047 --> 00:31:57,351
So, the file is saying, for example,

571
00:31:57,351 --> 00:32:00,275
it's legal to have a bean tag

572
00:32:00,275 --> 00:32:04,588
and it's legal to have a
property tag inside a bean tag,

573
00:32:04,588 --> 00:32:08,088
but it is not legal to have a property tag

574
00:32:09,464 --> 00:32:10,981
outside of a bean tag.

575
00:32:10,981 --> 00:32:13,268
You can see that as soon
as I typed in that tag,

576
00:32:13,268 --> 00:32:15,551
I've got the squiggly red line

577
00:32:15,551 --> 00:32:19,968
and that's because I'm violating
the rules inside this file.

578
00:32:19,968 --> 00:32:21,968
So I better remove that.

579
00:32:23,505 --> 00:32:26,447
So that's fine, but I don't
know if you know this,

580
00:32:26,447 --> 00:32:29,740
but a DTD is quite an old-fashioned way

581
00:32:29,740 --> 00:32:31,657
of doing things in XML.

582
00:32:32,608 --> 00:32:35,633
As XML got more sophisticated,

583
00:32:35,633 --> 00:32:39,752
the XML committee,
essentially a committee,

584
00:32:39,752 --> 00:32:43,826
set up a second way of
validating XML documents

585
00:32:43,826 --> 00:32:47,057
and they called it an XML Schema.

586
00:32:47,057 --> 00:32:50,705
Now schema basically does
the same job as a DTD

587
00:32:50,705 --> 00:32:54,847
but it's a lot more flexible
and a lot more useful.

588
00:32:54,847 --> 00:32:56,665
And the reason this is relevant to us

589
00:32:56,665 --> 00:33:00,082
is that in Spring 2, the Spring 2 people

590
00:33:01,259 --> 00:33:05,093
decided that for any
extensions to the XML,

591
00:33:05,093 --> 00:33:07,997
any new features that they add to the XML

592
00:33:07,997 --> 00:33:12,164
such as these new AOP tags,
they were going to use schema

593
00:33:13,472 --> 00:33:16,512
to validate those tags instead.

594
00:33:16,512 --> 00:33:20,595
So this DTD way of working
was kind of deprecated

595
00:33:22,027 --> 00:33:24,027
and made less important.

596
00:33:24,871 --> 00:33:27,437
You can still use it, as we've been doing

597
00:33:27,437 --> 00:33:32,300
throughout the course, but for
any new features in Spring,

598
00:33:32,300 --> 00:33:35,170
you have to stop using the DTD

599
00:33:35,170 --> 00:33:37,849
and move across to the schema.

600
00:33:37,849 --> 00:33:41,098
Now I did want to use the
DTD for the early part

601
00:33:41,098 --> 00:33:43,017
of the course, just so you've seen it

602
00:33:43,017 --> 00:33:46,323
and you're going to find a lot
of projects still using it,

603
00:33:46,323 --> 00:33:49,933
but now this DTD has served its purpose

604
00:33:49,933 --> 00:33:52,213
and I'm afraid it's time to retire it,

605
00:33:52,213 --> 00:33:56,254
so we're going to need
to delete the two lines

606
00:33:56,254 --> 00:33:58,895
at the top of your XML file

607
00:33:58,895 --> 00:34:00,330
and we're going to bring into here

608
00:34:00,330 --> 00:34:03,762
a pointer to the schema instead.

609
00:34:03,762 --> 00:34:06,457
But there is a problem
and you'll know this

610
00:34:06,457 --> 00:34:08,737
if you've worked with XML before.

611
00:34:08,737 --> 00:34:11,404
Schema definitions are horrible.

612
00:34:12,271 --> 00:34:16,438
And you would certainly not
want to type these in by hand.

613
00:34:17,494 --> 00:34:19,529
In fact, let's switch across to a caption

614
00:34:19,529 --> 00:34:22,683
to have a look at what they look like.

615
00:34:22,683 --> 00:34:25,381
So this tag, in fact it's four lines long,

616
00:34:25,381 --> 00:34:29,504
is what we need to add
to replace the old DTD.

617
00:34:29,504 --> 00:34:31,671
And yes I admit it's ugly.

618
00:34:33,153 --> 00:34:35,593
Now the first thing I want to point out

619
00:34:35,593 --> 00:34:38,926
is that this is, in fact, an entire tag.

620
00:34:40,747 --> 00:34:42,856
And if you look carefully here,

621
00:34:42,856 --> 00:34:45,856
you'll see that it is the beans tag.

622
00:34:47,435 --> 00:34:49,354
So this is slightly different.

623
00:34:49,354 --> 00:34:52,337
The text you can see
here is not going to go

624
00:34:52,337 --> 00:34:56,504
right at the top of the
XML file like the DTD did.

625
00:34:58,273 --> 00:35:02,023
Instead it's going to
replace this line here.

626
00:35:03,376 --> 00:35:06,929
Or alternatively we need
to add the new stuff

627
00:35:06,929 --> 00:35:08,512
into the < > there.

628
00:35:09,376 --> 00:35:11,776
And it is quite the common
mistake that people make

629
00:35:11,776 --> 00:35:14,037
that they copy and paste
what you've just seen

630
00:35:14,037 --> 00:35:16,556
into this line here and then, I'm afraid,

631
00:35:16,556 --> 00:35:21,176
you've got two beans tags
which is not correct.

632
00:35:21,176 --> 00:35:25,176
Now this is not an XML course,
so I'm not going to bore you

633
00:35:25,176 --> 00:35:28,797
with what all of this means in detail.

634
00:35:28,797 --> 00:35:31,360
It's enough to know
that you need this text

635
00:35:31,360 --> 00:35:34,384
if you want Spring to
validate using a schema

636
00:35:34,384 --> 00:35:38,092
and, therefore, to use the new AOP tags.

637
00:35:38,092 --> 00:35:40,576
But I think, as a
developer, you should have

638
00:35:40,576 --> 00:35:44,956
at least a vague grasp
of what these lines mean.

639
00:35:44,956 --> 00:35:47,976
So let's go for a quick overview.

640
00:35:47,976 --> 00:35:52,256
This line is saying that
we are wanting to use

641
00:35:52,256 --> 00:35:54,339
a namespace called beans.

642
00:35:55,916 --> 00:35:59,833
Now a namespace in XML
is a collection of tags.

643
00:36:01,881 --> 00:36:04,016
Now we're saying, then, that we want

644
00:36:04,016 --> 00:36:06,856
to use Spring's collection of tags

645
00:36:06,856 --> 00:36:09,606
from this namespace called beans.

646
00:36:10,715 --> 00:36:13,357
Now this namespace
contains all of the tags

647
00:36:13,357 --> 00:36:16,585
that we've been working
with on the course so far.

648
00:36:16,585 --> 00:36:20,752
That's got tags such as
beans, and bean, and property,

649
00:36:22,951 --> 00:36:25,284
and all of those basic tags.

650
00:36:26,320 --> 00:36:29,777
Now the next property that I've added here

651
00:36:29,777 --> 00:36:33,316
isn't actually required but it
is very useful in development

652
00:36:33,316 --> 00:36:36,883
because this will enable
things like auto completion

653
00:36:36,883 --> 00:36:39,383
and syntax error highlighting.

654
00:36:40,317 --> 00:36:42,234
This xsi:schemaLocation

655
00:36:44,577 --> 00:36:47,877
is telling the parser, the XML parser,

656
00:36:47,877 --> 00:36:52,557
where to find the file
that defines the namespace.

657
00:36:52,557 --> 00:36:55,097
There's two elements here.

658
00:36:55,097 --> 00:36:59,167
Here is the same string
that appeared at the top

659
00:36:59,167 --> 00:37:02,162
and the second string is
the actual name of the file,

660
00:37:02,162 --> 00:37:03,662
the so called XSD.

661
00:37:05,180 --> 00:37:07,300
And this file, a bit like the DTD,

662
00:37:07,300 --> 00:37:11,079
will be inside one of
the Spring jar files.

663
00:37:11,079 --> 00:37:13,739
Now, this really isn't very nice,

664
00:37:13,739 --> 00:37:18,300
but I promise you that I have
not typed this in myself.

665
00:37:18,300 --> 00:37:19,514
You are definitely

666
00:37:19,514 --> 00:37:23,402
going to want to copy
and paste this string.

667
00:37:23,402 --> 00:37:25,142
Well, where did I get that string from?

668
00:37:25,142 --> 00:37:27,997
Well, the reference manual.

669
00:37:27,997 --> 00:37:31,382
Here I am in chapter 33
of the reference manual.

670
00:37:31,382 --> 00:37:34,402
Now, of course by the time
you follow this course,

671
00:37:34,402 --> 00:37:36,692
the chapter number may have changed.

672
00:37:36,692 --> 00:37:40,502
But if you look in the Contents
page for something like

673
00:37:40,502 --> 00:37:43,085
XML Schema-based configuration,

674
00:37:43,962 --> 00:37:47,912
then you should find the
information you're looking for.

675
00:37:47,912 --> 00:37:51,582
And if we go a little further down,

676
00:37:51,582 --> 00:37:53,622
they're showing you how to change

677
00:37:53,622 --> 00:37:56,200
from the DTD that we had before

678
00:37:56,200 --> 00:37:58,867
to this schema-based definition.

679
00:37:59,980 --> 00:38:02,181
And what you can see here,

680
00:38:02,181 --> 00:38:06,198
is exactly what I've just
shown you on the caption.

681
00:38:06,198 --> 00:38:10,340
And if you feel awkward
about copying and pasting,

682
00:38:10,340 --> 00:38:13,660
notice here they even
say this is boiler plate,

683
00:38:13,660 --> 00:38:16,140
that you can copy and paste.

684
00:38:16,140 --> 00:38:17,961
So we'll do just that, then.

685
00:38:17,961 --> 00:38:21,880
It's this text here
that we're looking for.

686
00:38:21,880 --> 00:38:24,680
I've just taken there the beans tag,

687
00:38:24,680 --> 00:38:28,847
back into my XML I need to
remove the existing beans tag

688
00:38:30,360 --> 00:38:32,820
and paste that into place.

689
00:38:32,820 --> 00:38:34,580
And now you can see that my tags

690
00:38:34,580 --> 00:38:37,830
such as bean and property are all fine,

691
00:38:39,860 --> 00:38:42,840
there's no big red
squiggles underneath them.

692
00:38:42,840 --> 00:38:46,507
But we still have an
error under aop:config.

693
00:38:48,445 --> 00:38:50,239
And that's because Spring have decided,

694
00:38:50,239 --> 00:38:55,119
instead of putting everything
into this beans namespace,

695
00:38:55,119 --> 00:38:58,111
they've decided to create
separate namespaces

696
00:38:58,111 --> 00:39:01,028
for each the major areas of Spring.

697
00:39:01,999 --> 00:39:03,979
So if we want to use a set of tags

698
00:39:03,979 --> 00:39:07,419
for a particular area such as AOP,

699
00:39:07,419 --> 00:39:10,938
then we've go to add another namespace

700
00:39:10,938 --> 00:39:14,399
into this definition here at the top.

701
00:39:14,399 --> 00:39:16,039
While it's not pleasant,

702
00:39:16,039 --> 00:39:20,619
but once again we can
go into this chapter 33.

703
00:39:20,619 --> 00:39:23,539
And if you have a look in chapter 33,

704
00:39:23,539 --> 00:39:25,969
you should find somewhere...

705
00:39:25,969 --> 00:39:28,061
Well, there's quite a
lot of stuff in here.

706
00:39:28,061 --> 00:39:30,062
I'm just going to do a Control + F

707
00:39:30,062 --> 00:39:33,312
and I'm going to search for aop schema.

708
00:39:35,516 --> 00:39:37,600
And it's giving me, it's taking me back

709
00:39:37,600 --> 00:39:38,939
to the Contents actually.

710
00:39:38,939 --> 00:39:41,599
But we're still in chapter 33.

711
00:39:41,599 --> 00:39:44,766
At the time of recording, it's 33.2.7.

712
00:39:46,499 --> 00:39:51,260
And that's going to show
me the exact text I need

713
00:39:51,260 --> 00:39:53,749
to bring in the AOP namespace.

714
00:39:53,749 --> 00:39:55,174
Now I can one of two things,

715
00:39:55,174 --> 00:39:58,424
I can either copy the entire tag there,

716
00:39:59,498 --> 00:40:00,819
because it just so happens

717
00:40:00,819 --> 00:40:04,986
that they have left in the
beans schema in this example.

718
00:40:06,719 --> 00:40:10,799
But more generally, as you
go forward with your schemas,

719
00:40:10,799 --> 00:40:13,709
you need to learn how to
unpick the pieces you need.

720
00:40:13,709 --> 00:40:16,008
We just want to add the AOP element,

721
00:40:16,008 --> 00:40:19,858
so I need to really copy
two separate things.

722
00:40:19,858 --> 00:40:23,798
First of all, I need the
namespace declaration

723
00:40:23,798 --> 00:40:26,378
which is that string there.

724
00:40:26,378 --> 00:40:28,638
And that's going to go alongside

725
00:40:28,638 --> 00:40:31,805
my existing XML namespace definitions.

726
00:40:33,193 --> 00:40:37,360
And then the schema location
is actually one big string.

727
00:40:38,898 --> 00:40:42,858
So I need to copy these two elements here,

728
00:40:42,858 --> 00:40:44,473
essentially I'm just
looking for everything

729
00:40:44,473 --> 00:40:48,238
that contains the phrase
AOP and I'm just going to

730
00:40:48,238 --> 00:40:52,718
copy that and drop that
into the same string.

731
00:40:52,718 --> 00:40:54,938
I know that's confusing,
you would've expected

732
00:40:54,938 --> 00:40:59,938
separate strings for that,
but it is one big long string.

733
00:40:59,938 --> 00:41:01,418
Now nobody likes doing this

734
00:41:01,418 --> 00:41:05,128
and if you're hating this
then don't worry, I am too.

735
00:41:05,128 --> 00:41:08,618
Now if I save again and
go back to the bottom,

736
00:41:08,618 --> 00:41:12,123
this is looking quite
encouraging because you can see

737
00:41:12,123 --> 00:41:15,298
we don't have that red squiggle anymore

738
00:41:15,298 --> 00:41:18,273
under that tag so it
appears to be correct.

739
00:41:18,273 --> 00:41:20,138
So I'm sorry that that
wasn't very pleasant

740
00:41:20,138 --> 00:41:21,789
but it is a one off job.

741
00:41:21,789 --> 00:41:23,888
We won't have to keep doing that.

742
00:41:23,888 --> 00:41:26,198
We've now got the AOP tags available

743
00:41:26,198 --> 00:41:30,303
and we can use them freely
throughout this document.

744
00:41:30,303 --> 00:41:33,318
So that's all good as long as it works.

745
00:41:33,318 --> 00:41:35,618
Let's go back to our client

746
00:41:35,618 --> 00:41:38,451
and see if there's any difference.

747
00:41:39,358 --> 00:41:42,258
And I have a big ugly exception.

748
00:41:42,258 --> 00:41:43,898
And I kind of expected this.

749
00:41:43,898 --> 00:41:46,058
Whenever you write a
pointcut for the first time,

750
00:41:46,058 --> 00:41:47,998
you're never going to get it correct.

751
00:41:47,998 --> 00:41:50,578
They're just too awkward to write.

752
00:41:50,578 --> 00:41:52,978
And the thing I've noticed immediately

753
00:41:52,978 --> 00:41:55,898
is pointcut is not well formed.

754
00:41:55,898 --> 00:41:58,498
It's giving me some kind of clues here

755
00:41:58,498 --> 00:42:01,219
but I often find it's just better to stare

756
00:42:01,219 --> 00:42:06,119
at the pointcut and see if
you can spot the problem.

757
00:42:06,119 --> 00:42:09,919
And well, if you spotted it for yourself,

758
00:42:09,919 --> 00:42:12,599
I did say there would be
a typo in here somewhere

759
00:42:12,599 --> 00:42:16,866
and I've completely failed
to spell execution correctly.

760
00:42:16,866 --> 00:42:17,949
ex-e-cu-tion.

761
00:42:20,474 --> 00:42:22,716
That's very embarrassing
but I can't go back

762
00:42:22,716 --> 00:42:24,417
and correct it in the video now,

763
00:42:24,417 --> 00:42:26,737
so I'll just have to go with it.

764
00:42:26,737 --> 00:42:29,687
Usually there will be some
kind of problem in here as well

765
00:42:29,687 --> 00:42:31,187
but lets try that.

766
00:42:34,762 --> 00:42:37,442
And it ran through okay this time.

767
00:42:37,442 --> 00:42:40,962
And I am getting output
for registerNewBook,

768
00:42:40,962 --> 00:42:44,411
getEntireCatalogue, and getBookByIsbn.

769
00:42:44,411 --> 00:42:48,062
So it looks like my pointcut did work.

770
00:42:48,062 --> 00:42:50,822
And what I really recommend you do,

771
00:42:50,822 --> 00:42:53,342
if you're following along with this

772
00:42:53,342 --> 00:42:56,332
is to play around with the pointcut

773
00:42:56,332 --> 00:42:58,062
and try different alternatives.

774
00:42:58,062 --> 00:43:01,182
If you're not following along
in this book store example,

775
00:43:01,182 --> 00:43:03,882
then you're going to be doing
pretty much the same job

776
00:43:03,882 --> 00:43:06,982
in the next practical
session and you'll definitely

777
00:43:06,982 --> 00:43:09,292
want to play around with this pointcut.

778
00:43:09,292 --> 00:43:13,742
So, for example, as I
suggested on the theory session

779
00:43:13,742 --> 00:43:18,365
we could make this advice
apply to only 'get' methods.

780
00:43:18,365 --> 00:43:21,615
So if this * here, which is the method,

781
00:43:22,563 --> 00:43:26,646
so I could just say get*
rather than all methods.

782
00:43:31,361 --> 00:43:34,484
And yep, it's now working
for getEntireCatalogue

783
00:43:34,484 --> 00:43:37,817
and getBookByIsbn, but not registerBook.

784
00:43:39,054 --> 00:43:43,221
And I could, oh the possibilities
are endless, really.

785
00:43:44,684 --> 00:43:47,337
I'll return that back to an *

786
00:43:47,337 --> 00:43:49,420
but this time I only want

787
00:43:52,475 --> 00:43:56,558
to apply the advice to
methods that return Lists.

788
00:43:57,561 --> 00:43:59,699
And, oh, I have an exception again!

789
00:43:59,699 --> 00:44:01,999
And the reason for the exception,

790
00:44:01,999 --> 00:44:04,699
and this is something I
didn't tell you in the theory,

791
00:44:04,699 --> 00:44:07,189
is that it's not sufficient
just to say List,

792
00:44:07,189 --> 00:44:11,439
you have to say what package
that class comes from.

793
00:44:11,439 --> 00:44:13,830
This is from the java util package

794
00:44:13,830 --> 00:44:16,080
so you need java.util.List.

795
00:44:18,159 --> 00:44:21,326
If I run again, hopefully this time...

796
00:44:22,459 --> 00:44:24,359
Yeah, we're getting the advice applied

797
00:44:24,359 --> 00:44:27,739
to getEntireCatalogue
because that returns a list

798
00:44:27,739 --> 00:44:31,913
but it's not been applied
to the getBookByIsbn method

799
00:44:31,913 --> 00:44:35,340
because that just returns a single book.

800
00:44:35,340 --> 00:44:38,641
So that's it then for our around advice.

801
00:44:38,641 --> 00:44:40,761
Now there are a few things to be aware of

802
00:44:40,761 --> 00:44:45,061
when you're writing either
before or after advice.

803
00:44:45,061 --> 00:44:47,321
Now we don't have any
before or after advice

804
00:44:47,321 --> 00:44:48,876
in our project at the moment,

805
00:44:48,876 --> 00:44:52,240
so I'm just going to very
quickly add in a new method

806
00:44:52,240 --> 00:44:54,500
into our advice class.

807
00:44:54,500 --> 00:44:58,580
And I'm going to make this before advice.

808
00:44:58,580 --> 00:44:59,980
I don't really know what to call it

809
00:44:59,980 --> 00:45:02,120
because I'm not going
to do anything serious,

810
00:45:02,120 --> 00:45:06,287
so I'm just going to call
this beforeAdviceTesting.

811
00:45:07,920 --> 00:45:10,841
And a little like I did
earlier on in the course,

812
00:45:10,841 --> 00:45:13,460
I'm just going to use this to log the fact

813
00:45:13,460 --> 00:45:16,420
that we have entered a method.

814
00:45:16,420 --> 00:45:17,385
So it will be a

815
00:45:17,385 --> 00:45:21,552
System.out.println("Now
entering a method...");

816
00:45:25,308 --> 00:45:26,932
Now, in a few moments I'll show you

817
00:45:26,932 --> 00:45:30,697
how we can output the name of
the method that we've entered.

818
00:45:30,697 --> 00:45:33,655
But for now, that should be enough.

819
00:45:33,655 --> 00:45:38,335
And notice that because we're
not writing around advice,

820
00:45:38,335 --> 00:45:41,235
we don't need to proceed in here.

821
00:45:41,235 --> 00:45:44,815
The proceed is automatic
at the end of the method.

822
00:45:44,815 --> 00:45:46,854
Therefore I don't need this parameter

823
00:45:46,854 --> 00:45:49,104
called ProceedingJoinPoint.

824
00:45:50,135 --> 00:45:54,302
So I can simply leave the
method without any parameters.

825
00:45:55,875 --> 00:45:59,934
Now I'll need to configure
that so back into the XML

826
00:45:59,934 --> 00:46:03,237
and I can add in another block of AOP.

827
00:46:03,237 --> 00:46:07,404
This time it's aop:before
and the method this time is

828
00:46:09,089 --> 00:46:11,479
well, I've forgotten the
name of it already...

829
00:46:11,479 --> 00:46:13,562
It's beforeAdviceTesting.

830
00:46:15,377 --> 00:46:19,079
And the pointcut, just
to keep things simple,

831
00:46:19,079 --> 00:46:22,679
I'm going to make the pointcut
be the same as before.

832
00:46:22,679 --> 00:46:25,659
So I'll do a copy and paste.

833
00:46:25,659 --> 00:46:27,319
While it's not good to copy and paste,

834
00:46:27,319 --> 00:46:29,459
and I'll show you in a moment
how we can improve that,

835
00:46:29,459 --> 00:46:32,679
but for now, I'm going
to copy that pointcut

836
00:46:32,679 --> 00:46:34,279
and we're expecting this pointcut

837
00:46:34,279 --> 00:46:38,446
to be applied only on the
getEntireCatalogue method.

838
00:46:39,499 --> 00:46:41,666
So let's see if that runs.

839
00:46:43,699 --> 00:46:44,879
And, good.

840
00:46:44,879 --> 00:46:46,569
If you have a look carefully there,

841
00:46:46,569 --> 00:46:49,079
you can see that the advice was applied

842
00:46:49,079 --> 00:46:53,246
and it fired just before we
went into getEntireCatalogue.

843
00:46:54,319 --> 00:46:56,519
I just want to comment, by the way,

844
00:46:56,519 --> 00:46:59,179
did you notice just how fast it was

845
00:46:59,179 --> 00:47:02,012
to setup that advice and apply it?

846
00:47:02,939 --> 00:47:06,779
I would have taken a lot
longer using the old-fashioned

847
00:47:06,779 --> 00:47:07,696
Spring AOP.

848
00:47:08,999 --> 00:47:11,779
But the point that I'm leading towards

849
00:47:11,779 --> 00:47:14,879
is what if we do want to get details

850
00:47:14,879 --> 00:47:17,399
of the method that we've accessed?

851
00:47:17,399 --> 00:47:20,639
So I want to put the
name of the method here.

852
00:47:20,639 --> 00:47:22,879
Well, if you want that, then you have to

853
00:47:22,879 --> 00:47:26,599
add in an additional
parameter to the method

854
00:47:26,599 --> 00:47:30,859
and it's very similar
to ProceedingJoinPoints.

855
00:47:30,859 --> 00:47:34,139
But this time it's just called JoinPoints.

856
00:47:34,139 --> 00:47:38,139
And I guess the reasoning behind
this is ProceedingJoinPoint

857
00:47:38,139 --> 00:47:42,879
is for around advice
because you need to proceed,

858
00:47:42,879 --> 00:47:44,459
but the JoinPoint is the version

859
00:47:44,459 --> 00:47:47,900
for where you don't need to call proceed.

860
00:47:47,900 --> 00:47:50,770
So I'll just call that parameter jp.

861
00:47:50,770 --> 00:47:53,674
It will need importing and notice

862
00:47:53,674 --> 00:47:58,199
it's from the same package
as ProceedingJoinPoint.

863
00:47:58,199 --> 00:48:00,899
Once I have this object called jp,

864
00:48:00,899 --> 00:48:02,779
of course I can call its methods

865
00:48:02,779 --> 00:48:04,379
and if we have a look inside there

866
00:48:04,379 --> 00:48:06,899
you're going to find
basically the same methods

867
00:48:06,899 --> 00:48:09,559
as inside ProceedingJoinPoint.

868
00:48:09,559 --> 00:48:13,144
The main one would be getSignature,

869
00:48:13,144 --> 00:48:18,124
which would allow me to
get the name of the method.

870
00:48:18,124 --> 00:48:20,925
And I can get a few other things as well

871
00:48:20,925 --> 00:48:23,925
such as the modifiers of the method,

872
00:48:25,325 --> 00:48:27,908
the declaring types, and so on.

873
00:48:28,745 --> 00:48:30,828
So let's give that a run.

874
00:48:32,790 --> 00:48:35,985
And great, you can now
see the name of the method

875
00:48:35,985 --> 00:48:37,485
inside the advice.

876
00:48:39,185 --> 00:48:43,760
Now while I'm here, let's
go back into the XML.

877
00:48:43,760 --> 00:48:45,545
One rather annoying thing I did there

878
00:48:45,545 --> 00:48:49,405
was I copied and pasted this pointcut.

879
00:48:49,405 --> 00:48:50,964
And it's certainly the case that often

880
00:48:50,964 --> 00:48:54,297
you want to reuse pointcuts in your AOP.

881
00:48:56,055 --> 00:48:59,505
Much better than copying
and pasting this string

882
00:48:59,505 --> 00:49:02,465
is we can define a common pointcut

883
00:49:02,465 --> 00:49:06,504
that we can reuse across
our entire system.

884
00:49:06,504 --> 00:49:10,484
And we do that just by going
into the aop:config tag

885
00:49:10,484 --> 00:49:13,401
and I can use the aop:pointcut tag.

886
00:49:15,504 --> 00:49:19,564
And there are two parameters
here, the expression is,

887
00:49:19,564 --> 00:49:23,375
of course, the pointcut's
expression itself.

888
00:49:23,375 --> 00:49:26,230
So I'm going to cut out
that entire expression

889
00:49:26,230 --> 00:49:27,980
and paste into there.

890
00:49:29,029 --> 00:49:32,305
And the ID, I'll tidy
this up a little bit,

891
00:49:32,305 --> 00:49:36,732
the ID just needs to be
a name for this pointcut.

892
00:49:36,732 --> 00:49:40,230
And what you should use
here is something strong

893
00:49:40,230 --> 00:49:42,730
and recognizable and readable.

894
00:49:43,674 --> 00:49:46,174
So this pointcut is describing

895
00:49:47,229 --> 00:49:49,979
allServiceMethodsThatReturnLists.

896
00:49:53,748 --> 00:49:58,137
And don't be afraid to use
quite verbose names here.

897
00:49:58,137 --> 00:50:01,370
And then the way that we
reference this pointcut

898
00:50:01,370 --> 00:50:03,278
is slightly different
to what we had before.

899
00:50:03,278 --> 00:50:05,710
Instead of the pointcut attribute,

900
00:50:05,710 --> 00:50:08,543
we use the pointcut-ref attribute.

901
00:50:10,750 --> 00:50:13,857
And then we simply paste
the name of the pointcut

902
00:50:13,857 --> 00:50:15,190
into the string.

903
00:50:16,210 --> 00:50:20,410
And so I can do exactly
the same thing here

904
00:50:20,410 --> 00:50:24,327
pointcut-ref followed by
a nice, readable name.

905
00:50:27,830 --> 00:50:29,663
Just check that works.

906
00:50:30,943 --> 00:50:35,334
And, yes, the advice
is still being applied.

907
00:50:35,334 --> 00:50:38,667
So we've seen how this new AOP namespace

908
00:50:39,623 --> 00:50:42,642
dramatically cuts down the amount of XML

909
00:50:42,642 --> 00:50:44,362
that you need to write.

910
00:50:44,362 --> 00:50:47,122
Now I know a lot of you won't like XML,

911
00:50:47,122 --> 00:50:49,362
but I think this is a really good,

912
00:50:49,362 --> 00:50:53,529
compact, readable and
understandable AOP namespace,

913
00:50:54,542 --> 00:50:56,810
very, very well designed.

914
00:50:56,810 --> 00:50:59,218
However, there is another approach

915
00:50:59,218 --> 00:51:01,850
to configuring AOP in Spring.

916
00:51:01,850 --> 00:51:05,042
And that's using annotations.

917
00:51:05,042 --> 00:51:08,234
Now, I have to be completely honest here

918
00:51:08,234 --> 00:51:11,267
and I'm going to say
that I don't, personally,

919
00:51:11,267 --> 00:51:14,684
like using annotations for AOP in Spring.

920
00:51:15,783 --> 00:51:18,050
Annotations are good
for some other purposes

921
00:51:18,050 --> 00:51:20,039
that we'll see later in the course,

922
00:51:20,039 --> 00:51:22,956
but for AOP, I much prefer the XML.

923
00:51:24,043 --> 00:51:27,865
However, you might love
the annotation approach.

924
00:51:27,865 --> 00:51:30,555
So, of course, we need to look at it.

925
00:51:30,555 --> 00:51:32,403
You're probably aware that XML

926
00:51:32,403 --> 00:51:35,227
is becoming unfashionable
in java these days

927
00:51:35,227 --> 00:51:39,362
and there is as big move
across to annotations.

928
00:51:39,362 --> 00:51:42,036
So the benefit of the annotations is

929
00:51:42,036 --> 00:51:46,203
that if you want, you can
completely remove all of this XML.

930
00:51:48,196 --> 00:51:51,948
So I'll do that and we need to replace

931
00:51:51,948 --> 00:51:55,868
that block of XML with one single tag.

932
00:51:55,868 --> 00:51:59,012
It's another tag from the AOP namespace.

933
00:51:59,012 --> 00:52:00,997
In fact, you can see it's popping up here

934
00:52:00,997 --> 00:52:03,310
on the AutoComplete.

935
00:52:03,310 --> 00:52:06,310
The tag is called aspectJ-autoproxy.

936
00:52:07,985 --> 00:52:09,889
And it's just a single tag.

937
00:52:09,889 --> 00:52:14,174
You don't have to provide
any further information.

938
00:52:14,174 --> 00:52:17,086
Now this is, I think the
first of these kinds of tags

939
00:52:17,086 --> 00:52:18,933
we've seen on the course.

940
00:52:18,933 --> 00:52:21,929
This tag isn't really
configuring anything.

941
00:52:21,929 --> 00:52:23,946
It's more of a command.

942
00:52:23,946 --> 00:52:27,110
It's telling Spring to go off and look

943
00:52:27,110 --> 00:52:30,170
for annotations in the code.

944
00:52:30,170 --> 00:52:32,649
So I'll reflect that in a comment,

945
00:52:32,649 --> 00:52:36,149
Tell Spring to search for AOP annotations.

946
00:52:40,768 --> 00:52:45,052
And the idea is, instead
of writing any further XML,

947
00:52:45,052 --> 00:52:47,825
we're going to go into our advice class

948
00:52:47,825 --> 00:52:50,960
and we're going to use
regular java annotations

949
00:52:50,960 --> 00:52:55,060
to tell Spring how this
advice should be applied.

950
00:52:55,060 --> 00:52:57,704
Now, of course, I don't know if you know

951
00:52:57,704 --> 00:52:59,999
about java annotations.

952
00:52:59,999 --> 00:53:01,875
Annotations have been
around for a long time now,

953
00:53:01,875 --> 00:53:04,395
so I guess, by now, you've
probably come across

954
00:53:04,395 --> 00:53:06,882
annotations in some form.

955
00:53:06,882 --> 00:53:09,246
But just in case you
haven't, an annotation

956
00:53:09,246 --> 00:53:13,413
is wherever you see the @
followed by some kind of a marker.

957
00:53:15,246 --> 00:53:17,795
And in our case, the
marker that we're using,

958
00:53:17,795 --> 00:53:22,752
the annotation that we're
using is the Aspect annotation.

959
00:53:22,752 --> 00:53:25,439
Now these aren't really java classes,

960
00:53:25,439 --> 00:53:29,606
but they can be imported just
like any other java class.

961
00:53:30,759 --> 00:53:32,915
So I just did the
Control + Shift + O there

962
00:53:32,915 --> 00:53:35,743
and you can see that
this Aspect annotation

963
00:53:35,743 --> 00:53:39,971
has been imported from
the AspectJ package.

964
00:53:39,971 --> 00:53:42,825
Now, you can think of an annotation

965
00:53:42,825 --> 00:53:46,187
as being like a comment, really.

966
00:53:46,187 --> 00:53:48,595
Just having this annotation in place,

967
00:53:48,595 --> 00:53:50,845
isn't going to do anything.

968
00:53:51,731 --> 00:53:54,398
It's just a marker on the class.

969
00:53:55,343 --> 00:53:57,312
Well, what's going to happen

970
00:53:57,312 --> 00:54:02,269
when we have this AspectJ
auto proxy command in our XML,

971
00:54:02,269 --> 00:54:06,980
is Spring is now going to
do a search at runtime.

972
00:54:06,980 --> 00:54:10,116
When we run the code, Spring will search

973
00:54:10,116 --> 00:54:14,033
for any class with the
Aspect annotation on it.

974
00:54:15,884 --> 00:54:17,816
And because we've put
this annotation in place,

975
00:54:17,816 --> 00:54:21,483
Spring knows that we
want this to be advice.

976
00:54:22,830 --> 00:54:25,703
So at runtime, Spring is
going to find this class

977
00:54:25,703 --> 00:54:29,396
and Spring is going to know
this class is an aspect

978
00:54:29,396 --> 00:54:31,496
but we need to go a little further.

979
00:54:31,496 --> 00:54:35,388
For each of the methods, we
need to add a further annotation

980
00:54:35,388 --> 00:54:39,555
to say whether this advice
is before, after, or around.

981
00:54:40,932 --> 00:54:45,099
So, our performTimingMeasurement
method is around advice,

982
00:54:46,369 --> 00:54:50,116
so we add in the @Around annotation.

983
00:54:50,116 --> 00:54:52,778
Again, that will need to be imported.

984
00:54:52,778 --> 00:54:54,223
Now, I have an error there,

985
00:54:54,223 --> 00:54:56,969
but I'll come back on to that in a minute.

986
00:54:56,969 --> 00:55:00,244
Because I also need an
annotation down here

987
00:55:00,244 --> 00:55:04,411
for my before advice and, of
course, you've guessed it,

988
00:55:05,732 --> 00:55:08,687
that annotation is going to be @Before.

989
00:55:08,687 --> 00:55:09,961
Do be a little careful here,

990
00:55:09,961 --> 00:55:12,426
there is a before class, I guess,

991
00:55:12,426 --> 00:55:15,758
in the junit framework
so that is ambiguous.

992
00:55:15,758 --> 00:55:19,987
You need to be sure to pick
the AspectJ annotation.

993
00:55:19,987 --> 00:55:22,003
Now the reason we have
a compiler error here

994
00:55:22,003 --> 00:55:26,868
is because in () we need to specify

995
00:55:26,868 --> 00:55:30,361
the pointcut for this piece of advice.

996
00:55:30,361 --> 00:55:33,050
Now that way that you
configure a pointcut,

997
00:55:33,050 --> 00:55:36,802
and I must admit I find
this really confusing,

998
00:55:36,802 --> 00:55:39,552
we declare a method in our class.

999
00:55:40,887 --> 00:55:42,853
Very strange, this.

1000
00:55:42,853 --> 00:55:45,647
The method will return void

1001
00:55:45,647 --> 00:55:49,506
and we can call the
method anything we like.

1002
00:55:49,506 --> 00:55:53,650
But rather as we did in
the XML, this method name

1003
00:55:53,650 --> 00:55:57,542
needs to describe the
intention of the pointcut.

1004
00:55:57,542 --> 00:56:00,904
So the pointcut is going to be,

1005
00:56:00,904 --> 00:56:04,557
let's make it just allServiceMethods.

1006
00:56:04,557 --> 00:56:06,993
I won't bother with service methods

1007
00:56:06,993 --> 00:56:09,906
that return lists this time around.

1008
00:56:09,906 --> 00:56:13,517
And it's just a parameter-less method.

1009
00:56:13,517 --> 00:56:16,877
There's just () there.

1010
00:56:16,877 --> 00:56:19,877
And you leave the method body empty.

1011
00:56:21,133 --> 00:56:22,716
So we just have {}.

1012
00:56:24,774 --> 00:56:26,509
Now it's a really weird method

1013
00:56:26,509 --> 00:56:29,785
in that we're never going
to call this method.

1014
00:56:29,785 --> 00:56:33,938
It's really just a tag or a marker method.

1015
00:56:33,938 --> 00:56:37,081
But the idea is that we add
an annotation to that method

1016
00:56:37,081 --> 00:56:39,144
so it's almost like this is just giving us

1017
00:56:39,144 --> 00:56:42,644
a hook to hang our pointcut annotation to.

1018
00:56:43,857 --> 00:56:47,357
So the annotation is, of course, Pointcut.

1019
00:56:48,841 --> 00:56:52,178
And then you specify in (),

1020
00:56:52,178 --> 00:56:56,276
just the string
representing your pointcuts.

1021
00:56:56,276 --> 00:57:00,443
So it's going to be, again,
our old friend execution

1022
00:57:03,423 --> 00:57:06,733
and we don't care what
the return types are

1023
00:57:06,733 --> 00:57:10,582
but we want to apply the
advice to all classes in the

1024
00:57:10,582 --> 00:57:14,749
com.virtualpairprogrammers.avalon.services
package

1025
00:57:18,488 --> 00:57:22,488
and we want to apply the
pointcut to all classes

1026
00:57:24,093 --> 00:57:26,926
and then all methods inside there.

1027
00:57:27,789 --> 00:57:28,977
And we don't care

1028
00:57:28,977 --> 00:57:32,785
what the parameters going
into the methods are.

1029
00:57:32,785 --> 00:57:34,214
So I have a compiler error

1030
00:57:34,214 --> 00:57:37,236
and that's because I don't
think I've imported pointcut.

1031
00:57:37,236 --> 00:57:39,786
So Control + Shift + O.

1032
00:57:39,786 --> 00:57:43,510
And just to check, there's the import.

1033
00:57:43,510 --> 00:57:47,766
So that's compiling now and
all we do in the around tag now

1034
00:57:47,766 --> 00:57:50,516
is string with name of the method

1035
00:57:52,497 --> 00:57:54,794
that defined that pointcut.

1036
00:57:54,794 --> 00:57:57,062
Now, of course, if you
wanted a different pointcut

1037
00:57:57,062 --> 00:57:59,946
for around advice and our before advice,

1038
00:57:59,946 --> 00:58:03,979
you just go ahead and
create further pointcuts.

1039
00:58:03,979 --> 00:58:06,723
Now, I must admit, I think
that's a very strange system

1040
00:58:06,723 --> 00:58:09,998
that they've setup, very
unusual to have a method in java

1041
00:58:09,998 --> 00:58:12,295
with an empty method body.

1042
00:58:12,295 --> 00:58:15,503
But if it works, I guess you have to admit

1043
00:58:15,503 --> 00:58:19,284
that these three annotations
replacing the big block

1044
00:58:19,284 --> 00:58:23,451
of XML that we had before
is arguably a little neater.

1045
00:58:25,365 --> 00:58:27,615
Let's check that this runs.

1046
00:58:28,874 --> 00:58:32,920
Now, it's telling me that the
pointcut is not well formed.

1047
00:58:32,920 --> 00:58:34,684
And it is a little bit confusing, this.

1048
00:58:34,684 --> 00:58:38,743
I guess you might be inclined
to go into the pointcut

1049
00:58:38,743 --> 00:58:40,649
and check that everything's okay there,

1050
00:58:40,649 --> 00:58:43,224
but it's just a little
bit of a tricky thing

1051
00:58:43,224 --> 00:58:45,576
that I always forget to do.

1052
00:58:45,576 --> 00:58:49,836
When you put the name of
this pointcut method in here,

1053
00:58:49,836 --> 00:58:53,419
you do have to include ().

1054
00:58:55,404 --> 00:58:57,336
I always forget to do that.

1055
00:58:57,336 --> 00:58:59,586
Let's see if that runs now.

1056
00:59:01,256 --> 00:59:02,880
Well, yes, that's looking good.

1057
00:59:02,880 --> 00:59:05,736
You can see that the
before advice is running

1058
00:59:05,736 --> 00:59:07,609
and the around advice.

1059
00:59:07,609 --> 00:59:09,236
And remember this time, the advice

1060
00:59:09,236 --> 00:59:11,252
is a little bit more general.

1061
00:59:11,252 --> 00:59:14,613
I've applied it to all
of the service methods.

1062
00:59:14,613 --> 00:59:18,504
I don't know which of the
two approaches you prefer.

1063
00:59:18,504 --> 00:59:21,215
You can go with either the AOP namespace

1064
00:59:21,215 --> 00:59:25,382
that we say in the XML of
you can use the annotations.

1065
00:59:26,877 --> 00:59:28,848
And I guess if you're
working on a project,

1066
00:59:28,848 --> 00:59:32,364
they will have made a
decision on which they prefer.

1067
00:59:32,364 --> 00:59:33,428
I'll tell you the reason

1068
00:59:33,428 --> 00:59:37,292
that I don't like the annotation version.

1069
00:59:37,292 --> 00:59:41,380
It's just that now, we have
the details of our AOP,

1070
00:59:41,380 --> 00:59:46,252
how we want it to be applied,
hard-coded into the code.

1071
00:59:46,252 --> 00:59:48,682
If I wanted to change this pointcut,

1072
00:59:48,682 --> 00:59:52,057
perhaps we are finished
using performanceTiming

1073
00:59:52,057 --> 00:59:54,349
and we want to switch it off.

1074
00:59:54,349 --> 00:59:55,931
Well, using the annotations,

1075
00:59:55,931 --> 00:59:58,101
I would have to go into this class,

1076
00:59:58,101 --> 01:00:02,440
change the pointcut here,
and recompile the code.

1077
01:00:02,440 --> 01:00:06,699
Whereas with XML version,
it's not there anymore,

1078
01:00:06,699 --> 01:00:09,597
but if I had the AOP namespace version,

1079
01:00:09,597 --> 01:00:13,785
then all I'm doing here is
editing a configuration file.

1080
01:00:13,785 --> 01:00:16,211
(energetic music)
I wouldn't have to recompile.

1081
01:00:16,211 --> 01:00:18,282
And I just like that level of,

1082
01:00:18,282 --> 01:00:22,622
kind of being able to
switch the advice on or off,

1083
01:00:22,622 --> 01:00:25,814
or change the classes to which it applies

1084
01:00:25,814 --> 01:00:28,418
in a configuration file feels, to me,

1085
01:00:28,418 --> 01:00:30,348
a lot more natural.

1086
01:00:30,348 --> 01:00:32,537
However, having said that,

1087
01:00:32,537 --> 01:00:36,704
a lot of people do prefer
this new annotation version.

1088
01:00:38,079 --> 01:00:41,242
So what I'm going to do
for the practical code

1089
01:00:41,242 --> 01:00:43,220
that's in your practicals and code folder,

1090
01:00:43,220 --> 01:00:46,086
I'm going to provide two
copies of the workspace.

1091
01:00:46,086 --> 01:00:50,512
One with the annotations
and one with the XML.

1092
01:00:50,512 --> 01:00:54,139
Now of course we need to do
a practical session on AOP,

1093
01:00:54,139 --> 01:00:56,941
so I'm going to be switching
across to our CRM system

1094
01:00:56,941 --> 01:01:01,221
in the next chapter while
you'll be flying solo with AOP.

1095
01:01:01,221 --> 01:01:04,375
And I'll be allowing you to
use any of the approaches

1096
01:01:04,375 --> 01:01:06,878
that we've seen so far.

1097
01:01:06,878 --> 01:01:11,205
So the pointcut syntax
borrowed from AspectJ

1098
01:01:11,205 --> 01:01:13,014
is a powerful way of defining

1099
01:01:13,014 --> 01:01:16,379
where you want your advice to apply.

1100
01:01:16,379 --> 01:01:19,488
All service classes, all DAOs,

1101
01:01:19,488 --> 01:01:22,298
just methods beginning with the letter Y.

1102
01:01:22,298 --> 01:01:24,538
It goes on and on.

1103
01:01:24,538 --> 01:01:26,599
The advice class is now just plain java

1104
01:01:26,599 --> 01:01:28,882
which means we can have
more than one piece

1105
01:01:28,882 --> 01:01:30,632
of advice in a class.

1106
01:01:31,736 --> 01:01:36,125
The AOP:Namespace gives
us a lovely set of tags

1107
01:01:36,125 --> 01:01:38,393
giving you real power and control

1108
01:01:38,393 --> 01:01:42,560
over the advice without
massive blocks of XML beans.

1109
01:01:43,797 --> 01:01:46,793
You can go for annotations instead.

1110
01:01:46,793 --> 01:01:48,825
I've made my feelings clear on this.

1111
01:01:48,825 --> 01:01:52,773
I don't like having my
pointcuts defined in code.

1112
01:01:52,773 --> 01:01:55,593
I do like annotations for other tasks,

1113
01:01:55,593 --> 01:01:58,457
as we'll see later, but not here.

1114
01:01:58,457 --> 01:02:01,117
Your opinions may vary, though.

1115
01:02:01,117 --> 01:02:04,113
As promised, the next
chapter is another practical.

1116
01:02:04,113 --> 01:02:07,530
Your chance to practice AOP for yourself.

1117
01:02:08,650 --> 01:02:11,483
(energetic music)

1
00:00:00,901 --> 00:00:03,401
(light music)

2
00:00:10,410 --> 00:00:11,338
- [Voiceover] So now it's time for the

3
00:00:11,338 --> 00:00:13,505
practical session for AOP.

4
00:00:14,493 --> 00:00:18,928
This practical session is
optional, if you want to skip it,

5
00:00:18,928 --> 00:00:22,109
you can safely proceed
to the next chapter,

6
00:00:22,109 --> 00:00:25,175
and the rest of the course.

7
00:00:25,175 --> 00:00:28,216
The requirements for this
practical are going to be

8
00:00:28,216 --> 00:00:32,257
really quite easy, but
of course before we start

9
00:00:32,257 --> 00:00:37,098
we're going to need to switch
to the CRM System project,

10
00:00:37,098 --> 00:00:41,015
so it's safest to close
your Bookstore project,

11
00:00:42,601 --> 00:00:46,101
at least temporarily, and then open up the

12
00:00:47,343 --> 00:00:49,593
project for the CRM System.

13
00:00:50,879 --> 00:00:54,118
Now I really couldn't
think of any interesting

14
00:00:54,118 --> 00:00:57,299
AOP requirements that we can implement

15
00:00:57,299 --> 00:00:59,947
apart from the performance timing

16
00:00:59,947 --> 00:01:02,849
that we did on the Bookstore.

17
00:01:02,849 --> 00:01:05,531
Now something like
transactions would be a good

18
00:01:05,531 --> 00:01:08,271
AOP requirement, but there's lots to say

19
00:01:08,271 --> 00:01:10,593
about transactions and we are covering

20
00:01:10,593 --> 00:01:14,343
them in detail later on in the course.

21
00:01:14,343 --> 00:01:18,604
So your job, if you choose
to accept this practical,

22
00:01:18,604 --> 00:01:22,110
is to implement some
performance timing advice,

23
00:01:22,110 --> 00:01:26,174
for the service classes in the CRM System.

24
00:01:26,174 --> 00:01:29,715
Use the AspectJ pointcut syntax and

25
00:01:29,715 --> 00:01:32,715
you can either use the AOP namespace

26
00:01:33,801 --> 00:01:36,384
or annotations to achieve this.

27
00:01:37,458 --> 00:01:39,978
There's an extra
requirement: I'd also like

28
00:01:39,978 --> 00:01:42,753
you to try setting up the advice

29
00:01:42,753 --> 00:01:45,586
so that it also triggers for daos,

30
00:01:46,839 --> 00:01:49,089
as well as service classes.

31
00:01:50,497 --> 00:01:53,236
Now you'll need a little
extra syntax for that.

32
00:01:53,236 --> 00:01:56,209
As a clue, I can tell you that the AspectJ

33
00:01:56,209 --> 00:02:00,209
pointcut syntax also
supports logical operators.

34
00:02:02,269 --> 00:02:04,881
And the syntax looks something like this.

35
00:02:04,881 --> 00:02:07,482
In fact you're going
to use the double pipe

36
00:02:07,482 --> 00:02:09,850
operator you can see here, which works

37
00:02:09,850 --> 00:02:14,017
exactly the same as standard
Java, it's a logical "or".

38
00:02:16,654 --> 00:02:18,860
So you're going to say something like

39
00:02:18,860 --> 00:02:21,147
"the pointcut needs to be by the

40
00:02:21,147 --> 00:02:23,980
"all-service classes or all daos."

41
00:02:26,780 --> 00:02:29,683
Something to be aware
of with the CRM system

42
00:02:29,683 --> 00:02:32,910
is the packaging structure
is slightly different

43
00:02:32,910 --> 00:02:35,592
to the structure we have on the Bookstore.

44
00:02:35,592 --> 00:02:38,204
And that is that we have three separate

45
00:02:38,204 --> 00:02:41,454
packages, each of which are subpackages

46
00:02:43,081 --> 00:02:46,018
of the services package, and you're going

47
00:02:46,018 --> 00:02:50,101
to want to apply advice
to all three subpackages.

48
00:02:51,962 --> 00:02:54,075
Now something that we didn't cover in the

49
00:02:54,075 --> 00:02:56,560
previous theory sessions is that when you

50
00:02:56,560 --> 00:02:59,520
provide a pointcut like this, and this is

51
00:02:59,520 --> 00:03:01,366
going to be the kind of pointcut

52
00:03:01,366 --> 00:03:03,818
you'll be writing, so here I'm saying

53
00:03:03,818 --> 00:03:07,985
look for classes in the
com.virtualpairprogrammers.services

54
00:03:09,321 --> 00:03:13,931
package, but because I have
.* here, that's telling

55
00:03:13,931 --> 00:03:17,764
it to look for classes
in the service package.

56
00:03:19,445 --> 00:03:22,406
But that's not what we want.

57
00:03:22,406 --> 00:03:24,712
Because it will only look for

58
00:03:24,712 --> 00:03:27,859
classes in the services package.

59
00:03:27,859 --> 00:03:30,942
And it won't look in the subpackages.

60
00:03:32,259 --> 00:03:36,426
What we need is a further
piece of AspectJ syntax.

61
00:03:37,565 --> 00:03:39,732
It's a very subtle change.

62
00:03:40,862 --> 00:03:45,029
Here's the difference, and if
you want to compare the two,

63
00:03:47,213 --> 00:03:49,848
I've made a very small change.

64
00:03:49,848 --> 00:03:52,180
I'll put a highlighter on the changes.

65
00:03:52,180 --> 00:03:54,763
Here, I've use the ".." syntax.

66
00:03:58,395 --> 00:04:02,562
And that's AspectJ for
search through subpackages.

67
00:04:05,489 --> 00:04:07,160
It's very subtle.

68
00:04:07,160 --> 00:04:10,376
It can be a very difficult
problem to debug.

69
00:04:10,376 --> 00:04:13,140
So this is going to look
in the services package

70
00:04:13,140 --> 00:04:16,042
and every subpackage,
and even if there were

71
00:04:16,042 --> 00:04:19,792
17 layers of subpackages
underneath services,

72
00:04:20,930 --> 00:04:23,449
it would look at all of the classes

73
00:04:23,449 --> 00:04:25,980
in all of the subpackages.

74
00:04:25,980 --> 00:04:27,199
So you'll definitely be needing

75
00:04:27,199 --> 00:04:30,671
that in this practical exercise.

76
00:04:30,671 --> 00:04:33,318
So as always, try this for yourself,

77
00:04:33,318 --> 00:04:37,485
and if you have any problems,
a full walkthrough follows.

78
00:04:42,037 --> 00:04:44,173
Okay so we're going to
go through the steps

79
00:04:44,173 --> 00:04:46,031
you need to follow to implement

80
00:04:46,031 --> 00:04:49,909
performance timing on the CRM system.

81
00:04:49,909 --> 00:04:52,428
This is probably one of
the easier practicals

82
00:04:52,428 --> 00:04:54,866
on the course, because this time around

83
00:04:54,866 --> 00:04:59,823
we're doing almost the same job
as we did for the Bookstore.

84
00:04:59,823 --> 00:05:03,990
So I'll start by going into
our Application.xml file.

85
00:05:05,234 --> 00:05:08,415
I think the worst job in this practical

86
00:05:08,415 --> 00:05:11,875
is going to be upgrading the doc type to

87
00:05:11,875 --> 00:05:14,603
be a schema instead so that we can use

88
00:05:14,603 --> 00:05:16,770
these new features in AOP.

89
00:05:17,900 --> 00:05:20,187
The best way to do that,
as on the theory session,

90
00:05:20,187 --> 00:05:21,941
is to use the reference manual.

91
00:05:21,941 --> 00:05:23,891
So I'm here on the chapter entitled

92
00:05:23,891 --> 00:05:26,474
XML Schema-based configuration.

93
00:05:27,560 --> 00:05:30,404
And really, the easiest way is

94
00:05:30,404 --> 00:05:33,783
just to do a control F in your browser.

95
00:05:33,783 --> 00:05:36,366
And I'm searching for AOP name.

96
00:05:37,765 --> 00:05:42,165
And that's landed me here on
the subtitle of the AOP schema.

97
00:05:42,165 --> 00:05:44,522
Now we're lucky for this chapter in that

98
00:05:44,522 --> 00:05:47,459
the fragment that they give us here,

99
00:05:47,459 --> 00:05:49,410
is everything that we need.

100
00:05:49,410 --> 00:05:51,987
Because the example includes both the

101
00:05:51,987 --> 00:05:55,154
AOP namespace and the beans namespace.

102
00:05:58,907 --> 00:06:01,670
And we need both of those.

103
00:06:01,670 --> 00:06:03,586
When we go alittle further in the course,

104
00:06:03,586 --> 00:06:05,908
and we need to add in new namespaces,

105
00:06:05,908 --> 00:06:08,880
we'll need to add elements to that.

106
00:06:08,880 --> 00:06:12,618
But for this chapter we can
safely copy that beans block.

107
00:06:12,618 --> 00:06:15,753
We need to delete the
dtd but also be careful

108
00:06:15,753 --> 00:06:18,503
to delete the existing beans tag.

109
00:06:19,747 --> 00:06:23,830
Because what we've just
copied replaces that tag.

110
00:06:24,716 --> 00:06:28,549
So that, by a long
distance, is the worst part

111
00:06:29,685 --> 00:06:31,685
of this practical, done.

112
00:06:32,622 --> 00:06:34,817
So we can forget all about that now,

113
00:06:34,817 --> 00:06:38,439
and the next job I suggest is going to be

114
00:06:38,439 --> 00:06:40,689
to write the actual advice.

115
00:06:41,655 --> 00:06:44,572
So this is going to be a new class,

116
00:06:46,543 --> 00:06:47,880
and remember this is the first

117
00:06:47,880 --> 00:06:49,935
advice we've written for this system,

118
00:06:49,935 --> 00:06:53,418
so I'm going to pop this in a new package.

119
00:06:53,418 --> 00:06:55,462
Now in this project, we don't have a

120
00:06:55,462 --> 00:06:57,784
package representing the project,

121
00:06:57,784 --> 00:07:01,951
so it's going to be just
com.virtualpairprogrammers.advice

122
00:07:04,459 --> 00:07:07,629
and the name of the
class, course it can be

123
00:07:07,629 --> 00:07:09,754
anything we want, but
I'm going to call this

124
00:07:09,754 --> 00:07:13,004
PerformanceTimingAdvice, I think that's

125
00:07:15,106 --> 00:07:19,273
probably the same as I called
it in the theory sessions.

126
00:07:21,747 --> 00:07:23,941
Now as you know now one
of the great advantages

127
00:07:23,941 --> 00:07:27,203
of the enhanced AOP
support is that this class

128
00:07:27,203 --> 00:07:30,141
can remain a plain Java class.

129
00:07:30,141 --> 00:07:33,392
We don't need to implement
a particular interface.

130
00:07:33,392 --> 00:07:37,095
But we will need to
annotate it with the @Aspect

131
00:07:37,095 --> 00:07:41,159
annotation, which will
need to be imported,

132
00:07:41,159 --> 00:07:44,142
and I'm going to say
this just one last time,

133
00:07:44,142 --> 00:07:48,926
I think for this it's the most
common source of confusion.

134
00:07:48,926 --> 00:07:52,759
The import is coming
from the AspectJ package,

135
00:07:54,626 --> 00:07:58,214
and I don't think I mentioned
this on the theory chapter,

136
00:07:58,214 --> 00:08:01,708
but here in your lib
directory, notice that you do

137
00:08:01,708 --> 00:08:04,541
actually have an AspectJ jar file.

138
00:08:05,377 --> 00:08:09,371
That comes directly from
the AspectJ project.

139
00:08:09,371 --> 00:08:12,704
But Spring is only borrowing the syntax.

140
00:08:14,572 --> 00:08:18,613
All of the other features
of AspectJ we are not using,

141
00:08:18,613 --> 00:08:22,757
this is still regular
Spring AOP, but the syntax

142
00:08:22,757 --> 00:08:24,998
we're using will tell Spring that

143
00:08:24,998 --> 00:08:28,423
it needs to generate some proxies.

144
00:08:28,423 --> 00:08:31,442
Well, now that I've said
that, probably six or seven

145
00:08:31,442 --> 00:08:34,983
times on the course, I'm
sorry for boring you there.

146
00:08:34,983 --> 00:08:37,955
What we need to do in here is to write our

147
00:08:37,955 --> 00:08:41,148
advice method and this is going to be

148
00:08:41,148 --> 00:08:45,315
a round advice, so it will
need to return an object.

149
00:08:46,868 --> 00:08:50,456
The key thing is we can call
the method anything we want.

150
00:08:50,456 --> 00:08:53,789
And I'm going to call this recordTiming.

151
00:08:55,494 --> 00:08:59,036
Now because this is going
to be a round advice,

152
00:08:59,036 --> 00:09:03,203
we need a parameter in here
which is ProceedingJoinPoint.

153
00:09:05,665 --> 00:09:09,748
I've always found that a
rather silly class name.

154
00:09:10,750 --> 00:09:12,375
And it will need to be imported,

155
00:09:12,375 --> 00:09:15,708
again from the AspectJ package.

156
00:09:15,708 --> 00:09:18,564
Well the work here is going
to be almost identical

157
00:09:18,564 --> 00:09:20,514
to what we did in the
Bookstore, so feel free

158
00:09:20,514 --> 00:09:24,681
to forward wind the video
if you find this boring.

159
00:09:25,657 --> 00:09:29,074
We're going to take a timing measurement.

160
00:09:32,867 --> 00:09:36,617
And I'm using the nanotime
method to do that.

161
00:09:38,742 --> 00:09:43,630
And then we're going to use
the ProceedingJoinPoint object

162
00:09:43,630 --> 00:09:46,297
to proceed to the target method.

163
00:09:47,403 --> 00:09:50,549
Now the target method
might return a value,

164
00:09:50,549 --> 00:09:51,382
so we'll

165
00:09:54,402 --> 00:09:57,212
capture that return value.

166
00:09:57,212 --> 00:09:59,499
And I have a couple of
compile errors here,

167
00:09:59,499 --> 00:10:02,669
but I'll worry about
those in a short while.

168
00:10:02,669 --> 00:10:04,252
And then we'll take

169
00:10:08,226 --> 00:10:11,143
the time, I'll call this timeAfter,

170
00:10:14,751 --> 00:10:18,918
and then we can calculate the
timeTaken is the timeAfter and

171
00:10:21,725 --> 00:10:24,808
subtract the previous time from that.

172
00:10:26,241 --> 00:10:28,563
I think just to do something
a little bit different

173
00:10:28,563 --> 00:10:32,313
to what we did on the previous videos,

174
00:10:32,313 --> 00:10:35,980
I'm going to convert
this into milliseconds,

175
00:10:37,572 --> 00:10:40,822
cause it's a little bit easier to read.

176
00:10:41,717 --> 00:10:44,213
I've gotta be careful with my maths here.

177
00:10:44,213 --> 00:10:48,126
I think that's going to
be the time in nanoseconds

178
00:10:48,126 --> 00:10:52,209
divided by, and I think
it's a one and six zeros.

179
00:10:56,439 --> 00:10:59,492
Well we'll probably be
better to extract that

180
00:10:59,492 --> 00:11:03,161
into a constant, so I'll
do a refactor there,

181
00:11:03,161 --> 00:11:07,108
and use Extract Constants,
and we'll call that

182
00:11:07,108 --> 00:11:10,441
constant "nanoseconds in a millisecond."

183
00:11:17,837 --> 00:11:20,504
And spell millisecond correctly.

184
00:11:22,632 --> 00:11:26,951
And that's perhaps just a
little bit more readable.

185
00:11:26,951 --> 00:11:30,451
And of course we'll output to the console.

186
00:11:31,711 --> 00:11:35,043
And I'm sure I've said this in
the theory sessions as well,

187
00:11:35,043 --> 00:11:37,714
but we probably want to use
a proper logging framework

188
00:11:37,714 --> 00:11:40,245
there if this was a real system.

189
00:11:40,245 --> 00:11:44,134
Now my first compile error
here is simply because

190
00:11:44,134 --> 00:11:46,131
I need to remember at
the end of this method

191
00:11:46,131 --> 00:11:49,719
to return the value, the return value

192
00:11:49,719 --> 00:11:53,387
that came back from the target method.

193
00:11:53,387 --> 00:11:57,554
And I have an error here
because the proceed method

194
00:11:59,053 --> 00:12:01,136
might throw an exception.

195
00:12:02,060 --> 00:12:03,616
It will throw an exception if the

196
00:12:03,616 --> 00:12:06,449
target method throws an exception.

197
00:12:07,528 --> 00:12:08,805
So the way to deal with this,

198
00:12:08,805 --> 00:12:10,837
there are two ways of dealing with it,

199
00:12:10,837 --> 00:12:13,566
and we did touch on this in the theory.

200
00:12:13,566 --> 00:12:16,375
The common way, is to simply declare

201
00:12:16,375 --> 00:12:20,208
throws throwable, on the
record timing method.

202
00:12:22,470 --> 00:12:26,348
And that's saying if this method fails,

203
00:12:26,348 --> 00:12:29,030
the target method throws an exception,

204
00:12:29,030 --> 00:12:32,896
then we simply rethrow
that exception immediately.

205
00:12:32,896 --> 00:12:35,868
Which is okay for some types of advice,

206
00:12:35,868 --> 00:12:38,353
but the problem with
that is, that means that

207
00:12:38,353 --> 00:12:41,936
the rest of the advice
method will not run,

208
00:12:42,834 --> 00:12:45,447
and therefore we won't
get the advice applied

209
00:12:45,447 --> 00:12:48,430
to any method that's thrown an exception.

210
00:12:48,430 --> 00:12:50,334
And that might be acceptable,

211
00:12:50,334 --> 00:12:53,225
but I would like to have the timing.

212
00:12:53,225 --> 00:12:55,431
So as on the theory
sessions, we're going to need

213
00:12:55,431 --> 00:12:59,671
a standard Java try/finally block.

214
00:12:59,671 --> 00:13:03,838
So we're going to "try" to
proceed to the target method,

215
00:13:05,743 --> 00:13:10,062
and we're going to "try"
to return the return value.

216
00:13:10,062 --> 00:13:12,106
I've effectively just moved that line

217
00:13:12,106 --> 00:13:15,856
from the bottom into the try block.

218
00:13:15,856 --> 00:13:20,616
So they're the two lines of
code that we want to try,

219
00:13:20,616 --> 00:13:24,616
but whether or not the
proceed succeeded or not,

220
00:13:27,872 --> 00:13:31,088
in the "finally" block,
we'll put in the code

221
00:13:31,088 --> 00:13:33,468
that we want to always run even

222
00:13:33,468 --> 00:13:36,196
if something goes horribly wrong.

223
00:13:36,196 --> 00:13:39,529
And that's going to be the stopping

224
00:13:39,529 --> 00:13:43,116
the clock and outputting the timing.

225
00:13:43,116 --> 00:13:47,551
It's compiling okay, and
assuming that my maths

226
00:13:47,551 --> 00:13:51,718
is correct there, I think
we've got usable advice.

227
00:13:53,414 --> 00:13:55,156
So the next step is going to be

228
00:13:55,156 --> 00:13:57,570
to make the advice be
applied, in other words,

229
00:13:57,570 --> 00:14:00,659
we need to weave this
advice into our code,

230
00:14:00,659 --> 00:14:05,291
and we'll do that using the
AOP namespace in the xml.

231
00:14:05,291 --> 00:14:08,041
So I'll add in the comments here.

232
00:14:10,957 --> 00:14:14,040
And it's going to be our AOP weaving.

233
00:14:15,972 --> 00:14:17,888
And referring back to what we did before,

234
00:14:17,888 --> 00:14:22,055
this is aopconfig, the
configuration of all of our AOP,

235
00:14:24,030 --> 00:14:27,280
and as part of that we want to define

236
00:14:27,280 --> 00:14:31,280
an aspect, and we need
to refer back to the bean

237
00:14:32,540 --> 00:14:35,373
that we've created for the advice.

238
00:14:36,952 --> 00:14:39,227
Well I haven't actually done that,

239
00:14:39,227 --> 00:14:43,310
so I'm going to call the
bean performance advice,

240
00:14:49,618 --> 00:14:51,661
and we'll declare that bean here.

241
00:14:51,661 --> 00:14:54,744
So bean id, again, performanceadvice,

242
00:14:57,037 --> 00:14:59,616
and the class is going to be

243
00:14:59,616 --> 00:15:02,715
the exact class that we just created

244
00:15:02,715 --> 00:15:06,882
com.virtualpairprogrammers.advice.performanceTimingAdvice.

245
00:15:12,154 --> 00:15:16,321
And there are no properties
to inject into that bean.

246
00:15:18,714 --> 00:15:20,618
So we're getting there with this now.

247
00:15:20,618 --> 00:15:22,464
This aspect that we're configuring

248
00:15:22,464 --> 00:15:25,471
is going to be this piece of advice.

249
00:15:25,471 --> 00:15:28,638
Inside that tag we use the AOP around.

250
00:15:31,915 --> 00:15:35,235
The method that we're invoking is

251
00:15:35,235 --> 00:15:39,498
this one here, the one
called recordTiming.

252
00:15:39,498 --> 00:15:41,460
So I'll paste that in.

253
00:15:41,460 --> 00:15:43,376
And now for the hard bit.

254
00:15:43,376 --> 00:15:46,755
We need to declare the pointcut.

255
00:15:46,755 --> 00:15:50,064
Now you probably think I've
got some kind of crib sheet,

256
00:15:50,064 --> 00:15:51,573
off camera that I'm copying from,

257
00:15:51,573 --> 00:15:54,301
but I promise you I haven't, so I'm almost

258
00:15:54,301 --> 00:15:56,774
certain to get this wrong.

259
00:15:56,774 --> 00:15:59,941
We need execution, and round brackets,

260
00:16:01,732 --> 00:16:04,031
and then just think in terms of a regular

261
00:16:04,031 --> 00:16:08,198
Java method signature, the first
element is the return type.

262
00:16:09,418 --> 00:16:11,984
But we don't care what
the return types are,

263
00:16:11,984 --> 00:16:15,408
so we wild card that,
but then we're interested

264
00:16:15,408 --> 00:16:19,575
in call classes that are in
the com.virtualpairprogrammers

265
00:16:22,839 --> 00:16:27,158
and for this project we're
straight into the packages.

266
00:16:27,158 --> 00:16:30,741
And the package is
called, I can't remember

267
00:16:31,628 --> 00:16:34,045
if it's service, or services.

268
00:16:35,087 --> 00:16:36,254
It's services.

269
00:16:42,657 --> 00:16:46,047
But then any class inside that package.

270
00:16:46,047 --> 00:16:48,648
Now we need to think about the methods.

271
00:16:48,648 --> 00:16:51,748
So this first wild card is for the class,

272
00:16:51,748 --> 00:16:54,035
but then we use .* to say that we

273
00:16:54,035 --> 00:16:56,972
don't care what the method is.

274
00:16:56,972 --> 00:16:59,410
We want all of them advising.

275
00:16:59,410 --> 00:17:01,570
And now we're into the parameter list

276
00:17:01,570 --> 00:17:03,842
in round brackets, and again we don't care

277
00:17:03,842 --> 00:17:07,509
about the parameters
so the ".." means zero,

278
00:17:09,359 --> 00:17:12,359
one, or more parameters of any type.

279
00:17:14,387 --> 00:17:18,554
I think that's all we need to
advise the service classes.

280
00:17:19,402 --> 00:17:23,884
Now I know I suggested to
also advise the daos as well,

281
00:17:23,884 --> 00:17:27,262
but we'll add that once
we've got this work in.

282
00:17:27,262 --> 00:17:30,362
Okay, so we've written the
advice, we've configured

283
00:17:30,362 --> 00:17:34,391
the weaving, all that
remains is now to test it.

284
00:17:34,391 --> 00:17:36,933
Now I can't remember, since
it's quite a long time

285
00:17:36,933 --> 00:17:40,395
since we've done anything on this project,

286
00:17:40,395 --> 00:17:43,414
we have a client test here.

287
00:17:43,414 --> 00:17:45,446
I think the important
thing really is that we're

288
00:17:45,446 --> 00:17:48,871
calling quite a few
service methods in here.

289
00:17:48,871 --> 00:17:51,564
We're calling the new customer method,

290
00:17:51,564 --> 00:17:55,639
and we're calling a method
on the diary service here,

291
00:17:55,639 --> 00:17:58,159
so we have quite a few method calls.

292
00:17:58,159 --> 00:18:00,318
Just before I run this
I just kind of realized

293
00:18:00,318 --> 00:18:04,441
that my system out print
line is not particularly

294
00:18:04,441 --> 00:18:07,226
meaningful, just printing a number.

295
00:18:07,226 --> 00:18:09,893
So time taken for the method is,

296
00:18:16,210 --> 00:18:18,984
let's pretty this up a little bit,

297
00:18:18,984 --> 00:18:20,621
and of course I'm forgetting

298
00:18:20,621 --> 00:18:23,547
that we can also output
the name of the method

299
00:18:23,547 --> 00:18:26,484
by calling on proceedingJoinPoints.

300
00:18:26,484 --> 00:18:30,484
We can call getSignature,
and then call getName.

301
00:18:36,771 --> 00:18:39,546
Probably need a string in there as well.

302
00:18:39,546 --> 00:18:42,518
I think I've just missed
a plus symbol there

303
00:18:42,518 --> 00:18:45,653
to concatenate those strings.

304
00:18:45,653 --> 00:18:48,403
So then, let's see if this works.

305
00:18:49,321 --> 00:18:53,488
I can't possibly have got
pointcut correct the first time.

306
00:18:55,149 --> 00:18:56,732
Well, the code ran.

307
00:18:58,249 --> 00:19:01,512
We don't have any exceptions,
so that suggests that

308
00:19:01,512 --> 00:19:05,088
my pointcut syntax was sort of correct.

309
00:19:05,088 --> 00:19:08,466
I don't have any typos
in it, but I'm not seeing

310
00:19:08,466 --> 00:19:10,966
any advice applied to my code,

311
00:19:12,506 --> 00:19:14,944
which is a little bit worrying.

312
00:19:14,944 --> 00:19:15,777
So.

313
00:19:17,232 --> 00:19:20,123
Now, the obvious suspicion is that

314
00:19:20,123 --> 00:19:23,623
there's something wrong with our pointcut.

315
00:19:24,671 --> 00:19:26,946
And what I often like to
do here is to deliberately

316
00:19:26,946 --> 00:19:30,615
introduce a typo into the
pointcut, because it could be

317
00:19:30,615 --> 00:19:33,459
that the problem is that for some reason

318
00:19:33,459 --> 00:19:37,616
this AOP config is not
being picked up properly.

319
00:19:37,616 --> 00:19:39,566
Now if that were the case,
it wouldn't matter what

320
00:19:39,566 --> 00:19:42,260
changes we made to this poincut,

321
00:19:42,260 --> 00:19:44,779
nothing's going to make any difference.

322
00:19:44,779 --> 00:19:47,194
So we want to make sure that putting

323
00:19:47,194 --> 00:19:50,111
in a typing mistake causes a crash.

324
00:19:53,382 --> 00:19:55,379
Oh, and it does.

325
00:19:55,379 --> 00:20:00,151
So that's good, that tells
us that the config code

326
00:20:00,151 --> 00:20:03,559
here is being picked up correctly,

327
00:20:03,559 --> 00:20:04,667
and it kind of suggests that there

328
00:20:04,667 --> 00:20:07,584
is no typing error in the pointcut.

329
00:20:10,356 --> 00:20:12,608
Now this is quite a subtle problem.

330
00:20:12,608 --> 00:20:15,406
And I think, I'm talking
a little bit slowly

331
00:20:15,406 --> 00:20:17,937
here to give myself time to think,

332
00:20:17,937 --> 00:20:21,235
I think I've spotted what the problem is.

333
00:20:21,235 --> 00:20:23,812
While in fact I did warn you about this

334
00:20:23,812 --> 00:20:26,517
in the introduction to the chapter.

335
00:20:26,517 --> 00:20:30,684
And the problem is, because
the AspectJ pointcut syntax

336
00:20:31,579 --> 00:20:35,213
is precise, when it comes
to the package names.

337
00:20:35,213 --> 00:20:37,907
This is saying, literally, go into the

338
00:20:37,907 --> 00:20:41,574
com.virtualpairprogrammers.services
package,

339
00:20:42,585 --> 00:20:44,977
and look at the classes in that package,

340
00:20:44,977 --> 00:20:47,624
but do not go any deeper.

341
00:20:47,624 --> 00:20:50,155
Now that worked okay on our Bookstore,

342
00:20:50,155 --> 00:20:54,416
but our package structure is
different in this project.

343
00:20:54,416 --> 00:20:56,750
In this project we have subpackages

344
00:20:56,750 --> 00:20:59,333
of calls, customers, and diary.

345
00:21:00,918 --> 00:21:04,585
If I added .services.customers.*
on to here,

346
00:21:09,329 --> 00:21:12,329
then I think that's going to pick up

347
00:21:13,915 --> 00:21:18,164
all of the service methods
in the customers package,

348
00:21:18,164 --> 00:21:18,997
and it is.

349
00:21:19,871 --> 00:21:22,042
See now it's catching the new

350
00:21:22,042 --> 00:21:24,792
customer and record call methods.

351
00:21:25,873 --> 00:21:28,067
And it looks like the
output's about right,

352
00:21:28,067 --> 00:21:31,067
71 and 21 milliseconds, sounds okay.

353
00:21:32,862 --> 00:21:35,068
The problem is we want to apply the advice

354
00:21:35,068 --> 00:21:39,132
to all three of these
services subpackages.

355
00:21:39,132 --> 00:21:41,825
So as I mentioned in the
introduction, this is

356
00:21:41,825 --> 00:21:45,401
one piece of theory that we
didn't have on the earlier

357
00:21:45,401 --> 00:21:50,335
chapters is that we can
wild card the package names.

358
00:21:50,335 --> 00:21:53,002
So as mentioned, we would use a,

359
00:21:55,211 --> 00:21:58,265
now I've got to be careful
here, it's never very readable.

360
00:21:58,265 --> 00:22:02,212
If I use a double dot
there, the double dot

361
00:22:02,212 --> 00:22:05,568
there means drill down into any

362
00:22:05,568 --> 00:22:09,027
subpackages of the services package.

363
00:22:09,027 --> 00:22:11,222
And indeed, any further subpackages.

364
00:22:11,222 --> 00:22:13,544
So even if there's another 10 or 12 levels

365
00:22:13,544 --> 00:22:17,328
below services, it will
iteratively go through,

366
00:22:17,328 --> 00:22:21,450
or recursively go through
all of those subpackages.

367
00:22:21,450 --> 00:22:23,168
I think that's right anyway.

368
00:22:23,168 --> 00:22:25,606
So the ".." means any
subpackages and then this

369
00:22:25,606 --> 00:22:28,273
asterisk means classes, and this

370
00:22:29,391 --> 00:22:32,058
asterisk represents the methods.

371
00:22:35,510 --> 00:22:37,867
And this looks good because
now we've got the advice

372
00:22:37,867 --> 00:22:42,151
applied to, these methods here
are on the customer service

373
00:22:42,151 --> 00:22:47,120
package, whereas this one
here, get all incomplete

374
00:22:47,120 --> 00:22:49,620
actions, is our diary package.

375
00:22:50,986 --> 00:22:52,948
And it occurs to me that the so-called

376
00:22:52,948 --> 00:22:56,373
"advanced reqiurements" I
gave you in the introduction,

377
00:22:56,373 --> 00:22:58,823
which was to expand this pointcut

378
00:22:58,823 --> 00:23:01,073
to also apply to your daos.

379
00:23:02,073 --> 00:23:05,371
You can actually handle
very quickly indeed.

380
00:23:05,371 --> 00:23:08,955
If you just take out the word "services",

381
00:23:08,955 --> 00:23:11,161
and make sure you've got two dots there

382
00:23:11,161 --> 00:23:14,214
after virtualpairprogrammers, this means

383
00:23:14,214 --> 00:23:17,748
apply the advice to all of the classes

384
00:23:17,748 --> 00:23:21,714
in our virtualpairprogrammers hierarchy.

385
00:23:21,714 --> 00:23:25,093
So it's going to advise
all of the services

386
00:23:25,093 --> 00:23:27,426
and the data access package.

387
00:23:28,320 --> 00:23:31,618
Now remember as I've mentioned in theory

388
00:23:31,618 --> 00:23:34,915
you won't get any advice
on your domain classes

389
00:23:34,915 --> 00:23:37,481
because they're not configured in the

390
00:23:37,481 --> 00:23:41,265
Spring factory, in the Spring container.

391
00:23:41,265 --> 00:23:44,040
It's only objects in this container

392
00:23:44,040 --> 00:23:46,409
that get advice applied to them.

393
00:23:46,409 --> 00:23:50,635
That is one of the big
weaknesses of Spring AOP.

394
00:23:50,635 --> 00:23:54,552
It can only basically do
your services and your

395
00:23:56,540 --> 00:23:59,644
data access objects
and that kind of thing.

396
00:23:59,644 --> 00:24:01,811
So let's see if that runs.

397
00:24:03,800 --> 00:24:06,970
And well it's not actually
that easy to read.

398
00:24:06,970 --> 00:24:10,441
But you have to kind of remember
the structure of the daos

399
00:24:10,441 --> 00:24:13,739
and the service classes,
but this method here,

400
00:24:13,739 --> 00:24:17,906
the create method, is the
data access object method.

401
00:24:19,857 --> 00:24:24,025
And a new customer is the method
that's calling that method.

402
00:24:24,025 --> 00:24:26,057
So, if you like, the service layer

403
00:24:26,057 --> 00:24:28,913
took about four milliseconds, whereas the

404
00:24:28,913 --> 00:24:32,825
data access object took
66 milliseconds of that

405
00:24:32,825 --> 00:24:36,169
71 milliseconds, if that makes sense.

406
00:24:36,169 --> 00:24:38,831
I think what will be helpful in fact,

407
00:24:38,831 --> 00:24:42,140
if we expand this advice,
as well as the method,

408
00:24:42,140 --> 00:24:46,331
it would be useful to find out
the name of the target class.

409
00:24:46,331 --> 00:24:49,350
So we could do that, by interrogating the

410
00:24:49,350 --> 00:24:52,433
proceedingJoinPoints a little harder.

411
00:24:53,982 --> 00:24:55,769
So we've got the method name there,

412
00:24:55,769 --> 00:24:58,436
from the class and we'll output,

413
00:25:01,139 --> 00:25:03,705
let's put this one a new line,

414
00:25:03,705 --> 00:25:05,622
we can call the jp.get,

415
00:25:09,057 --> 00:25:10,404
and this might be quite
hard work actually,

416
00:25:10,404 --> 00:25:14,386
we can get a reference
to the target object,

417
00:25:14,386 --> 00:25:17,803
and we can then call the getClass method,

418
00:25:19,250 --> 00:25:23,167
which will allow us to
call the getName method.

419
00:25:24,382 --> 00:25:28,178
I hope you followed that, that
was kind of standard Java.

420
00:25:28,178 --> 00:25:30,384
I think that's the method we need.

421
00:25:30,384 --> 00:25:33,833
Anyway, there was a getSimpleName
method in there as well,

422
00:25:33,833 --> 00:25:35,214
but let's try and see if that makes

423
00:25:35,214 --> 00:25:37,881
the output a little bit clearer.

424
00:25:39,823 --> 00:25:41,948
Yeah, I guess getName
is outputting the fully

425
00:25:41,948 --> 00:25:44,340
qualified name of the
class, so we've got quite

426
00:25:44,340 --> 00:25:46,905
a verbose output now, but we can see that

427
00:25:46,905 --> 00:25:49,808
the time taken from this
method, which is from

428
00:25:49,808 --> 00:25:53,558
the customer dao class,
took 60 milliseconds,

429
00:25:54,789 --> 00:25:59,433
whereas the new customer
method from the service,

430
00:25:59,433 --> 00:26:03,600
customer management service
class, took 66 milliseconds.

431
00:26:05,702 --> 00:26:08,221
While I've probably overdone the output

432
00:26:08,221 --> 00:26:12,388
a little bit there, and it
might be worth trying that

433
00:26:14,288 --> 00:26:16,038
getSimpleName method,

434
00:26:19,010 --> 00:26:21,123
which just outputs the class name,

435
00:26:21,123 --> 00:26:25,454
rather than the full
package and class name.

436
00:26:25,454 --> 00:26:29,564
Well my intention when I set
the practical was for you

437
00:26:29,564 --> 00:26:33,647
to try the "and" and "or"
syntax in the pointcut,

438
00:26:35,322 --> 00:26:36,913
then I realized with these packages

439
00:26:36,913 --> 00:26:38,794
you don't necessarily need it.

440
00:26:38,794 --> 00:26:43,094
But let's imagine that
may be this pointcut

441
00:26:43,094 --> 00:26:47,261
expression is too wide, it's
hitting too many packages.

442
00:26:49,537 --> 00:26:53,113
We really do just want to
go down to just the service

443
00:26:53,113 --> 00:26:56,280
packages, and the data access package.

444
00:26:57,133 --> 00:26:58,221
Then the syntax we're looking for

445
00:26:58,221 --> 00:26:59,988
would be something like this.

446
00:26:59,988 --> 00:27:02,473
So we'll start with, first
of all we'll drill down

447
00:27:02,473 --> 00:27:06,223
to our services package,
and any subpackages.

448
00:27:08,475 --> 00:27:13,235
So I've effectively just
reverted that back to how it was.

449
00:27:13,235 --> 00:27:17,542
And I'm going to check that
works before I go any further.

450
00:27:17,542 --> 00:27:20,445
That's good, so I've got
it back as it was now

451
00:27:20,445 --> 00:27:24,241
with just advising the
service class methods.

452
00:27:24,241 --> 00:27:28,433
So now I can extend the pointcut
to add in the "all" clause.

453
00:27:28,433 --> 00:27:31,765
As I showed you on the
caption a short while ago,

454
00:27:31,765 --> 00:27:34,348
we just need to add in an "or",

455
00:27:37,198 --> 00:27:40,547
and this is going to be
a little bit tedious,

456
00:27:40,547 --> 00:27:43,194
it's going to be just the other package,

457
00:27:43,194 --> 00:27:46,277
this is the data access package, and,

458
00:27:47,710 --> 00:27:50,229
to be safe, we'll use dot dot again,

459
00:27:50,229 --> 00:27:52,273
I can't remember if
there are any subpackages

460
00:27:52,273 --> 00:27:56,023
in there, but it won't
hurt, and we'll do *.*

461
00:27:58,310 --> 00:28:02,339
and again we don't care what
the input parameters are.

462
00:28:02,339 --> 00:28:06,506
So we have two separate
pointcuts combined with an "or".

463
00:28:09,038 --> 00:28:11,116
And that looks like it's working, it was

464
00:28:11,116 --> 00:28:13,798
quite a slow one that one, but we can see

465
00:28:13,798 --> 00:28:16,688
that the create method from the dao was

466
00:28:16,688 --> 00:28:19,904
advised new customer,
from customer management

467
00:28:19,904 --> 00:28:21,936
service was advised, and also

468
00:28:21,936 --> 00:28:24,862
the methods on the diary service.

469
00:28:24,862 --> 00:28:28,600
And the diary dao in
fact also being advised.

470
00:28:28,600 --> 00:28:31,456
So I hope that's given
you a chance to practice

471
00:28:31,456 --> 00:28:34,103
configuring AOP from scratch, and also

472
00:28:34,103 --> 00:28:36,878
given you a chance to push the pointcut

473
00:28:36,878 --> 00:28:39,932
expressions a little bit harder.

474
00:28:39,932 --> 00:28:41,847
As I've mentioned several times, you can

475
00:28:41,847 --> 00:28:44,053
always check the Spring reference manual

476
00:28:44,053 --> 00:28:46,735
if you want more information
on what you can do

477
00:28:46,735 --> 00:28:50,021
inside these pointcut expressions.

478
00:28:50,021 --> 00:28:51,565
So I hope you managed to get through

479
00:28:51,565 --> 00:28:53,736
that without too many problems.

480
00:28:53,736 --> 00:28:56,046
As always you can always
pop in a support call

481
00:28:56,046 --> 00:28:58,728
if you've hit something
that, if you've hit

482
00:28:58,728 --> 00:29:00,609
some kind of problem that we haven't

483
00:29:00,609 --> 00:29:03,337
handled in this walkthrough.

484
00:29:03,337 --> 00:29:05,207
Well the next chapters
are going to be covering

485
00:29:05,207 --> 00:29:08,666
a really important topic
in enterprise systems

486
00:29:08,666 --> 00:29:12,289
and that's transaction management.

487
00:29:12,289 --> 00:29:15,946
And you're going to see that
AOP is really the engine

488
00:29:15,946 --> 00:29:18,198
behind transaction management.

489
00:29:18,198 --> 00:29:19,824
And so, have a good break, and I'll

490
00:29:19,824 --> 00:29:22,324
see you for some transactions!

1
00:00:00,084 --> 00:00:01,102
(funky music)

2
00:00:10,053 --> 00:00:11,357
- [Voiceover] Welcome back.

3
00:00:11,357 --> 00:00:13,549
A major topic coming up now.

4
00:00:13,549 --> 00:00:17,194
This is Application Transactions.

5
00:00:17,194 --> 00:00:19,904
To begin I'll review the basic concepts

6
00:00:19,904 --> 00:00:22,332
of Database Transactions.

7
00:00:22,332 --> 00:00:25,529
In other words begins and commits.

8
00:00:25,529 --> 00:00:28,554
If you already know about
this you can miss about

9
00:00:28,554 --> 00:00:31,641
the first eight minutes of the chapter,

10
00:00:31,641 --> 00:00:34,261
but then we'll see that
so far on the course,

11
00:00:34,261 --> 00:00:39,261
we've been sort of
accidentally using Autocommit.

12
00:00:40,075 --> 00:00:44,986
This is really bad and we
need to do something about.

13
00:00:44,986 --> 00:00:49,475
We'll then talk about what
Application Transactions are,

14
00:00:49,475 --> 00:00:52,504
closely related to Database Transactions,

15
00:00:52,504 --> 00:00:55,232
but this is how you handle Transactions

16
00:00:55,232 --> 00:00:59,735
when you have multiple tiers as we do.

17
00:00:59,735 --> 00:01:01,642
We're going to see that Transactions

18
00:01:01,642 --> 00:01:05,299
are best handled using advice.

19
00:01:05,299 --> 00:01:07,225
We'll see how to apply the advice

20
00:01:07,225 --> 00:01:08,555
and you have a choice,

21
00:01:08,555 --> 00:01:12,057
either annotations or XML.

22
00:01:14,012 --> 00:01:16,022
At the most simple level,

23
00:01:16,022 --> 00:01:18,440
a Transaction is a group of operations

24
00:01:18,440 --> 00:01:23,440
that we want to run as
a single unit of work

25
00:01:23,568 --> 00:01:26,297
and we would never want the situation

26
00:01:26,297 --> 00:01:29,476
where only some of the
operations are applied.

27
00:01:30,436 --> 00:01:35,436
Here, I'm showing you a console
from something like MySQL

28
00:01:36,052 --> 00:01:41,052
and what I'm doing here
is a two step process.

29
00:01:41,085 --> 00:01:44,342
I want in this process to first of all

30
00:01:44,342 --> 00:01:48,401
delete from a table called Book,

31
00:01:48,401 --> 00:01:52,313
and then secondly I want
to insert into a table

32
00:01:52,313 --> 00:01:54,689
called Invoices.

33
00:01:54,689 --> 00:01:57,407
And the way that I would
do that in a database

34
00:01:57,407 --> 00:02:01,310
is I would begin a Transaction.

35
00:02:01,310 --> 00:02:03,550
And notice as the caption says

36
00:02:03,550 --> 00:02:07,119
that the syntax for
beginning a Transaction

37
00:02:07,119 --> 00:02:10,259
does vary for different databases.

38
00:02:10,259 --> 00:02:13,209
And in fact many database consoles

39
00:02:13,209 --> 00:02:16,709
such as the MySQL console
will do this automatically

40
00:02:18,340 --> 00:02:21,483
if there's no transaction currently open.

41
00:02:21,483 --> 00:02:25,142
Here's the SQL that I want to execute

42
00:02:25,142 --> 00:02:30,142
but only at the point where
I type the command commit

43
00:02:31,020 --> 00:02:36,020
will the operations actually
be applied to the database.

44
00:02:36,566 --> 00:02:39,710
Until then the changes
would not be visible

45
00:02:39,710 --> 00:02:43,247
by any of the process or transaction

46
00:02:43,247 --> 00:02:45,538
running on the same database

47
00:02:46,387 --> 00:02:49,352
so if some kind of disaster happened

48
00:02:49,352 --> 00:02:52,049
after I'd issued the delete

49
00:02:52,049 --> 00:02:56,525
but before I'd completed the insert,

50
00:02:56,525 --> 00:02:58,998
let's say the database
crashes or the network

51
00:02:58,998 --> 00:03:01,238
goes down or something,

52
00:03:01,238 --> 00:03:04,986
the delete command would not be applied.

53
00:03:05,824 --> 00:03:10,578
Effectively the whole
transaction would be discarded.

54
00:03:10,578 --> 00:03:15,578
Also, I could have issued
the delete and the inserts,

55
00:03:15,987 --> 00:03:19,403
but then decide to change my mind,

56
00:03:19,403 --> 00:03:23,517
and as long as I do that
before issuing the commits,

57
00:03:23,517 --> 00:03:28,436
I could issue the alternative
command of rollback.

58
00:03:29,381 --> 00:03:33,829
And that tells the database
to ignore all the changes

59
00:03:33,829 --> 00:03:35,385
in this transaction,

60
00:03:35,385 --> 00:03:40,385
effectively the whole work in
the transaction is discarded.

61
00:03:40,723 --> 00:03:42,907
And just to see this in live action,

62
00:03:42,907 --> 00:03:47,418
I thought I'd illustrate this
by firing up a real database

63
00:03:47,418 --> 00:03:50,738
and showing you some
transactions in action.

64
00:03:50,738 --> 00:03:55,475
This is the MySQL query browser,
a slightly old tool now,

65
00:03:55,475 --> 00:03:58,103
I don't think it's available
any more from MySQL,

66
00:03:58,103 --> 00:04:01,495
they've replaced it with a work bench,

67
00:04:01,495 --> 00:04:03,955
but I like to use this
because it's quite simple

68
00:04:03,955 --> 00:04:08,276
and will enable me to
illustrate the concepts.

69
00:04:08,276 --> 00:04:11,507
If I go to my Book table in this tool

70
00:04:11,507 --> 00:04:15,805
if you click three times
on the table name then,

71
00:04:15,805 --> 00:04:20,805
it does a select all
columns from that table

72
00:04:21,326 --> 00:04:24,660
so you can see that I've got
four rows in the database.

73
00:04:25,551 --> 00:04:30,551
In the Invoices table I
currently have no rows.

74
00:04:30,626 --> 00:04:33,869
Back to the book table
I'm going to issue now

75
00:04:33,869 --> 00:04:37,963
roughly the SQL that I showed you before.

76
00:04:37,963 --> 00:04:41,291
There is a slight problem
in the default behavior

77
00:04:41,291 --> 00:04:45,244
of the query browser is
to automatically commit

78
00:04:45,244 --> 00:04:48,679
every time you issue a statement.

79
00:04:48,679 --> 00:04:51,570
That's kind of a little bit like

80
00:04:51,570 --> 00:04:54,203
not using transactions properly,

81
00:04:54,203 --> 00:04:59,012
but as long as you click the
Start transactions button here,

82
00:04:59,012 --> 00:05:01,102
then things are different.

83
00:05:01,102 --> 00:05:03,468
We then get a proper transaction

84
00:05:03,468 --> 00:05:06,506
over which we have full control.

85
00:05:06,506 --> 00:05:09,981
I'll click that, and then
once we're in a transaction

86
00:05:09,981 --> 00:05:13,288
we can either commit the
transaction with this button,

87
00:05:13,288 --> 00:05:17,458
or run back the transaction
with this button.

88
00:05:17,458 --> 00:05:21,254
So let's have a go at doing
what I suggested on the caption

89
00:05:21,254 --> 00:05:23,995
and that's to delete a particular book

90
00:05:23,995 --> 00:05:28,731
so I'm going to delete from the Book table

91
00:05:28,731 --> 00:05:33,041
where the I equals let's say four.

92
00:05:33,041 --> 00:05:37,529
We're going to delete this
book called Thetan Clouds

93
00:05:37,529 --> 00:05:41,267
and then I'll click on
the Execute button here.

94
00:05:42,711 --> 00:05:46,068
One row was affected so that looks good

95
00:05:46,068 --> 00:05:49,365
and crucially, and this
is really interesting,

96
00:05:49,365 --> 00:05:54,196
if I do that Select
again on the Book table,

97
00:05:54,196 --> 00:05:58,279
I can now only see three rows

98
00:05:58,279 --> 00:06:03,279
so it appears as though that
change has been made effective.

99
00:06:04,004 --> 00:06:06,274
However what I'm going to do is switch

100
00:06:06,274 --> 00:06:11,274
to another MySQL Query browser
which I've opened up here

101
00:06:12,023 --> 00:06:14,242
and the bottom of the screen.

102
00:06:14,242 --> 00:06:16,598
And what I'm doing here is I'm simulating

103
00:06:16,598 --> 00:06:19,606
another transaction in the system,

104
00:06:19,606 --> 00:06:23,095
another process running
in the same database.

105
00:06:24,040 --> 00:06:28,426
Now remember the previous transaction here

106
00:06:28,426 --> 00:06:32,474
still has not been
committed, it's still open.

107
00:06:32,474 --> 00:06:36,183
If I do the Select here
on the Over transaction,

108
00:06:37,932 --> 00:06:42,865
that's really important that
we can still see the book

109
00:06:42,865 --> 00:06:45,297
of ID4.

110
00:06:45,297 --> 00:06:48,978
And that's because my
transaction here at the top

111
00:06:48,978 --> 00:06:51,601
has not yet been committed

112
00:06:51,601 --> 00:06:53,883
so my change, the deleting of the book,

113
00:06:53,883 --> 00:06:56,575
has not yet been replied.

114
00:06:56,575 --> 00:06:59,802
But my view of the database
in which transaction

115
00:06:59,802 --> 00:07:03,528
is that the book is going to be deleted.

116
00:07:03,528 --> 00:07:06,854
It's going to be the same
form with the Invoice.

117
00:07:06,854 --> 00:07:11,664
Step two of the process
is to insert a new invoice

118
00:07:11,664 --> 00:07:13,860
into this table.

119
00:07:13,860 --> 00:07:18,860
So I do an Insert into Invoices

120
00:07:20,916 --> 00:07:25,321
and the two columns I'm filling
in are the ID and the Detail

121
00:07:25,321 --> 00:07:28,082
and for the Values we'll
just have the ID of one

122
00:07:28,082 --> 00:07:31,509
and the Detail of Item put new sale.

123
00:07:31,509 --> 00:07:33,784
That really doesn't matter

124
00:07:33,784 --> 00:07:36,489
so I'll execute that statement

125
00:07:37,661 --> 00:07:41,156
and do a Select on the table and yes,

126
00:07:41,156 --> 00:07:43,935
the data's gone into the table

127
00:07:43,935 --> 00:07:48,756
but again if I go across
to my other query browser

128
00:07:48,756 --> 00:07:51,817
remember this is a completely
separate transaction,

129
00:07:51,817 --> 00:07:54,622
if I do a Select on the Invoices table

130
00:07:54,622 --> 00:07:57,652
there's complete nothing there.

131
00:07:57,652 --> 00:08:01,938
It's only at the point where
I commit this transaction

132
00:08:01,938 --> 00:08:05,817
and I'm going to do that by
pressing this button here

133
00:08:05,817 --> 00:08:08,047
that the changes will be applied

134
00:08:08,047 --> 00:08:11,885
so that means the delete and the insert.

135
00:08:11,885 --> 00:08:16,885
I'll do a commit and switch
across to my other transactions

136
00:08:18,730 --> 00:08:22,302
and now if I query the Book table

137
00:08:22,302 --> 00:08:25,246
yes the change is now being effective

138
00:08:25,246 --> 00:08:30,246
and in the Invoices table
yes the new data is live.

139
00:08:30,619 --> 00:08:33,851
So that's a basic overview of Transactions

140
00:08:33,851 --> 00:08:36,047
but you might think you need this point,

141
00:08:36,047 --> 00:08:40,388
well, why do we even
care about Transactions?

142
00:08:40,388 --> 00:08:43,143
Because our fur on the course

143
00:08:43,143 --> 00:08:46,375
our code has been running just fine

144
00:08:46,375 --> 00:08:50,772
and we've never even
mentioned Transactions.

145
00:08:50,772 --> 00:08:52,734
Here I am back in the Bookstore,

146
00:08:52,734 --> 00:08:55,134
I've just reopened that project

147
00:08:55,134 --> 00:08:57,204
and you remember from previous videos

148
00:08:57,204 --> 00:09:00,876
that when I run this application

149
00:09:00,876 --> 00:09:03,089
or every time I run this program

150
00:09:03,089 --> 00:09:05,542
I'm inserting a new book into the system

151
00:09:05,542 --> 00:09:08,414
called Warren P Spy Leo Toaster

152
00:09:08,414 --> 00:09:12,339
which is why this list
is getting really long.

153
00:09:12,339 --> 00:09:15,355
And remember that if
we refresh the project

154
00:09:16,670 --> 00:09:20,991
you can look in the script
file for the database,

155
00:09:20,991 --> 00:09:23,071
and it's popping up here in Notepad

156
00:09:23,071 --> 00:09:27,540
and the important thing is
that we can see the data

157
00:09:27,540 --> 00:09:30,783
is being inserted into the database.

158
00:09:30,783 --> 00:09:35,043
We have never done a commit
so far on the course.

159
00:09:35,043 --> 00:09:37,575
The problem is, and let me be clear,

160
00:09:37,575 --> 00:09:40,325
this is a big problem.

161
00:09:40,325 --> 00:09:44,613
At the moment we're running in JDBC's

162
00:09:44,613 --> 00:09:49,613
default mode which is Autocommit.

163
00:09:50,389 --> 00:09:55,389
Autocommit will issue a
commit for you automatically

164
00:09:56,252 --> 00:09:59,841
on every single operation.

165
00:10:01,137 --> 00:10:06,137
That's why everything has
been working fine so far.

166
00:10:06,908 --> 00:10:10,382
Every time for example we call the method

167
00:10:10,382 --> 00:10:13,159
that creates a broken out system

168
00:10:13,159 --> 00:10:17,993
we've been getting an Autocommit for free.

169
00:10:17,993 --> 00:10:22,342
You might think that's great but it isn't,

170
00:10:22,342 --> 00:10:25,510
it's absolutely awful!

171
00:10:25,510 --> 00:10:29,507
For any non trivial system
you almost certainly

172
00:10:29,507 --> 00:10:33,794
do not want Autocommiting.

173
00:10:33,794 --> 00:10:36,862
With Autocommiting you're
essentially getting

174
00:10:36,862 --> 00:10:41,862
an implicit transaction
for every single operation.

175
00:10:42,248 --> 00:10:45,009
Every insert will get a commit,

176
00:10:45,009 --> 00:10:49,212
every delete will get a commit and so on.

177
00:10:49,212 --> 00:10:50,095
So why is it bad?

178
00:10:50,095 --> 00:10:55,095
Well, at least two good
reasons for this being bad.

179
00:10:55,649 --> 00:10:59,968
Number one is that this is going
to have some kind of impact

180
00:10:59,968 --> 00:11:02,593
on the performance of your code,

181
00:11:02,593 --> 00:11:05,224
and that's because every
time a commit happens

182
00:11:05,224 --> 00:11:08,808
the database has to do some hard work

183
00:11:08,808 --> 00:11:11,377
to physically commit your data

184
00:11:11,377 --> 00:11:14,897
to something like a hard disk.

185
00:11:14,897 --> 00:11:18,812
With autocommitting you're
going to get far more commits

186
00:11:18,812 --> 00:11:23,256
than you ordinarily would and
that could slow things down.

187
00:11:23,256 --> 00:11:26,312
It's a bit like having buffering off

188
00:11:26,312 --> 00:11:29,146
when you're writing to files,

189
00:11:29,146 --> 00:11:31,608
but that's not the important reason.

190
00:11:31,608 --> 00:11:33,857
The main reason autocommit is bad

191
00:11:33,857 --> 00:11:38,774
is that we lose the ability
to rollback transactions,

192
00:11:38,774 --> 00:11:41,398
our example from before is a good one.

193
00:11:41,398 --> 00:11:44,033
If we had autocommit on

194
00:11:44,033 --> 00:11:48,156
then as soon as the book
is deleted it's gone.

195
00:11:48,156 --> 00:11:53,156
If something goes wrong before
we issue the second statement

196
00:11:53,903 --> 00:11:58,903
the insert, the process is
terminated before the insert

197
00:11:59,536 --> 00:12:01,890
and the book has been deleted

198
00:12:01,890 --> 00:12:05,635
without an invoice being recorded,

199
00:12:05,635 --> 00:12:10,635
so with autocommit on changes
are happening to soon.

200
00:12:12,200 --> 00:12:15,483
In this chapter we've got to make sure

201
00:12:15,483 --> 00:12:18,737
that autocommut is off,

202
00:12:18,737 --> 00:12:21,953
and we're going to have
to begin and commit

203
00:12:21,953 --> 00:12:24,812
our transactions properly.

204
00:12:24,812 --> 00:12:28,396
I'm assuming then that you're
at least slightly familiar

205
00:12:28,396 --> 00:12:31,242
with the concept of a transaction.

206
00:12:31,242 --> 00:12:34,464
The thing is transactions are easy enough

207
00:12:34,464 --> 00:12:39,309
when you're working directly
at the database level.

208
00:12:39,309 --> 00:12:44,275
If our system was coded as
a series of database scripts

209
00:12:44,275 --> 00:12:48,732
perhaps if you're using
a language such as PLSQL

210
00:12:48,732 --> 00:12:52,794
then basically you would
code something like this.

211
00:12:52,794 --> 00:12:55,758
You would have a begin
or a start transaction

212
00:12:55,758 --> 00:12:57,544
at the top of the script

213
00:12:57,544 --> 00:13:00,648
and a commit at the bottom,

214
00:13:00,648 --> 00:13:03,154
but we're not building
our system like this.

215
00:13:03,154 --> 00:13:08,154
We're using object orientation
and we have multiple layers

216
00:13:08,593 --> 00:13:11,665
so what we need to look at is how is this

217
00:13:11,665 --> 00:13:14,067
beginning a committing affected

218
00:13:14,067 --> 00:13:17,908
when we're working on a
system with multiple teirs

219
00:13:17,908 --> 00:13:22,717
of services, data access object and so on.

220
00:13:22,717 --> 00:13:25,300
It's simply a bit more complicated.

221
00:13:26,375 --> 00:13:29,007
Let me take you through an example.

222
00:13:29,007 --> 00:13:31,098
Recall that throughout this course

223
00:13:31,098 --> 00:13:36,098
we've been working with a
service class called BookService.

224
00:13:36,156 --> 00:13:38,923
By the way for this
picture I'm going to remove

225
00:13:38,923 --> 00:13:42,316
the interfaces and the implementation.

226
00:13:42,316 --> 00:13:45,714
I assume you've got the
idea of that by now.

227
00:13:46,587 --> 00:13:49,389
We have here our BookService,

228
00:13:49,389 --> 00:13:53,054
and you also know that
the BookService delegates

229
00:13:53,054 --> 00:13:54,985
to a Dao.

230
00:13:54,985 --> 00:13:59,886
A data access object, and
it's in here that we apply

231
00:13:59,886 --> 00:14:02,640
our database operations.

232
00:14:02,640 --> 00:14:04,548
We have five or six different methods

233
00:14:04,548 --> 00:14:06,947
on the BookService class so far

234
00:14:06,947 --> 00:14:11,794
but I'm just focusing
here on one of the methods

235
00:14:11,794 --> 00:14:14,533
that I'm going to need for this session

236
00:14:14,533 --> 00:14:16,396
and I've decided to call that method

237
00:14:16,396 --> 00:14:19,270
deleteBookFromStock.

238
00:14:20,215 --> 00:14:24,661
Much earlier in the course we
created a second service class

239
00:14:24,661 --> 00:14:28,498
and that one was called Accounts Service.

240
00:14:28,498 --> 00:14:31,215
We haven't really needed it much until now

241
00:14:31,215 --> 00:14:34,194
but we will need it for this chapter.

242
00:14:34,194 --> 00:14:37,562
We have methods in there
that relate to the accounts

243
00:14:37,562 --> 00:14:41,472
on our system and by that I
mean the financial accounts,

244
00:14:41,472 --> 00:14:43,936
so we can do things in there such as

245
00:14:43,936 --> 00:14:47,263
raising invoices for customers,

246
00:14:47,263 --> 00:14:51,111
and in turn that will
probably have it's own

247
00:14:51,111 --> 00:14:54,454
data access object as well so I have here

248
00:14:54,454 --> 00:14:58,369
a Dao called Account Dao.

249
00:14:58,369 --> 00:15:01,418
What I want to look at
through this chapter

250
00:15:01,418 --> 00:15:06,218
is the use case that I'm
going to call Buy Book.

251
00:15:06,218 --> 00:15:09,575
The steps involved in
Buy Book are step one,

252
00:15:10,635 --> 00:15:13,285
we need to delete the book from stock,

253
00:15:13,285 --> 00:15:15,801
so I want to buy a particular book,

254
00:15:15,801 --> 00:15:18,617
I've typed in the ISPL on the webpage,

255
00:15:18,617 --> 00:15:20,076
and what the system will do

256
00:15:20,076 --> 00:15:23,108
is it will remove that book from stock,

257
00:15:23,957 --> 00:15:28,831
and then in step two an
invoice will be raise for me

258
00:15:28,831 --> 00:15:32,823
so that I can pay for
the books that I wanted

259
00:15:32,823 --> 00:15:36,263
and well it's a fairly
simple two step process.

260
00:15:37,890 --> 00:15:39,858
How do we implement this process,

261
00:15:39,858 --> 00:15:44,858
where is this use case
called Buy Book going to be?

262
00:15:45,245 --> 00:15:49,500
We could write a client
application or a webpage

263
00:15:49,500 --> 00:15:54,054
or whatever that makes
this two separate calls

264
00:15:54,054 --> 00:15:57,221
to the two separate services,

265
00:15:57,221 --> 00:15:59,671
but I think from the object
oriented point of view

266
00:15:59,671 --> 00:16:03,754
that that would be quite
clunky and unpleasant

267
00:16:03,754 --> 00:16:07,754
because I would have to
remember to do both steps

268
00:16:07,754 --> 00:16:11,594
every time I wanted to invoke this process

269
00:16:11,594 --> 00:16:13,385
and in general that would make

270
00:16:13,385 --> 00:16:16,285
the client code less cohesive.

271
00:16:16,285 --> 00:16:18,553
We'd be doing two lines
of code where really,

272
00:16:18,553 --> 00:16:23,553
we just want a single call
to a method called Buy Book

273
00:16:24,367 --> 00:16:28,078
so I think a better solution
would be to introduce

274
00:16:28,078 --> 00:16:31,059
a third service class.

275
00:16:31,059 --> 00:16:34,972
This one is called the Purchasing Service

276
00:16:34,972 --> 00:16:37,753
and the beauty of this is that
I can have a single method

277
00:16:37,753 --> 00:16:40,633
in there called Buy Book,

278
00:16:40,633 --> 00:16:43,766
and that means that the
client is going to be calling

279
00:16:43,766 --> 00:16:47,094
a very clean and simple interface,

280
00:16:47,094 --> 00:16:48,423
they want to buy a book,

281
00:16:48,423 --> 00:16:51,387
so they call a method called Buy Book.

282
00:16:51,387 --> 00:16:54,436
Oh and by the way there's still
nothing to stop the client

283
00:16:54,436 --> 00:16:59,245
calling the Book Service and
Accounts Service directly

284
00:16:59,245 --> 00:17:02,100
if we have the requirement
where the client

285
00:17:02,100 --> 00:17:05,895
needs to raise an invoice and
to just raise an invoice then

286
00:17:05,895 --> 00:17:08,305
it will be fine for the client to continue

287
00:17:08,305 --> 00:17:10,423
calling the Accounts service.

288
00:17:11,539 --> 00:17:14,886
Another thing, I've not
created this Purchasing service

289
00:17:14,886 --> 00:17:17,830
just to hold one method.

290
00:17:17,830 --> 00:17:20,433
In general we don't have a new service

291
00:17:20,433 --> 00:17:22,363
for every method of course,

292
00:17:22,363 --> 00:17:26,159
but thinking ahead I can imaging
that the purchasing service

293
00:17:26,159 --> 00:17:29,252
is going to be a good home for really,

294
00:17:29,252 --> 00:17:32,631
any methods dealing with
the purchasing process,

295
00:17:32,631 --> 00:17:36,919
so I don't know, maybe monitors
the process of the sale

296
00:17:36,919 --> 00:17:39,231
and as we go forward there'll probably be

297
00:17:39,231 --> 00:17:41,986
quite a few methods in
the Purchasing service.

298
00:17:43,016 --> 00:17:45,768
We need to think about
where are we going to put

299
00:17:45,768 --> 00:17:48,732
our database trasactions.

300
00:17:48,732 --> 00:17:52,101
In other words where are
we going to see a begin

301
00:17:52,101 --> 00:17:55,117
and where are we going to see a commit.

302
00:17:56,061 --> 00:17:58,056
Many people's first thought is that well,

303
00:17:58,056 --> 00:18:02,000
because begin and commit
are database operations

304
00:18:02,000 --> 00:18:06,753
then clearly they're
going to live in the Daos,

305
00:18:06,753 --> 00:18:08,668
but that's a mistake.

306
00:18:09,644 --> 00:18:13,602
Putting begin and commit
into the Dao layer

307
00:18:13,602 --> 00:18:18,602
is going to make the
commit happen top early.

308
00:18:18,888 --> 00:18:23,476
let's say for example in
the delete method down here,

309
00:18:23,476 --> 00:18:27,819
if we put a commit at the
end of the delete method,

310
00:18:27,819 --> 00:18:30,525
that means when this
delete method is called

311
00:18:30,525 --> 00:18:34,342
as part of the pier level
process of Buy Book,

312
00:18:34,342 --> 00:18:37,274
we're only halfway through buying a book,

313
00:18:37,274 --> 00:18:41,782
but already the deletion of
the book has been committed.

314
00:18:41,782 --> 00:18:46,124
That would be terrible because
we've executed step one

315
00:18:46,124 --> 00:18:48,932
but then if for some
reason something crashes

316
00:18:48,932 --> 00:18:52,753
or whatever and step two never happens,

317
00:18:52,753 --> 00:18:56,432
then we will have lost
stock for the system

318
00:18:56,432 --> 00:18:59,221
and the customer will never be billed,

319
00:18:59,221 --> 00:19:01,599
so the point I'm trying to make is that

320
00:19:01,599 --> 00:19:06,599
when building an object oriented
system with multiple teirs

321
00:19:06,698 --> 00:19:11,698
transactions are at a very
different level to the database.

322
00:19:12,119 --> 00:19:14,196
You can think of the database operations

323
00:19:14,196 --> 00:19:16,468
as being very low level,

324
00:19:16,468 --> 00:19:21,468
but the transactions
really need to live up here

325
00:19:21,483 --> 00:19:24,310
at the service layer,

326
00:19:24,310 --> 00:19:27,613
so really we need to
think about transactions

327
00:19:27,613 --> 00:19:30,197
as not being database operations

328
00:19:30,197 --> 00:19:33,322
but a higher level of operation

329
00:19:33,322 --> 00:19:37,222
when we're working on
this kind of architecture.

330
00:19:37,222 --> 00:19:39,599
This is the kind of
code that you might see

331
00:19:39,599 --> 00:19:43,813
in that Buy Book method
up in the service class,

332
00:19:43,813 --> 00:19:45,999
and I'm wondering if there's some way

333
00:19:45,999 --> 00:19:50,999
of making this whole method
become a transaction.

334
00:19:51,471 --> 00:19:53,807
I can tell you that our Java API

335
00:19:53,807 --> 00:19:57,676
is that we could use
in this service class,

336
00:19:57,676 --> 00:20:02,676
the main API available
for us is one called JTA,

337
00:20:03,105 --> 00:20:06,495
or the Java Transaction API.

338
00:20:06,495 --> 00:20:09,407
That API does indeed allow us to do

339
00:20:09,407 --> 00:20:14,047
a begin transaction and
a commit transaction

340
00:20:14,047 --> 00:20:18,199
so we could add those lines
of code to this method.

341
00:20:19,035 --> 00:20:22,321
However I think that
would be quite intrusive.

342
00:20:22,321 --> 00:20:27,321
It would mean that our service
class would be less cohesive,

343
00:20:27,389 --> 00:20:29,107
it would mean that we would see

344
00:20:29,107 --> 00:20:32,179
a lot of transaction management code

345
00:20:32,179 --> 00:20:34,621
here in our service class,

346
00:20:34,621 --> 00:20:38,854
and we'd lose sight of the
business process that's going on.

347
00:20:38,854 --> 00:20:40,653
What I'd really like is to keep

348
00:20:40,653 --> 00:20:43,149
this method implementation clean,

349
00:20:43,149 --> 00:20:48,149
and somehow to switch a
transaction on for this method.

350
00:20:49,372 --> 00:20:52,205
To this end one of Spring's key features

351
00:20:52,205 --> 00:20:56,472
is that we can program
transactions declaratively

352
00:20:56,472 --> 00:20:59,117
which means we can
declare the transactions

353
00:20:59,117 --> 00:21:01,301
outside of the code,

354
00:21:01,301 --> 00:21:05,815
and the way that Spring
does this is via AOP,

355
00:21:05,815 --> 00:21:08,626
and that's why we waited
until this part of the course

356
00:21:08,626 --> 00:21:10,395
to add in Transactions.

357
00:21:10,395 --> 00:21:13,381
You need to know a little bit of AOP

358
00:21:13,381 --> 00:21:15,792
to work with Transactions,

359
00:21:15,792 --> 00:21:17,964
so I assume that by now you've studied

360
00:21:17,964 --> 00:21:20,299
the previous AOP chapters.

361
00:21:20,299 --> 00:21:24,404
If you haven't I recommend
you go back and review them.

362
00:21:24,404 --> 00:21:27,837
You don't need to know AOP in great detail

363
00:21:27,837 --> 00:21:30,920
because a lot of it will be handled for as

364
00:21:30,920 --> 00:21:35,788
the AOP in transaction kid
of happens under the hood

365
00:21:35,788 --> 00:21:40,788
but I'll be assuming that
you know general idea of AOP

366
00:21:41,778 --> 00:21:44,827
recall then the purpose of AOP

367
00:21:44,827 --> 00:21:49,827
is to allow you to define
cross cutting concerns

368
00:21:49,926 --> 00:21:53,178
in this case the concern of the aspects

369
00:21:53,178 --> 00:21:58,052
that we're interested in
is transaction managements

370
00:21:58,052 --> 00:22:00,840
now it's definitely cross cutting

371
00:22:00,840 --> 00:22:04,141
because we want to apply
transaction management to

372
00:22:04,141 --> 00:22:07,084
not just the survice class

373
00:22:07,084 --> 00:22:11,831
but probably all of our classes service

374
00:22:11,831 --> 00:22:15,485
if my client calls a method
directly on a book service

375
00:22:15,485 --> 00:22:19,142
I would want the transaction
to be rapped around that method

376
00:22:20,000 --> 00:22:22,637
if the clients call by book

377
00:22:22,637 --> 00:22:24,231
in the purchasing service

378
00:22:24,231 --> 00:22:26,278
I would want a transaction to be rapped

379
00:22:26,278 --> 00:22:29,097
around that method as well

380
00:22:30,830 --> 00:22:32,575
So using AOP

381
00:22:32,575 --> 00:22:35,946
we're going to get the
transactions applied

382
00:22:35,946 --> 00:22:38,706
as a piece of advice.

383
00:22:38,706 --> 00:22:43,108
The advice that Spring
applies service methods

384
00:22:43,108 --> 00:22:45,954
is fairly simple here I'm representing

385
00:22:45,954 --> 00:22:47,765
the Buy Book method

386
00:22:47,765 --> 00:22:49,361
using this block

387
00:22:49,361 --> 00:22:53,223
and the arrow coming in from the left here

388
00:22:53,223 --> 00:22:57,308
is representing the call from the clients.

389
00:22:57,308 --> 00:23:01,982
And what Spring is going
to do with this advice

390
00:23:01,982 --> 00:23:05,337
is it's going rap around
the Buy Book method

391
00:23:05,337 --> 00:23:07,951
at the start of the method

392
00:23:07,951 --> 00:23:11,800
it will begin a new transaction,

393
00:23:11,800 --> 00:23:13,824
and at the end of the method

394
00:23:13,824 --> 00:23:16,288
assuming everything went well

395
00:23:16,288 --> 00:23:20,555
Spring will automatically issue a commit

396
00:23:20,555 --> 00:23:23,499
and as a normal AOP

397
00:23:23,499 --> 00:23:25,952
this begin and commit code

398
00:23:25,952 --> 00:23:28,232
it's going to be in it's own class

399
00:23:28,232 --> 00:23:30,202
an advice class

400
00:23:30,202 --> 00:23:34,615
and it will not affect
our service class at all.

401
00:23:34,615 --> 00:23:36,994
Rather similar to AOP

402
00:23:36,994 --> 00:23:39,358
there are three diffrent ways

403
00:23:39,358 --> 00:23:42,339
of configuring transactions in Spring.

404
00:23:42,339 --> 00:23:47,339
The first is to manually
define proxies in the XML

405
00:23:48,452 --> 00:23:52,111
if you remember back to
our very early AOP work

406
00:23:52,111 --> 00:23:54,244
we did something similar there.

407
00:23:54,244 --> 00:23:56,441
In this approach you would have to take

408
00:23:56,441 --> 00:23:59,395
everyone of your service classes

409
00:23:59,395 --> 00:24:03,948
and define a proxy for that class.

410
00:24:03,948 --> 00:24:06,796
It turns out this is really tedious

411
00:24:06,796 --> 00:24:10,860
and it's an approach that
has by now in the industry

412
00:24:10,860 --> 00:24:13,793
fallen into disuse.

413
00:24:13,793 --> 00:24:16,678
The first edition of this
course covered how to do it

414
00:24:16,678 --> 00:24:18,822
because at the time we recorded it

415
00:24:18,822 --> 00:24:23,822
some projects were still
doing manual proxies.

416
00:24:23,888 --> 00:24:27,888
In my experience these days
defining proxies by hand

417
00:24:27,888 --> 00:24:30,414
is just too tedious to be practical

418
00:24:30,414 --> 00:24:32,910
so for this version of the course,

419
00:24:32,910 --> 00:24:35,364
we won't go into any more detail

420
00:24:35,364 --> 00:24:39,101
on manually defining proxies.

421
00:24:39,101 --> 00:24:41,501
There are two other approaches though

422
00:24:41,501 --> 00:24:44,625
that lead to a lot less configuration.

423
00:24:44,625 --> 00:24:48,624
As a second option we
have something called

424
00:24:48,624 --> 00:24:51,929
the tx: Namepace

425
00:24:51,929 --> 00:24:55,870
and this was introduced
back in Spring Two.

426
00:24:55,870 --> 00:24:59,714
And finally for me the best
of the three approaches

427
00:24:59,714 --> 00:25:03,361
is to use Annotations.

428
00:25:03,361 --> 00:25:05,580
There's one drawback to Annotations

429
00:25:05,580 --> 00:25:10,455
and that is it does rely on
you having at least Java 5

430
00:25:10,455 --> 00:25:13,228
but I don't think this
is a problem any more,

431
00:25:13,228 --> 00:25:16,438
at the time of recording
almost all projects

432
00:25:16,438 --> 00:25:20,658
have migrated to Java 5, 6, 7, 8,

433
00:25:20,658 --> 00:25:25,330
or even higher by the
time you watch this video.

434
00:25:25,330 --> 00:25:27,656
These three different approaches

435
00:25:27,656 --> 00:25:31,077
are really just different syntaxes.

436
00:25:31,077 --> 00:25:32,869
Whichever version you'll use

437
00:25:32,869 --> 00:25:36,198
the end result will be exactly the same.

438
00:25:36,198 --> 00:25:40,144
Spring is going to create a proxy class

439
00:25:40,144 --> 00:25:42,769
just as it does in AOP

440
00:25:42,769 --> 00:25:47,621
so when your client thinks
it's calling the service class,

441
00:25:47,621 --> 00:25:52,561
in fact at runtime the client
is really calling the proxy.

442
00:25:52,561 --> 00:25:56,582
The proxy is going to
issue a begin transaction

443
00:25:57,648 --> 00:26:01,366
then it will call the
target service method,

444
00:26:01,366 --> 00:26:04,558
then when the service method is finished,

445
00:26:04,558 --> 00:26:09,085
we return to the proxy
which will issue a commit,

446
00:26:09,085 --> 00:26:12,999
then Control returns back to the client.

447
00:26:12,999 --> 00:26:15,709
I want to point out that
all three approaches

448
00:26:15,709 --> 00:26:19,602
result in exactly the same mechanism.

449
00:26:19,602 --> 00:26:22,855
In the old and complacent technique

450
00:26:22,855 --> 00:26:24,924
of manually defining proxies,

451
00:26:24,924 --> 00:26:28,465
you basically have to
configure this proxy object

452
00:26:28,465 --> 00:26:30,918
in the Spring container and therefore

453
00:26:30,918 --> 00:26:33,349
in the Spring XML by yourself,

454
00:26:33,349 --> 00:26:36,400
but in the other two systems,

455
00:26:36,400 --> 00:26:39,290
creation of the proxy is much simpler

456
00:26:39,290 --> 00:26:42,682
but the proxy is still there.

457
00:26:42,682 --> 00:26:45,264
Let's get to work regardless

458
00:26:45,264 --> 00:26:48,196
of which of the three
approaches you've used.

459
00:26:48,196 --> 00:26:51,556
The first step in setting
up Transactions in Spring

460
00:26:51,556 --> 00:26:54,200
is to always define a bean called

461
00:26:54,200 --> 00:26:56,898
the Transaction Manager.

462
00:26:56,898 --> 00:27:00,333
You only need one of these
for your entire project

463
00:27:00,333 --> 00:27:02,955
so no matter how big your project is

464
00:27:02,955 --> 00:27:07,073
this is always a one off job.

465
00:27:07,073 --> 00:27:10,817
This is a class provided
by the Spring Framework

466
00:27:10,817 --> 00:27:14,185
that is going to manage
transactions for us.

467
00:27:14,185 --> 00:27:17,278
If you prefer AOP jargon,

468
00:27:17,278 --> 00:27:20,936
what we're looking at here is
that the Transaction Manager

469
00:27:20,936 --> 00:27:24,243
is basically the Advice.

470
00:27:24,243 --> 00:27:27,763
This class contains the begin and commit,

471
00:27:27,763 --> 00:27:29,937
and by the way very importantly

472
00:27:29,937 --> 00:27:33,512
this advice class will also make sure

473
00:27:33,512 --> 00:27:37,296
that Autocommit is off,

474
00:27:37,296 --> 00:27:40,688
and that's a big relief.

475
00:27:40,688 --> 00:27:42,990
As you can see here I'm creating a bean

476
00:27:42,990 --> 00:27:46,802
with an ID of Transaction Manager.

477
00:27:46,802 --> 00:27:50,557
Theoretically you can call
this bean anything you like

478
00:27:50,557 --> 00:27:55,367
but I recommend you call it
Transaction Manager like I have,

479
00:27:55,367 --> 00:27:58,716
because it makes some
configuration a little bit easier

480
00:27:58,716 --> 00:28:00,892
that's coming up soon.

481
00:28:00,892 --> 00:28:03,601
The implementing class
here, I've just copied this

482
00:28:03,601 --> 00:28:05,670
from the Spring Reference Manual

483
00:28:05,670 --> 00:28:07,662
it's a bit of a mouthful.

484
00:28:07,662 --> 00:28:10,831
Org.sprinframework.jdbc

485
00:28:10,831 --> 00:28:15,588
.datasource.datasourceTransactionManager.

486
00:28:15,588 --> 00:28:16,727
You don't need to remember that,

487
00:28:16,727 --> 00:28:20,631
you can always look that up.

488
00:28:20,631 --> 00:28:22,550
This bean takes only one property

489
00:28:22,550 --> 00:28:25,462
and that's the name of the Datasource

490
00:28:25,462 --> 00:28:28,634
that we're using for our
database connections.

491
00:28:29,626 --> 00:28:33,537
The Datasource Transaction
Manager needs this property

492
00:28:33,537 --> 00:28:35,922
so that it can talk to the database

493
00:28:35,922 --> 00:28:39,313
and therefore so it can issue a begin

494
00:28:39,313 --> 00:28:41,361
and a commit.

495
00:28:41,361 --> 00:28:43,473
Later in the course we're
going to be looking at

496
00:28:43,473 --> 00:28:45,707
how to use more sophisticated techniques

497
00:28:45,707 --> 00:28:50,707
for database access such
as JPA or Hibernate.

498
00:28:51,217 --> 00:28:54,577
I must tell you that if
you're using JPA or Hibernate

499
00:28:54,577 --> 00:28:58,628
the you would use a different
Transaction manager here,

500
00:28:58,628 --> 00:29:02,302
but I'll show you how
to change that later.

501
00:29:02,302 --> 00:29:06,282
For now just think of the
Datasource Transaction Mananger

502
00:29:06,282 --> 00:29:08,963
as being the class that you need to use

503
00:29:08,963 --> 00:29:11,744
if you're using JDBC.

504
00:29:11,744 --> 00:29:13,724
This is a very routine job,

505
00:29:13,724 --> 00:29:17,505
let's switch across to
eclipse and get this in

506
00:29:17,505 --> 00:29:18,866
so if you're following along with me

507
00:29:18,866 --> 00:29:21,307
make sure you're back
in the Bookstore project

508
00:29:21,307 --> 00:29:24,928
and that your CRM system is closed.

509
00:29:24,928 --> 00:29:26,727
And this should be a very easy job

510
00:29:26,727 --> 00:29:29,808
where in the application.xml file,

511
00:29:29,808 --> 00:29:31,648
and really the only decision to make

512
00:29:31,648 --> 00:29:36,648
is where are we going to put
this Transaction Manager.

513
00:29:36,739 --> 00:29:39,330
On my projects I tend to
put my Transaction Manager

514
00:29:39,330 --> 00:29:42,551
here at the top because,

515
00:29:42,551 --> 00:29:44,411
well I don't really have a
good reason to be honest,

516
00:29:45,554 --> 00:29:48,394
it's quite closely
aligned to the Datasources

517
00:29:48,394 --> 00:29:50,208
and I have those here,

518
00:29:50,208 --> 00:29:52,706
and down at the bottom
I've got my service classes

519
00:29:52,706 --> 00:29:56,116
and I don't really want
this to get in the way.

520
00:29:57,042 --> 00:29:59,360
I'm going to put mine
here but you can put it

521
00:29:59,360 --> 00:30:00,634
anywhere you like it,

522
00:30:00,634 --> 00:30:04,078
it doesn't matter the
order of these beans.

523
00:30:04,078 --> 00:30:06,319
We'll add a comment in here to say

524
00:30:06,319 --> 00:30:10,219
this is our Transaction
Manager for the project.

525
00:30:10,219 --> 00:30:13,519
I've said this already but
you'd only have one of these

526
00:30:13,519 --> 00:30:16,101
for an entire project,

527
00:30:16,101 --> 00:30:18,671
so the bean is going to have the ID

528
00:30:18,671 --> 00:30:23,415
of Transaction Manager,

529
00:30:23,415 --> 00:30:27,257
that's got a lowercase
t on the first letter,

530
00:30:27,257 --> 00:30:29,097
and I would recommend any project use

531
00:30:29,097 --> 00:30:31,977
transaction manager as the ID.

532
00:30:31,977 --> 00:30:35,937
It makes the work coming
up a little easier.

533
00:30:35,937 --> 00:30:39,276
The difficult bit is the class name

534
00:30:39,276 --> 00:30:41,956
and I think nobody sensible
would try to remember

535
00:30:41,956 --> 00:30:46,256
the full package name of the
Datasource transaction manager

536
00:30:46,256 --> 00:30:51,256
so the way I always work
is I go into the API docs,

537
00:30:51,435 --> 00:30:53,914
the Java docs for Spring,

538
00:30:53,914 --> 00:30:57,213
and then use a Control+F for my browser

539
00:30:57,213 --> 00:31:01,951
and simply search for the phrase

540
00:31:01,951 --> 00:31:06,148
Datasource Transaction Manager
which I can remember that bit

541
00:31:06,148 --> 00:31:08,587
I can never remember the
package name it comes from

542
00:31:08,587 --> 00:31:11,447
so if I follow the link through there,

543
00:31:11,447 --> 00:31:14,187
that will give me right here at the top

544
00:31:14,187 --> 00:31:17,646
the name of the package
that that class comes from.

545
00:31:17,646 --> 00:31:20,964
Back into the XMl, I
can copy that in place

546
00:31:20,964 --> 00:31:25,964
and then Datasource transaction manager.

547
00:31:29,761 --> 00:31:33,587
And there's one property for this class

548
00:31:33,587 --> 00:31:37,755
and the name of it is Datasource.

549
00:31:41,405 --> 00:31:45,905
And this is referring
to whatever we've called

550
00:31:45,905 --> 00:31:47,914
our Datasource.

551
00:31:47,914 --> 00:31:50,950
But you can see it right
here and just coincidentally,

552
00:31:52,113 --> 00:31:55,076
I've called my Datasource
Datasource as well

553
00:31:55,076 --> 00:31:57,778
so as it often happens,

554
00:31:57,778 --> 00:32:02,778
the name of the property is
the same as the reference bean.

555
00:32:04,261 --> 00:32:06,382
So that tells the transaction manager

556
00:32:06,382 --> 00:32:08,383
how to find the database

557
00:32:08,383 --> 00:32:11,768
so it can issue the begins and commits.

558
00:32:12,613 --> 00:32:14,982
We've declared the transaction manager

559
00:32:14,982 --> 00:32:19,982
and you only need to do
that once for a project.

560
00:32:20,014 --> 00:32:22,734
Now we need to see how to tell Spring

561
00:32:22,734 --> 00:32:27,098
which of our classes need a
transaction applying to it.

562
00:32:27,098 --> 00:32:31,578
We've seen that usually in
Spring it's the service classes

563
00:32:31,578 --> 00:32:34,290
that we want to make transactional.

564
00:32:34,290 --> 00:32:36,771
Remember our example from before.

565
00:32:36,771 --> 00:32:39,391
We don't want begins and commits

566
00:32:39,391 --> 00:32:42,138
down in the data access layer.

567
00:32:42,138 --> 00:32:45,058
Usually each of the Dao methods

568
00:32:45,058 --> 00:32:48,264
are single database operations,

569
00:32:48,264 --> 00:32:51,333
but in business processes
we're going to be combining

570
00:32:51,333 --> 00:32:54,469
multiple database operations,

571
00:32:54,469 --> 00:32:59,469
so it's up here where we're
defining the business processes

572
00:32:59,530 --> 00:33:03,369
that we want to define Transactions.

573
00:33:03,369 --> 00:33:06,849
The service layer, one
of it's real purposes,

574
00:33:06,849 --> 00:33:09,667
one of it's benefits is
that it's a good place

575
00:33:09,667 --> 00:33:12,765
to hold our transactions.

576
00:33:12,765 --> 00:33:15,682
There are two popular ways
of configuring transactions

577
00:33:15,682 --> 00:33:17,734
as I've mentioned before.

578
00:33:17,734 --> 00:33:19,392
I'm now going to show you them both

579
00:33:19,392 --> 00:33:23,032
and it's up to you or your project

580
00:33:23,032 --> 00:33:25,431
as to which of them you prefer.

581
00:33:25,431 --> 00:33:28,810
For me by far the best approach of the two

582
00:33:28,810 --> 00:33:30,746
is the Annotations approach,

583
00:33:30,746 --> 00:33:34,246
so I've decided to
start with that approach

584
00:33:34,246 --> 00:33:37,884
and spend as much time as
possible on Annotations

585
00:33:37,884 --> 00:33:40,844
because I think you're far
more likely to use them

586
00:33:40,844 --> 00:33:43,122
in a real project.

587
00:33:43,122 --> 00:33:45,360
What I'll do then at
the end of the chapter,

588
00:33:45,360 --> 00:33:47,000
only if you're interested,

589
00:33:47,000 --> 00:33:51,078
is I'll show you how to
use the tx: Namespace.

590
00:33:51,078 --> 00:33:54,538
It's a little bit confusing
that even when using annotations

591
00:33:54,538 --> 00:33:58,258
you do still need the tx: Namespace

592
00:33:58,258 --> 00:34:00,767
here in your schema declaration

593
00:34:00,767 --> 00:34:03,667
and that's because we're
going to use just one tag

594
00:34:03,667 --> 00:34:05,807
from that namespace.

595
00:34:05,807 --> 00:34:09,168
By the way I assume you're
familiar with namespaces

596
00:34:09,168 --> 00:34:11,549
and the schema declaration.

597
00:34:11,549 --> 00:34:13,829
I covered that in some detail

598
00:34:13,829 --> 00:34:16,609
on our earlier chapters on AOP,

599
00:34:16,609 --> 00:34:18,429
so if you're in any doubt

600
00:34:18,429 --> 00:34:21,950
you will need to go back and
review what we did there.

601
00:34:21,950 --> 00:34:24,332
What it means is that in order to use

602
00:34:24,332 --> 00:34:27,572
the new transaction tags,

603
00:34:27,572 --> 00:34:30,432
very powerful tags that we can apply,

604
00:34:30,432 --> 00:34:34,721
but we need to declare that
we're using the transaction tags

605
00:34:34,721 --> 00:34:39,041
here at the top in our schema declaration.

606
00:34:39,041 --> 00:34:41,081
I'll show you this on a caption.

607
00:34:41,081 --> 00:34:44,323
We need to add the following three lines

608
00:34:44,323 --> 00:34:46,963
into the top of our XML.

609
00:34:46,963 --> 00:34:48,444
First of all we need to declare

610
00:34:48,444 --> 00:34:52,444
that we're using the tx: Namespace

611
00:34:52,444 --> 00:34:56,764
and secondly in this big string here,

612
00:34:56,764 --> 00:35:01,084
we need to add in the two
lines that tell Spring

613
00:35:01,084 --> 00:35:03,499
where to find the file that defines

614
00:35:03,499 --> 00:35:07,797
what tags are valid in the tx: Namespace.

615
00:35:07,797 --> 00:35:10,917
Now I've put these two lines in the middle

616
00:35:10,917 --> 00:35:14,003
in between my beans and AOP

617
00:35:14,003 --> 00:35:17,402
actually you can put them
anywhere in that string.

618
00:35:17,402 --> 00:35:20,745
It's just one big long string.

619
00:35:20,745 --> 00:35:23,038
As always I'm going to advice caution

620
00:35:23,038 --> 00:35:25,118
please don't pause the video

621
00:35:25,118 --> 00:35:27,750
and try to type that in for yourself

622
00:35:27,750 --> 00:35:29,830
you're almost certain to have

623
00:35:29,830 --> 00:35:32,470
some kind of a mistake along the way.

624
00:35:32,470 --> 00:35:34,651
We'll want to Copy it and Paste it

625
00:35:34,651 --> 00:35:37,152
and the right place to paste it from is

626
00:35:37,152 --> 00:35:39,567
of course the Spring Reference Manual.

627
00:35:39,567 --> 00:35:42,749
There's a chapter called XML
Scheme Based Configuration

628
00:35:42,749 --> 00:35:46,047
that we saw earlier on
when we looked at AOP

629
00:35:46,047 --> 00:35:48,470
and if you have look
down the Contents list

630
00:35:48,470 --> 00:35:53,470
there is an item here which
is the TX transaction schema

631
00:35:55,152 --> 00:35:56,815
and if you follow that link

632
00:35:56,815 --> 00:36:00,439
they give you exactly what
you need here in this block.

633
00:36:00,439 --> 00:36:02,598
You have two options you can Copy

634
00:36:02,598 --> 00:36:05,456
and Paste this entire beans block,

635
00:36:05,456 --> 00:36:07,074
but the problem with that is

636
00:36:07,074 --> 00:36:09,652
you might overwrite something that you've

637
00:36:09,652 --> 00:36:12,713
added to your schema declaration.

638
00:36:12,713 --> 00:36:15,653
I recommend that you pick
out the bits you need

639
00:36:15,653 --> 00:36:17,333
and the first thing you'll need is the

640
00:36:17,333 --> 00:36:20,916
XML Namespace declaration

641
00:36:20,916 --> 00:36:24,357
for TX which is that block here,

642
00:36:24,357 --> 00:36:28,857
and that goes here along
with all of your other

643
00:36:28,857 --> 00:36:31,456
XML Namespace declarations,

644
00:36:32,760 --> 00:36:35,144
and then the second Copy and Paste is

645
00:36:35,144 --> 00:36:37,665
you need this long string here,

646
00:36:37,665 --> 00:36:41,086
don't just take that,
you need the whole line,

647
00:36:41,086 --> 00:36:43,187
so that the two elements in there

648
00:36:43,187 --> 00:36:46,770
separated by space mentioning TX

649
00:36:47,772 --> 00:36:49,391
And you're going to copy that

650
00:36:49,391 --> 00:36:52,023
into this string here.

651
00:36:52,023 --> 00:36:53,944
That's just one big long string

652
00:36:53,944 --> 00:36:56,608
and just to to prove that
you can paste it anywhere,

653
00:36:56,608 --> 00:36:59,299
I'm going to add it to the end.

654
00:36:59,299 --> 00:37:02,935
That's really tedious work I admit,

655
00:37:02,935 --> 00:37:06,217
but what we're going to
do is we're going to use

656
00:37:06,217 --> 00:37:09,671
right here at the bottom, in
fact you can put this anywhere,

657
00:37:09,671 --> 00:37:11,803
in your Spring XML.

658
00:37:11,803 --> 00:37:16,056
I'm going to call this the
Transaction Configuration block

659
00:37:16,056 --> 00:37:18,957
and we're going to use just one tag

660
00:37:18,957 --> 00:37:21,339
from the tx: Namespace

661
00:37:21,339 --> 00:37:23,362
and that tag is and even got

662
00:37:23,362 --> 00:37:25,944
Autocomplete popping up here.

663
00:37:25,944 --> 00:37:30,327
That tag is annotation driven.

664
00:37:30,327 --> 00:37:33,388
There is a parameter into this tag

665
00:37:33,388 --> 00:37:38,388
and the parameter is the name
of your transaction manager.

666
00:37:38,436 --> 00:37:40,975
I just did Control+Space there,

667
00:37:40,975 --> 00:37:43,555
it's Command+Space on a Macintosh.

668
00:37:43,555 --> 00:37:48,555
The attribute is transaction-manager

669
00:37:48,908 --> 00:37:51,641
and you're supposed to plug into here

670
00:37:51,641 --> 00:37:54,322
the name of your transaction manager bean,

671
00:37:54,322 --> 00:37:57,272
I've gone and put that at the top.

672
00:37:57,272 --> 00:38:00,053
I call the bean transaction
manager and in fact

673
00:38:00,053 --> 00:38:02,796
I recommended that you
called it transaction manager

674
00:38:02,796 --> 00:38:05,518
because there is a
little bit of magic here,

675
00:38:05,518 --> 00:38:09,638
if and only if you've called
your transaction manager

676
00:38:09,638 --> 00:38:11,554
Transaction Manager,

677
00:38:11,554 --> 00:38:15,439
then you can in fact omit this block,

678
00:38:15,439 --> 00:38:18,840
which makes it a lot easier to type in.

679
00:38:18,840 --> 00:38:20,203
If you'd called it something else,

680
00:38:20,203 --> 00:38:21,944
and I think the Spring Reference Manual

681
00:38:21,944 --> 00:38:26,165
often calls the Transaction
Manager tx: Manager,

682
00:38:26,165 --> 00:38:28,907
then you would have had to include this

683
00:38:28,907 --> 00:38:30,742
then you would have had to type in

684
00:38:31,629 --> 00:38:33,755
the correct name there,

685
00:38:33,755 --> 00:38:36,616
but we don't need it because we've gone

686
00:38:36,616 --> 00:38:38,947
with the good default name.

687
00:38:38,947 --> 00:38:43,068
So what does this
annotation block give us?

688
00:38:43,068 --> 00:38:45,969
When Spring sees this tag

689
00:38:45,969 --> 00:38:49,209
in our application.xml file

690
00:38:49,209 --> 00:38:53,191
It will go away and run
through all of the beans

691
00:38:53,191 --> 00:38:56,355
that we've defined in our container,

692
00:38:56,355 --> 00:39:00,157
so it's going to check the
transaction manager bean,

693
00:39:00,157 --> 00:39:02,617
the atasource bean, the template bean,

694
00:39:02,617 --> 00:39:06,688
the book dao bean, the
account service bean,

695
00:39:06,688 --> 00:39:08,621
and the purchasing service bean,

696
00:39:08,621 --> 00:39:11,780
and even this performance
timing advice bean.

697
00:39:11,780 --> 00:39:13,981
It will check each of them,

698
00:39:13,981 --> 00:39:18,902
and it will look for an
annotation on each class

699
00:39:18,902 --> 00:39:22,202
to determine where the
transactions are needed

700
00:39:22,202 --> 00:39:24,590
for that class or not.

701
00:39:25,699 --> 00:39:29,703
Let's start with, what's
a really interesting class

702
00:39:29,703 --> 00:39:33,515
in this example and that's
the purchasing service class.

703
00:39:34,540 --> 00:39:39,540
I'm looking here at the
implementation class.

704
00:39:40,210 --> 00:39:43,135
At the moment there's
no annotation in place

705
00:39:43,135 --> 00:39:46,624
so Spring is going to do
nothing with this class.

706
00:39:47,737 --> 00:39:52,737
If however I add on the
@transactional annotation,

707
00:39:54,439 --> 00:39:56,878
and it will need imported,

708
00:39:56,878 --> 00:39:58,501
and check the import there,

709
00:39:58,501 --> 00:40:01,201
it is from the Spring Framework.

710
00:40:01,201 --> 00:40:04,213
This tells Spring that
it needs to generate

711
00:40:04,213 --> 00:40:08,369
a transaction proxy for this class.

712
00:40:09,499 --> 00:40:13,019
And that means that all of
the methods in the class

713
00:40:13,019 --> 00:40:16,210
are going to become transactional methods,

714
00:40:16,210 --> 00:40:18,583
and effectively that means for Buy Book

715
00:40:18,583 --> 00:40:21,062
we're going to get a begin transaction

716
00:40:21,062 --> 00:40:22,824
at the beginning of the method

717
00:40:22,824 --> 00:40:26,721
and a commit transaction
at the end of the method

718
00:40:26,721 --> 00:40:28,396
for free.

719
00:40:28,396 --> 00:40:30,235
And the fact that I've put it on the class

720
00:40:30,235 --> 00:40:35,235
means that even there are
157 methods in this class,

721
00:40:35,315 --> 00:40:40,037
all 157 methods will have a transaction

722
00:40:40,037 --> 00:40:41,067
wrapped around it.

723
00:40:42,000 --> 00:40:44,759
I could alternatively
have put the annotation

724
00:40:44,759 --> 00:40:47,018
on the method,

725
00:40:47,018 --> 00:40:50,062
and in this case this would
mean that only Buy Book

726
00:40:50,062 --> 00:40:51,760
is transactional

727
00:40:51,760 --> 00:40:54,264
so doing this we could pick and choose

728
00:40:54,264 --> 00:40:56,614
which methods are going to be transactions

729
00:40:56,614 --> 00:41:00,376
but you'll probably find
that's is often the case,

730
00:41:00,376 --> 00:41:05,024
that all or maybe most of the
methods in a service class

731
00:41:05,024 --> 00:41:06,664
need to be transncational

732
00:41:06,664 --> 00:41:10,624
so it's kinda of better to
put it at the class level.

733
00:41:10,624 --> 00:41:12,266
I'll show you later in the course

734
00:41:12,266 --> 00:41:14,100
how you can put it on the class level

735
00:41:14,100 --> 00:41:16,262
and then maybe for the one or two methods

736
00:41:16,262 --> 00:41:18,122
that don't need transaction

737
00:41:18,122 --> 00:41:20,602
you can put at in annotation on to say

738
00:41:20,602 --> 00:41:24,334
or the switch transactions
of for this method.

739
00:41:24,334 --> 00:41:25,545
I don't just want transaction

740
00:41:25,545 --> 00:41:27,073
on the purchasing service

741
00:41:27,073 --> 00:41:32,014
in fact I want transaction
on all of my service classes.

742
00:41:32,014 --> 00:41:33,115
So I'm going to go ahead

743
00:41:33,115 --> 00:41:35,508
and go into my production implementation

744
00:41:35,508 --> 00:41:38,130
of the Book service

745
00:41:38,130 --> 00:41:43,130
and I'm going to add
transactional to that as well.

746
00:41:44,332 --> 00:41:46,632
And that will need to be ported

747
00:41:46,632 --> 00:41:48,267
and again at the risk of boring you

748
00:41:48,267 --> 00:41:51,288
that means get all books by author

749
00:41:51,288 --> 00:41:53,306
and register new book,

750
00:41:53,306 --> 00:41:56,366
and I could keep going
all of those methods

751
00:41:56,366 --> 00:41:59,267
are going to get transactions.

752
00:41:59,267 --> 00:42:00,949
If you think about it,

753
00:42:00,949 --> 00:42:02,668
we definately need a transaction

754
00:42:02,668 --> 00:42:04,427
for register new book

755
00:42:04,427 --> 00:42:07,318
because if we call this
method directly from a client,

756
00:42:07,318 --> 00:42:10,811
and that's what we will do in the client

757
00:42:11,881 --> 00:42:13,560
we're going to want a begin

758
00:42:13,560 --> 00:42:15,520
and a commit wrapped around it

759
00:42:15,520 --> 00:42:19,035
otherwise the data will
not go into the database.

760
00:42:20,245 --> 00:42:24,405
And there's a slight problem
with this example system

761
00:42:24,405 --> 00:42:27,577
at the moment for account service,

762
00:42:27,577 --> 00:42:30,656
I've only got a mock implementation.

763
00:42:30,656 --> 00:42:32,598
When setting up this example system

764
00:42:32,598 --> 00:42:35,337
I kind of thought that
we wouldn't really need

765
00:42:35,337 --> 00:42:38,417
a full implementation of accounts service,

766
00:42:38,417 --> 00:42:41,768
so we don't have any
database operations in here,

767
00:42:41,768 --> 00:42:43,697
I could go ahead and add them now,

768
00:42:43,697 --> 00:42:45,931
but it would be very boring for you,

769
00:42:45,931 --> 00:42:49,119
and I don't think it would
really add much to the exercise,

770
00:42:49,119 --> 00:42:52,024
so just for this illustration,

771
00:42:52,024 --> 00:42:54,804
we're not going to see
any transactions applied

772
00:42:54,804 --> 00:42:56,674
to the accounts service.

773
00:42:58,244 --> 00:43:03,244
Actually I can safely add
transactional to the service,

774
00:43:04,610 --> 00:43:07,139
it's just that it's going
to be no database operations

775
00:43:07,139 --> 00:43:08,701
in raise invoice,

776
00:43:08,701 --> 00:43:11,877
so what we'll see if
we called raise invoice

777
00:43:11,877 --> 00:43:13,436
directly from a client is

778
00:43:13,436 --> 00:43:16,845
we wouldl get a begin and a commit,

779
00:43:16,845 --> 00:43:18,766
and they won't be doing anything and

780
00:43:18,766 --> 00:43:21,552
that could possibly impact performance,

781
00:43:21,552 --> 00:43:23,652
it would slow the system down a little bit

782
00:43:23,652 --> 00:43:26,792
but it won't hurt anything.

783
00:43:26,792 --> 00:43:27,714
Just to be safe though,

784
00:43:27,714 --> 00:43:30,609
I'm going to remove the
transactional annotation

785
00:43:30,609 --> 00:43:31,998
from our mock implementation

786
00:43:31,998 --> 00:43:34,841
because transactions just aren't needed

787
00:43:34,841 --> 00:43:38,211
for a class that isn't
doing database operations.

788
00:43:39,320 --> 00:43:41,723
This is a long chapter and
I've spoken quite a lot

789
00:43:41,723 --> 00:43:43,559
about the theory behind the transactions,

790
00:43:43,559 --> 00:43:45,543
but I just want you to
sit back for a moment

791
00:43:45,543 --> 00:43:48,764
and recognize that all that
we've done in terms of coding

792
00:43:48,764 --> 00:43:52,025
is we've added one tag to our XML,

793
00:43:53,015 --> 00:43:56,100
and that is one tag that we'll
apply to the entire project,

794
00:43:56,100 --> 00:43:57,534
we only have to do it once.

795
00:43:58,413 --> 00:44:01,893
And then a single simple annotation

796
00:44:01,893 --> 00:44:04,035
on all of our service classes

797
00:44:04,035 --> 00:44:06,455
to say that we want our transactions on,

798
00:44:06,455 --> 00:44:09,937
and that's enough for
Spring to know what to do.

799
00:44:09,937 --> 00:44:12,886
Of course we need to test this out,

800
00:44:12,886 --> 00:44:16,271
If I go cross to my client
application at the moment

801
00:44:16,271 --> 00:44:18,798
I'm not calling the purchasing service,

802
00:44:18,798 --> 00:44:21,778
but remember that we
have applied transactions

803
00:44:21,778 --> 00:44:25,100
to the register New Book Method,

804
00:44:25,100 --> 00:44:26,743
and because we are calling that method

805
00:44:26,743 --> 00:44:28,244
directly from a client,

806
00:44:28,244 --> 00:44:33,244
we should see a transaction
applied to that method.

807
00:44:33,647 --> 00:44:35,573
To test this out before I even think

808
00:44:35,573 --> 00:44:37,811
about purchasing service,

809
00:44:37,811 --> 00:44:39,700
I'm going to just to make sure

810
00:44:39,700 --> 00:44:43,495
that we get transactions
for register new book.

811
00:44:43,495 --> 00:44:45,840
Problem is with transactions
it's kind of difficult

812
00:44:45,840 --> 00:44:48,281
to know if they're working or not.

813
00:44:48,281 --> 00:44:50,035
Let me explain just to keep things clean,

814
00:44:50,035 --> 00:44:52,496
I'm going to Refresh the project,

815
00:44:52,496 --> 00:44:54,119
and delete the database,

816
00:44:54,119 --> 00:44:57,659
we got a nice clean sheet of paper,

817
00:44:57,659 --> 00:44:59,241
And we expect in this client

818
00:44:59,241 --> 00:45:03,085
that we're going to insert
one book to the system,

819
00:45:03,085 --> 00:45:04,986
then we do a Select,

820
00:45:04,986 --> 00:45:06,857
and then we're going to find a book

821
00:45:06,857 --> 00:45:09,487
that doesn't actually exist.

822
00:45:09,487 --> 00:45:12,777
Let's run the program.

823
00:45:14,505 --> 00:45:17,169
It's saying we're running get anti-catalog

824
00:45:17,169 --> 00:45:21,734
and we got warrant piece
by Leo Toll styling system,

825
00:45:21,734 --> 00:45:26,189
and if I refresh the project again,

826
00:45:26,189 --> 00:45:29,369
check inside the database script

827
00:45:29,369 --> 00:45:34,003
yeah we can see the book did
get entered into the database

828
00:45:34,003 --> 00:45:35,593
so I don't know about you

829
00:45:35,593 --> 00:45:38,613
but I'm not entirely sure the
work we've done has worked

830
00:45:38,613 --> 00:45:42,027
because remember we
were getting autocommit

831
00:45:42,027 --> 00:45:44,578
in previous chapters.

832
00:45:44,578 --> 00:45:46,053
It's possible that I've
done something wrong

833
00:45:46,053 --> 00:45:50,784
and we're just getting everything
autocommiting as before

834
00:45:50,784 --> 00:45:55,784
so for that reason I
think it's really useful

835
00:45:55,913 --> 00:46:00,913
to check that transactions
are working by using login.

836
00:46:01,540 --> 00:46:02,808
Right from the start of the project

837
00:46:02,808 --> 00:46:06,017
we've had a file in our SRC directory

838
00:46:06,017 --> 00:46:10,626
called log for J.properties.disabled.

839
00:46:10,626 --> 00:46:12,062
What you need to do with that file

840
00:46:12,062 --> 00:46:17,062
is to rename it by right-clicking
Refactor and Rename

841
00:46:18,856 --> 00:46:22,880
and we want to lose the .disabled

842
00:46:22,880 --> 00:46:25,856
That's going to bring that file into use

843
00:46:25,856 --> 00:46:27,936
and I open it open it up in the eclipse.

844
00:46:27,936 --> 00:46:31,174
I don't know if your familiar with log4 J

845
00:46:31,174 --> 00:46:35,751
so I can't go into deep detail
about whats going on here

846
00:46:35,751 --> 00:46:40,315
except to say that this line
here is the crucial line

847
00:46:40,315 --> 00:46:44,805
and this is telling log4J
that we want full login

848
00:46:44,805 --> 00:46:49,805
for the class called data
source transaction manager.

849
00:46:50,269 --> 00:46:54,191
And it just so happens that
Spring have quite diligently

850
00:46:54,191 --> 00:46:58,313
put in good login into that class

851
00:46:58,313 --> 00:47:02,006
and by enabling and setting
it to level to Debug,

852
00:47:02,006 --> 00:47:06,683
we can have a look at
exactly what it's doing.

853
00:47:06,683 --> 00:47:09,933
These are the two lines I'll
front later on in the course

854
00:47:09,933 --> 00:47:14,175
and you want to leave these
commented out for now.

855
00:47:14,175 --> 00:47:16,998
Let's have a look at the
difference that that makes.

856
00:47:16,998 --> 00:47:19,204
Again just to be clean I'm going

857
00:47:19,204 --> 00:47:22,656
to delete the existing database.

858
00:47:25,980 --> 00:47:28,361
And we'll run the clients again,

859
00:47:29,929 --> 00:47:32,603
Now this is really good
we've got a lot of login

860
00:47:32,603 --> 00:47:34,721
and I know it's not
that's not easy to read,

861
00:47:34,721 --> 00:47:38,034
but it's certainly going
to be illuminating.

862
00:47:38,034 --> 00:47:39,565
If you have a look at this three lines

863
00:47:39,565 --> 00:47:41,703
of debugging at the top,

864
00:47:41,703 --> 00:47:44,499
notice that they happen before

865
00:47:44,499 --> 00:47:48,175
we enter the register new book method.

866
00:47:48,175 --> 00:47:50,058
And if I just scroll across to the right

867
00:47:50,058 --> 00:47:51,239
I think this is going to be some

868
00:47:51,239 --> 00:47:53,880
fantastic information in here,

869
00:47:53,880 --> 00:47:56,522
have a look at this line
here which is saying

870
00:47:56,522 --> 00:48:01,040
switching the JDBC
connection I'll keep going,

871
00:48:02,830 --> 00:48:06,208
we're switching to manual commits.

872
00:48:06,208 --> 00:48:08,508
That effectively means that we've got rid

873
00:48:08,508 --> 00:48:11,286
of the horrible Autocommit mode

874
00:48:11,286 --> 00:48:14,842
and we're doing proper transactions,

875
00:48:14,842 --> 00:48:16,999
which is great.

876
00:48:16,999 --> 00:48:21,276
In here we've entered the
register new book method

877
00:48:21,276 --> 00:48:22,935
but have a good look at what's happening

878
00:48:22,935 --> 00:48:24,589
after that method.

879
00:48:24,589 --> 00:48:26,805
If I go cross to the right

880
00:48:26,805 --> 00:48:31,481
it's telling me it's
initiating the commits

881
00:48:31,481 --> 00:48:33,518
which is great.

882
00:48:33,518 --> 00:48:35,518
It's committing the transaction

883
00:48:35,518 --> 00:48:38,215
and then it's releasing the connection

884
00:48:38,215 --> 00:48:39,559
and what you'll find if you look down

885
00:48:39,559 --> 00:48:41,280
the rest of the login,

886
00:48:41,280 --> 00:48:43,122
is essentially for
every one of the methods

887
00:48:43,122 --> 00:48:45,994
such as get entire catalog

888
00:48:45,994 --> 00:48:50,313
and get book by ISPN, we're
seeing begin and a commit

889
00:48:50,313 --> 00:48:53,431
wrapped around each of them.

890
00:48:53,431 --> 00:48:54,466
You might be wondering at this point

891
00:48:54,466 --> 00:48:56,630
well that's all very well
we can see the transaction

892
00:48:56,630 --> 00:49:01,535
wrapped around every single
one of these service methods.

893
00:49:01,535 --> 00:49:05,143
But what happens if you
have one service method

894
00:49:05,143 --> 00:49:07,243
calling another service method.

895
00:49:07,243 --> 00:49:10,613
when you have a chain of service methods?

896
00:49:10,613 --> 00:49:12,252
Are you going to get a transaction

897
00:49:12,252 --> 00:49:14,563
wrapped around every single one of them?

898
00:49:14,563 --> 00:49:16,601
That's a quite complicated question

899
00:49:16,601 --> 00:49:20,530
so if that is in your head
I promise we will be looking

900
00:49:20,530 --> 00:49:25,530
at that in the chapter called
Transaction Propagation.

901
00:49:25,589 --> 00:49:27,459
But that's for later on in the course

902
00:49:27,459 --> 00:49:28,598
the important thing is

903
00:49:28,598 --> 00:49:31,036
we are seeing transactions happening.

904
00:49:32,026 --> 00:49:34,218
I could do just for fun

905
00:49:34,218 --> 00:49:38,475
is if I go into the
register new book method

906
00:49:38,475 --> 00:49:40,607
in our service class,

907
00:49:42,454 --> 00:49:44,401
Here is just where I just new book

908
00:49:44,401 --> 00:49:46,196
Now what I'm going to do

909
00:49:46,196 --> 00:49:47,894
to be a little bit cheeky

910
00:49:47,894 --> 00:49:50,274
after we've called the Dao

911
00:49:50,274 --> 00:49:53,812
and therefore after we've issued the SQL

912
00:49:53,812 --> 00:49:56,613
I'm going to throw an exception.

913
00:49:56,613 --> 00:49:58,629
It needs to be an unchecked exception

914
00:49:58,629 --> 00:50:02,329
for reasons that I'll explain later on.

915
00:50:02,329 --> 00:50:05,765
I'm going to make it a
no pointer exception.

916
00:50:05,765 --> 00:50:10,533
Now really here I'm simulating a crash

917
00:50:10,533 --> 00:50:14,072
and you might imagine that
this is a, I don't know if

918
00:50:14,072 --> 00:50:17,122
we've run out of memory
or something like that.

919
00:50:18,380 --> 00:50:22,007
In our old system when
we had autocommitting

920
00:50:22,007 --> 00:50:24,785
even though this process had crashed

921
00:50:24,785 --> 00:50:26,563
because we'd left the Dao,

922
00:50:26,563 --> 00:50:29,641
that operation would have autocommited.

923
00:50:29,641 --> 00:50:31,999
But now what I want to see

924
00:50:31,999 --> 00:50:35,133
is I want to see Spring catching the fight

925
00:50:35,133 --> 00:50:37,370
that this method has failed

926
00:50:37,370 --> 00:50:40,728
and I want it to unroll or rollback

927
00:50:40,728 --> 00:50:43,684
all of the database operations
that have taken place

928
00:50:43,684 --> 00:50:45,736
in this method.

929
00:50:45,736 --> 00:50:47,695
We can see if that happens

930
00:50:47,695 --> 00:50:51,671
I'll again refresh the projects

931
00:50:51,671 --> 00:50:55,770
and drop the database.

932
00:50:55,770 --> 00:50:57,694
The reason I'm dropping
the database by the way

933
00:50:57,694 --> 00:51:00,260
is because everytime I'm
registering a new book

934
00:51:00,260 --> 00:51:03,025
it's entering a new book on the system,

935
00:51:03,025 --> 00:51:05,112
and they've all got the same key

936
00:51:05,112 --> 00:51:08,204
which could cause problems later on but

937
00:51:10,092 --> 00:51:14,805
my use of ISBN for a
key isn't ideal really,

938
00:51:14,805 --> 00:51:16,614
but anyway let's run the clients again

939
00:51:16,614 --> 00:51:18,924
with the login on.

940
00:51:20,354 --> 00:51:21,247
And of course we have a crash

941
00:51:21,247 --> 00:51:25,698
and that's the result of
that new appointer exception,

942
00:51:25,698 --> 00:51:28,816
but before that happened let's
have a look at the login.

943
00:51:28,816 --> 00:51:31,620
We went into register new book

944
00:51:31,620 --> 00:51:33,230
then clearly something went wrong

945
00:51:33,230 --> 00:51:35,355
after the SQL was issued

946
00:51:35,355 --> 00:51:38,673
but have a look at that line
there, that's really good.

947
00:51:38,673 --> 00:51:40,791
We can see from the login,

948
00:51:40,791 --> 00:51:44,064
that clearly the transaction manager

949
00:51:44,064 --> 00:51:49,064
is being careful to
rollback that transaction.

950
00:51:49,641 --> 00:51:52,300
We would find in this case that that book

951
00:51:52,300 --> 00:51:56,310
has not gone into the
database which is great.

952
00:51:56,310 --> 00:51:59,649
I just want to warn you if
you're following along with me

953
00:51:59,649 --> 00:52:02,509
in this chapter there is a slight problem

954
00:52:02,509 --> 00:52:04,748
with what we've done here

955
00:52:04,748 --> 00:52:08,051
because we've made the code crash

956
00:52:08,051 --> 00:52:10,429
here in the middle of the run.

957
00:52:10,429 --> 00:52:14,797
What will have happened is
if I go back to the clients,

958
00:52:14,797 --> 00:52:18,657
what will have happened
is on this line of code,

959
00:52:18,657 --> 00:52:20,334
we've had an exception,

960
00:52:20,334 --> 00:52:24,328
and the program has
terminated at this point

961
00:52:24,328 --> 00:52:27,187
because it's an unchecked exception

962
00:52:27,187 --> 00:52:29,521
and the unchecked exception will be thrown

963
00:52:29,521 --> 00:52:31,356
from this main method

964
00:52:31,356 --> 00:52:36,356
so all of this this
code will not have run.

965
00:52:36,581 --> 00:52:38,245
What that means for us because we're using

966
00:52:38,245 --> 00:52:43,245
this file based database
if I refresh the project,

967
00:52:43,317 --> 00:52:46,302
yeah you'll see that
things aren't right now.

968
00:52:46,302 --> 00:52:49,798
We have this database.back.lck file,

969
00:52:49,798 --> 00:52:51,574
that's a lock file.

970
00:52:51,574 --> 00:52:53,934
It means the database is locked

971
00:52:53,934 --> 00:52:56,353
and you'll find if you look in the script

972
00:52:56,353 --> 00:52:58,892
that any changes you will have expected

973
00:52:58,892 --> 00:53:01,241
will not have appeared

974
00:53:01,241 --> 00:53:02,786
and that's because we didn't close

975
00:53:02,786 --> 00:53:05,477
the database down cleanly.

976
00:53:05,477 --> 00:53:07,289
I'm going to delete the database

977
00:53:07,289 --> 00:53:12,052
so we've got a clean
sheet to start from again.

978
00:53:12,052 --> 00:53:15,652
If you were wanting to experiment yourself

979
00:53:15,652 --> 00:53:17,336
and you want to play around with this,

980
00:53:17,336 --> 00:53:19,998
then you're wanting to do is
make a slight change here,

981
00:53:19,998 --> 00:53:22,679
it's standard Java really.

982
00:53:22,679 --> 00:53:25,101
After you've created the container,

983
00:53:25,101 --> 00:53:26,835
you'll need a try block,

984
00:53:29,961 --> 00:53:32,304
note you'll want everything out

985
00:53:32,304 --> 00:53:34,665
and a finally.

986
00:53:34,665 --> 00:53:39,665
And a finally needs to
contain the container.close

987
00:53:40,189 --> 00:53:43,090
you're probably familiar with try finally.

988
00:53:43,090 --> 00:53:45,993
What it means is even if
an exception is thrown

989
00:53:45,993 --> 00:53:48,493
in the middle of the process

990
00:53:48,493 --> 00:53:53,493
and before crashing we must
always run container.close

991
00:53:54,154 --> 00:53:57,475
so that will make sure that
we always close the database

992
00:53:57,475 --> 00:54:00,155
down in a clean way.

993
00:54:00,155 --> 00:54:04,747
Let's try that again, so
we have transactions on,

994
00:54:06,795 --> 00:54:09,317
and the process of entering the book

995
00:54:09,317 --> 00:54:11,461
has crashed in the middle of that process

996
00:54:11,461 --> 00:54:14,334
so we've concealed rollback here,

997
00:54:15,263 --> 00:54:18,704
and now a Refresh,

998
00:54:18,704 --> 00:54:20,725
we'll check inside the database,

999
00:54:20,725 --> 00:54:23,065
notice there was no lock this time,

1000
00:54:23,065 --> 00:54:25,345
and you can see at the bottom here,

1001
00:54:25,345 --> 00:54:29,248
and right at the bottom of
the script there is no book

1002
00:54:29,248 --> 00:54:33,829
in the database because
that line was rolled back.

1003
00:54:33,829 --> 00:54:37,451
And just if you want proof
that there is a big difference,

1004
00:54:37,451 --> 00:54:42,451
if I go into application.xml
and remove temporarily,

1005
00:54:42,912 --> 00:54:44,935
cause I'm going to put that back,

1006
00:54:44,935 --> 00:54:49,296
the tx: Annotation driven command.

1007
00:54:49,296 --> 00:54:54,296
This now means that we have
switched transaction off

1008
00:54:54,495 --> 00:54:58,276
and we're back in that
horrible Auto-commit mode.

1009
00:54:58,276 --> 00:55:00,189
If I run my client again,

1010
00:55:01,946 --> 00:55:04,242
we still have the crash,

1011
00:55:04,242 --> 00:55:06,506
we don't have any login this time.

1012
00:55:06,506 --> 00:55:09,107
The big difference is,
I'll just remind you,

1013
00:55:09,107 --> 00:55:13,627
that this crash happened after
we've made the call to create

1014
00:55:13,627 --> 00:55:16,508
and because we now don't
have transactions on,

1015
00:55:16,508 --> 00:55:19,708
we've fallen back into autocommit mode

1016
00:55:19,708 --> 00:55:23,472
and that means horribly checking script.

1017
00:55:23,472 --> 00:55:26,952
The book made it's way into the database

1018
00:55:26,952 --> 00:55:30,572
even though the register new book method

1019
00:55:30,572 --> 00:55:33,212
crashed before it could finish.

1020
00:55:33,212 --> 00:55:34,614
So I think that's a good illustration

1021
00:55:34,614 --> 00:55:38,025
of why we really do want transactions on,

1022
00:55:38,025 --> 00:55:40,997
and I've got to be
careful to make sure that

1023
00:55:40,997 --> 00:55:43,633
annotations driven is back in the XML.

1024
00:55:44,662 --> 00:55:46,698
Now let check that's working again,

1025
00:55:49,871 --> 00:55:52,233
and yes there's our rollback.

1026
00:55:52,233 --> 00:55:55,792
I'm going to remove the
throwing of the exception

1027
00:55:55,792 --> 00:55:58,615
that was a useful thing to try

1028
00:55:58,615 --> 00:55:59,859
to make sure that the transactions

1029
00:55:59,859 --> 00:56:02,359
were rolling back correctly.

1030
00:56:02,359 --> 00:56:04,120
Now we've got quite a lot more

1031
00:56:04,120 --> 00:56:06,479
studying to do on transactions,

1032
00:56:06,479 --> 00:56:09,839
and the next few chapters are
going to be doing just that.

1033
00:56:09,839 --> 00:56:12,343
We need to have a look at
what happens when you have

1034
00:56:12,343 --> 00:56:17,047
multiple service methods
calling one another in a chain,

1035
00:56:17,047 --> 00:56:20,047
we need to see how that
affects transactions.

1036
00:56:20,047 --> 00:56:22,309
And we also need to think
in a bit more detail

1037
00:56:22,309 --> 00:56:25,271
about things just rollbacks.

1038
00:56:25,271 --> 00:56:27,751
But for the basics of transactions

1039
00:56:27,751 --> 00:56:31,151
you're going to find that
all you need for a project,

1040
00:56:31,151 --> 00:56:35,892
the one XML tag of TX:annotation driven,

1041
00:56:35,892 --> 00:56:38,996
and then in each of your
services implementations

1042
00:56:38,996 --> 00:56:42,597
adding the art transactional annotation

1043
00:56:42,597 --> 00:56:47,157
switches transactions on for
every one of the methods.

1044
00:56:47,157 --> 00:56:50,897
But I did tell you there's a
second approach you can follow,

1045
00:56:50,897 --> 00:56:54,099
I call it the TX namespace.

1046
00:56:54,099 --> 00:56:55,702
Now I must worn you in advance

1047
00:56:55,702 --> 00:56:58,736
that I don't think this
is a nice approach,

1048
00:56:59,772 --> 00:57:01,830
I far prefer the annotations

1049
00:57:01,830 --> 00:57:04,010
but I have worked with some projects,

1050
00:57:04,010 --> 00:57:06,931
I like to use the TX namespace.

1051
00:57:06,931 --> 00:57:11,931
So I'm going to very quickly
run through how that works.

1052
00:57:12,131 --> 00:57:17,131
First of all I'm going to move
the TX:annotation driven tag,

1053
00:57:17,334 --> 00:57:18,855
and by the way what I've done with that

1054
00:57:18,855 --> 00:57:22,584
is I've offensively
switched transactions off.

1055
00:57:23,675 --> 00:57:26,967
If I run the code without that tag,

1056
00:57:27,998 --> 00:57:30,739
notice the login has now gone.

1057
00:57:30,739 --> 00:57:33,802
Now the data will be
going to the database,

1058
00:57:33,802 --> 00:57:36,281
but that's because we've
got autocommitting on,

1059
00:57:36,281 --> 00:57:40,801
which is as I have said many
times now not a good thing.

1060
00:57:40,801 --> 00:57:44,540
The alternative way then
of setting up transactions

1061
00:57:44,540 --> 00:57:48,281
is to use the tag again
is from the TX namesspace

1062
00:57:48,281 --> 00:57:51,217
called the Advice Tag.

1063
00:57:51,217 --> 00:57:53,956
Now this allows as to define which methods

1064
00:57:53,956 --> 00:57:56,397
we want to be transactional.

1065
00:57:56,397 --> 00:57:57,534
So in other words it's really

1066
00:57:57,534 --> 00:58:00,635
an alternative to this annotation.

1067
00:58:00,635 --> 00:58:03,235
And what I will do using TX: advice

1068
00:58:03,235 --> 00:58:06,913
is first of all we have
to give the advice an ID.

1069
00:58:06,913 --> 00:58:09,193
I'm going to use meaningful ID here,

1070
00:58:09,193 --> 00:58:12,213
and you'll see why it's
meaningful in a few seconds.

1071
00:58:12,213 --> 00:58:14,133
I'm going to be describing in this tag

1072
00:58:14,133 --> 00:58:19,133
that I want all methods
to be transactional.

1073
00:58:22,273 --> 00:58:26,110
And it's quite easy to
fill in the advice tag,

1074
00:58:26,110 --> 00:58:29,466
because if we using
intelescence you'll see

1075
00:58:29,466 --> 00:58:31,704
is only one supported tag

1076
00:58:31,704 --> 00:58:34,774
and that's TX:attributes,

1077
00:58:36,403 --> 00:58:37,802
which I find it a bit confusing

1078
00:58:37,802 --> 00:58:41,017
because it's actually a blanked tag,

1079
00:58:41,017 --> 00:58:44,756
there's nothing you put in
there,there is no attributes.

1080
00:58:44,756 --> 00:58:47,532
Inside the TX attributes tag,

1081
00:58:47,532 --> 00:58:51,329
you the follow up with the TX Method Tag.

1082
00:58:51,329 --> 00:58:53,985
That's tag asking me for the name

1083
00:58:53,985 --> 00:58:57,085
it's basically saying what's
the name of the method

1084
00:58:57,085 --> 00:59:00,345
that the you want to be transactional.

1085
00:59:00,345 --> 00:59:02,883
Let's say for example that we want

1086
00:59:02,883 --> 00:59:05,103
in the purchasing service,

1087
00:59:05,103 --> 00:59:08,865
the register New Book
Method to be transactional,

1088
00:59:08,865 --> 00:59:12,246
or we would put the method name in there.

1089
00:59:12,246 --> 00:59:14,566
Well that might be frightening you

1090
00:59:14,566 --> 00:59:16,108
you certainly don't have to go ahead now

1091
00:59:16,108 --> 00:59:19,672
and use very single one of
the methods in your system

1092
00:59:19,672 --> 00:59:22,675
that would be far too tedious.

1093
00:59:22,675 --> 00:59:25,614
We can use a wildcard here,

1094
00:59:25,614 --> 00:59:28,476
and that's effectively
saying that all methods

1095
00:59:28,476 --> 00:59:30,816
are going to be transactional.

1096
00:59:30,816 --> 00:59:34,757
The reason we've done this is
that allows us the potential

1097
00:59:34,757 --> 00:59:37,538
to do things such as, well okay,

1098
00:59:37,538 --> 00:59:40,478
all methods are going to be transactional,

1099
00:59:40,478 --> 00:59:42,539
but I could make an exception.

1100
00:59:42,539 --> 00:59:46,539
I could say that for example
the raise Invoice method

1101
00:59:46,539 --> 00:59:49,661
I don't want to be transactional,

1102
00:59:49,661 --> 00:59:51,263
but that's the only one.

1103
00:59:51,263 --> 00:59:54,424
And I could switch off
transactions using some syntax

1104
00:59:54,424 --> 00:59:56,725
that we're going to see later.

1105
00:59:56,725 --> 00:59:59,825
Actually the easiest
thing to do is just to say

1106
00:59:59,825 --> 01:00:03,688
I want all methods in
transactional classes

1107
01:00:03,688 --> 01:00:05,858
to be transactional.

1108
01:00:06,928 --> 01:00:10,050
I've always found this to be

1109
01:00:10,050 --> 01:00:13,111
a little bit tricky and confusing.

1110
01:00:13,111 --> 01:00:15,791
The reason is if I run the code now,

1111
01:00:15,791 --> 01:00:20,791
I think we're going to
find, yeah, no transactions.

1112
01:00:20,824 --> 01:00:23,495
You see there's no login going on

1113
01:00:23,495 --> 01:00:28,177
so again we're still running
under autocommit mode,

1114
01:00:28,177 --> 01:00:30,197
and the reason is all we've done here

1115
01:00:30,197 --> 01:00:34,239
is we've set what methods
we want to be transactional,

1116
01:00:34,239 --> 01:00:37,479
but we haven't define what classes

1117
01:00:37,479 --> 01:00:40,100
we want the transactions to be in.

1118
01:00:40,100 --> 01:00:43,400
And you have to do that
using a separate block,

1119
01:00:43,400 --> 01:00:46,063
and believe it or not you have to go back

1120
01:00:46,063 --> 01:00:49,724
to the AOP Namespace to do this,

1121
01:00:49,724 --> 01:00:52,255
so we're going to need AOP config.

1122
01:00:53,464 --> 01:00:55,466
If you want to use this approach

1123
01:00:55,466 --> 01:00:57,686
you really do need to be quite confident

1124
01:00:57,686 --> 01:00:59,709
with your AOP,

1125
01:00:59,709 --> 01:01:02,379
and we are going to have
to define a point cut.

1126
01:01:02,379 --> 01:01:03,970
Something else I've always found confusing

1127
01:01:03,970 --> 01:01:06,433
about this is we're
not going to define it,

1128
01:01:06,433 --> 01:01:09,714
this as an aspect like we did before.

1129
01:01:09,714 --> 01:01:12,254
If you remember we set up AOP aspect

1130
01:01:12,254 --> 01:01:15,235
and then we defined some around advice.

1131
01:01:15,235 --> 01:01:17,415
Instead what we're expected to do

1132
01:01:17,415 --> 01:01:20,475
is define an advisor.

1133
01:01:20,475 --> 01:01:24,136
We didn't cover advisors
in the previous chapter.

1134
01:01:24,136 --> 01:01:27,957
All an advisor is it's a combination

1135
01:01:27,957 --> 01:01:31,837
of advice and a point cut.

1136
01:01:31,837 --> 01:01:35,700
We've already defined
the advice that's here.

1137
01:01:35,700 --> 01:01:37,617
The point cut is going to be,

1138
01:01:37,617 --> 01:01:41,240
for use we want all service classes

1139
01:01:41,240 --> 01:01:44,121
to be picked up as transactional,

1140
01:01:44,121 --> 01:01:45,843
so for the advice ref we just need

1141
01:01:45,843 --> 01:01:49,923
to plug in that name into here,

1142
01:01:49,923 --> 01:01:53,823
and in the second parameter
into the advisor tag

1143
01:01:53,823 --> 01:01:56,765
is the point cut.

1144
01:01:56,765 --> 01:01:58,925
And you've gotta think carefully now,

1145
01:01:58,925 --> 01:02:01,185
it's the usual business
with the point cut,

1146
01:02:01,185 --> 01:02:05,086
we need execution with round brackets,

1147
01:02:05,086 --> 01:02:09,266
and we want all service classes,

1148
01:02:09,266 --> 01:02:12,509
so looking for, we don't
care about the return type.

1149
01:02:12,509 --> 01:02:14,151
For us it's going to be all classes

1150
01:02:14,151 --> 01:02:17,900
in com.virtualpairprogramers

1151
01:02:17,900 --> 01:02:21,641
.avalon I think is the next package name,

1152
01:02:21,641 --> 01:02:24,343
and then we've got services package.

1153
01:02:24,343 --> 01:02:28,323
On this particular project we
don't have any sub-packages

1154
01:02:28,323 --> 01:02:32,443
but we might have later
on so I'm going the ..

1155
01:02:32,443 --> 01:02:35,165
that you saw in the
previous practical session

1156
01:02:35,165 --> 01:02:39,135
and then all classes that
are found in that package.

1157
01:02:40,085 --> 01:02:42,006
And then, it's funny off that we have

1158
01:02:42,006 --> 01:02:43,698
to refer to methods again

1159
01:02:43,698 --> 01:02:47,339
so we're going to check at
least all of the methods

1160
01:02:47,339 --> 01:02:52,339
in those classes and we don't
care what the parameters are.

1161
01:02:52,419 --> 01:02:54,339
I hated writing that,

1162
01:02:54,339 --> 01:02:56,599
if you're in any confusion
there do feel free

1163
01:02:56,599 --> 01:03:00,120
to look back on our
previous chapter on AOP.

1164
01:03:00,120 --> 01:03:02,880
What we're doing is we're
saying that for transactions

1165
01:03:02,880 --> 01:03:05,020
we want to scheme through

1166
01:03:05,020 --> 01:03:08,612
every single one of the services classes,

1167
01:03:09,740 --> 01:03:12,822
and the for each of those services classes

1168
01:03:12,822 --> 01:03:15,362
we're going to apply this advice

1169
01:03:15,362 --> 01:03:18,883
but only to the methods
that are defined here.

1170
01:03:18,883 --> 01:03:21,484
As it happens for us
it's all of the methods

1171
01:03:21,484 --> 01:03:24,464
but we could have been a
little bit more choosy.

1172
01:03:24,464 --> 01:03:27,504
I know that usually
you can see the methods

1173
01:03:27,504 --> 01:03:30,404
using this asterisk here,

1174
01:03:30,404 --> 01:03:32,126
but because in transactions you might need

1175
01:03:32,126 --> 01:03:34,466
to give further information.

1176
01:03:34,466 --> 01:03:38,217
For instance you can set
up read only transactions

1177
01:03:38,217 --> 01:03:40,501
and we would configure that in here.

1178
01:03:41,428 --> 01:03:42,751
I didn't enjoy that,

1179
01:03:42,751 --> 01:03:44,911
as I said it's a little bit harder

1180
01:03:44,911 --> 01:03:46,911
than using the annotations,

1181
01:03:46,911 --> 01:03:50,061
but let's give that a
run and see if it works.

1182
01:03:51,592 --> 01:03:53,412
And yes that looks good,

1183
01:03:53,412 --> 01:03:55,592
we're now seeing the login back on

1184
01:03:55,592 --> 01:03:57,953
and we have a transaction wrapped around

1185
01:03:57,953 --> 01:04:00,173
every single one of the methods.

1186
01:04:00,173 --> 01:04:02,933
As I say I'm not a fan

1187
01:04:02,933 --> 01:04:05,453
of using the XML style

1188
01:04:05,453 --> 01:04:08,454
for configuring transactions.

1189
01:04:08,454 --> 01:04:11,134
You might be a bit surprised
to hear me say that

1190
01:04:11,134 --> 01:04:12,555
because in the previous chapters

1191
01:04:12,555 --> 01:04:16,115
when we looked at just regular AOP,

1192
01:04:16,115 --> 01:04:19,176
when we were doing things
such as performance timing,

1193
01:04:19,176 --> 01:04:22,317
I showed you a similar simplification

1194
01:04:22,317 --> 01:04:27,317
where we could either
use XML or annotations,

1195
01:04:27,557 --> 01:04:30,799
and that time around I
said, well, it's up to you,

1196
01:04:30,799 --> 01:04:34,719
but I hate using annotations for AOP,

1197
01:04:34,719 --> 01:04:38,190
so why do I have a different feeling here?

1198
01:04:38,190 --> 01:04:40,742
It's all to do with coupling really

1199
01:04:40,742 --> 01:04:43,923
and the point cuts that we've got here.

1200
01:04:43,923 --> 01:04:46,724
Remember the point cuts
allow us to configure

1201
01:04:46,724 --> 01:04:50,434
where and when advice is applied.

1202
01:04:50,434 --> 01:04:54,907
With regular AOP for things
such as performance timing,

1203
01:04:54,907 --> 01:04:58,868
I much prefer to have
those here in the XML,

1204
01:04:58,868 --> 01:05:00,728
so that I can tweak them,

1205
01:05:00,728 --> 01:05:04,529
I can change the, I can
switch them on and off,

1206
01:05:04,529 --> 01:05:06,192
inc@configuration file

1207
01:05:06,192 --> 01:05:08,982
without having to recompile any code.

1208
01:05:09,933 --> 01:05:14,359
For transactions though these
have a very different feel.

1209
01:05:14,359 --> 01:05:17,100
Looking here at our Book Service,

1210
01:05:17,100 --> 01:05:20,960
I cannot imagine the situation
where this book service

1211
01:05:20,960 --> 01:05:23,360
is not going to be transactional,

1212
01:05:23,360 --> 01:05:25,951
because we're using Dao therefore

1213
01:05:25,951 --> 01:05:28,994
clearly we need transactions.

1214
01:05:28,994 --> 01:05:30,826
It feels to me as though transactions

1215
01:05:30,826 --> 01:05:33,568
are almost kind of hard
baked into the class

1216
01:05:33,568 --> 01:05:38,568
so I have no qualms about
using an annotation here,

1217
01:05:38,911 --> 01:05:43,091
and not likely to need to
change the transactional major,

1218
01:05:43,091 --> 01:05:44,706
of the class very often,

1219
01:05:44,706 --> 01:05:46,646
and if I was changing it.

1220
01:05:46,646 --> 01:05:49,782
I'm probably doing major re-architecting

1221
01:05:49,782 --> 01:05:53,480
and not need to retest
and recompile anyway,

1222
01:05:53,480 --> 01:05:57,230
so for me, and in fact many
of the projects I work with,

1223
01:05:57,230 --> 01:06:02,230
this using the tx: advice tag
is just a little bit too fiddly

1224
01:06:03,290 --> 01:06:07,034
and doesn't really give
you all that much extra.

1225
01:06:08,055 --> 01:06:10,401
For the rest of the course
and for the purposes

1226
01:06:10,401 --> 01:06:12,380
of the practical code

1227
01:06:12,380 --> 01:06:15,118
that I've given you in the
Practicals and Code folder.

1228
01:06:15,118 --> 01:06:19,588
From this point on I'm
going to use the tx:

1229
01:06:19,588 --> 01:06:21,949
annotation driven tag,

1230
01:06:21,949 --> 01:06:24,569
and that's the only XML I need

1231
01:06:24,569 --> 01:06:27,307
to switch transactions on.

1232
01:06:27,307 --> 01:06:32,027
As long as my classes have
the transactional annotation.

1233
01:06:32,027 --> 01:06:33,284
As we go through the rest of the course

1234
01:06:33,284 --> 01:06:35,144
you're going to see
there are some parameters

1235
01:06:35,144 --> 01:06:37,283
we can plug into here too,

1236
01:06:37,283 --> 01:06:40,439
and make the transactions
work slightly differently,

1237
01:06:40,439 --> 01:06:45,439
but for most cases all you
need is that single annotation.

1238
01:06:45,917 --> 01:06:49,060
Along chapter that but not
mention the layer of code

1239
01:06:49,060 --> 01:06:53,981
quick tag a few annotations
and you're good to go.

1240
01:06:53,981 --> 01:06:57,340
We've seen that the
default behavior for JDBC

1241
01:06:57,340 --> 01:07:02,340
is to Autocommit and that's
really not a good thing.

1242
01:07:02,501 --> 01:07:05,123
We need proper transactions,

1243
01:07:05,123 --> 01:07:08,045
but when you have multiple
tiers you need to recognize

1244
01:07:08,045 --> 01:07:11,780
that you can't just have half
coded commits in the Daos.

1245
01:07:12,709 --> 01:07:16,552
We call these high level
service based transactions,

1246
01:07:16,552 --> 01:07:18,603
Application Transactions.

1247
01:07:19,613 --> 01:07:22,053
To make them work we'll use advice

1248
01:07:22,053 --> 01:07:24,691
wrapped around the services,

1249
01:07:24,691 --> 01:07:29,691
we've got a choice, usually
AOP is best done using XML,

1250
01:07:30,003 --> 01:07:31,422
not here.

1251
01:07:31,422 --> 01:07:34,468
Annotations are in my
opinion the cleanest way

1252
01:07:34,468 --> 01:07:35,790
of making them work,

1253
01:07:35,790 --> 01:07:39,431
and most projects use this approach.

1254
01:07:39,431 --> 01:07:42,360
You can use XML if you prefer.

1255
01:07:43,853 --> 01:07:45,660
There's more to came with Transactions

1256
01:07:45,660 --> 01:07:47,947
and we have three chapters in fact,

1257
01:07:47,947 --> 01:07:49,113
so you'll want a good break

1258
01:07:49,113 --> 01:07:53,019
before rejoining me for
Transaction Propagation.

1259
01:07:53,019 --> 01:07:54,258
(funky music)

1
00:00:00,491 --> 00:00:05,491
(easy listening dance music)

2
00:00:10,811 --> 00:00:12,545
- Welcome back to Chapter 18.

3
00:00:12,545 --> 00:00:16,153
This chapter concentrates
on propagation rules.

4
00:00:16,153 --> 00:00:18,197
We won't need to do much coding.

5
00:00:18,197 --> 00:00:21,132
This is a bit of a theory chapter.

6
00:00:21,132 --> 00:00:23,158
What I'll be looking
here is what happens if

7
00:00:23,158 --> 00:00:26,589
we have one method that
is marked as needing

8
00:00:26,589 --> 00:00:27,901
a transaction.

9
00:00:27,901 --> 00:00:31,912
And it calls another
method that is also marked

10
00:00:31,912 --> 00:00:34,281
as needing a transaction.

11
00:00:34,281 --> 00:00:36,537
Will we get two transactions?

12
00:00:36,537 --> 00:00:39,277
Or just one transaction?

13
00:00:39,277 --> 00:00:41,117
Well, let's find out.

14
00:00:41,117 --> 00:00:44,309
It turns out that the
default behavior in this case

15
00:00:44,309 --> 00:00:47,900
is almost always what you want.

16
00:00:47,900 --> 00:00:51,632
However, you can tune
that default behavior.

17
00:00:51,632 --> 00:00:54,367
It's quite rare, the need to do so.

18
00:00:54,367 --> 00:00:58,766
But you do it using the so
called propagation rules.

19
00:00:58,766 --> 00:01:00,322
Although you won't need them very often,

20
00:01:00,322 --> 00:01:03,186
I think it's useful to understand them.

21
00:01:03,186 --> 00:01:05,502
And firmly, so that you'll
know that you're not missing

22
00:01:05,502 --> 00:01:10,502
out on anything by
relying on the defaults.

23
00:01:12,511 --> 00:01:15,620
I'm returning back to
the buy book method in

24
00:01:15,620 --> 00:01:18,133
the purchasing service.

25
00:01:18,133 --> 00:01:20,877
And in the previous chapter, we applied

26
00:01:20,877 --> 00:01:24,888
transactional advice to
the entire purchasing

27
00:01:24,888 --> 00:01:27,818
service class.

28
00:01:27,818 --> 00:01:30,005
And that means, that
when a client calls the

29
00:01:30,005 --> 00:01:33,968
buy book method, Spring
will automatically begin

30
00:01:33,968 --> 00:01:37,783
a transaction at the start of the method,

31
00:01:37,783 --> 00:01:40,690
and at the end of the
method, it will commit

32
00:01:40,690 --> 00:01:45,684
the transaction assuming that
everything has gone well.

33
00:01:45,684 --> 00:01:48,022
Now, if an unchecked
exception is thrown, then the

34
00:01:48,022 --> 00:01:50,684
transaction will be rolled back.

35
00:01:50,684 --> 00:01:54,633
And we'll talk about that a
little bit later in the course.

36
00:01:54,633 --> 00:01:58,071
Now, we've also applied
transactional advice

37
00:01:58,071 --> 00:02:01,896
to all of our other services as well.

38
00:02:01,896 --> 00:02:05,756
You saw that, for example,
we applied the advice to our

39
00:02:05,756 --> 00:02:08,275
book service as well.

40
00:02:08,275 --> 00:02:11,518
So, I'm showing you here,
a different service.

41
00:02:11,518 --> 00:02:14,772
And in particular, I'm
looking here at the delete

42
00:02:14,772 --> 00:02:16,626
book method.

43
00:02:16,626 --> 00:02:21,301
If we were going to call
directly from a client,

44
00:02:21,301 --> 00:02:26,178
the delete book method, then, once again,

45
00:02:26,178 --> 00:02:30,336
Spring will apply a
transaction to that method.

46
00:02:30,336 --> 00:02:33,371
We would see a begin
transaction at the beginning

47
00:02:33,371 --> 00:02:36,563
of delete book, and the
commit to transaction

48
00:02:36,563 --> 00:02:38,954
at the end of the method.

49
00:02:38,954 --> 00:02:42,314
Now, what we're looking
at in this chapter,

50
00:02:42,314 --> 00:02:46,188
is what's going to happen
if we have a transactional

51
00:02:46,188 --> 00:02:51,188
method calling another
transactional method?

52
00:02:53,013 --> 00:02:56,905
In fact, that's exactly the
scenario we have in buy book.

53
00:02:56,905 --> 00:02:59,511
I'm just showing you here
what the code looks like

54
00:02:59,511 --> 00:03:01,665
inside buy book.

55
00:03:01,665 --> 00:03:06,298
And focus on this line
here, we're calling the

56
00:03:06,298 --> 00:03:11,298
delete book method from buy book.

57
00:03:11,499 --> 00:03:13,666
So, what happens here?

58
00:03:13,666 --> 00:03:18,115
We've annotated that the book
service is transactional.

59
00:03:18,115 --> 00:03:20,063
So, what will Spring do?

60
00:03:20,063 --> 00:03:23,827
Will it create a new
transaction for delete book,

61
00:03:23,827 --> 00:03:26,994
or will it somehow reuse the old one?

62
00:03:26,994 --> 00:03:29,098
What is going to happen?

63
00:03:29,098 --> 00:03:30,989
Now, the quick answer to this question,

64
00:03:30,989 --> 00:03:35,853
is that by default, we
can change this behavior

65
00:03:35,853 --> 00:03:40,802
as we'll see, but the default
is that when the delete book

66
00:03:40,802 --> 00:03:45,730
method is called, Spring will
identify that there is already

67
00:03:45,730 --> 00:03:48,037
a transaction open.

68
00:03:48,037 --> 00:03:52,206
The parent method has already
created a transaction.

69
00:03:52,206 --> 00:03:55,653
So, what will happen, is
that the child method,

70
00:03:55,653 --> 00:04:00,523
in this case, delete book,
it will simply join in

71
00:04:00,523 --> 00:04:02,943
the parent method's transaction.

72
00:04:02,943 --> 00:04:06,354
So, that means, for the buy book process,

73
00:04:06,354 --> 00:04:10,284
we will see a kind of big transaction,

74
00:04:10,284 --> 00:04:13,062
spanning the two methods.

75
00:04:13,062 --> 00:04:17,037
And going further, if
we had seven methods,

76
00:04:17,037 --> 00:04:22,037
linked in a chain, there
will still only be one begin,

77
00:04:22,076 --> 00:04:24,323
and one commit.

78
00:04:24,323 --> 00:04:27,754
And the commit will happen
when the parent method

79
00:04:27,754 --> 00:04:29,629
is completed.

80
00:04:29,629 --> 00:04:33,633
Now, this is almost always
what we want to happen.

81
00:04:33,633 --> 00:04:38,633
The first method in the
chain is a business process.

82
00:04:38,768 --> 00:04:42,417
And the sub methods, or the child methods

83
00:04:42,417 --> 00:04:47,417
are just small intermediate
steps in that process.

84
00:04:47,851 --> 00:04:51,692
And that's why, we've called
transactions on this course

85
00:04:51,692 --> 00:04:54,842
application transactions.

86
00:04:54,842 --> 00:04:58,787
It's to remind you that they
don't really wrap around

87
00:04:58,787 --> 00:05:01,581
single database operations.

88
00:05:01,581 --> 00:05:04,568
They wrap around the
application's business

89
00:05:04,568 --> 00:05:07,752
processes at the service level.

90
00:05:07,752 --> 00:05:10,770
Now, this behavior is the default.

91
00:05:10,770 --> 00:05:14,614
We have to do no work for that to happen.

92
00:05:14,614 --> 00:05:17,469
So, what I'll do now, is I'll
switch across to eclipse,

93
00:05:17,469 --> 00:05:22,290
and show you the buy book
method in live action.

94
00:05:22,290 --> 00:05:25,850
And we'll use the login
to check that we really do

95
00:05:25,850 --> 00:05:30,413
only get one transaction
wrapping the whole process.

96
00:05:30,413 --> 00:05:32,461
So, here we are back in eclipse.

97
00:05:32,461 --> 00:05:36,052
And here is the purchasing service.

98
00:05:36,052 --> 00:05:37,381
And remember that we have made that

99
00:05:37,381 --> 00:05:39,590
plus transactional.

100
00:05:39,590 --> 00:05:41,837
Now, one problem with the
code that I've given you

101
00:05:41,837 --> 00:05:45,244
so far is that at present,
the buy book method isn't

102
00:05:45,244 --> 00:05:47,247
quite complete.

103
00:05:47,247 --> 00:05:50,813
All I'm doing at present,
is I'm finding the book,

104
00:05:50,813 --> 00:05:55,385
and then I'm calling raising
voice on the account service.

105
00:05:55,385 --> 00:05:57,186
So, I'm sorry, that's my bad.

106
00:05:57,186 --> 00:06:00,449
I just didn't quite complete
the code before I put this

107
00:06:00,449 --> 00:06:02,651
in the starting work specs.

108
00:06:02,651 --> 00:06:06,822
So, we can upgrade that now.

109
00:06:06,822 --> 00:06:07,874
And remember, you don't
have to follow along with me

110
00:06:07,874 --> 00:06:10,244
in this chapter, because
you'll be getting a full chance

111
00:06:10,244 --> 00:06:13,188
to do practical work
when we come back to the

112
00:06:13,188 --> 00:06:16,456
CRM system but, it you are
following along with me,

113
00:06:16,456 --> 00:06:20,920
then we just need to add in
a line to delete the book

114
00:06:20,920 --> 00:06:22,053
from stock.

115
00:06:22,053 --> 00:06:26,229
And we'll be doing that by
calling the book service.

116
00:06:26,229 --> 00:06:30,033
I've called the book service
just books in this class.

117
00:06:30,033 --> 00:06:32,677
And unfortunately, we don't
presently have a method

118
00:06:32,677 --> 00:06:35,175
to support that operation.

119
00:06:35,175 --> 00:06:37,384
So, I'm going to need to add that in.

120
00:06:37,384 --> 00:06:40,559
So, we'll call that delete from stock,

121
00:06:40,559 --> 00:06:45,559
and we'll pass in the book as a parameter.

122
00:06:46,162 --> 00:06:48,618
Now, we're going to
need to add this method,

123
00:06:48,618 --> 00:06:53,618
delete from stock to the
book service interface

124
00:06:54,273 --> 00:06:57,346
first of all.

125
00:06:57,346 --> 00:06:59,647
So, we'll make that avoid method,

126
00:06:59,647 --> 00:07:04,647
delete from stock, and we'll
call the parameter Old Book.

127
00:07:08,085 --> 00:07:11,069
Now, we have two implementations at this

128
00:07:11,069 --> 00:07:12,825
service interface.

129
00:07:12,825 --> 00:07:14,701
I'll start with the mock implementation.

130
00:07:14,701 --> 00:07:18,138
Remember, we wrote that
very early on in the course.

131
00:07:18,138 --> 00:07:20,425
And, it's a bit of a
debate you need to make

132
00:07:20,425 --> 00:07:24,459
with yourself really, with
these prototype implementations.

133
00:07:24,459 --> 00:07:26,869
Once you've got your
production implementation,

134
00:07:26,869 --> 00:07:30,670
you could delete this
prototype implementation,

135
00:07:30,670 --> 00:07:34,965
but sometimes they'll still
useful for testing and so on.

136
00:07:34,965 --> 00:07:38,269
So, I'm going to keep this implementation.

137
00:07:38,269 --> 00:07:42,718
But it will mean that I
need to create some kind of

138
00:07:42,718 --> 00:07:47,718
implementation of delete from stock.

139
00:07:49,438 --> 00:07:51,119
And because we're working with a map,

140
00:07:51,119 --> 00:07:53,454
this is just going to be standard Java.

141
00:07:53,454 --> 00:07:57,273
We'll take the test books,
and we'll do a remove,

142
00:07:57,273 --> 00:07:59,888
and we just need the key of the book,

143
00:07:59,888 --> 00:08:04,016
which is for ISBNs.

144
00:08:04,016 --> 00:08:07,693
So, I'll extract the
ISBN, and remove that book

145
00:08:07,693 --> 00:08:09,616
from the map.

146
00:08:09,616 --> 00:08:14,616
The important one though, is
the production implementation,

147
00:08:15,369 --> 00:08:17,903
and of course, I have
an error on that class,

148
00:08:17,903 --> 00:08:20,478
because I'm missing a method.

149
00:08:20,478 --> 00:08:24,031
I'll quick fix this one,
a left click on there,

150
00:08:24,031 --> 00:08:28,443
and I can select add
on implemented methods.

151
00:08:28,443 --> 00:08:30,845
It has created me a
skeleton implementation

152
00:08:30,845 --> 00:08:32,722
here at the bottom.

153
00:08:32,722 --> 00:08:35,613
And I think we're finished
now because I believe

154
00:08:35,613 --> 00:08:40,613
on the day, we did implement
a full implementation

155
00:08:40,932 --> 00:08:44,926
of the delete method, and
I just have to pass in

156
00:08:44,926 --> 00:08:48,556
the old book as a parameter.

157
00:08:48,556 --> 00:08:51,009
So, I'm sorry that that
wasn't in place before

158
00:08:51,009 --> 00:08:52,930
this exercise.

159
00:08:52,930 --> 00:08:54,524
Something else I ought to mention.

160
00:08:54,524 --> 00:08:58,330
If I go back to the purchasing service,

161
00:08:58,330 --> 00:09:01,815
so the first line of code
is not that important.

162
00:09:01,815 --> 00:09:05,363
But the two operations that
we're carrying out here,

163
00:09:05,363 --> 00:09:08,039
the delete from stock, and raising voice,

164
00:09:08,039 --> 00:09:10,940
remember we want these two operations

165
00:09:10,940 --> 00:09:14,492
to be combined into a single transaction.

166
00:09:14,492 --> 00:09:18,586
Now, a slight problem is,
with our account service,

167
00:09:18,586 --> 00:09:20,962
we only have a mock implementation.

168
00:09:20,962 --> 00:09:24,107
So, we're not actually going
to be doing any database

169
00:09:24,107 --> 00:09:28,434
operations for real in this exercise.

170
00:09:28,434 --> 00:09:30,849
Now, that doesn't actually
matter because what we're

171
00:09:30,849 --> 00:09:35,020
interested in, is making
sure that there is a commit

172
00:09:35,020 --> 00:09:37,047
in the right place.

173
00:09:37,047 --> 00:09:39,993
And that means at the end
of the buy book method.

174
00:09:39,993 --> 00:09:42,565
In fact, there wasn't
any database operations

175
00:09:42,565 --> 00:09:45,598
and raising voice doesn't really matter.

176
00:09:45,598 --> 00:09:46,992
If you're not happy with that though,

177
00:09:46,992 --> 00:09:49,519
of course you could
implement a full production

178
00:09:49,519 --> 00:09:52,755
implementation of the account service.

179
00:09:52,755 --> 00:09:55,518
But that will get in the
way of this exercise.

180
00:09:55,518 --> 00:09:59,248
So, what I want to do now,
is go back to the client,

181
00:09:59,248 --> 00:10:00,965
and here's the operations we're doing

182
00:10:00,965 --> 00:10:02,678
in an earlier chapter.

183
00:10:02,678 --> 00:10:05,126
Now, because I'm doing a
completely different example

184
00:10:05,126 --> 00:10:08,150
this time, I'm going to
delete the code from the

185
00:10:08,150 --> 00:10:11,220
previous chapter, where we
were playing around with

186
00:10:11,220 --> 00:10:13,793
various operations.

187
00:10:13,793 --> 00:10:16,369
And this time around, I'm
going to work with the

188
00:10:16,369 --> 00:10:19,885
purchasing service.

189
00:10:19,885 --> 00:10:24,096
I'll call it purchasing, and we'll extract

190
00:10:24,096 --> 00:10:25,788
from the container.

191
00:10:25,788 --> 00:10:28,437
And I'm going to use this form of the

192
00:10:28,437 --> 00:10:30,237
get beam method.

193
00:10:30,237 --> 00:10:34,810
So, that's going to allow me to call the

194
00:10:34,810 --> 00:10:39,810
buy book method, based on an ISBN.

195
00:10:42,461 --> 00:10:45,895
Now, that might throw an exception

196
00:10:45,895 --> 00:10:50,321
if the book doesn't exist
with that particular

197
00:10:50,321 --> 00:10:52,483
ISBN number.

198
00:10:52,483 --> 00:10:54,974
So, of course, we need to handle that.

199
00:10:54,974 --> 00:10:57,298
We'll catch the book not found exception,

200
00:10:57,298 --> 00:10:59,627
and we can handle that very easily.

201
00:10:59,627 --> 00:11:04,627
Sorry, that book doesn't exist.

202
00:11:04,647 --> 00:11:07,625
Well, I just made this ISBN number up.

203
00:11:07,625 --> 00:11:09,677
It was just a random number.

204
00:11:09,677 --> 00:11:13,189
So, in fact, if I run this
code now, we should see

205
00:11:13,189 --> 00:11:16,374
that error.

206
00:11:16,374 --> 00:11:18,337
Ok, well that ran through successfully.

207
00:11:18,337 --> 00:11:20,869
You can see, the sorry
the book doesn't exist.

208
00:11:20,869 --> 00:11:23,841
And we'll study the login in a few moments

209
00:11:23,841 --> 00:11:26,863
when we got this code working properly.

210
00:11:26,863 --> 00:11:31,161
I think what I'd like to
do is to enter this book

211
00:11:31,161 --> 00:11:34,474
onto the system so that
the purchasing of the book

212
00:11:34,474 --> 00:11:36,153
should work.

213
00:11:36,153 --> 00:11:38,608
So, to do that, I am going
to have to make a call

214
00:11:38,608 --> 00:11:43,608
directly on the book service.

215
00:11:48,797 --> 00:11:50,638
So, I'll get the book service as well.

216
00:11:50,638 --> 00:11:53,944
Now, we've got to be careful
to think this through

217
00:11:53,944 --> 00:11:54,680
properly.

218
00:11:54,680 --> 00:11:57,502
So, I'm going to call register new book.

219
00:11:57,502 --> 00:12:02,502
I'm going create a new book
with exactly that ISBN.

220
00:12:05,528 --> 00:12:07,322
We'll need the other parameters as well,

221
00:12:07,322 --> 00:12:12,322
or just do a test title.

222
00:12:12,912 --> 00:12:17,912
And author, and I think
next field is a price.

223
00:12:18,188 --> 00:12:20,270
Ok, so now, that book will exist,

224
00:12:20,270 --> 00:12:22,070
and this process should work.

225
00:12:22,070 --> 00:12:24,521
Before I run this, just
think very carefully about

226
00:12:24,521 --> 00:12:26,727
what's going to happen here.

227
00:12:26,727 --> 00:12:30,285
This register new book,
because we're calling that

228
00:12:30,285 --> 00:12:35,285
directly from the client will
get it's own transaction.

229
00:12:35,302 --> 00:12:39,362
So, I would expect to see a begin here,

230
00:12:39,362 --> 00:12:43,159
and a commit here.

231
00:12:43,159 --> 00:12:46,388
And that's fine, because
this is kind of its own

232
00:12:46,388 --> 00:12:49,211
separate business process.

233
00:12:49,211 --> 00:12:51,776
But then, because we're
starting a new use case,

234
00:12:51,776 --> 00:12:54,522
we'll expect to begin here.

235
00:12:54,522 --> 00:12:59,202
And we'll effectively, a commit here,

236
00:12:59,202 --> 00:13:01,709
and we don't want an
extra begin and commit

237
00:13:01,709 --> 00:13:05,622
wrapped around all of the
steps involved in buy book.

238
00:13:05,622 --> 00:13:07,221
So, I hope that's reasonably clear.

239
00:13:07,221 --> 00:13:09,967
It can get quite
complicated, tracking these

240
00:13:09,967 --> 00:13:12,583
transaction boundaries.

241
00:13:12,583 --> 00:13:17,313
Well, we need to see if that even works.

242
00:13:17,313 --> 00:13:20,871
And we've got lots of login here.

243
00:13:20,871 --> 00:13:22,946
Now, I hope that doesn't put you off.

244
00:13:22,946 --> 00:13:25,115
But the login combined
with our performance

245
00:13:25,115 --> 00:13:28,495
timing advice is going to
really be quite useful.

246
00:13:28,495 --> 00:13:31,116
So, looking through the
first three lines of

247
00:13:31,116 --> 00:13:33,518
login here, we're seeing here,

248
00:13:33,518 --> 00:13:36,426
switching JDBC connection.

249
00:13:36,426 --> 00:13:39,539
I'll need to scroll to the
right to manual commit.

250
00:13:39,539 --> 00:13:40,765
So, that's good.

251
00:13:40,765 --> 00:13:45,018
That means that we are
running proper transactions.

252
00:13:45,018 --> 00:13:49,142
Now, we're entering the
register new book method,

253
00:13:49,142 --> 00:13:53,786
and the next line of login,
is where it's telling us

254
00:13:53,786 --> 00:13:57,813
it's committing the
registering of the new book.

255
00:13:57,813 --> 00:14:02,030
And when you see
releasing JDBC Connection,

256
00:14:02,030 --> 00:14:05,856
you know that effectively
that use case is complete.

257
00:14:05,856 --> 00:14:09,491
So, those three lines of login work for

258
00:14:09,491 --> 00:14:11,466
register for new book.

259
00:14:11,466 --> 00:14:13,642
But now, the important
bit, we're about to go

260
00:14:13,642 --> 00:14:16,501
into the buy book method.

261
00:14:16,501 --> 00:14:18,953
Now, by the way, the transaction advice

262
00:14:18,953 --> 00:14:23,953
is kicking in before our
performance timing advice.

263
00:14:23,986 --> 00:14:26,875
And we'll have a look
later at how you can change

264
00:14:26,875 --> 00:14:28,942
the ordering of advice.

265
00:14:28,942 --> 00:14:30,785
But, that's the default ordering.

266
00:14:30,785 --> 00:14:34,218
So, we're in fact seeing the
creating of the transaction

267
00:14:34,218 --> 00:14:35,758
for buy book.

268
00:14:35,758 --> 00:14:38,832
We're seeing a login of
that before we actually see

269
00:14:38,832 --> 00:14:40,952
that we've entered the method.

270
00:14:40,952 --> 00:14:43,689
The really important thing is that we have

271
00:14:43,689 --> 00:14:47,210
creating new transaction here,

272
00:14:47,210 --> 00:14:50,032
and you can pause the video if you want

273
00:14:50,032 --> 00:14:53,753
to pick your way through
the rest of the login,

274
00:14:53,753 --> 00:14:57,613
but a key thing is we
can only see one commit.

275
00:14:57,613 --> 00:14:59,828
And that's here at the bottom.

276
00:14:59,828 --> 00:15:03,746
And that is fact, when
buy book is completed.

277
00:15:03,746 --> 00:15:08,030
And crucially, I think,
if you look at the delete

278
00:15:08,030 --> 00:15:10,761
from stock method here,

279
00:15:10,761 --> 00:15:13,061
the line of login before it,

280
00:15:13,061 --> 00:15:18,061
wonderfully is saying participating
in existing transaction.

281
00:15:20,074 --> 00:15:22,537
In fact, there's another one there.

282
00:15:22,537 --> 00:15:25,519
That's before we called the
get book by ISBN method,

283
00:15:25,519 --> 00:15:30,059
which is in fact, the first
step in the buy book process.

284
00:15:30,059 --> 00:15:34,065
So, we had one transaction for
the registering of the book.

285
00:15:34,065 --> 00:15:36,919
That was a separate
business process, but then

286
00:15:36,919 --> 00:15:41,919
one big transaction for
the whole of buying a book.

287
00:15:42,307 --> 00:15:45,615
Now, this default behavior,
that you've just seen

288
00:15:45,615 --> 00:15:49,169
is good for most cases.

289
00:15:49,169 --> 00:15:52,929
So, often, you just put the
transactional annotation

290
00:15:52,929 --> 00:15:57,080
on your service class,
and you're good to go.

291
00:15:57,080 --> 00:16:01,740
But sometimes, and it really
is only just sometimes,

292
00:16:01,740 --> 00:16:06,030
you might want to tune
that default behavior.

293
00:16:06,030 --> 00:16:08,908
Now, I'll warn you, what's coming up here,

294
00:16:08,908 --> 00:16:13,908
is called propagation rules
and is a little bit tricky.

295
00:16:13,933 --> 00:16:16,579
At least the first time you
see this, it can be a bit

296
00:16:16,579 --> 00:16:19,081
of a struggle to understand it.

297
00:16:19,081 --> 00:16:22,059
But, I don't want you to
worry, because as long as

298
00:16:22,059 --> 00:16:24,157
you've understand that default behavior

299
00:16:24,157 --> 00:16:26,418
that you've just seen in eclipse,

300
00:16:26,418 --> 00:16:29,642
then that's what you're going
to use most of the time.

301
00:16:29,642 --> 00:16:33,692
So, don't worry too much
about these propagation rules,

302
00:16:33,692 --> 00:16:37,205
because you don't really
need them that often.

303
00:16:37,205 --> 00:16:39,453
But the point of this,
is that we can change

304
00:16:39,453 --> 00:16:41,989
the default behavior.

305
00:16:41,989 --> 00:16:44,191
Now, what we can do for any method,

306
00:16:44,191 --> 00:16:47,128
that we've set up as
being as transactional,

307
00:16:47,128 --> 00:16:52,128
is we can supply Spring with
one of seven different values.

308
00:16:52,812 --> 00:16:56,868
And this value is used
by Spring to determine

309
00:16:56,868 --> 00:17:01,565
whether it should start
a new transaction or not.

310
00:17:01,565 --> 00:17:03,732
Now, what I'm going to do first of all,

311
00:17:03,732 --> 00:17:07,483
is I'm going to show you
these seven different values

312
00:17:07,483 --> 00:17:09,562
that you can choose from.

313
00:17:09,562 --> 00:17:11,526
And then, we'll have a
look at what each of the

314
00:17:11,526 --> 00:17:13,979
seven values mean.

315
00:17:13,979 --> 00:17:15,285
Now, the values by the way,

316
00:17:15,285 --> 00:17:19,228
are called the propagation rules.

317
00:17:19,228 --> 00:17:23,678
And the seven values that
we can choose from are,

318
00:17:23,678 --> 00:17:26,250
they're quite strange labels these,

319
00:17:26,250 --> 00:17:31,250
they are required,
supports, not supported,

320
00:17:35,006 --> 00:17:40,006
requires new, never, mandatory,

321
00:17:41,772 --> 00:17:45,946
and the final one is nested.

322
00:17:45,946 --> 00:17:49,458
I find these values quite strange.

323
00:17:49,458 --> 00:17:53,259
I don't think any of them
are self-explanatory.

324
00:17:53,259 --> 00:17:56,941
If I were to ask you to think about what

325
00:17:56,941 --> 00:17:59,576
not supported means,
I think you'd probably

326
00:17:59,576 --> 00:18:02,845
struggle to work it out from scratch.

327
00:18:02,845 --> 00:18:05,047
Now, this isn't really Spring's fault.

328
00:18:05,047 --> 00:18:08,285
These values were originally designed by

329
00:18:08,285 --> 00:18:10,894
the EJB standard.

330
00:18:10,894 --> 00:18:13,838
And what Spring have
decided to do, is they've

331
00:18:13,838 --> 00:18:18,244
decided to support the same
values that are present

332
00:18:18,244 --> 00:18:20,527
in the EJB Standard.

333
00:18:20,527 --> 00:18:23,465
And that's kind of to make Spring work in

334
00:18:23,465 --> 00:18:28,465
a coherent way with the
existing Java EE standard.

335
00:18:29,832 --> 00:18:33,451
In fact, if you've been in
our Java EE training course,

336
00:18:33,451 --> 00:18:35,821
you will recognize all of these values.

337
00:18:35,821 --> 00:18:40,461
And they work exactly
the same as in Java EE.

338
00:18:40,461 --> 00:18:43,253
Now, before I show what
the propagation rules

339
00:18:43,253 --> 00:18:46,406
actually mean, I'm going
to show you how to change

340
00:18:46,406 --> 00:18:49,145
the propagation rules in the code.

341
00:18:49,145 --> 00:18:51,708
Let's say we're in our book service

342
00:18:51,708 --> 00:18:53,722
production implementation,

343
00:18:53,722 --> 00:18:58,722
and we decide that we don't
want the default behavior for

344
00:18:59,116 --> 00:19:01,550
this particular class.

345
00:19:01,550 --> 00:19:04,831
Well, what we can do is
plug here a parameter

346
00:19:04,831 --> 00:19:07,938
called propagation.

347
00:19:07,938 --> 00:19:11,988
And you set it to the value
of where there is a class

348
00:19:11,988 --> 00:19:16,038
in the Spring framework
called propagation.

349
00:19:16,038 --> 00:19:19,099
And that's really just a helper class

350
00:19:19,099 --> 00:19:21,272
that contains some constants.

351
00:19:21,272 --> 00:19:23,760
You see as soon as I press that dot,

352
00:19:23,760 --> 00:19:27,068
all seven of the values
that you just saw on

353
00:19:27,068 --> 00:19:30,784
the previous caption are in that list.

354
00:19:30,784 --> 00:19:34,060
So, if I wanted to change
the default behavior

355
00:19:34,060 --> 00:19:38,551
of the book service, I could
choose any of these values

356
00:19:38,551 --> 00:19:42,484
such as requires new, and I've changed the

357
00:19:42,484 --> 00:19:44,613
default behavior.

358
00:19:44,613 --> 00:19:46,577
So, that's easy to do.

359
00:19:46,577 --> 00:19:49,107
The tricky bit is understanding what those

360
00:19:49,107 --> 00:19:51,385
seven values mean.

361
00:19:51,385 --> 00:19:55,608
So, we're gonna have to
do that on a caption.

362
00:19:55,608 --> 00:19:59,206
Well, the first of these seven
values that we can choose

363
00:19:59,206 --> 00:20:02,473
is the value of required.

364
00:20:02,473 --> 00:20:07,217
Now, what the required
flag, is it tells Spring

365
00:20:07,217 --> 00:20:11,138
that this method requires a transaction,

366
00:20:11,138 --> 00:20:16,138
but if the parent method has
already created a transaction,

367
00:20:16,847 --> 00:20:21,254
then it's fine for the
child method to join the

368
00:20:21,254 --> 00:20:23,459
parent method's transaction.

369
00:20:23,459 --> 00:20:28,189
Well, actually this is
the default behavior.

370
00:20:28,189 --> 00:20:32,605
So, the required
propagation rule is exactly

371
00:20:32,605 --> 00:20:35,585
the same behavior that we saw when we ran

372
00:20:35,585 --> 00:20:37,668
buy book earlier.

373
00:20:37,668 --> 00:20:42,668
So, you could if you wanted
to, explicitly specify

374
00:20:42,842 --> 00:20:46,197
propagation dot required,
but that's what you get

375
00:20:46,197 --> 00:20:47,874
for free anyway.

376
00:20:47,874 --> 00:20:50,241
You'll find that most people
on projects would just

377
00:20:50,241 --> 00:20:54,788
leave this entire piece of code out.

378
00:20:54,788 --> 00:20:56,923
But just to prove that's the
default, I'll leave required

379
00:20:56,923 --> 00:21:00,679
in there, and I'll run the client again,

380
00:21:00,679 --> 00:21:04,655
and we should see exactly
the same as before.

381
00:21:04,655 --> 00:21:07,310
And I don't know if you could tell,

382
00:21:07,310 --> 00:21:11,385
but we have the book service
methods are participating

383
00:21:11,385 --> 00:21:15,273
in the existing transaction,
and we have one commit

384
00:21:15,273 --> 00:21:16,702
at the end.

385
00:21:16,702 --> 00:21:19,689
So, that's the required propagation rule

386
00:21:19,689 --> 00:21:24,246
and it's a very good default.

387
00:21:24,246 --> 00:21:29,070
But not all methods require transactions.

388
00:21:29,070 --> 00:21:33,477
What would happen if
delete book didn't talk to

389
00:21:33,477 --> 00:21:36,587
a relational database?

390
00:21:36,587 --> 00:21:39,433
Maybe it makes its changes in memory,

391
00:21:39,433 --> 00:21:42,131
or it just executes some business logic,

392
00:21:42,131 --> 00:21:45,727
and it never talks to
a transactional store.

393
00:21:45,727 --> 00:21:50,145
Now, I know the delete
book method is probably

394
00:21:50,145 --> 00:21:53,620
not a good example here,
because you know and I know

395
00:21:53,620 --> 00:21:56,102
that yeah, that it's going
to talk to a database.

396
00:21:56,102 --> 00:21:58,190
But I want to use the delete book method

397
00:21:58,190 --> 00:22:01,503
throughout this chapter,
so if you can imagine for a

398
00:22:01,503 --> 00:22:04,365
few moments that delete
book for some reason

399
00:22:04,365 --> 00:22:08,406
on our system isn't going to
talk to a relational database,

400
00:22:08,406 --> 00:22:11,594
then what we could do
with that method is switch

401
00:22:11,594 --> 00:22:16,594
its propagation rule to
the value of support.

402
00:22:16,944 --> 00:22:21,944
Now, the English statements of
the support propagation rule

403
00:22:22,072 --> 00:22:24,533
is that for the delete
book method in this case,

404
00:22:24,533 --> 00:22:28,887
Spring does not need to bother
creating a new transaction.

405
00:22:28,887 --> 00:22:32,568
If it's called directly from a client's.

406
00:22:32,568 --> 00:22:37,568
But it doesn't matter if there
is already one in existence.

407
00:22:38,664 --> 00:22:41,560
So, there are really
two possibilities here.

408
00:22:41,560 --> 00:22:46,059
If delete book is called by
a method such as buy book

409
00:22:46,059 --> 00:22:48,474
as in the picture we have
here, and buy book method

410
00:22:48,474 --> 00:22:53,474
has the default propagation
rule of required,

411
00:22:54,097 --> 00:22:57,786
then what we'll get really is
exactly the same as before.

412
00:22:57,786 --> 00:23:02,284
We have a new transaction
begun at the start of buy book,

413
00:23:02,284 --> 00:23:06,702
and that transaction is
committed at the end of buy book.

414
00:23:06,702 --> 00:23:10,296
It's just that throughout the
progress of the delete book

415
00:23:10,296 --> 00:23:14,820
child method, no changes
were made to the database.

416
00:23:14,820 --> 00:23:18,501
However, if I change
things around a little bit

417
00:23:18,501 --> 00:23:21,363
and the propagation
rule for buy book itself

418
00:23:21,363 --> 00:23:26,363
was set to support, then what
will happen now is when we

419
00:23:26,795 --> 00:23:31,254
call buy book, Spring
won't create a transaction.

420
00:23:31,254 --> 00:23:33,946
We're calling directly from
the client, and now we're

421
00:23:33,946 --> 00:23:37,499
saying that buy book
doesn't need a transaction.

422
00:23:37,499 --> 00:23:39,663
So, Spring won't create one.

423
00:23:39,663 --> 00:23:42,684
Now, again, in our system
that would be a bad choice,

424
00:23:42,684 --> 00:23:45,915
because we are writing to a database.

425
00:23:45,915 --> 00:23:48,560
And if we use this support rule,

426
00:23:48,560 --> 00:23:50,772
then we would lose transactions.

427
00:23:50,772 --> 00:23:53,480
Well, actually, as we saw
in the previous chapter,

428
00:23:53,480 --> 00:23:56,866
if we did this and we made
calls through a database,

429
00:23:56,866 --> 00:23:59,029
we'd end up in auto commit mode,

430
00:23:59,029 --> 00:24:02,258
which is rarely a good idea.

431
00:24:02,258 --> 00:24:05,848
So, the use of support then,
is whenever a particular

432
00:24:05,848 --> 00:24:10,848
method or an entire service
class is not going to need

433
00:24:11,118 --> 00:24:13,319
any transactions.

434
00:24:13,319 --> 00:24:16,956
So, the example would be
if you have a method that

435
00:24:16,956 --> 00:24:21,956
is just working in memory,
then supports is a good choice.

436
00:24:22,511 --> 00:24:25,411
Now, almost by accident,
I do have an example

437
00:24:25,411 --> 00:24:29,048
where supports could
be useful in this code.

438
00:24:29,048 --> 00:24:31,988
Remember that our account
service is currently

439
00:24:31,988 --> 00:24:34,519
just a mock implementation.

440
00:24:34,519 --> 00:24:38,189
It's running completely in memory.

441
00:24:38,189 --> 00:24:43,091
So, what we could do is we
could set a transactional

442
00:24:43,091 --> 00:24:45,777
annotation on here,

443
00:24:45,777 --> 00:24:50,777
and we could set the propagation
rule to be propagation,

444
00:24:53,706 --> 00:24:58,706
support, and it looks
like I need to import

445
00:24:59,388 --> 00:25:01,674
the transactional annotation.

446
00:25:01,674 --> 00:25:04,047
So, this means that this
class is going to be working

447
00:25:04,047 --> 00:25:05,232
in memory.

448
00:25:05,232 --> 00:25:08,799
So, database support isn't needed.

449
00:25:08,799 --> 00:25:13,799
However, if we run the code,

450
00:25:16,973 --> 00:25:19,982
now here, down at the bottom,
I'll need a highlighter

451
00:25:19,982 --> 00:25:21,419
for this.

452
00:25:21,419 --> 00:25:24,113
That's telling us that we're
entering raising voice,

453
00:25:24,113 --> 00:25:27,870
and remember the login for
transactions comes before

454
00:25:27,870 --> 00:25:30,287
our performance timing.

455
00:25:30,287 --> 00:25:34,451
So, this line is here is
telling us that raising voice

456
00:25:34,451 --> 00:25:37,694
is participating in the
existing transaction.

457
00:25:37,694 --> 00:25:40,266
And that's fine, it's not
going to hurt anything

458
00:25:40,266 --> 00:25:43,903
that a transaction is already open.

459
00:25:43,903 --> 00:25:46,353
However, if we go back to the client.

460
00:25:46,353 --> 00:25:51,353
And I'm going to temporarily
commit out this code.

461
00:25:52,157 --> 00:25:55,431
If we had a different use
case, where we were calling

462
00:25:55,431 --> 00:26:00,431
the account service directly...

463
00:26:07,802 --> 00:26:11,239
So, this time I'm going
to call raising voice.

464
00:26:11,239 --> 00:26:14,412
It looks like I have to pass in a book.

465
00:26:14,412 --> 00:26:17,073
It really doesn't matter
what the parameters

466
00:26:17,073 --> 00:26:19,674
are for that book.

467
00:26:19,674 --> 00:26:23,152
Now, because we're calling
directly from a client,

468
00:26:23,152 --> 00:26:27,543
and we've set the
propagation rule of support,

469
00:26:27,543 --> 00:26:32,171
Spring will know that no
transaction is needed.

470
00:26:32,171 --> 00:26:34,335
And we don't even see any login

471
00:26:34,335 --> 00:26:36,827
from the transaction manager.

472
00:26:36,827 --> 00:26:41,325
So, contrast that with
the defaults if we remove

473
00:26:41,325 --> 00:26:44,473
the supports from the account service.

474
00:26:44,473 --> 00:26:49,473
Now, what we would see is
something slightly different.

475
00:26:52,524 --> 00:26:55,551
Now, can you see that what's happening now

476
00:26:55,551 --> 00:26:58,737
is that because we've got
the default propagation

477
00:26:58,737 --> 00:27:02,495
rule in place, Spring
thinks that we need a begin

478
00:27:02,495 --> 00:27:07,480
and a commit wrapped around
that raising voice method.

479
00:27:07,480 --> 00:27:10,751
But we never even wrote to
that database in that method,

480
00:27:10,751 --> 00:27:14,831
so this begin and commit was
a complete waste of time.

481
00:27:14,831 --> 00:27:17,577
So, that could harm performance.

482
00:27:17,577 --> 00:27:20,606
So, that's really the
main purpose of supports.

483
00:27:20,606 --> 00:27:25,424
To switch off transactions
where they're not needed.

484
00:27:25,424 --> 00:27:27,545
Now, you might be a bit
confused at this point.

485
00:27:27,545 --> 00:27:30,692
In fact, if you leave the annotation off,

486
00:27:30,692 --> 00:27:33,632
then Spring is not going
to apply any transactional

487
00:27:33,632 --> 00:27:38,632
advice to this class, and therefore,

488
00:27:39,937 --> 00:27:41,784
we don't get any transactions,

489
00:27:41,784 --> 00:27:44,610
which is kind of what we want here.

490
00:27:44,610 --> 00:27:47,631
But the real purpose
for having that flag is,

491
00:27:47,631 --> 00:27:49,633
let's use book service as an example,

492
00:27:49,633 --> 00:27:52,370
because there's lots of methods in here.

493
00:27:52,370 --> 00:27:54,812
Now, what I've done is
I've got the default

494
00:27:54,812 --> 00:27:58,042
propagation rule here of required.

495
00:27:58,042 --> 00:28:00,698
Remember that that's optional.

496
00:28:00,698 --> 00:28:03,232
But that means in one fell
swoop, we have a transaction

497
00:28:03,232 --> 00:28:07,317
applied to every single
one of these methods.

498
00:28:07,317 --> 00:28:12,317
But it might be, that
just one of the methods,

499
00:28:12,672 --> 00:28:16,339
let's say the get all
recommended books method.

500
00:28:16,339 --> 00:28:19,403
Now, I haven't implemented this just yet.

501
00:28:19,403 --> 00:28:22,887
But, let's say that the
entire implementation of

502
00:28:22,887 --> 00:28:26,278
that method is done in memory.

503
00:28:26,278 --> 00:28:29,299
There might be a complicated
algorithm in here,

504
00:28:29,299 --> 00:28:34,248
and that algorithm is never
going to call a database.

505
00:28:34,248 --> 00:28:37,394
Well, in that case, this
is where the flag would

506
00:28:37,394 --> 00:28:42,394
be useful because we
could override the default

507
00:28:42,666 --> 00:28:47,666
by plugging in a propagation

508
00:28:51,206 --> 00:28:53,734
of support.

509
00:28:53,734 --> 00:28:56,552
And that means now, that all
the methods in this class

510
00:28:56,552 --> 00:28:59,995
are transactional with the
default propagation rule

511
00:28:59,995 --> 00:29:04,995
except this one, which is going
to be in memory operation.

512
00:29:05,591 --> 00:29:09,182
So, that's where that
field might be useful.

513
00:29:09,182 --> 00:29:13,597
Well, the two propagation
rules of required supports

514
00:29:13,597 --> 00:29:18,597
will handle 95 or 99%
of your requirements.

515
00:29:20,949 --> 00:29:24,552
We do have five other values though.

516
00:29:24,552 --> 00:29:26,639
Not supported, requires new, never,

517
00:29:26,639 --> 00:29:29,704
mandatory, and nested.

518
00:29:29,704 --> 00:29:33,291
So, let's start with not supported.

519
00:29:33,291 --> 00:29:36,563
So, what I've down now is I've
changed the propagation rule

520
00:29:36,563 --> 00:29:39,991
of delete book to not supported.

521
00:29:39,991 --> 00:29:44,991
Now, this will ask Spring
to automatically suspend

522
00:29:46,121 --> 00:29:50,126
any transaction that is
currently open when that

523
00:29:50,126 --> 00:29:52,527
method is called.

524
00:29:52,527 --> 00:29:54,452
If there's no transaction running,

525
00:29:54,452 --> 00:29:56,366
then it doesn't matter,

526
00:29:56,366 --> 00:29:59,485
Spring won't do anything special.

527
00:29:59,485 --> 00:30:02,744
Now, if we follow the logic
of this particular example,

528
00:30:02,744 --> 00:30:07,744
we'd go into buy book, a
transaction would be started,

529
00:30:08,958 --> 00:30:11,246
we'd get halfway through the buy book,

530
00:30:11,246 --> 00:30:13,739
and they we call delete book,

531
00:30:13,739 --> 00:30:16,802
and that's the point
where Spring would suspend

532
00:30:16,802 --> 00:30:19,453
the parent method's transaction.

533
00:30:19,453 --> 00:30:23,953
And it would suspend it for
the duration of delete book.

534
00:30:23,953 --> 00:30:25,586
Now, before I go any
further, I've not really

535
00:30:25,586 --> 00:30:30,321
defined what suspending
a transaction means.

536
00:30:30,321 --> 00:30:34,569
It's really just as far as the
delete method is concerned,

537
00:30:34,569 --> 00:30:38,331
delete book thinks there
is no transaction running.

538
00:30:38,331 --> 00:30:42,007
If you're interested, the way
that Spring makes this happen,

539
00:30:42,007 --> 00:30:45,195
is that it will run the
delete book method on

540
00:30:45,195 --> 00:30:48,859
a different thread to the buy book method.

541
00:30:48,859 --> 00:30:51,563
That's only if you're
interested in what's happening

542
00:30:51,563 --> 00:30:53,368
under the hood.

543
00:30:53,368 --> 00:30:55,375
But in other words, to
convert this propagation

544
00:30:55,375 --> 00:30:58,927
level into English, you use not supported,

545
00:30:58,927 --> 00:31:02,352
where you're telling
Spring, we definitely must

546
00:31:02,352 --> 00:31:07,343
not have a transaction
open for the duration

547
00:31:07,343 --> 00:31:09,793
of this method call.

548
00:31:09,793 --> 00:31:14,046
Now, the uses of this to be
honest, are pretty limited.

549
00:31:14,046 --> 00:31:16,869
This is only where
having a transaction open

550
00:31:16,869 --> 00:31:19,358
would cause you some kind of problem

551
00:31:19,358 --> 00:31:21,924
in the delete book method.

552
00:31:21,924 --> 00:31:24,336
Now, an example off the top of my head,

553
00:31:24,336 --> 00:31:27,482
is that if you're calling
a stored procedure,

554
00:31:27,482 --> 00:31:29,438
in the delete book method,

555
00:31:29,438 --> 00:31:32,420
and you're planning to
issue some data definitions

556
00:31:32,420 --> 00:31:35,317
such as creating or dropping a table,

557
00:31:35,317 --> 00:31:38,337
maybe a temporary table
or something like that,

558
00:31:38,337 --> 00:31:41,609
then within some database environments,

559
00:31:41,609 --> 00:31:44,143
that would cause a crash.

560
00:31:44,143 --> 00:31:48,307
In other words, you can't
issue create and drop tables

561
00:31:48,307 --> 00:31:51,613
while you're in a transaction.

562
00:31:51,613 --> 00:31:54,966
So, in that case, I would
be using the not supported

563
00:31:54,966 --> 00:31:58,431
flag to kind of get around the problem.

564
00:31:58,431 --> 00:32:01,621
Now, that is a fairly
rare example I admit,

565
00:32:01,621 --> 00:32:04,111
and that's why you're not going to see the

566
00:32:04,111 --> 00:32:09,111
not supported propagation
rule used very often.

567
00:32:09,137 --> 00:32:13,909
And similarly, the propagation
rule of requires new

568
00:32:13,909 --> 00:32:17,711
has only a small number of usages.

569
00:32:17,711 --> 00:32:19,919
Now, what will happen with requires new

570
00:32:19,919 --> 00:32:22,619
as I'm illustrating on the picture here,

571
00:32:22,619 --> 00:32:25,069
is that when we get to the method that

572
00:32:25,069 --> 00:32:28,468
we've set a flag of requires new for,

573
00:32:28,468 --> 00:32:33,001
Spring will begin a brand new transaction.

574
00:32:33,001 --> 00:32:34,339
Now, you've got to be careful here.

575
00:32:34,339 --> 00:32:37,647
Some people call this a child transaction,

576
00:32:37,647 --> 00:32:41,964
but to be precise about
it, it's not really

577
00:32:41,964 --> 00:32:46,964
a child transaction, because
the original transaction

578
00:32:48,689 --> 00:32:53,153
that was started by the
parent method is suspended.

579
00:32:53,153 --> 00:32:56,065
Now, that means that
the delete book method

580
00:32:56,065 --> 00:32:59,826
won't be able to see any
of the data that buy book

581
00:32:59,826 --> 00:33:03,213
has written to the database so far.

582
00:33:03,213 --> 00:33:07,017
So, delete book really is
running a completely separate

583
00:33:07,017 --> 00:33:12,017
transaction, so it's wrong to
call this a child transaction.

584
00:33:13,178 --> 00:33:16,558
So, what will happen is that
at the end of delete book,

585
00:33:16,558 --> 00:33:21,145
any changes made in delete
book will be committed

586
00:33:21,145 --> 00:33:24,004
and can't be rolled back now.

587
00:33:24,004 --> 00:33:28,087
Control would return
back to the parent method

588
00:33:28,087 --> 00:33:30,819
and buy book would continue.

589
00:33:30,819 --> 00:33:33,594
So, you might be able
to see the danger here.

590
00:33:33,594 --> 00:33:37,605
If the buy book method were to roll back,

591
00:33:37,605 --> 00:33:42,177
towards the end of buy
book, i.e. after delete book

592
00:33:42,177 --> 00:33:45,895
has been run, then it's
now too late to roll back

593
00:33:45,895 --> 00:33:49,936
any changes made in
the delete book method.

594
00:33:49,936 --> 00:33:52,880
So, in our example, this
would be a disastrous choice

595
00:33:52,880 --> 00:33:56,516
of propagation rule,
because if buy book fails

596
00:33:56,516 --> 00:33:58,678
three quarters of the way
through the deleting of the book,

597
00:33:58,678 --> 00:34:02,613
then the deleting of the book
will still have happened.

598
00:34:02,613 --> 00:34:07,429
So, what requires new
means to me in English,

599
00:34:07,429 --> 00:34:11,310
is that we need a brand new transaction

600
00:34:11,310 --> 00:34:16,310
completely isolated from the
parent method's transaction.

601
00:34:16,378 --> 00:34:19,770
And when this child method completes,

602
00:34:19,770 --> 00:34:23,163
the changes must commit immediately.

603
00:34:23,163 --> 00:34:25,244
Now, the only uses that
we can think of that this

604
00:34:25,244 --> 00:34:28,022
would be for something
like auditing or login.

605
00:34:28,022 --> 00:34:31,450
Let's say that the child
method is writing to

606
00:34:31,450 --> 00:34:36,195
a log table, and regardless
of whether the parent method

607
00:34:36,195 --> 00:34:41,182
succeeds or not, we still
want that login to stand

608
00:34:41,182 --> 00:34:42,905
in a table.

609
00:34:42,905 --> 00:34:46,163
So, commonly, something
like a banking application

610
00:34:46,163 --> 00:34:47,846
might use this.

611
00:34:47,846 --> 00:34:50,130
The parent method is running
some kind of business

612
00:34:50,130 --> 00:34:52,173
process for a customer,
but the child method

613
00:34:52,173 --> 00:34:57,173
is just login that the parent
method has actually run.

614
00:34:58,024 --> 00:35:00,473
So, even if the parent method fails,

615
00:35:00,473 --> 00:35:05,052
we still want to record
in the log that an attempt

616
00:35:05,052 --> 00:35:07,173
was made.

617
00:35:07,173 --> 00:35:10,483
Another often quoted example,
is if the subordinate

618
00:35:10,483 --> 00:35:15,109
method is somehow generating keys manually

619
00:35:15,109 --> 00:35:17,478
Well, in that case we
probably want to commit

620
00:35:17,478 --> 00:35:21,569
the transaction so as
to release any locks.

621
00:35:21,569 --> 00:35:24,516
Because the parent's method might well be

622
00:35:24,516 --> 00:35:26,679
running for quite a long time.

623
00:35:26,679 --> 00:35:30,843
And we wouldn't want to
hold up the key table.

624
00:35:30,843 --> 00:35:34,109
Now, I must admit these
are fairly rare examples.

625
00:35:34,109 --> 00:35:36,994
In normal regular business
code, you wouldn't

626
00:35:36,994 --> 00:35:39,043
use requires new.

627
00:35:39,043 --> 00:35:41,163
But hey, I don't see
why that shouldn't stop

628
00:35:41,163 --> 00:35:45,340
us trying it out, just
to see it in operation.

629
00:35:45,340 --> 00:35:47,424
So, just for fun, I'm going to go into the

630
00:35:47,424 --> 00:35:49,876
book service here, and I'm going to try

631
00:35:49,876 --> 00:35:53,600
switching this to requires new.

632
00:35:53,600 --> 00:35:56,583
Now, remember, if you
just dropped into the

633
00:35:56,583 --> 00:35:59,852
middle of this video,
this is not a good choice

634
00:35:59,852 --> 00:36:04,052
for this application, but I
would like to see it in action.

635
00:36:04,052 --> 00:36:09,052
I'll go back to my client
and return the code

636
00:36:10,343 --> 00:36:13,415
back.

637
00:36:16,146 --> 00:36:18,835
And now, let's run again.

638
00:36:18,835 --> 00:36:21,489
And you could probably see
very quickly that there's

639
00:36:21,489 --> 00:36:23,206
a lot more login.

640
00:36:23,206 --> 00:36:25,115
And there's a lot more
logging because every

641
00:36:25,115 --> 00:36:27,077
single one of the methods
that we're calling

642
00:36:27,077 --> 00:36:31,156
in book service, is delete from stock

643
00:36:31,156 --> 00:36:33,477
is getting its own commit.

644
00:36:33,477 --> 00:36:36,254
Definitely not what we
want in this application.

645
00:36:36,254 --> 00:36:39,481
So, I'll go back to annotation,

646
00:36:39,481 --> 00:36:42,054
and I'm going to return this back

647
00:36:42,054 --> 00:36:43,852
to the default setting.

648
00:36:43,852 --> 00:36:46,134
On then, to the final
three propagation rules,

649
00:36:46,134 --> 00:36:47,760
and if you're getting tired at this point,

650
00:36:47,760 --> 00:36:49,686
we've put these at the end, because these

651
00:36:49,686 --> 00:36:53,136
are the rarer propagation rules

652
00:36:53,136 --> 00:36:56,196
Never is I think is the
strangest of the seven.

653
00:36:56,196 --> 00:36:58,238
The idea behind never is,

654
00:36:58,238 --> 00:37:00,811
if we were to set the child
method with the propagation

655
00:37:00,811 --> 00:37:05,811
rule of never, then what will
happen is if you call it,

656
00:37:05,871 --> 00:37:10,116
and a transaction is
currently running, then Spring

657
00:37:10,116 --> 00:37:12,850
will throw an exception.

658
00:37:12,850 --> 00:37:15,357
And that will effectively
mean that the business process

659
00:37:15,357 --> 00:37:17,358
is terminated.

660
00:37:17,358 --> 00:37:22,220
So, the English translation
of this, is that never will

661
00:37:22,220 --> 00:37:25,852
throw an exception if the method is called

662
00:37:25,852 --> 00:37:28,670
when a transaction is open.

663
00:37:28,670 --> 00:37:30,173
Now, in writing this course,
all the way back to the

664
00:37:30,173 --> 00:37:32,792
first edition, we've tried
to think of a use for

665
00:37:32,792 --> 00:37:35,247
this propagation rule, and we can't really

666
00:37:35,247 --> 00:37:37,032
think of one.

667
00:37:37,032 --> 00:37:39,859
It's certainly one that
I haven't seen in any

668
00:37:39,859 --> 00:37:42,355
production code.

669
00:37:42,355 --> 00:37:46,154
The next propagation
rule is called mandatory.

670
00:37:46,154 --> 00:37:48,890
And it's really the
complete opposite of the

671
00:37:48,890 --> 00:37:50,609
previous one, never.

672
00:37:50,609 --> 00:37:54,150
With mandatory, an
exception will be thrown

673
00:37:54,150 --> 00:37:59,029
if a transaction hasn't been
started by the parent method.

674
00:37:59,029 --> 00:38:02,468
So, using mandatory, you
will get an exception

675
00:38:02,468 --> 00:38:05,283
if there's no transaction.

676
00:38:05,283 --> 00:38:09,460
The use of this is just if
you need to force the client

677
00:38:09,460 --> 00:38:13,711
to be in charge of beginning
transactions themselves.

678
00:38:13,711 --> 00:38:15,630
And rather few uses of this one.

679
00:38:15,630 --> 00:38:19,765
And one example that I have is

680
00:38:19,765 --> 00:38:23,210
just a project that I
worked on a few years ago,

681
00:38:23,210 --> 00:38:26,364
decided that they wanted
to be very careful,

682
00:38:26,364 --> 00:38:31,364
that the client code never
called a day old directly.

683
00:38:31,580 --> 00:38:33,499
They wanted to be absolutely sure that

684
00:38:33,499 --> 00:38:37,088
all of the client code went
through the service layer,

685
00:38:37,088 --> 00:38:40,858
which is after all the correct behavior.

686
00:38:40,858 --> 00:38:45,657
So, what they did was they
went into their day old

687
00:38:45,657 --> 00:38:47,887
classes, so here I'm in my book day old,

688
00:38:47,887 --> 00:38:50,664
and they annotated with transactional,

689
00:38:50,664 --> 00:38:55,664
with a propagation rule,

690
00:38:58,394 --> 00:39:02,107
set to mandatory.

691
00:39:02,107 --> 00:39:04,883
So, that means that as long
as we're doing everything

692
00:39:04,883 --> 00:39:08,684
correctly, and we're
always calling the day old

693
00:39:08,684 --> 00:39:11,504
from a service class.

694
00:39:11,504 --> 00:39:13,218
Well, because our
service class is creating

695
00:39:13,218 --> 00:39:16,529
the transaction, then when
the day old is called,

696
00:39:16,529 --> 00:39:18,288
all will be well.

697
00:39:18,288 --> 00:39:23,288
So, I should be able to run my
code perfectly successfully.

698
00:39:25,526 --> 00:39:29,571
Everything ran through
ok with usual combining

699
00:39:29,571 --> 00:39:32,229
of the child methods into
a single transaction.

700
00:39:32,229 --> 00:39:36,285
But now, imagine that some bad programmer

701
00:39:36,285 --> 00:39:39,431
came along, and they thought "Oh well,

702
00:39:39,431 --> 00:39:41,228
"I don't like calling
the services classes.

703
00:39:41,228 --> 00:39:44,046
"I'm going to straight to the database."

704
00:39:44,046 --> 00:39:49,046
So, they got hold of the book day old,

705
00:39:49,633 --> 00:39:52,612
and remember you can do that by going

706
00:39:52,612 --> 00:39:56,365
into the container and call and get being.

707
00:39:56,365 --> 00:39:59,174
We're looking for any
being that implements

708
00:39:59,174 --> 00:40:02,297
the book day old interface.

709
00:40:02,297 --> 00:40:05,076
So, now this bad programmer could go

710
00:40:05,076 --> 00:40:10,076
straight in and I don't
know, call the create method.

711
00:40:14,389 --> 00:40:16,967
I'll just put some silly data in here.

712
00:40:16,967 --> 00:40:18,926
And if you think about it, that could be a

713
00:40:18,926 --> 00:40:22,197
really serious blunder because we might

714
00:40:22,197 --> 00:40:26,480
have business logic in the
service classes that's crucial

715
00:40:26,480 --> 00:40:28,977
in maintaining the
integrity of our system,

716
00:40:28,977 --> 00:40:32,248
and therefore the
integrity of the database.

717
00:40:32,248 --> 00:40:35,030
But this idiot programmer has gone in and

718
00:40:35,030 --> 00:40:36,626
destroyed all of that, and they've gone in

719
00:40:36,626 --> 00:40:38,580
and written straight to the database.

720
00:40:38,580 --> 00:40:41,081
But because we've set
this propagation rule

721
00:40:41,081 --> 00:40:46,081
on the data axis subjects,
transactions are mandatory.

722
00:40:48,309 --> 00:40:51,456
And an exception will
be thrown if one hasn't

723
00:40:51,456 --> 00:40:53,949
been created by the parent method.

724
00:40:53,949 --> 00:40:57,916
So, you can see here
we have the exception,

725
00:40:57,916 --> 00:41:01,711
and it's saying no
existing transaction found

726
00:41:01,711 --> 00:41:04,858
for a transaction marked with propagation

727
00:41:04,858 --> 00:41:06,573
of mandatory.

728
00:41:06,573 --> 00:41:10,010
So, our bad programmer has been stopped

729
00:41:10,010 --> 00:41:12,375
in their tracks.

730
00:41:12,375 --> 00:41:14,462
Well, that was just one
project I worked on.

731
00:41:14,462 --> 00:41:18,159
And I must say that it's
probably not routine practice.

732
00:41:18,159 --> 00:41:20,418
There is another use of mandatory,

733
00:41:20,418 --> 00:41:23,154
but it is a little advanced,
so I'll be pointing you

734
00:41:23,154 --> 00:41:26,748
to a reference guide at
the end of the course,

735
00:41:26,748 --> 00:41:30,056
which contains an
advanced use of mandatory,

736
00:41:30,056 --> 00:41:33,128
but I won't go any further
with mandatory here.

737
00:41:33,128 --> 00:41:34,967
Now, the six rules that we've seen so far,

738
00:41:34,967 --> 00:41:39,824
were all defined by the EJB
specification from Java EE.

739
00:41:39,824 --> 00:41:42,482
So, maybe you were already
familiar with them,

740
00:41:42,482 --> 00:41:45,004
but there is a seventh
one, and this one that

741
00:41:45,004 --> 00:41:48,939
Spring has added as a special extra.

742
00:41:48,939 --> 00:41:51,190
And it's called the NESTED rule.

743
00:41:51,190 --> 00:41:52,464
So, let's have a look.

744
00:41:52,464 --> 00:41:55,725
What would happen if we
set our subordinate method

745
00:41:55,725 --> 00:41:58,715
to the propagation rule of NESTED.

746
00:41:58,715 --> 00:42:01,954
Well, what would happen is
as the picture shows is,

747
00:42:01,954 --> 00:42:06,081
that as we go into buy book,
we've set that to required

748
00:42:06,081 --> 00:42:09,394
so we'll get a begin transaction.

749
00:42:09,394 --> 00:42:11,681
When we get to the subordinate method,

750
00:42:11,681 --> 00:42:13,519
the delete book,

751
00:42:13,519 --> 00:42:17,275
Spring will set a save point.

752
00:42:17,275 --> 00:42:19,060
I don't know if you're
familiar with save points,

753
00:42:19,060 --> 00:42:22,047
but they're part of the JDBC standard,

754
00:42:22,047 --> 00:42:25,725
and it's not a new transaction.

755
00:42:25,725 --> 00:42:30,448
You can think of it as a kind of a marker.

756
00:42:30,448 --> 00:42:34,263
And what will happen, is if
the delete book method fails,

757
00:42:34,263 --> 00:42:38,223
and that means an unchecked
exception is thrown,

758
00:42:38,223 --> 00:42:41,246
then we will get a roll back.

759
00:42:41,246 --> 00:42:46,167
But the roll back will only
go back to the save point.

760
00:42:46,167 --> 00:42:50,302
So, it's almost like
undoing a block of work.

761
00:42:50,302 --> 00:42:54,391
However, if the delete
book method completes,

762
00:42:54,391 --> 00:42:55,985
and all is well,

763
00:42:55,985 --> 00:42:59,296
then there's no commit at
the end of delete book.

764
00:42:59,296 --> 00:43:01,821
We go back to buy book.

765
00:43:01,821 --> 00:43:04,201
And the process continues.

766
00:43:04,201 --> 00:43:08,362
If buy book rolls back
towards the end of buy book,

767
00:43:08,362 --> 00:43:11,268
then all of the changes
including the changes made

768
00:43:11,268 --> 00:43:15,367
in the delete book method
will all be rolled back.

769
00:43:15,367 --> 00:43:17,785
Now, this propagation rule
is often confused with

770
00:43:17,785 --> 00:43:20,562
requires new, because it's
almost like in delete book

771
00:43:20,562 --> 00:43:22,654
you have a kind of a new transaction,

772
00:43:22,654 --> 00:43:25,095
but it really isn't a new transaction.

773
00:43:25,095 --> 00:43:26,980
There are two big differences.

774
00:43:26,980 --> 00:43:29,307
First of all, the nested
transaction can see

775
00:43:29,307 --> 00:43:32,391
all of the changes that have been made

776
00:43:32,391 --> 00:43:34,754
by the parent method.

777
00:43:34,754 --> 00:43:38,587
And secondly, if there's a
roll back in the parent method,

778
00:43:38,587 --> 00:43:43,326
then the nested transaction
will roll back as well.

779
00:43:43,326 --> 00:43:46,555
Now, I can't give you a
specific use for nested

780
00:43:46,555 --> 00:43:49,412
transactions because they're very generic.

781
00:43:49,412 --> 00:43:51,935
What we're talking about here is that

782
00:43:51,935 --> 00:43:55,168
if you want to attempt to do something

783
00:43:55,168 --> 00:43:58,866
in the nested transaction,
you know it might fail,

784
00:43:58,866 --> 00:44:01,756
but you don't want the
failure of it to roll back

785
00:44:01,756 --> 00:44:04,829
your parent's method transaction.

786
00:44:04,829 --> 00:44:08,342
So, I often think of
this as a let's attempt

787
00:44:08,342 --> 00:44:11,042
to do something transaction.

788
00:44:11,042 --> 00:44:14,587
An example might be that
you're calling a legacy

789
00:44:14,587 --> 00:44:19,050
system and that legacy
system is constantly crashing

790
00:44:19,050 --> 00:44:22,637
and it depends on the time of
day as to whether it works.

791
00:44:22,637 --> 00:44:26,988
So, you could put its work
in a nested transaction,

792
00:44:26,988 --> 00:44:29,307
and if it fails, never mind,

793
00:44:29,307 --> 00:44:31,842
we'll just try again.

794
00:44:31,842 --> 00:44:35,082
Now, you can only use
this propagation level

795
00:44:35,082 --> 00:44:37,281
if you're using JDBC.

796
00:44:37,281 --> 00:44:40,565
And that's because Spring
is using JDBC save points

797
00:44:40,565 --> 00:44:42,275
to make this work.

798
00:44:42,275 --> 00:44:45,108
It also won't work on
distributed transactions

799
00:44:45,108 --> 00:44:47,855
if you're running on
an application server.

800
00:44:47,855 --> 00:44:50,144
And it won't work, if
you're using something

801
00:44:50,144 --> 00:44:53,333
like hibernate, what we'll
be covering later on.

802
00:44:53,333 --> 00:44:56,927
With those caveats in mind,
it could be a really useful

803
00:44:56,927 --> 00:45:00,760
propagation level for
some of your requirements.

804
00:45:00,760 --> 00:45:03,504
There's no doubt the the propagation rules

805
00:45:03,504 --> 00:45:05,221
are quite strange.

806
00:45:05,221 --> 00:45:07,181
You may have found this quite complicated

807
00:45:07,181 --> 00:45:10,043
especially if it's the
first time you've seen them.

808
00:45:10,043 --> 00:45:14,133
They do date back to the
older EJB specification.

809
00:45:14,133 --> 00:45:16,219
They've been copied by Spring,

810
00:45:16,219 --> 00:45:20,421
and some of the language
is a little bit archaic.

811
00:45:20,421 --> 00:45:22,871
But the main thing to
remember, is that there

812
00:45:22,871 --> 00:45:25,485
are two propagation rules
that you'll be using

813
00:45:25,485 --> 00:45:27,406
most of the time.

814
00:45:27,406 --> 00:45:30,878
Propagation required is the usual choice

815
00:45:30,878 --> 00:45:33,043
for transactional methods.

816
00:45:33,043 --> 00:45:35,376
And here you're seeing
that Spring must make sure

817
00:45:35,376 --> 00:45:39,592
that there's a transaction,
either an existing one created

818
00:45:39,592 --> 00:45:43,749
by a parent method, or
we need a new one if one

819
00:45:43,749 --> 00:45:45,968
hasn't been created.

820
00:45:45,968 --> 00:45:50,014
Propagation support says
you don't care if the method

821
00:45:50,014 --> 00:45:51,976
is part of a transaction or not.

822
00:45:51,976 --> 00:45:54,312
So, you'll use that
attribute if the method's

823
00:45:54,312 --> 00:45:56,764
non-transactional and
you don't want to risk

824
00:45:56,764 --> 00:45:59,875
the overhead of
transactions being committed

825
00:45:59,875 --> 00:46:03,956
if it were called by a client directly.

826
00:46:03,956 --> 00:46:06,982
The other five options
are somewhat advanced,

827
00:46:06,982 --> 00:46:11,393
and probably fairly rare
that you'll need to use them.

828
00:46:11,393 --> 00:46:13,306
nested, I think is pretty useful,

829
00:46:13,306 --> 00:46:16,214
but in my experience, people
seem a little scared of it.

830
00:46:16,214 --> 00:46:20,424
And I've not seen it very
often out in the wild.

831
00:46:20,424 --> 00:46:22,728
So, although you're not
going to use them very often,

832
00:46:22,728 --> 00:46:26,290
I still think you should
be aware that they exist.

833
00:46:26,290 --> 00:46:29,773
If you've decided to use
the T X name spacings,

834
00:46:29,773 --> 00:46:32,057
instead of using annotations,

835
00:46:32,057 --> 00:46:34,553
then you configure propagation rules

836
00:46:34,553 --> 00:46:38,269
just as a parameter in the T X method tag.

837
00:46:38,269 --> 00:46:41,204
So, for example, here I'm specifying that

838
00:46:41,204 --> 00:46:44,927
all methods beginning with
get need the propagation rule

839
00:46:44,927 --> 00:46:47,905
of supports.

840
00:46:47,905 --> 00:46:51,032
An odd chapter then,
in that there was quite

841
00:46:51,032 --> 00:46:52,446
a lot to take in.

842
00:46:52,446 --> 00:46:54,783
But the ending message is that the default

843
00:46:54,783 --> 00:46:56,534
behavior, when you have

844
00:46:56,534 --> 00:46:59,273
chains of transactional methods,

845
00:46:59,273 --> 00:47:03,041
is that almost always
the behavior you want.

846
00:47:03,041 --> 00:47:05,980
You get a single transaction
spanning the whole

847
00:47:05,980 --> 00:47:07,980
business process.

848
00:47:07,980 --> 00:47:09,979
When the parent method completes,

849
00:47:09,979 --> 00:47:11,887
we get a commit.

850
00:47:11,887 --> 00:47:14,299
You can tune this
behavior using the rather

851
00:47:14,299 --> 00:47:17,322
scary propagation rules.

852
00:47:17,322 --> 00:47:19,531
But you rarely need to touch them.

853
00:47:19,531 --> 00:47:22,425
I hope you found it useful
to have a little look

854
00:47:22,425 --> 00:47:24,018
at them though.

855
00:47:24,018 --> 00:47:26,824
The next chapter is again
related to transactions,

856
00:47:26,824 --> 00:47:28,873
but it is an important one.

857
00:47:28,873 --> 00:47:31,908
We need to have a proper
look at what happens

858
00:47:31,908 --> 00:47:36,279
with roll backs.

1
00:00:10,470 --> 00:00:11,803
- [Voiceover] It's time
to have a think about

2
00:00:11,803 --> 00:00:16,006
what happens when we
need to force a rollback.

3
00:00:16,006 --> 00:00:19,165
As always, I'll use an
example from our bookstore.

4
00:00:19,165 --> 00:00:20,944
And we'll see that there are two ways

5
00:00:20,944 --> 00:00:23,665
of forcing Spring to rollback.

6
00:00:23,665 --> 00:00:26,022
One of the methods isn't very elegant,

7
00:00:26,022 --> 00:00:27,185
but the other one,

8
00:00:27,185 --> 00:00:31,387
the declarative rollbacks is really neat.

9
00:00:31,387 --> 00:00:34,064
That's the important part of the chapter.

10
00:00:34,064 --> 00:00:36,369
At the end, I'll fit in a quick chat about

11
00:00:36,369 --> 00:00:38,449
read only transactions,

12
00:00:38,449 --> 00:00:40,866
and then how to set timeouts.

13
00:00:45,029 --> 00:00:46,907
We've seen that thanks to Springs

14
00:00:46,907 --> 00:00:50,587
automatic declarative
transaction management.

15
00:00:50,587 --> 00:00:52,230
If we declare a method,

16
00:00:52,230 --> 00:00:53,649
such a buy book,

17
00:00:53,649 --> 00:00:55,388
to be transactional

18
00:00:55,388 --> 00:00:58,982
then Spring will automatically
begin a new transaction

19
00:00:58,982 --> 00:01:01,084
at the start of the method

20
00:01:01,084 --> 00:01:05,607
and automatically commit
at the end of the method.

21
00:01:05,607 --> 00:01:07,761
What we haven't addressed really,

22
00:01:07,761 --> 00:01:10,261
is how do we manage rollbacks?

23
00:01:11,505 --> 00:01:13,190
What we've seen so far,

24
00:01:13,190 --> 00:01:16,742
is that in the event of
an unchecked exception,

25
00:01:16,742 --> 00:01:20,325
Spring will automatically
issue a rollback.

26
00:01:21,565 --> 00:01:23,868
That's great, it means if there's any

27
00:01:23,868 --> 00:01:27,526
unpredicted problem with
the applications server,

28
00:01:27,526 --> 00:01:29,842
such as a null pointer exception,

29
00:01:29,842 --> 00:01:34,225
or if the application
server runs out of memory.

30
00:01:34,225 --> 00:01:38,086
All of these things are
unchecked exceptions

31
00:01:38,086 --> 00:01:41,414
and therefore we would see a rollback.

32
00:01:41,414 --> 00:01:43,910
But what happens if we want to rollback

33
00:01:43,910 --> 00:01:46,918
because of some business case?

34
00:01:46,918 --> 00:01:48,699
What we're going to do in this chapter,

35
00:01:48,699 --> 00:01:50,172
is we're going to see

36
00:01:50,172 --> 00:01:53,137
a checked exception thrown.

37
00:01:53,137 --> 00:01:56,164
And we'll see how that interacts

38
00:01:56,164 --> 00:01:58,113
with rollbacks.

39
00:01:58,113 --> 00:02:01,217
Now, an important
prerequisite to this chapter

40
00:02:01,217 --> 00:02:04,277
is that you understand
the difference between

41
00:02:04,277 --> 00:02:07,743
checked and unchecked exceptions.

42
00:02:07,743 --> 00:02:10,623
If not there are a lot
of resources out there

43
00:02:10,623 --> 00:02:13,120
for example, on the internet.

44
00:02:13,120 --> 00:02:16,203
And at the address you can
see on the screen here,

45
00:02:16,203 --> 00:02:18,283
I've written a blog post

46
00:02:18,283 --> 00:02:20,277
talking about the pros and cons of

47
00:02:20,277 --> 00:02:23,541
checked and unchecked exceptions.

48
00:02:23,541 --> 00:02:25,718
But in a single sentence,

49
00:02:25,718 --> 00:02:27,637
unchecked exceptions,

50
00:02:27,637 --> 00:02:31,659
those exceptions which are
allowed to be unhandled

51
00:02:31,659 --> 00:02:33,664
and can cause a crash.

52
00:02:33,664 --> 00:02:37,078
Such as null pointer exceptions.

53
00:02:37,078 --> 00:02:40,051
Whereas a check exception is an exception

54
00:02:40,051 --> 00:02:43,697
that must be handled
somewhere in your code

55
00:02:43,697 --> 00:02:45,639
with a try-catch block.

56
00:02:45,639 --> 00:02:47,783
And the compilier will check

57
00:02:47,783 --> 00:02:51,922
that you really have
handled that exception.

58
00:02:51,922 --> 00:02:54,460
Recall that this is the rough logic

59
00:02:54,460 --> 00:02:56,679
of our buy book method.

60
00:02:56,679 --> 00:02:58,780
We have two steps.

61
00:02:58,780 --> 00:03:02,225
Step one, we delete the book from stock.

62
00:03:02,225 --> 00:03:04,924
And step two, we raise an invoice

63
00:03:04,924 --> 00:03:06,257
in the database.

64
00:03:07,466 --> 00:03:10,308
Now we're going to extend this example now

65
00:03:10,308 --> 00:03:13,134
and I'm going to say
that my business states

66
00:03:13,134 --> 00:03:16,793
that it is possible
for a customer's credit

67
00:03:16,793 --> 00:03:18,043
to be exceeded.

68
00:03:19,108 --> 00:03:21,470
Now this case is going to be flagged up

69
00:03:21,470 --> 00:03:24,963
at the point where we raise the invoice.

70
00:03:24,963 --> 00:03:28,302
And if the customers credit is exceeded,

71
00:03:28,302 --> 00:03:31,993
then the buying of the book must fail.

72
00:03:31,993 --> 00:03:33,764
Now to put it into the

73
00:03:33,764 --> 00:03:35,289
database terminology,

74
00:03:35,289 --> 00:03:37,732
that means that if the
raising voice method

75
00:03:37,732 --> 00:03:39,588
throws an exception,

76
00:03:39,588 --> 00:03:42,733
then we want the database
transaction for buy book

77
00:03:42,733 --> 00:03:44,452
to be rolled back.

78
00:03:44,452 --> 00:03:46,135
Let's go into Eclipse, and have a look

79
00:03:46,135 --> 00:03:48,425
at how we could implement that.

80
00:03:48,425 --> 00:03:50,943
So here's the account service interface

81
00:03:50,943 --> 00:03:53,460
that you're familiar with now.

82
00:03:53,460 --> 00:03:55,178
And what I'm going to do is

83
00:03:55,178 --> 00:03:57,663
I'm going to add an exception

84
00:03:57,663 --> 00:04:00,842
that the raising voice method might throw.

85
00:04:00,842 --> 00:04:02,239
And this is going to be

86
00:04:02,239 --> 00:04:03,903
the customer

87
00:04:03,903 --> 00:04:06,070
credit exceeded exception.

88
00:04:09,802 --> 00:04:11,337
So as I've said in the introduction,

89
00:04:11,337 --> 00:04:13,577
this exception will be thrown

90
00:04:13,577 --> 00:04:16,180
if for some reason, the customer

91
00:04:16,180 --> 00:04:18,079
that's trying to buy the book

92
00:04:18,079 --> 00:04:22,632
is out of credit, they can't
afford to buy the book.

93
00:04:22,632 --> 00:04:24,535
I'll have a compilier of course because

94
00:04:24,535 --> 00:04:26,775
this exception is new.

95
00:04:26,775 --> 00:04:29,133
So I'm going to use the
quick fix option here.

96
00:04:29,133 --> 00:04:32,696
I'll just left-click on
the arrow on the left,

97
00:04:32,696 --> 00:04:35,767
and that gives me the
option to create the class.

98
00:04:35,767 --> 00:04:37,691
All I really need to do is to decide

99
00:04:37,691 --> 00:04:39,015
on which package it should live.

100
00:04:39,015 --> 00:04:41,019
And I think the services package

101
00:04:41,019 --> 00:04:42,534
is good enough.

102
00:04:42,534 --> 00:04:45,394
And wonderfully, that's
all the work I need to do.

103
00:04:45,394 --> 00:04:48,796
Because, by default, Eclipse has chosen

104
00:04:48,796 --> 00:04:52,198
the exception class as the base class

105
00:04:52,198 --> 00:04:53,659
for this exception.

106
00:04:53,659 --> 00:04:55,227
Now as you probably know,

107
00:04:55,227 --> 00:04:59,248
that means that this exception
is a checked exception.

108
00:04:59,248 --> 00:05:03,120
And therefore, if it's
thrown, it must be handled

109
00:05:03,120 --> 00:05:05,037
with a try-catch block.

110
00:05:06,181 --> 00:05:10,384
Going into the implementation
of the account service.

111
00:05:10,384 --> 00:05:13,082
Well we only have a mock
implementation at the moment,

112
00:05:13,082 --> 00:05:15,483
but that doesn't really matter.

113
00:05:15,483 --> 00:05:17,560
Now just for the purposes of development,

114
00:05:17,560 --> 00:05:19,938
for the purposes of testing,

115
00:05:19,938 --> 00:05:21,303
what I'm going to do
is I'm going to remove

116
00:05:21,303 --> 00:05:22,936
the existing implementation

117
00:05:22,936 --> 00:05:26,979
and I'm just going to
immediately throw this new

118
00:05:26,979 --> 00:05:29,816
customer credit exceeded exception.

119
00:05:29,816 --> 00:05:32,344
I can do a control
space or a command space

120
00:05:32,344 --> 00:05:34,221
on a Macintosh.

121
00:05:34,221 --> 00:05:37,406
So of course this isn't what the

122
00:05:37,406 --> 00:05:38,793
real code would look like.

123
00:05:38,793 --> 00:05:41,737
The real code would be if
the customer is in credit,

124
00:05:41,737 --> 00:05:44,041
then we go ahead, run a business logic,

125
00:05:44,041 --> 00:05:45,924
and raise the invoice.

126
00:05:45,924 --> 00:05:48,976
If the customer can't afford the book,

127
00:05:48,976 --> 00:05:51,184
then we'll throw the exception.

128
00:05:51,184 --> 00:05:53,422
But, I'm going to make
it so that we always

129
00:05:53,422 --> 00:05:55,364
get this exception thrown.

130
00:05:55,364 --> 00:05:57,498
Now we have compilier here purely because

131
00:05:57,498 --> 00:05:59,415
we also have to declare

132
00:06:00,999 --> 00:06:02,573
the possibility of that exception

133
00:06:02,573 --> 00:06:03,971
on the signature.

134
00:06:03,971 --> 00:06:06,638
So I'll add that in right there.

135
00:06:08,152 --> 00:06:10,434
So now we have a compile error,

136
00:06:10,434 --> 00:06:11,854
which has been flagged up here

137
00:06:11,854 --> 00:06:15,075
on the purchasing service implementation.

138
00:06:15,075 --> 00:06:17,293
And again, I'm assuming
that you're familiar

139
00:06:17,293 --> 00:06:18,776
with standard Java,

140
00:06:18,776 --> 00:06:21,848
so you should have been
expecting this compile error.

141
00:06:21,848 --> 00:06:25,752
Of course now when we
attempt to raise the invoice

142
00:06:25,752 --> 00:06:27,576
from the buy book method,

143
00:06:27,576 --> 00:06:28,909
this might fail.

144
00:06:30,008 --> 00:06:33,795
Well, you know and I
know that it will fail,

145
00:06:33,795 --> 00:06:35,917
but from the purposes of buy book,

146
00:06:35,917 --> 00:06:37,250
this might fail.

147
00:06:38,392 --> 00:06:41,070
Now, if the raising of the invoice fails,

148
00:06:41,070 --> 00:06:42,083
then what we want to do is,

149
00:06:42,083 --> 00:06:45,035
we want to rollback the transaction.

150
00:06:45,035 --> 00:06:47,680
So that the previous operations

151
00:06:47,680 --> 00:06:49,239
are removed from the database.

152
00:06:49,239 --> 00:06:50,072
In other words,

153
00:06:50,072 --> 00:06:54,156
we want the delete from
stock to be revoked.

154
00:06:54,156 --> 00:06:56,140
So what I need to show you here is,

155
00:06:56,140 --> 00:06:59,473
how do we make Spring invoke a rollback?

156
00:07:00,843 --> 00:07:02,847
We haven't seen how to do that so far

157
00:07:02,847 --> 00:07:05,033
because Spring has been
doing that automatically

158
00:07:05,033 --> 00:07:08,650
when an unchecked exception occurs.

159
00:07:08,650 --> 00:07:10,826
Now the easy answer is that in here

160
00:07:10,826 --> 00:07:14,536
we can tell Spring that
we want to rollback.

161
00:07:14,536 --> 00:07:16,797
So what we would do is roughly

162
00:07:16,797 --> 00:07:18,557
something like

163
00:07:18,557 --> 00:07:19,557
we would try

164
00:07:21,235 --> 00:07:23,347
to raise the invoice,

165
00:07:23,347 --> 00:07:26,504
but we can catch the possibility of the

166
00:07:26,504 --> 00:07:28,680
customer credit being exceeded.

167
00:07:28,680 --> 00:07:31,261
I just use control space there.

168
00:07:31,261 --> 00:07:33,779
And here in the catch
block we'll need to do

169
00:07:33,779 --> 00:07:35,327
two things really.

170
00:07:35,327 --> 00:07:38,494
We'll need to tell Spring to rollback,

171
00:07:39,423 --> 00:07:42,121
but we still need to
throw the customer credit

172
00:07:42,121 --> 00:07:45,038
exceeded exception from this method

173
00:07:45,961 --> 00:07:48,468
so that the client knows that something

174
00:07:48,468 --> 00:07:50,004
went wrong as well.

175
00:07:50,004 --> 00:07:52,564
The client's going to want
to catch that exception

176
00:07:52,564 --> 00:07:53,886
and tell the user sorry,

177
00:07:53,886 --> 00:07:55,636
you're out of credit.

178
00:07:56,807 --> 00:07:59,591
So that second step is easy,

179
00:07:59,591 --> 00:08:02,174
we'll throw the exception again

180
00:08:03,730 --> 00:08:05,191
but to the client.

181
00:08:05,191 --> 00:08:06,874
So let me do that first,

182
00:08:06,874 --> 00:08:09,861
because it will need a little bit of work.

183
00:08:09,861 --> 00:08:12,592
We can just do throw E.

184
00:08:12,592 --> 00:08:14,193
I don't know if you're
familiar with that but,

185
00:08:14,193 --> 00:08:15,971
that will just take the exception

186
00:08:15,971 --> 00:08:17,688
that has been caught,

187
00:08:17,688 --> 00:08:20,408
and it will rethrow it.

188
00:08:20,408 --> 00:08:22,691
So it's almost like
we've partially handled

189
00:08:22,691 --> 00:08:24,824
the exception with the rollback,

190
00:08:24,824 --> 00:08:26,743
but then we still need to throw it again

191
00:08:26,743 --> 00:08:30,910
so the client can complete
the handling of the exception.

192
00:08:32,086 --> 00:08:33,942
The compilier here is because

193
00:08:33,942 --> 00:08:37,569
we need to upgrade the
interface to buy book.

194
00:08:37,569 --> 00:08:40,065
We know it might throw the
book not found exception,

195
00:08:40,065 --> 00:08:43,905
but now, it might also throw the customer

196
00:08:43,905 --> 00:08:46,529
credit exceeded exception.

197
00:08:46,529 --> 00:08:50,582
So I'm going to add it
there to the implementation

198
00:08:50,582 --> 00:08:54,749
and that will mean we also need
to add it to the interface.

199
00:08:57,526 --> 00:08:59,169
So that's all good.

200
00:08:59,169 --> 00:09:01,206
We're going to have an error on the client

201
00:09:01,206 --> 00:09:04,342
but we'll come back to
that in a short while.

202
00:09:04,342 --> 00:09:06,411
So what I need to show you is,

203
00:09:06,411 --> 00:09:09,750
how can we tell Spring to rollback.

204
00:09:09,750 --> 00:09:11,265
Something that's worth mentioning here

205
00:09:11,265 --> 00:09:13,291
is that we do have to somehow

206
00:09:13,291 --> 00:09:15,619
tell Spring that we want to rollback,

207
00:09:15,619 --> 00:09:19,599
because the rule is
with a checked exception

208
00:09:19,599 --> 00:09:22,979
Spring won't automatically
issue a rollback.

209
00:09:22,979 --> 00:09:25,839
So if we just threw the
customer credit exceeded

210
00:09:25,839 --> 00:09:27,202
back to the client,

211
00:09:27,202 --> 00:09:30,615
Spring wouldn't know whether
that's a bad situation

212
00:09:30,615 --> 00:09:32,695
or an expected situation,

213
00:09:32,695 --> 00:09:35,757
so the default in Spring
is checked exceptions

214
00:09:35,757 --> 00:09:38,007
do not result in rollbacks.

215
00:09:39,010 --> 00:09:42,754
So we're going to have to
explicitly tell Spring here,

216
00:09:42,754 --> 00:09:44,428
that we want to rollback.

217
00:09:44,428 --> 00:09:46,915
Now I'm going to hesitate
before showing you this,

218
00:09:46,915 --> 00:09:48,567
because actually,

219
00:09:48,567 --> 00:09:51,255
I'm going to show you a much
better way of doing this

220
00:09:51,255 --> 00:09:52,706
in a few moments.

221
00:09:52,706 --> 00:09:55,010
But I think this is
instructive to show you that

222
00:09:55,010 --> 00:09:58,253
you can do this in the
code if you want to.

223
00:09:58,253 --> 00:10:01,015
There's a class in Spring called,

224
00:10:01,015 --> 00:10:02,872
and it's quite a mouthful this one,

225
00:10:02,872 --> 00:10:05,789
it's called the transaction aspect,

226
00:10:06,946 --> 00:10:09,249
I think I'll use control space there.

227
00:10:09,249 --> 00:10:13,890
You can see it's called
transaction aspect support.

228
00:10:13,890 --> 00:10:16,195
And if I hit the dot on there,

229
00:10:16,195 --> 00:10:18,733
there's a static method in there called

230
00:10:18,733 --> 00:10:20,983
current transaction status.

231
00:10:22,400 --> 00:10:24,736
And then I can hit the dot again,

232
00:10:24,736 --> 00:10:26,741
and I can call a method on there

233
00:10:26,741 --> 00:10:29,056
if I can find it in the list

234
00:10:29,056 --> 00:10:31,139
called set rollback only.

235
00:10:32,665 --> 00:10:34,201
Now it's important to be aware that

236
00:10:34,201 --> 00:10:36,302
this doesn't immediately

237
00:10:36,302 --> 00:10:37,347
issue a rollback,

238
00:10:37,347 --> 00:10:39,385
it just sets a flag.

239
00:10:39,385 --> 00:10:41,750
It tells the transaction
manager that at the end

240
00:10:41,750 --> 00:10:45,537
of this code, when Spring
gets to the point where it

241
00:10:45,537 --> 00:10:47,819
would usually commit,

242
00:10:47,819 --> 00:10:50,944
it actually needs to rollback instead.

243
00:10:50,944 --> 00:10:55,264
So that means if you
had some code down here,

244
00:10:55,264 --> 00:10:58,303
that was issuing some
further database operations

245
00:10:58,303 --> 00:11:02,484
then you would still have
those database operations

246
00:11:02,484 --> 00:11:04,746
issued to the database,

247
00:11:04,746 --> 00:11:07,371
but they're going to get rolled back.

248
00:11:07,371 --> 00:11:09,908
So something to be aware of there.

249
00:11:09,908 --> 00:11:12,394
It doesn't effect us here because

250
00:11:12,394 --> 00:11:14,218
as soon as we set this flag,

251
00:11:14,218 --> 00:11:17,749
we're going to return back
to the client, which means

252
00:11:17,749 --> 00:11:19,978
we'd get the rollback there.

253
00:11:19,978 --> 00:11:22,441
Now, I admit that this a really ugly

254
00:11:22,441 --> 00:11:24,136
line of code, and I think

255
00:11:24,136 --> 00:11:26,899
Spring have deliberately
made it ugly because

256
00:11:26,899 --> 00:11:28,838
they don't really want
you to use this approach.

257
00:11:28,838 --> 00:11:32,570
There is a far slicker
way of handling this,

258
00:11:32,570 --> 00:11:34,617
but I'll show you that in a short while.

259
00:11:34,617 --> 00:11:38,574
It would be useful to make
sure that this is working okay.

260
00:11:38,574 --> 00:11:40,974
So let's go back to our client,

261
00:11:40,974 --> 00:11:43,374
and we have a compilier here of course,

262
00:11:43,374 --> 00:11:46,243
because we're attempting to buy a book.

263
00:11:46,243 --> 00:11:47,544
And we're handling the case where

264
00:11:47,544 --> 00:11:49,186
the books not found.

265
00:11:49,186 --> 00:11:52,226
But we now need to add in the final case

266
00:11:52,226 --> 00:11:55,393
of if the customer credit is exceeded,

267
00:11:56,290 --> 00:11:58,957
then we need to tell the user...

268
00:12:00,528 --> 00:12:04,611
I don't know, sorry you
can't afford it, go away.

269
00:12:07,705 --> 00:12:09,583
So let's give this a run.

270
00:12:09,583 --> 00:12:13,998
I'm going to I think start
from a clean database,

271
00:12:13,998 --> 00:12:17,583
because I can't remember what
state I left it in before.

272
00:12:17,583 --> 00:12:20,505
And just to review what
the client's going to do,

273
00:12:20,505 --> 00:12:22,082
it's first of all going to register a book

274
00:12:22,082 --> 00:12:24,237
on to the system.

275
00:12:24,237 --> 00:12:27,352
It's then going to
attempt to buy that book.

276
00:12:27,352 --> 00:12:30,658
Now previously, the buy book
would have been successful

277
00:12:30,658 --> 00:12:34,072
and this book would be
deleted from the system.

278
00:12:34,072 --> 00:12:36,885
But because we're expecting
this customer credit

279
00:12:36,885 --> 00:12:39,296
exceeded exception,

280
00:12:39,296 --> 00:12:41,643
we're expecting the deletion of the book

281
00:12:41,643 --> 00:12:43,403
to be rolled back.

282
00:12:43,403 --> 00:12:45,301
So at the end of this run,

283
00:12:45,301 --> 00:12:47,158
we should get the error message here,

284
00:12:47,158 --> 00:12:48,779
but we should also see

285
00:12:48,779 --> 00:12:51,563
the book in the database.

286
00:12:51,563 --> 00:12:53,396
Let's give that a try.

287
00:12:56,640 --> 00:12:58,976
Good, we've got some good
logging on the console,

288
00:12:58,976 --> 00:13:00,459
and the first thing is

289
00:13:00,459 --> 00:13:03,402
we've got the sorry go away message.

290
00:13:03,402 --> 00:13:05,717
This looks very promising.

291
00:13:05,717 --> 00:13:07,541
We're seeing,

292
00:13:07,541 --> 00:13:10,742
information saying that
there is a rollback

293
00:13:10,742 --> 00:13:13,078
of the transaction.

294
00:13:13,078 --> 00:13:15,360
So that's certainly looks promising.

295
00:13:15,360 --> 00:13:18,336
And have a look in the database script,

296
00:13:18,336 --> 00:13:19,862
all the way down at the bottom.

297
00:13:19,862 --> 00:13:21,099
That's excellent.

298
00:13:21,099 --> 00:13:25,502
You can see that the books
has been left in the database.

299
00:13:25,502 --> 00:13:29,939
So the delete operation was
successfully rolled back.

300
00:13:29,939 --> 00:13:31,569
Let's go back to the purchasing service.

301
00:13:31,569 --> 00:13:33,265
Now I wanted to show you

302
00:13:33,265 --> 00:13:36,710
this way of setting a rollback in Spring.

303
00:13:36,710 --> 00:13:38,523
Just to be complete, really.

304
00:13:38,523 --> 00:13:40,785
But I'm not particularly happy

305
00:13:40,785 --> 00:13:42,588
with having to call this line of code,

306
00:13:42,588 --> 00:13:46,492
because it's really ruined
what was quite a clean

307
00:13:46,492 --> 00:13:49,605
and easy to understand service class.

308
00:13:49,605 --> 00:13:52,188
And suddenly I'm having
to manually work with

309
00:13:52,188 --> 00:13:55,964
transactions in the middle of my code.

310
00:13:55,964 --> 00:14:00,625
It would be much better if
we had a less invasive way

311
00:14:00,625 --> 00:14:02,811
of telling Spring that if we get

312
00:14:02,811 --> 00:14:04,719
customer credit exceeded,

313
00:14:04,719 --> 00:14:07,578
then we want to see a rollback.

314
00:14:07,578 --> 00:14:09,495
And of course there is.

315
00:14:10,714 --> 00:14:11,855
What we can do instead,

316
00:14:11,855 --> 00:14:13,818
is we can use an annotation

317
00:14:13,818 --> 00:14:15,631
on the buy book method.

318
00:14:15,631 --> 00:14:17,818
Let me unroll the work we've done.

319
00:14:17,818 --> 00:14:19,717
I'm going to remove the

320
00:14:19,717 --> 00:14:21,384
try and catch block.

321
00:14:25,178 --> 00:14:27,951
And remember again, this is standard Java,

322
00:14:27,951 --> 00:14:31,993
although I do need a try-catch
block for raise invoice.

323
00:14:31,993 --> 00:14:35,514
The fact that I've declared
on the method signature

324
00:14:35,514 --> 00:14:37,914
that it might throw that exception,

325
00:14:37,914 --> 00:14:42,298
that's going to result in a
kind of automatic rethrow.

326
00:14:42,298 --> 00:14:46,319
And the client is then
forced to have a catch block.

327
00:14:46,319 --> 00:14:50,639
So that's okay, but as
it stands at the moment,

328
00:14:50,639 --> 00:14:52,271
because this is a checked exception,

329
00:14:52,271 --> 00:14:55,021
Spring will not issue a rollback.

330
00:14:56,111 --> 00:14:58,810
But Spring will issue a rollback if we add

331
00:14:58,810 --> 00:15:01,455
an annotation to the method.

332
00:15:01,455 --> 00:15:05,092
The annotation is in fact
just the transactional

333
00:15:05,092 --> 00:15:06,852
annotation again.

334
00:15:06,852 --> 00:15:09,039
Transactional I should say.

335
00:15:09,039 --> 00:15:10,659
But the difference this
time is we're going

336
00:15:10,659 --> 00:15:13,997
to add a parameter into the annotation.

337
00:15:13,997 --> 00:15:17,582
And the parameter is rollback four.

338
00:15:17,582 --> 00:15:19,277
What we're allowed to do is specify

339
00:15:19,277 --> 00:15:21,742
any checked exceptions that we would like

340
00:15:21,742 --> 00:15:24,483
Spring to count as a rollback.

341
00:15:24,483 --> 00:15:28,878
So I can add in here customer
credit exceeded exception.

342
00:15:28,878 --> 00:15:31,878
I have to put the dot class modifier

343
00:15:32,870 --> 00:15:34,748
on the end of there.

344
00:15:34,748 --> 00:15:36,945
And it also occurs to me that this process

345
00:15:36,945 --> 00:15:41,112
might also fail if the get
book by ISBN method fails.

346
00:15:42,114 --> 00:15:46,081
In other words, we see the
book not found exception.

347
00:15:46,081 --> 00:15:48,332
And I think, I didn't do this on

348
00:15:48,332 --> 00:15:49,589
first edition of the course,

349
00:15:49,589 --> 00:15:52,341
but I think, if that exception is thrown

350
00:15:52,341 --> 00:15:54,368
than the process is failed.

351
00:15:54,368 --> 00:15:57,930
Therefore we should issue
a rollback there as well.

352
00:15:57,930 --> 00:16:00,544
Now you might not agree with me on that.

353
00:16:00,544 --> 00:16:03,690
After all, we've only done a query here.

354
00:16:03,690 --> 00:16:06,347
So there's no changes in the database

355
00:16:06,347 --> 00:16:08,170
that need rolling back.

356
00:16:08,170 --> 00:16:10,421
But I think it's good practice

357
00:16:10,421 --> 00:16:12,405
if a transaction has failed

358
00:16:12,405 --> 00:16:14,368
to roll it back,

359
00:16:14,368 --> 00:16:19,177
even though in this case it
won't be undoing any work.

360
00:16:19,177 --> 00:16:21,673
It could be the case
that later on as we add

361
00:16:21,673 --> 00:16:23,572
further requirements to the system

362
00:16:23,572 --> 00:16:28,030
that get book by ISBN does
insert some data somewhere

363
00:16:28,030 --> 00:16:30,974
and we want that insert to be rolled back.

364
00:16:30,974 --> 00:16:33,089
So it's perhaps a little bit of a

365
00:16:33,089 --> 00:16:35,085
kind of a pedantic point really.

366
00:16:35,085 --> 00:16:38,881
But I would like to also include the

367
00:16:38,881 --> 00:16:42,060
book not found exception
in the list of rollbacks.

368
00:16:42,060 --> 00:16:43,168
The way that you do that is

369
00:16:43,168 --> 00:16:45,409
that you turn this into an array.

370
00:16:45,409 --> 00:16:47,927
So curly brackets there,

371
00:16:47,927 --> 00:16:49,526
and then inside the curly brackets,

372
00:16:49,526 --> 00:16:53,443
a comma separated list
of all of the exceptions

373
00:16:54,709 --> 00:16:57,930
that you want to trigger a rollback.

374
00:16:57,930 --> 00:16:59,638
Feel free to take your own view

375
00:16:59,638 --> 00:17:01,417
on whether book not found exception

376
00:17:01,417 --> 00:17:04,790
should be in that rollback list.

377
00:17:04,790 --> 00:17:06,132
But this is wonderful I think.

378
00:17:06,132 --> 00:17:10,013
It's a very elegant way
of handling rollbacks.

379
00:17:10,013 --> 00:17:12,392
We haven't had to change the code

380
00:17:12,392 --> 00:17:14,174
inside our service method.

381
00:17:14,174 --> 00:17:17,171
And this works beautifully, the annotation

382
00:17:17,171 --> 00:17:18,109
it's almost a

383
00:17:18,109 --> 00:17:20,093
a kind of a comment

384
00:17:20,093 --> 00:17:22,354
as a maintenance program where I can see

385
00:17:22,354 --> 00:17:24,626
at a glance that yet

386
00:17:24,626 --> 00:17:26,543
buy book is going to be transactional,

387
00:17:26,543 --> 00:17:28,720
but there will be
rollbacks issued for these

388
00:17:28,720 --> 00:17:31,323
two particular exceptions.

389
00:17:31,323 --> 00:17:33,317
I think that's really great.

390
00:17:33,317 --> 00:17:35,001
Well, it's only great if it runs,

391
00:17:35,001 --> 00:17:36,835
so I'll go back to my client.

392
00:17:36,835 --> 00:17:38,392
Now in my previous run,

393
00:17:38,392 --> 00:17:41,848
I registered that book and
we know it's in the database,

394
00:17:41,848 --> 00:17:45,333
so I'm going to comment
that line of code out.

395
00:17:45,333 --> 00:17:48,299
I could have cleared the
database as well I guess.

396
00:17:48,299 --> 00:17:49,301
Let's run the client again,

397
00:17:49,301 --> 00:17:52,634
we expect the same results as last time.

398
00:17:53,706 --> 00:17:55,381
And it looks good.

399
00:17:55,381 --> 00:17:56,842
We've got the error message there,

400
00:17:56,842 --> 00:17:59,062
we can see the rollback in the log,

401
00:17:59,062 --> 00:18:01,345
and there's one final check,

402
00:18:01,345 --> 00:18:03,178
we'll look inside the script.

403
00:18:03,178 --> 00:18:05,928
And yes, our book is still there.

404
00:18:07,222 --> 00:18:10,298
Just to absolutely complete this testing,

405
00:18:10,298 --> 00:18:12,485
I think it will be worth checking that

406
00:18:12,485 --> 00:18:13,840
if everything goes well,

407
00:18:13,840 --> 00:18:16,581
the data is committed to the database.

408
00:18:16,581 --> 00:18:18,321
So let's do that with,

409
00:18:18,321 --> 00:18:21,147
I'll do it in a fairly
inelegant way I guess.

410
00:18:21,147 --> 00:18:23,866
I'll go into the account service,

411
00:18:23,866 --> 00:18:26,885
and I'll comment out the
throwing of the exception

412
00:18:26,885 --> 00:18:30,000
and I'll replace that line of code where

413
00:18:30,000 --> 00:18:32,144
we've said raise

414
00:18:32,144 --> 00:18:33,061
an invoice.

415
00:18:35,483 --> 00:18:38,106
Of course if we'd gone a
little further with this,

416
00:18:38,106 --> 00:18:40,729
there would have been database
operations in here as well.

417
00:18:40,729 --> 00:18:43,790
Which, would have been
committed or rolled back

418
00:18:43,790 --> 00:18:46,766
when the buy book process completes.

419
00:18:46,766 --> 00:18:49,007
So I'll run the client once more,

420
00:18:49,007 --> 00:18:52,507
this time we don't want the error message.

421
00:18:55,065 --> 00:18:57,167
No error message this time,

422
00:18:57,167 --> 00:19:01,027
and we're seeing initiating
transaction commit,

423
00:19:01,027 --> 00:19:02,307
and that must mean

424
00:19:02,307 --> 00:19:03,390
if I refresh,

425
00:19:05,892 --> 00:19:08,473
and check the script.

426
00:19:08,473 --> 00:19:10,306
The book has now gone.

427
00:19:11,534 --> 00:19:13,945
For the purposes of the
practicals and code folder,

428
00:19:13,945 --> 00:19:16,250
I'll uncomment the line
where I'm registering

429
00:19:16,250 --> 00:19:17,486
that new book.

430
00:19:17,486 --> 00:19:21,006
And as always, you really
should take this code now

431
00:19:21,006 --> 00:19:23,385
and have a little bit of a play around

432
00:19:23,385 --> 00:19:26,788
and try working with your own rollbacks.

433
00:19:26,788 --> 00:19:29,614
If you've decided not to use annotations,

434
00:19:29,614 --> 00:19:32,995
and you're using the
tx: namespace instead,

435
00:19:32,995 --> 00:19:37,038
then adding rollbacks is similarly simple.

436
00:19:37,038 --> 00:19:39,098
In your tx method tag,

437
00:19:39,098 --> 00:19:41,636
you'll specify the name of the method,

438
00:19:41,636 --> 00:19:42,938
in this case buy a book.

439
00:19:42,938 --> 00:19:46,584
And then you use the
attribute rollback four.

440
00:19:46,584 --> 00:19:49,699
Notice it's slightly different
to the attribute we used

441
00:19:49,699 --> 00:19:51,265
in the annotation.

442
00:19:51,265 --> 00:19:53,793
It's rollback hyphen four,

443
00:19:53,793 --> 00:19:57,047
and then you specify the
name of the exception.

444
00:19:57,047 --> 00:19:59,351
Some of the methods in our service layout

445
00:19:59,351 --> 00:20:01,751
are read only methods.

446
00:20:01,751 --> 00:20:04,790
For example, here I am in
the book service interface.

447
00:20:04,790 --> 00:20:07,348
And we can be pretty
certain that the get book

448
00:20:07,348 --> 00:20:08,515
by ISBN method

449
00:20:09,493 --> 00:20:11,935
is going to be a query method.

450
00:20:11,935 --> 00:20:13,311
They'll be no inserts,

451
00:20:13,311 --> 00:20:18,133
deletes or updates as a result
of that method being called.

452
00:20:18,133 --> 00:20:20,810
Get all recommended books
is an interesting one.

453
00:20:20,810 --> 00:20:23,028
If we go to the quick type hierarchy,

454
00:20:23,028 --> 00:20:26,585
or pressing control or command T,

455
00:20:26,585 --> 00:20:30,179
I can bounce straight to
the implementation there.

456
00:20:30,179 --> 00:20:34,520
And to get all recommended
books method that we have here,

457
00:20:34,520 --> 00:20:36,141
is currently not implemented,

458
00:20:36,141 --> 00:20:38,904
because it's going to be a
very complex method this one.

459
00:20:38,904 --> 00:20:42,019
But I imagine there's going
to be a lot of database

460
00:20:42,019 --> 00:20:43,362
operations in there,

461
00:20:43,362 --> 00:20:46,029
which will be all query methods.

462
00:20:46,979 --> 00:20:49,485
Now I think for these read only methods,

463
00:20:49,485 --> 00:20:52,707
transactions are still valuable.

464
00:20:52,707 --> 00:20:55,405
Although we're not committing any data

465
00:20:55,405 --> 00:20:56,302
in these methods,

466
00:20:56,302 --> 00:20:59,960
we probably still want other
properties of transactions

467
00:20:59,960 --> 00:21:01,460
such as isolation.

468
00:21:02,328 --> 00:21:04,920
So that we get consistent set of data

469
00:21:04,920 --> 00:21:08,205
if we're doing more than
one read through the method.

470
00:21:08,205 --> 00:21:10,870
Well, isolation is quite
the complicated topic,

471
00:21:10,870 --> 00:21:13,952
so I have an optional chapter coming up

472
00:21:13,952 --> 00:21:16,576
that will cover that topic,

473
00:21:16,576 --> 00:21:19,190
but it's generally recommended by experts

474
00:21:19,190 --> 00:21:21,376
that even if you're querying,

475
00:21:21,376 --> 00:21:24,459
a transaction is still a good choice.

476
00:21:26,112 --> 00:21:28,352
My favorite stack overflow question

477
00:21:28,352 --> 00:21:30,528
is the one you can see here.

478
00:21:30,528 --> 00:21:34,155
And there are three really
wonderful answers actually,

479
00:21:34,155 --> 00:21:36,352
that go into quite a little bit of detail

480
00:21:36,352 --> 00:21:39,531
of what's going on under
the hood with transactions.

481
00:21:39,531 --> 00:21:41,696
And the general point is
that you're note going

482
00:21:41,696 --> 00:21:43,691
to save any performance by

483
00:21:43,691 --> 00:21:46,955
not using a transaction
for a query method,

484
00:21:46,955 --> 00:21:48,235
and in any case,

485
00:21:48,235 --> 00:21:50,252
almost all databases will give you

486
00:21:50,252 --> 00:21:52,535
a transaction anyway

487
00:21:52,535 --> 00:21:54,752
if you don't start one.

488
00:21:54,752 --> 00:21:56,470
So it's quite an interesting thread that,

489
00:21:56,470 --> 00:21:59,969
feel free to study it
if you're interested.

490
00:21:59,969 --> 00:22:01,334
But my point is,

491
00:22:01,334 --> 00:22:04,054
having at transactional at the top

492
00:22:04,054 --> 00:22:06,133
and leaving all of these methods

493
00:22:06,133 --> 00:22:07,742
as regular transactions.

494
00:22:07,742 --> 00:22:11,177
In fact I'm going to remove
this propagation support

495
00:22:11,177 --> 00:22:12,530
from get all recommended books.

496
00:22:12,530 --> 00:22:14,823
I left that in earlier in the course

497
00:22:14,823 --> 00:22:16,967
as an example, because
at present we're not

498
00:22:16,967 --> 00:22:18,533
doing database operations,

499
00:22:18,533 --> 00:22:19,533
but we will.

500
00:22:21,155 --> 00:22:24,462
So, I suggest that propagation
required is still the best

501
00:22:24,462 --> 00:22:26,574
attribute for all of the methods.

502
00:22:26,574 --> 00:22:29,017
However, Spring does have
a very useful feature

503
00:22:29,017 --> 00:22:29,998
and that is

504
00:22:29,998 --> 00:22:32,675
for any method that we know for a fact

505
00:22:32,675 --> 00:22:34,435
is a read only method,

506
00:22:34,435 --> 00:22:37,219
we can tell Spring that that's the case.

507
00:22:37,219 --> 00:22:41,134
I'm going to go here on the
get book by ISBN method.

508
00:22:41,134 --> 00:22:44,422
And I'm going to add in here the

509
00:22:44,422 --> 00:22:46,797
transactional annotation.

510
00:22:46,797 --> 00:22:48,440
Now usually I don't need this,

511
00:22:48,440 --> 00:22:51,064
because I've already
marked the entire class

512
00:22:51,064 --> 00:22:53,080
as being transactional.

513
00:22:53,080 --> 00:22:55,341
But I'm doing this
because I want to override

514
00:22:55,341 --> 00:22:57,090
the transactional

515
00:22:57,090 --> 00:22:59,756
and I want to add in an extra property.

516
00:22:59,756 --> 00:23:00,939
And it's very simple,

517
00:23:00,939 --> 00:23:04,139
we just add in the flag of read only,

518
00:23:04,139 --> 00:23:05,139
equals true.

519
00:23:05,995 --> 00:23:10,441
Now that means that if this
method is called directly

520
00:23:10,441 --> 00:23:12,354
from a client,

521
00:23:12,354 --> 00:23:15,426
in other words, this
method is the entire scope

522
00:23:15,426 --> 00:23:17,154
of the transaction,

523
00:23:17,154 --> 00:23:20,904
then Spring will tell
the underlying database

524
00:23:22,594 --> 00:23:25,773
that we're running in read only mode.

525
00:23:25,773 --> 00:23:29,368
Now if you're interested in
looking under the hood at this,

526
00:23:29,368 --> 00:23:30,508
all it means is,

527
00:23:30,508 --> 00:23:35,128
in JDBC there's an
interface called connection,

528
00:23:35,128 --> 00:23:37,794
that represents the database connection.

529
00:23:37,794 --> 00:23:39,789
And all Spring is doing is

530
00:23:39,789 --> 00:23:43,392
it's calling a method
on the connection called

531
00:23:43,392 --> 00:23:44,559
set read only.

532
00:23:45,814 --> 00:23:47,851
So it's standard Java.

533
00:23:47,851 --> 00:23:51,457
And that attempt to tell the database

534
00:23:51,457 --> 00:23:54,017
that we're running in read only mode.

535
00:23:54,017 --> 00:23:56,416
Now it depends on your
database as to whether

536
00:23:56,416 --> 00:23:59,411
that will make any difference or not,

537
00:23:59,411 --> 00:24:03,614
I have no idea if hsql
DB does anything useful

538
00:24:03,614 --> 00:24:05,395
in read only mode.

539
00:24:05,395 --> 00:24:08,168
But databases such as Oracle for example,

540
00:24:08,168 --> 00:24:10,131
will take that hint

541
00:24:10,131 --> 00:24:12,413
and it will do things like

542
00:24:12,413 --> 00:24:14,632
not keep a rollback log.

543
00:24:14,632 --> 00:24:16,158
A rollback log is when the database

544
00:24:16,158 --> 00:24:18,902
keeps a file with a list
of all the operations

545
00:24:18,902 --> 00:24:20,553
you've carried out so that

546
00:24:20,553 --> 00:24:24,148
it can unwind them if you rollback.

547
00:24:24,148 --> 00:24:25,524
Well, on those databases,

548
00:24:25,524 --> 00:24:27,167
if we set read only,

549
00:24:27,167 --> 00:24:28,490
it won't do that,

550
00:24:28,490 --> 00:24:32,106
and that could have an
improvement on performance.

551
00:24:32,106 --> 00:24:34,953
You've got to be really
careful with this flag though,

552
00:24:34,953 --> 00:24:37,044
because if you do

553
00:24:37,044 --> 00:24:41,044
do any database inserts
of dates or deletes

554
00:24:41,044 --> 00:24:44,788
inside this method, then
you will get an exception.

555
00:24:44,788 --> 00:24:47,124
And you've got to think
ahead a little bit here.

556
00:24:47,124 --> 00:24:48,970
Although we can see at a glance

557
00:24:48,970 --> 00:24:52,170
oh we're just calling find by ISBN

558
00:24:52,170 --> 00:24:53,524
on a DayOh.

559
00:24:53,524 --> 00:24:56,553
Well in real life you could
have a chain of objects,

560
00:24:56,553 --> 00:24:58,889
doing a complex series of operations

561
00:24:58,889 --> 00:25:01,524
and it can be sometimes
difficult at this level

562
00:25:01,524 --> 00:25:04,692
to know whether it's read only or not.

563
00:25:04,692 --> 00:25:05,749
Use it with care,

564
00:25:05,749 --> 00:25:10,154
but it can have a positive
effect on performance.

565
00:25:10,154 --> 00:25:11,754
If you're using hibernate,

566
00:25:11,754 --> 00:25:14,804
which we'll be describing
in a future chapter's time.

567
00:25:14,804 --> 00:25:17,546
Then it actually has quite
a big impact on performance

568
00:25:17,546 --> 00:25:19,698
because it's almost switches off,

569
00:25:19,698 --> 00:25:23,581
hibernates checking of whether
the objects you worked with

570
00:25:23,581 --> 00:25:25,235
have changed or not.

571
00:25:25,235 --> 00:25:27,379
If you know the terminology of hibernate,

572
00:25:27,379 --> 00:25:30,037
then I can tell you that this int

573
00:25:30,037 --> 00:25:32,120
will switch flushing off.

574
00:25:33,198 --> 00:25:35,702
Which is quite a big optimization.

575
00:25:35,702 --> 00:25:38,572
And if you're working
with the tx: namespace,

576
00:25:38,572 --> 00:25:41,612
then it's very easy to
add the ready only hint

577
00:25:41,612 --> 00:25:44,172
to a transactional method.

578
00:25:44,172 --> 00:25:45,666
Here's an example.

579
00:25:45,666 --> 00:25:49,292
One final thing you can do
with the transactional rules,

580
00:25:49,292 --> 00:25:51,864
is that you can optionally set a time out

581
00:25:51,864 --> 00:25:53,612
for a transaction.

582
00:25:53,612 --> 00:25:56,450
Now this is probably something
that you won't want to do

583
00:25:56,450 --> 00:25:58,028
very often,

584
00:25:58,028 --> 00:26:00,567
but it's one of those things
that when you need it,

585
00:26:00,567 --> 00:26:02,285
you really need it.

586
00:26:02,285 --> 00:26:04,674
So I want the course
to be comprehensive, so

587
00:26:04,674 --> 00:26:06,220
I'll mention it here.

588
00:26:06,220 --> 00:26:07,361
Let's say

589
00:26:07,361 --> 00:26:09,559
for some reason that the buy book method

590
00:26:09,559 --> 00:26:11,138
we've got a bit of a problem with it

591
00:26:11,138 --> 00:26:13,196
because this raising voice method

592
00:26:13,196 --> 00:26:16,140
is actually being run on a legacy database

593
00:26:16,140 --> 00:26:20,215
which is running really slow and sometimes

594
00:26:20,215 --> 00:26:24,599
users are having to sit and
wait for several minutes

595
00:26:24,599 --> 00:26:27,181
and obviously they don't wait that long

596
00:26:27,181 --> 00:26:29,698
so they've been closing their browsers.

597
00:26:29,698 --> 00:26:31,415
So what I'd like to do,

598
00:26:31,415 --> 00:26:33,634
is make it so that buy book will fail

599
00:26:33,634 --> 00:26:37,079
after ten seconds if
the transaction hasn't

600
00:26:37,079 --> 00:26:39,021
completed in time.

601
00:26:39,021 --> 00:26:41,517
Well we can do that by adding another flag

602
00:26:41,517 --> 00:26:42,592
on here,

603
00:26:42,592 --> 00:26:44,128
and I've alright got a rollback rule,

604
00:26:44,128 --> 00:26:45,909
so I'll need a comma there,

605
00:26:45,909 --> 00:26:47,669
and it's very simple,

606
00:26:47,669 --> 00:26:50,187
it's just timeout equals,

607
00:26:50,187 --> 00:26:54,443
followed by the timeout
we'd like in seconds.

608
00:26:54,443 --> 00:26:56,426
You might have expected
milliseconds there,

609
00:26:56,426 --> 00:26:59,104
but this is actually seconds.

610
00:26:59,104 --> 00:27:01,323
So just by adding that,

611
00:27:01,323 --> 00:27:03,823
if I now go back to my client.

612
00:27:05,504 --> 00:27:07,744
Now the way I'll do this I think is,

613
00:27:07,744 --> 00:27:10,806
I'll go into the buy book method,

614
00:27:10,806 --> 00:27:13,706
and I'm going to add a break point there

615
00:27:13,706 --> 00:27:16,706
just so I can run this on the debug.

616
00:27:18,506 --> 00:27:20,051
Now just on this first run,

617
00:27:20,051 --> 00:27:22,686
I'm going to just wait
for three or four seconds

618
00:27:22,686 --> 00:27:24,606
and then resume,

619
00:27:24,606 --> 00:27:27,091
and the point of doing
that is to show you that

620
00:27:27,091 --> 00:27:29,574
everything ran absolutely fine,

621
00:27:29,574 --> 00:27:31,469
there were no problems because we were

622
00:27:31,469 --> 00:27:33,847
inside the timeout.

623
00:27:33,847 --> 00:27:36,347
Now I'm going to run it again,

624
00:27:38,604 --> 00:27:41,868
but this time I'm going
to leave the code running

625
00:27:41,868 --> 00:27:43,564
at this line of code,

626
00:27:43,564 --> 00:27:47,397
and I'm going to waffle
for about ten seconds.

627
00:27:48,546 --> 00:27:51,405
And once I've resumed the
code running with a gap

628
00:27:51,405 --> 00:27:53,312
of longer than ten seconds,

629
00:27:53,312 --> 00:27:55,328
you can see I'm getting
an exception here of

630
00:27:55,328 --> 00:27:57,409
transaction timed out,

631
00:27:57,409 --> 00:27:59,626
it's telling me what the deadline was,

632
00:27:59,626 --> 00:28:02,411
and we exceeded the deadline.

633
00:28:02,411 --> 00:28:04,746
Now, I actually had to
press the play button

634
00:28:04,746 --> 00:28:07,147
to make that crash happen.

635
00:28:07,147 --> 00:28:09,365
When you're running in this in real life,

636
00:28:09,365 --> 00:28:11,311
when we've reached the deadline,

637
00:28:11,311 --> 00:28:14,736
the transaction will be rolled back.

638
00:28:14,736 --> 00:28:16,773
And if you're using the tx: namespace,

639
00:28:16,773 --> 00:28:20,254
then the timeout is just
added another attribute,

640
00:28:20,254 --> 00:28:23,469
but notice that you set
the value in seconds

641
00:28:23,469 --> 00:28:24,469
as a string.

642
00:28:25,889 --> 00:28:27,766
So again, not much code,

643
00:28:27,766 --> 00:28:30,614
but another chance where
you need an understanding

644
00:28:30,614 --> 00:28:33,505
of the under the hood mechanism.

645
00:28:33,505 --> 00:28:35,734
If you want a rollback to happen

646
00:28:35,734 --> 00:28:38,070
in the event of a checked exception,

647
00:28:38,070 --> 00:28:40,673
then you need to make it happen.

648
00:28:40,673 --> 00:28:42,113
And the best way to do that

649
00:28:42,113 --> 00:28:44,908
is via declarative rollback.

650
00:28:44,908 --> 00:28:46,816
As when you declare in the annotation

651
00:28:46,816 --> 00:28:50,709
which exceptions should
trigger a rollback.

652
00:28:50,709 --> 00:28:54,090
We also had a quick look
at read only transactions,

653
00:28:54,090 --> 00:28:56,938
which are usable but be careful.

654
00:28:56,938 --> 00:28:58,938
And how to set timeouts.

655
00:29:00,072 --> 00:29:03,539
Okay, the next chapter is
the last one on transactions,

656
00:29:03,539 --> 00:29:05,993
you might be hearing about them now,

657
00:29:05,993 --> 00:29:08,830
so this one is going to be optional.

658
00:29:08,830 --> 00:29:10,014
There's not much Spring in there,

659
00:29:10,014 --> 00:29:14,181
but you might find it useful
to look at isolation rules.

1
00:00:00,090 --> 00:00:03,100
(groovy synth music)

2
00:00:10,331 --> 00:00:11,492
- [Voiceover] Welcome back.

3
00:00:11,492 --> 00:00:13,851
This is an optional chapter.

4
00:00:13,851 --> 00:00:17,272
It is quite useful, but
you can safely skip it,

5
00:00:17,272 --> 00:00:19,612
if you don't have time.

6
00:00:19,612 --> 00:00:23,493
I'm going to talk about what
transaction isolation is

7
00:00:23,493 --> 00:00:27,252
and how it affects your
database performance.

8
00:00:27,252 --> 00:00:30,572
We'll see that there are
four isolation levels

9
00:00:30,572 --> 00:00:34,073
defined by an ANSI/ISO standard.

10
00:00:34,073 --> 00:00:38,153
We'll see how changing them
can affect your application.

11
00:00:38,153 --> 00:00:40,872
And if you ever do need
to change the levels,

12
00:00:40,872 --> 00:00:43,293
we'll show you how to do that in Spring,

13
00:00:43,293 --> 00:00:45,422
that's the easy bit.

14
00:00:47,412 --> 00:00:50,692
In Spring, we are allowed to change the

15
00:00:50,692 --> 00:00:55,212
isolation level of each transaction.

16
00:00:55,212 --> 00:00:57,912
And to do so is fairly simple,

17
00:00:57,912 --> 00:01:00,092
it's just a property that you change

18
00:01:00,092 --> 00:01:03,172
on the transaction annotation.

19
00:01:03,172 --> 00:01:06,672
But in order to fully
understand what's going on here,

20
00:01:06,672 --> 00:01:08,952
to understand what this means,

21
00:01:08,952 --> 00:01:12,992
you will need to understand
what isolation levels are

22
00:01:12,992 --> 00:01:14,972
in databases.

23
00:01:14,972 --> 00:01:19,793
These levels are defined
by an ANSI/ISO standard.

24
00:01:19,793 --> 00:01:23,073
This course isn't a course
on database theory so,

25
00:01:23,073 --> 00:01:26,272
I can't cover isolation
levels in deep detail,

26
00:01:26,272 --> 00:01:28,832
but I am going to try to get across

27
00:01:28,832 --> 00:01:31,752
at least the basics.

28
00:01:31,752 --> 00:01:36,752
What does it mean for a
transaction to be isolated?

29
00:01:36,874 --> 00:01:38,273
Well what I'm going to do here is

30
00:01:38,273 --> 00:01:40,594
I'm going to run two transactions

31
00:01:40,594 --> 00:01:43,313
in parallel with each other.

32
00:01:43,313 --> 00:01:45,493
Down the left-hand side,

33
00:01:45,493 --> 00:01:47,913
I'm going to do a very simple transaction,

34
00:01:47,913 --> 00:01:51,614
where I'm selecting all of the
columns from the book table,

35
00:01:51,614 --> 00:01:55,655
where the ID is less than 10.

36
00:01:55,655 --> 00:01:57,894
Let's have a look at what
the results I get are.

37
00:01:57,894 --> 00:02:00,434
Well, in this particular database,

38
00:02:00,434 --> 00:02:03,775
I'm getting two rows.

39
00:02:03,775 --> 00:02:06,315
The concepts of isolation is all about

40
00:02:06,315 --> 00:02:08,795
how transactions are affected

41
00:02:08,795 --> 00:02:10,976
by other transactions

42
00:02:10,976 --> 00:02:13,956
that are running at the same time.

43
00:02:13,956 --> 00:02:16,775
So imagine that in another transaction,

44
00:02:16,775 --> 00:02:19,255
maybe this is another part of the system,

45
00:02:19,255 --> 00:02:24,096
or another thread in
the system, or whatever.

46
00:02:24,096 --> 00:02:28,017
Either way, we have a
new transaction running.

47
00:02:28,017 --> 00:02:30,237
I'll call this transaction two,

48
00:02:30,237 --> 00:02:33,576
it's going to be on the
right-hand side of the screen.

49
00:02:33,576 --> 00:02:36,936
And they have done two things,

50
00:02:36,936 --> 00:02:41,576
they've updated the titles
of one of the books,

51
00:02:41,576 --> 00:02:45,936
they've changed Fly
Fishing to Fly Hunting,

52
00:02:45,936 --> 00:02:48,736
and they've also inserted a new row

53
00:02:48,736 --> 00:02:50,636
into the book table.

54
00:02:50,636 --> 00:02:52,476
So, a new book.

55
00:02:52,476 --> 00:02:56,756
And they've issued a commit statement.

56
00:02:56,756 --> 00:02:59,416
Now let's switch back
across to transaction one

57
00:02:59,416 --> 00:03:01,677
on the left-hand side.

58
00:03:01,677 --> 00:03:03,976
Now, as we go down the screen,

59
00:03:03,976 --> 00:03:07,636
you can imagine this as time passing.

60
00:03:07,636 --> 00:03:10,716
So transaction one hasn't yet committed,

61
00:03:10,716 --> 00:03:13,417
they've been maybe doing
some other processing,

62
00:03:13,417 --> 00:03:16,596
or some in-memory operations,

63
00:03:16,596 --> 00:03:20,056
or maybe they've been waiting
for some input from a user,

64
00:03:20,056 --> 00:03:23,556
but anyway, some time has passed,

65
00:03:23,556 --> 00:03:27,196
their transaction has not yet completed.

66
00:03:27,196 --> 00:03:29,136
Now what transaction one is going to do,

67
00:03:29,136 --> 00:03:31,917
is they're going to repeat the query,

68
00:03:31,917 --> 00:03:35,936
select star from book
where ID is less than 10,

69
00:03:35,936 --> 00:03:39,956
after transaction two has committed.

70
00:03:39,956 --> 00:03:41,777
My question is,

71
00:03:41,777 --> 00:03:46,616
what do you think the results
of this repeated query

72
00:03:46,616 --> 00:03:48,337
are going to be?

73
00:03:48,337 --> 00:03:49,777
Before I answer that,

74
00:03:49,777 --> 00:03:51,916
let me get one frequently asked question

75
00:03:51,916 --> 00:03:54,096
out of the way first.

76
00:03:54,096 --> 00:03:55,616
Why would we do this?

77
00:03:55,616 --> 00:04:00,017
Why would we issue the same select again

78
00:04:00,017 --> 00:04:02,516
in the same transaction?

79
00:04:02,516 --> 00:04:07,396
Well, okay, I guess we probably wouldn't,

80
00:04:07,396 --> 00:04:11,897
but the point that we're
really asking here is,

81
00:04:11,897 --> 00:04:15,437
while this left-hand
transaction has been running,

82
00:04:15,437 --> 00:04:17,658
some changes might've been made

83
00:04:17,658 --> 00:04:20,497
by other transactions.

84
00:04:20,497 --> 00:04:24,598
What will the effect of those changes be

85
00:04:24,598 --> 00:04:27,797
on our first transaction?

86
00:04:27,797 --> 00:04:30,957
So while we probably wouldn't
repeat the query like this,

87
00:04:30,957 --> 00:04:34,717
it's a good way of generically stating,

88
00:04:34,717 --> 00:04:36,477
how are we affected

89
00:04:36,477 --> 00:04:39,257
by the concurrent changes?

90
00:04:39,257 --> 00:04:41,337
So for example,

91
00:04:41,337 --> 00:04:44,547
if we insert a new book into the

92
00:04:44,547 --> 00:04:46,507
book table here,

93
00:04:46,507 --> 00:04:48,762
around this point,

94
00:04:48,762 --> 00:04:51,141
can I be sure that the ID

95
00:04:51,141 --> 00:04:53,521
of the new book that I've inserted

96
00:04:53,521 --> 00:04:56,002
is going to be three?

97
00:04:56,002 --> 00:04:58,862
Can we be absolutely sure?

98
00:04:58,862 --> 00:05:00,982
Remember this other transaction,

99
00:05:00,982 --> 00:05:03,262
on the right-hand side has jumped in

100
00:05:03,262 --> 00:05:06,422
and it has done an insert.

101
00:05:06,422 --> 00:05:08,082
But to keep it general,

102
00:05:08,082 --> 00:05:10,343
all of the isolation theory

103
00:05:10,343 --> 00:05:12,042
is stated as

104
00:05:12,042 --> 00:05:16,663
what happens if the query is repeated?

105
00:05:16,663 --> 00:05:17,923
Well perhaps you might want to

106
00:05:17,923 --> 00:05:19,563
pause the video for a few moments

107
00:05:19,563 --> 00:05:21,523
and think about what you think

108
00:05:21,523 --> 00:05:24,584
the results should be.

109
00:05:24,584 --> 00:05:28,305
Well the answer in fact is, it depends,

110
00:05:28,305 --> 00:05:32,406
but in a fully isolated
database, in other words,

111
00:05:32,406 --> 00:05:36,355
if we are applying the full
theory of transactions,

112
00:05:36,355 --> 00:05:39,326
if we have true transactions,

113
00:05:39,326 --> 00:05:41,125
then what we would expect

114
00:05:41,125 --> 00:05:45,285
is for this second
query in transaction one

115
00:05:45,285 --> 00:05:48,606
to return the following results.

116
00:05:48,606 --> 00:05:52,365
Exactly the same results as before

117
00:05:52,365 --> 00:05:55,465
because in transactional theory,

118
00:05:55,465 --> 00:05:57,946
once a transaction begins,

119
00:05:57,946 --> 00:06:01,045
that transaction will not be affected

120
00:06:01,045 --> 00:06:05,025
by other transactions
running at the same time.

121
00:06:05,025 --> 00:06:08,306
That's effectively so that
we don't see transactions

122
00:06:08,306 --> 00:06:11,866
trampling on other's data,

123
00:06:11,866 --> 00:06:15,287
and causing unpredictable problems.

124
00:06:15,287 --> 00:06:17,207
So this means for example,

125
00:06:17,207 --> 00:06:22,207
we can be sure that once we've
done the first select here,

126
00:06:22,866 --> 00:06:25,707
if we were then to do an insert,

127
00:06:25,707 --> 00:06:30,608
even if it takes us a few
seconds to get to the insert,

128
00:06:30,608 --> 00:06:35,608
then the ID of our book
will definitely be three.

129
00:06:35,748 --> 00:06:36,848
In other words,

130
00:06:36,848 --> 00:06:39,189
the other transaction here on the right,

131
00:06:39,189 --> 00:06:43,188
can't sort of jump in and steal the ID

132
00:06:43,188 --> 00:06:46,490
that we're expecting to have.

133
00:06:46,490 --> 00:06:51,109
This is full and true isolation.

134
00:06:51,109 --> 00:06:53,189
But there's a huge problem with this,

135
00:06:53,189 --> 00:06:56,310
and that's performance.

136
00:06:56,310 --> 00:06:59,950
In order to support this
kind of functionality,

137
00:06:59,950 --> 00:07:04,789
the database will have to use
strategies such as locking.

138
00:07:04,789 --> 00:07:07,849
With the ID example I mentioned before,

139
00:07:07,849 --> 00:07:10,749
once we've done this select here,

140
00:07:10,749 --> 00:07:14,569
the database will have
to lock the book table,

141
00:07:14,569 --> 00:07:17,430
so that we can safely work on it.

142
00:07:17,430 --> 00:07:19,570
The transaction here on the right,

143
00:07:19,570 --> 00:07:21,390
when it tries to make this change,

144
00:07:21,390 --> 00:07:23,790
when it tries to do the insert,

145
00:07:23,790 --> 00:07:27,250
it will have to stop and wait,

146
00:07:27,250 --> 00:07:29,109
it will be blocked

147
00:07:29,109 --> 00:07:32,880
until our first transaction commits.

148
00:07:34,030 --> 00:07:37,010
Another problem with full isolation is

149
00:07:37,010 --> 00:07:40,209
you potentially get deadlocks.

150
00:07:40,209 --> 00:07:43,230
And that's where
transaction one is waiting

151
00:07:43,230 --> 00:07:47,489
for some kind of a lock to be
released by transaction two,

152
00:07:47,489 --> 00:07:51,429
but transaction two is waiting
for a lock to be released

153
00:07:51,429 --> 00:07:53,549
by transaction one.

154
00:07:53,549 --> 00:07:58,289
And it's surprisingly easy
to get into that situation.

155
00:07:58,289 --> 00:07:59,829
So we have a general problem,

156
00:07:59,829 --> 00:08:02,429
especially in databases where you have

157
00:08:02,429 --> 00:08:05,750
lots of concurrent transactions.

158
00:08:05,750 --> 00:08:08,911
Now for what we are generally
calling enterprise systems,

159
00:08:08,911 --> 00:08:13,092
these are usually systems
with lots of concurrent users,

160
00:08:13,092 --> 00:08:16,112
possibly thousands of concurrent users

161
00:08:16,112 --> 00:08:20,932
accessing the same database
through a web frontend.

162
00:08:20,932 --> 00:08:22,691
So usually,

163
00:08:22,691 --> 00:08:24,891
we need to do some kind of compromise

164
00:08:24,891 --> 00:08:27,932
to make the database perform well.

165
00:08:27,932 --> 00:08:30,712
So what happens in real-life,

166
00:08:30,712 --> 00:08:32,771
is on our database we compromise

167
00:08:32,771 --> 00:08:37,591
and set a less rigorous
level of isolation.

168
00:08:37,591 --> 00:08:40,121
You can do this either
for the entire database,

169
00:08:40,121 --> 00:08:42,071
as a global default,

170
00:08:42,071 --> 00:08:43,831
and you can also change this on a

171
00:08:43,831 --> 00:08:47,331
transaction by transaction basis.

172
00:08:47,331 --> 00:08:50,151
As I mentioned before,
there is an ISO standard

173
00:08:50,151 --> 00:08:52,391
that defines four levels

174
00:08:52,391 --> 00:08:55,811
of database isolation that you can set.

175
00:08:55,811 --> 00:08:59,031
The previous level that
we have just described,

176
00:08:59,031 --> 00:09:01,691
in other words, full isolation

177
00:09:01,691 --> 00:09:04,431
is called by the standard,

178
00:09:04,431 --> 00:09:07,511
serializable.

179
00:09:07,511 --> 00:09:09,731
This is a confusing term

180
00:09:09,731 --> 00:09:13,131
because it has nothing whatsoever to do

181
00:09:13,131 --> 00:09:16,591
with the Java term, serializable.

182
00:09:16,591 --> 00:09:17,892
You may have come across that

183
00:09:17,892 --> 00:09:20,431
when handling files, and streams,

184
00:09:20,431 --> 00:09:24,412
and that kind of thing in Java.

185
00:09:24,412 --> 00:09:25,672
This is nothing to do with that.

186
00:09:25,672 --> 00:09:30,052
They call this isolation
level serializable

187
00:09:30,052 --> 00:09:33,212
because it feels as though
the transactions are run

188
00:09:33,212 --> 00:09:38,032
serially, i.e. one after the after.

189
00:09:38,032 --> 00:09:41,052
Here's the transaction that we had before,

190
00:09:41,052 --> 00:09:43,952
and assuming that the database was set

191
00:09:43,952 --> 00:09:48,932
to the full level of
serializable transactions,

192
00:09:48,932 --> 00:09:52,632
then although in real-life,

193
00:09:52,632 --> 00:09:56,452
the transaction timeline looked like this,

194
00:09:56,452 --> 00:09:58,873
what the database is going to do,

195
00:09:58,873 --> 00:10:02,272
is we begin the transaction
on transaction one,

196
00:10:02,272 --> 00:10:04,733
but then in transaction two,

197
00:10:04,733 --> 00:10:06,092
when we get to the commit,

198
00:10:06,092 --> 00:10:10,053
the database is going
to postpone the commit.

199
00:10:10,053 --> 00:10:14,133
It's going to make transaction two wait

200
00:10:14,133 --> 00:10:18,233
until transaction one is finished.

201
00:10:18,233 --> 00:10:22,294
Imagine that there's a commit about here.

202
00:10:22,294 --> 00:10:26,773
Only then, will transaction
two be allowed to execute.

203
00:10:26,773 --> 00:10:30,653
It is as if the transactions
are being serialized,

204
00:10:30,653 --> 00:10:33,073
one after the other.

205
00:10:33,073 --> 00:10:37,394
As I've said, this is likely
to compromise performance,

206
00:10:37,394 --> 00:10:39,054
so there are three other levels

207
00:10:39,054 --> 00:10:42,233
that you can set for your database.

208
00:10:42,233 --> 00:10:46,153
Again, these are defined
by the ANSI/ISO standard,

209
00:10:46,153 --> 00:10:50,833
and the three levels are
quite strange terms really,

210
00:10:50,833 --> 00:10:54,493
they are repeatable read,

211
00:10:54,493 --> 00:10:56,734
read committed,

212
00:10:56,734 --> 00:10:59,813
and read uncommitted.

213
00:10:59,813 --> 00:11:02,473
I'll explain how each of them behaves

214
00:11:02,473 --> 00:11:04,393
in a few moments.

215
00:11:04,393 --> 00:11:07,694
But roughly, as we go
down the screen here,

216
00:11:07,694 --> 00:11:11,594
we're getting better
and better performance,

217
00:11:11,594 --> 00:11:15,693
but at the cost of less integrity.

218
00:11:15,693 --> 00:11:19,993
So you can think of repeatable
read as being the safest

219
00:11:19,993 --> 00:11:21,813
of these three.

220
00:11:21,813 --> 00:11:24,333
But it won't perform as well

221
00:11:24,333 --> 00:11:27,794
as the other alternatives.

222
00:11:27,794 --> 00:11:30,573
Read uncommitted, here at the bottom,

223
00:11:30,573 --> 00:11:33,573
will give the best
performance of the three,

224
00:11:33,573 --> 00:11:36,113
but the least integrity.

225
00:11:36,113 --> 00:11:37,653
So, let's look at them all,

226
00:11:37,653 --> 00:11:38,874
and we'll begin by looking at

227
00:11:38,874 --> 00:11:40,874
what would happen if we set our

228
00:11:40,874 --> 00:11:43,734
database's default isolation level

229
00:11:43,734 --> 00:11:46,094
to repeatable read.

230
00:11:46,094 --> 00:11:47,354
Well, what I will do is

231
00:11:47,354 --> 00:11:50,296
repeat the experiment again.

232
00:11:50,296 --> 00:11:53,976
Recall that we have transaction
one on the left-hand side,

233
00:11:53,976 --> 00:11:56,095
and we are going to issue the

234
00:11:56,095 --> 00:12:01,095
select star from book
where ID is less than 10.

235
00:12:01,395 --> 00:12:05,095
As before, we have two rows returned back

236
00:12:05,095 --> 00:12:07,275
from the database.

237
00:12:07,275 --> 00:12:09,736
And once again, we have transaction two

238
00:12:09,736 --> 00:12:11,935
on the right-hand side,

239
00:12:11,935 --> 00:12:13,936
begins a transaction,

240
00:12:13,936 --> 00:12:16,195
updates one of the rows,

241
00:12:16,195 --> 00:12:19,335
and then it inserts a
new row into the table

242
00:12:19,335 --> 00:12:23,295
and then attempts to commit the changes.

243
00:12:23,295 --> 00:12:26,995
We go back to transaction
one on the left-hand side,

244
00:12:26,995 --> 00:12:29,155
as before, we're going to

245
00:12:29,155 --> 00:12:32,436
reissue that select statement.

246
00:12:32,436 --> 00:12:35,955
Remember we've set the database
now to repeatable read,

247
00:12:35,955 --> 00:12:39,415
what results can we expect?

248
00:12:39,415 --> 00:12:41,555
There's the results.

249
00:12:41,555 --> 00:12:45,616
This time around we can still guarantee,

250
00:12:45,616 --> 00:12:48,335
that the first two rows

251
00:12:48,335 --> 00:12:51,756
will still be the same
as they were before.

252
00:12:51,756 --> 00:12:55,135
So the update made by transaction two,

253
00:12:55,135 --> 00:12:58,015
the Fly Hunting is not yet visible,

254
00:12:58,015 --> 00:13:00,276
and therefore this has not affected

255
00:13:00,276 --> 00:13:02,776
our work in transaction one.

256
00:13:02,776 --> 00:13:07,776
However, we can see the new
row that has been added.

257
00:13:08,395 --> 00:13:11,117
We're seeing a book of ID three,

258
00:13:11,117 --> 00:13:13,876
called War and Peace.

259
00:13:13,876 --> 00:13:16,676
So this is a kind of compromise.

260
00:13:16,676 --> 00:13:21,377
We are getting different
results with our second select,

261
00:13:21,377 --> 00:13:25,178
but at least the data
that we've already seen

262
00:13:25,178 --> 00:13:28,057
is being preserved.

263
00:13:28,057 --> 00:13:30,357
So it means, for example that,

264
00:13:30,357 --> 00:13:32,017
we can be safe in the knowledge that

265
00:13:32,017 --> 00:13:34,919
for the duration of this transaction,

266
00:13:34,919 --> 00:13:36,539
the book with ID one,

267
00:13:36,539 --> 00:13:38,778
is not going to change.

268
00:13:38,778 --> 00:13:42,278
So we can safely read
the values from the book,

269
00:13:42,278 --> 00:13:46,418
knowing that we don't suddenly
see some kind of change.

270
00:13:46,418 --> 00:13:49,698
But we are not safe in assuming that

271
00:13:49,698 --> 00:13:53,198
if we do an insert in transaction one,

272
00:13:53,198 --> 00:13:57,278
that we can guarantee a particular ID.

273
00:13:57,278 --> 00:14:00,318
If I'd done an insert around here,

274
00:14:00,318 --> 00:14:01,758
in the timeline,

275
00:14:01,758 --> 00:14:04,698
then I would of got an ID of three.

276
00:14:04,698 --> 00:14:07,558
But if I'd waited a few milliseconds,

277
00:14:07,558 --> 00:14:11,859
and tried to do an insert
in the timeline here,

278
00:14:11,859 --> 00:14:13,439
or here,

279
00:14:13,439 --> 00:14:16,739
I would have an ID of four.

280
00:14:16,739 --> 00:14:18,299
And that's assuming that there aren't

281
00:14:18,299 --> 00:14:21,240
another series of transactions that are

282
00:14:21,240 --> 00:14:23,219
taking up the IDs as well.

283
00:14:23,219 --> 00:14:24,959
So I have really no way of knowing

284
00:14:24,959 --> 00:14:26,959
when I insert at this level,

285
00:14:26,959 --> 00:14:30,439
what the resulting ID is going to be.

286
00:14:30,439 --> 00:14:32,820
So, if you're running at this

287
00:14:32,820 --> 00:14:35,119
softer isolation level,

288
00:14:35,119 --> 00:14:37,100
you need to be aware

289
00:14:37,100 --> 00:14:39,999
of what the compromises are,

290
00:14:39,999 --> 00:14:43,159
and you need to make allowances for it.

291
00:14:43,159 --> 00:14:44,999
By the way, there's a jargon term

292
00:14:44,999 --> 00:14:49,460
for this phenomenon where
we're seeing rows appear

293
00:14:49,460 --> 00:14:52,299
that we haven't seen
before in the transaction,

294
00:14:52,299 --> 00:14:53,699
and it's called

295
00:14:53,699 --> 00:14:56,199
a phantom read.

296
00:14:56,199 --> 00:14:58,759
I'm not quite sure where
the term comes from

297
00:14:58,759 --> 00:15:00,759
or who invented it, but,

298
00:15:00,759 --> 00:15:02,479
I guess it's kinda like this

299
00:15:02,479 --> 00:15:07,479
third row has appeared from
nowhere like a ghost, hmm.

300
00:15:08,340 --> 00:15:09,820
So it might not look
like a big difference,

301
00:15:09,820 --> 00:15:11,760
but it is quite a big compromise.

302
00:15:11,760 --> 00:15:14,760
The database, when we
do a select statement,

303
00:15:14,760 --> 00:15:18,819
it doesn't have to lock
an entire range of values.

304
00:15:18,819 --> 00:15:21,299
It will often actually just record the

305
00:15:21,299 --> 00:15:24,460
IDs of the rows that you have selected,

306
00:15:24,460 --> 00:15:27,020
and then it will cache
the data from those rows

307
00:15:27,020 --> 00:15:29,840
in some kind of local working memory.

308
00:15:29,840 --> 00:15:32,421
So it doesn't even need to use locks

309
00:15:32,421 --> 00:15:34,620
to make this work.

310
00:15:34,620 --> 00:15:36,260
In the previous isolation level,

311
00:15:36,260 --> 00:15:39,460
the full isolation of serializable,

312
00:15:39,460 --> 00:15:43,100
basically the entire
table has to be locked.

313
00:15:43,100 --> 00:15:45,540
In this case it doesn't have to be.

314
00:15:45,540 --> 00:15:48,060
So it will perform better
than full isolation,

315
00:15:48,060 --> 00:15:50,761
but you have to be aware of the risks

316
00:15:50,761 --> 00:15:53,600
of phantom reads.

317
00:15:53,600 --> 00:15:55,720
If that doesn't perform
well enough for you,

318
00:15:55,720 --> 00:15:58,540
then you can drop down to the next level,

319
00:15:58,540 --> 00:16:02,920
and this is called by the
ANSI standard, read committed.

320
00:16:02,920 --> 00:16:04,880
And I'll repeat the experiment again

321
00:16:04,880 --> 00:16:06,700
exactly the same as before,

322
00:16:06,700 --> 00:16:09,760
we do the select in transaction one,

323
00:16:09,760 --> 00:16:11,621
we get the two rows back,

324
00:16:11,621 --> 00:16:14,021
transaction two begins and commits

325
00:16:14,021 --> 00:16:17,600
with an update and an insert,

326
00:16:17,600 --> 00:16:19,522
and then we get to the point again where

327
00:16:19,522 --> 00:16:21,602
we repeat the select

328
00:16:21,602 --> 00:16:23,702
back in transaction one.

329
00:16:23,702 --> 00:16:28,562
At this level, we will
potentially see some big changes.

330
00:16:28,562 --> 00:16:31,122
As you can see here,

331
00:16:31,122 --> 00:16:34,102
not only are we seeing the
third row in the table,

332
00:16:34,102 --> 00:16:36,623
that's the phantom read.

333
00:16:36,623 --> 00:16:39,903
We're also seeing the row with ID one

334
00:16:39,903 --> 00:16:42,763
has suddenly changed.

335
00:16:42,763 --> 00:16:45,203
So this is a far less

336
00:16:45,203 --> 00:16:47,903
rigorous level of isolation.

337
00:16:47,903 --> 00:16:50,583
And so you are prone in this to see

338
00:16:50,583 --> 00:16:53,603
changes happening from
multiple transactions

339
00:16:53,603 --> 00:16:56,264
overlapping each other.

340
00:16:56,264 --> 00:16:58,423
In this level of isolation,

341
00:16:58,423 --> 00:17:00,523
this phenomenon is known

342
00:17:00,523 --> 00:17:03,423
as a non repeatable read.

343
00:17:03,423 --> 00:17:05,644
That means in this case, a minute ago,

344
00:17:05,644 --> 00:17:06,924
I made a read,

345
00:17:06,924 --> 00:17:09,446
and I saw the value of Fly Fishing,

346
00:17:09,446 --> 00:17:13,887
and now, later on, it's
changed to Fly Hunting.

347
00:17:13,887 --> 00:17:16,988
And I feel like I can't
go back to the state

348
00:17:16,988 --> 00:17:20,308
that we were in at the
beginning of the transaction.

349
00:17:20,308 --> 00:17:22,507
Now just have a think about how serious

350
00:17:22,507 --> 00:17:24,627
the impact of this could be,

351
00:17:24,627 --> 00:17:26,529
if you had a big transaction

352
00:17:26,529 --> 00:17:29,670
that might be running for several seconds,

353
00:17:29,670 --> 00:17:32,050
that's doing complicated reporting

354
00:17:32,050 --> 00:17:35,650
across multiple tables,
or something like that.

355
00:17:35,650 --> 00:17:37,829
You could see calculations made

356
00:17:37,829 --> 00:17:41,371
at the start of the
transaction that don't tally

357
00:17:41,371 --> 00:17:42,813
with calculations you're making

358
00:17:42,813 --> 00:17:45,093
towards the end of the transaction.

359
00:17:45,093 --> 00:17:46,874
You have to be aware

360
00:17:46,874 --> 00:17:50,093
of the risk of non repeatable reads,

361
00:17:50,093 --> 00:17:52,413
if you're running at this level.

362
00:17:52,413 --> 00:17:55,093
The fourth level of isolation

363
00:17:55,093 --> 00:17:58,374
is called read uncommitted.

364
00:17:58,374 --> 00:18:01,793
This is the most dangerous level,

365
00:18:01,793 --> 00:18:06,434
but it is afterall, the
most performance level.

366
00:18:06,434 --> 00:18:08,373
If I can summarize this level of English,

367
00:18:08,373 --> 00:18:11,417
it basically means no isolation at all.

368
00:18:11,417 --> 00:18:12,456
I'll repeat the example,

369
00:18:12,456 --> 00:18:15,357
but it will be slightly
different this time.

370
00:18:15,357 --> 00:18:16,917
We do the select,

371
00:18:16,917 --> 00:18:19,276
and get those two rows back.

372
00:18:19,276 --> 00:18:21,497
Over to transaction two,

373
00:18:21,497 --> 00:18:23,916
this is going to update one row

374
00:18:23,916 --> 00:18:25,636
and insert another row,

375
00:18:25,636 --> 00:18:27,556
but this is the difference,

376
00:18:27,556 --> 00:18:31,077
I haven't yet committed.

377
00:18:31,077 --> 00:18:36,077
This transaction is still in progress.

378
00:18:36,258 --> 00:18:38,159
Back to transaction one,

379
00:18:38,159 --> 00:18:41,161
we're going to issue the select here.

380
00:18:41,161 --> 00:18:44,362
Well, at this level of isolation,

381
00:18:44,362 --> 00:18:46,781
I can potentially pick up

382
00:18:46,781 --> 00:18:50,282
the uncommitted changes.

383
00:18:50,282 --> 00:18:54,202
Meaning that transaction one
is now seeing Fly Hunting

384
00:18:54,202 --> 00:18:57,243
and War and Peace.

385
00:18:57,243 --> 00:18:59,304
Now this is, in many cases,

386
00:18:59,304 --> 00:19:02,264
a horrible level of isolation.

387
00:19:02,264 --> 00:19:05,665
Because transaction two over
here on the right-hand side,

388
00:19:05,665 --> 00:19:08,745
might decide to terminate
what they were doing,

389
00:19:08,745 --> 00:19:10,825
they've rolled back,

390
00:19:10,825 --> 00:19:13,926
and yet somehow the data of Fly Hunting

391
00:19:13,926 --> 00:19:15,906
and War and Peace has been picked up

392
00:19:15,906 --> 00:19:18,045
by transaction one.

393
00:19:18,045 --> 00:19:21,026
And of course, transaction one might now,

394
00:19:21,026 --> 00:19:23,605
save that data to the database.

395
00:19:23,605 --> 00:19:25,506
So this kind of invalid data

396
00:19:25,506 --> 00:19:28,506
that was never intended
to be in the system,

397
00:19:28,506 --> 00:19:32,146
has kind of leaked into the database.

398
00:19:32,146 --> 00:19:34,866
This potential problem, I like this,

399
00:19:34,866 --> 00:19:38,066
is called a dirty read.

400
00:19:38,066 --> 00:19:40,028
Well there's are the four levels

401
00:19:40,028 --> 00:19:44,049
defined by the ANSI/ISO standard,
but the next question is,

402
00:19:44,049 --> 00:19:47,829
does a database have to
support all four levels?

403
00:19:47,829 --> 00:19:49,748
And the answer's no.

404
00:19:49,748 --> 00:19:51,788
Database vendors are free to support

405
00:19:51,788 --> 00:19:55,848
any or all of the four
levels that you've just seen.

406
00:19:55,848 --> 00:19:57,489
I thought I'd just take you through

407
00:19:57,489 --> 00:20:00,469
three examples of database
vendors to show you

408
00:20:00,469 --> 00:20:02,809
how these things vary.

409
00:20:02,809 --> 00:20:06,291
MySQL for instance, of
course a very popular

410
00:20:06,291 --> 00:20:08,712
and widely used database.

411
00:20:08,712 --> 00:20:11,072
If you're using transactions,

412
00:20:11,072 --> 00:20:15,112
and therefore if you're
using the InnoDB engine,

413
00:20:15,112 --> 00:20:19,094
then in that case, all
four levels are supported,

414
00:20:19,094 --> 00:20:23,375
but the default is repeatable read.

415
00:20:23,375 --> 00:20:24,817
Oracle, on the other hand,

416
00:20:24,817 --> 00:20:28,218
I know a lot of you will be
using Oracle on projects.

417
00:20:28,218 --> 00:20:32,538
They support just two
of the isolation levels,

418
00:20:32,538 --> 00:20:34,758
that's serializable,

419
00:20:34,758 --> 00:20:39,758
on top of the default of read committed.

420
00:20:40,099 --> 00:20:43,100
Now I'll also mention HSQLDB because

421
00:20:43,100 --> 00:20:45,640
you're using that in the practical work.

422
00:20:45,640 --> 00:20:47,160
Well in version one that we used

423
00:20:47,160 --> 00:20:49,420
on the first edition of this course,

424
00:20:49,420 --> 00:20:51,940
only read uncommitted was supported,

425
00:20:51,940 --> 00:20:53,881
but they have expanded that now

426
00:20:53,881 --> 00:20:57,322
in the later version of HSQLDB.

427
00:20:57,322 --> 00:21:02,103
They now support read
committed and serializable.

428
00:21:02,103 --> 00:21:04,744
Now HSQLDB, we're using as a kind of

429
00:21:04,744 --> 00:21:07,389
embedded database, which
is only going to run on

430
00:21:07,389 --> 00:21:10,109
single threads, so it
doesn't really matter

431
00:21:10,109 --> 00:21:13,829
about isolation levels when
you're using it for that.

432
00:21:13,829 --> 00:21:17,669
But the point is that,
now you could use HSQLDB

433
00:21:17,669 --> 00:21:22,089
as a production standard
transactional database.

434
00:21:22,089 --> 00:21:24,810
If you want to experiment
with isolation levels,

435
00:21:24,810 --> 00:21:27,412
and it's very instructive to do so.

436
00:21:27,412 --> 00:21:30,276
My recommendation will be
to get hold of a database

437
00:21:30,276 --> 00:21:33,776
that supports all four isolation levels,

438
00:21:33,776 --> 00:21:36,675
and of course therefore
MySQL is a good choice

439
00:21:36,675 --> 00:21:40,596
because it's open-source
and easy to get hold of.

440
00:21:40,596 --> 00:21:43,695
Then you could take two query browsers,

441
00:21:43,695 --> 00:21:45,196
I've obtained these query browsers

442
00:21:45,196 --> 00:21:47,917
from the archive downloads page

443
00:21:47,917 --> 00:21:50,337
on the MySQL site

444
00:21:50,337 --> 00:21:51,917
because they've now switched to

445
00:21:51,917 --> 00:21:53,237
something called the Workbench,

446
00:21:53,237 --> 00:21:55,998
which I don't like very much.

447
00:21:55,998 --> 00:21:58,919
Query browser is great for
doing this kind of thing.

448
00:21:58,919 --> 00:22:00,979
And then we can run two separate windows

449
00:22:00,979 --> 00:22:02,640
alongside each other,

450
00:22:02,640 --> 00:22:05,000
and then effectively, in one window

451
00:22:05,000 --> 00:22:06,779
you've got one transaction,

452
00:22:06,779 --> 00:22:10,340
and in the second window,
you have another transaction.

453
00:22:10,340 --> 00:22:12,281
Make sure if you are using MySQL,

454
00:22:12,281 --> 00:22:16,262
that you are using the
InnoDB database engine.

455
00:22:16,262 --> 00:22:19,802
On Windows, I think
that's the default anyway,

456
00:22:19,802 --> 00:22:22,302
but on Linux or Unix,

457
00:22:22,302 --> 00:22:24,642
you may have to explicitly make the

458
00:22:24,642 --> 00:22:28,062
InnoDB engine be the default.

459
00:22:28,062 --> 00:22:29,583
What you can do in the query browser,

460
00:22:29,583 --> 00:22:32,245
is you can do a select,

461
00:22:32,245 --> 00:22:34,505
and it's quite strange syntax this,

462
00:22:34,505 --> 00:22:38,165
it's select @@,

463
00:22:38,165 --> 00:22:43,165
and then tx_isolation.

464
00:22:43,447 --> 00:22:45,228
It's non-standard SQL that,

465
00:22:45,228 --> 00:22:48,388
but if I execute that query,

466
00:22:48,388 --> 00:22:50,388
it's telling me that the level is,

467
00:22:50,388 --> 00:22:54,148
as we expected, repeatable read.

468
00:22:54,148 --> 00:22:58,169
Remember that's the default on MySQL.

469
00:22:58,169 --> 00:22:59,869
To change the isolation level,

470
00:22:59,869 --> 00:23:02,429
it's quite a long command this.

471
00:23:02,429 --> 00:23:04,209
It is the command

472
00:23:04,209 --> 00:23:09,209
set global transaction

473
00:23:09,931 --> 00:23:12,830
isolation level,

474
00:23:12,830 --> 00:23:15,311
and then you follow it with
one of those four levels,

475
00:23:15,311 --> 00:23:18,671
but if you want a level
such as read committed,

476
00:23:18,671 --> 00:23:22,232
then it's two separate words.

477
00:23:22,232 --> 00:23:24,112
I'm going to run through
a quick example here

478
00:23:24,112 --> 00:23:27,592
of using serializable,

479
00:23:27,592 --> 00:23:30,632
you've got to be really
careful to spell it correctly.

480
00:23:30,632 --> 00:23:34,593
And a good tip here, I wasted
a lot of time in rehearsing

481
00:23:34,593 --> 00:23:36,213
for this session,

482
00:23:36,213 --> 00:23:39,193
when you run that command,

483
00:23:39,193 --> 00:23:42,553
make sure you get the output down here of

484
00:23:42,553 --> 00:23:45,894
query returned no results set.

485
00:23:45,894 --> 00:23:48,434
If you have a typo in here,

486
00:23:48,434 --> 00:23:51,393
and you run it, you might
think it's worked okay,

487
00:23:51,393 --> 00:23:54,515
there will be an error down
there that you might not notice.

488
00:23:54,515 --> 00:23:57,755
And it's very easy to get confused.

489
00:23:57,755 --> 00:23:59,715
So I'd probably recommend when you have

490
00:23:59,715 --> 00:24:01,836
changed the isolation level,

491
00:24:01,836 --> 00:24:04,377
just go back a command,

492
00:24:04,377 --> 00:24:06,537
and you can rerun this.

493
00:24:06,537 --> 00:24:09,058
And, oh well, that kind
of proves my point,

494
00:24:09,058 --> 00:24:11,437
it didn't appear to work,

495
00:24:11,437 --> 00:24:12,797
but the reason for that is

496
00:24:12,797 --> 00:24:16,138
the set global transaction isolation level

497
00:24:16,138 --> 00:24:19,459
sets it as the database's default

498
00:24:19,459 --> 00:24:21,979
for future sessions.

499
00:24:21,979 --> 00:24:25,610
So if I were to close this query browser.

500
00:24:26,859 --> 00:24:29,619
And start up a new one,

501
00:24:29,619 --> 00:24:31,599
and we'll check the isolation here

502
00:24:31,599 --> 00:24:34,620
with select

503
00:24:34,620 --> 00:24:37,700
tx_isolation.

504
00:24:37,700 --> 00:24:39,520
Yeah, it's now set to serializable,

505
00:24:39,520 --> 00:24:41,680
which is a little bit confusing.

506
00:24:41,680 --> 00:24:44,420
You can use the alternative command of

507
00:24:44,420 --> 00:24:48,680
set session transaction

508
00:24:48,680 --> 00:24:51,742
isolation level

509
00:24:51,742 --> 00:24:52,862
to whatever level,

510
00:24:52,862 --> 00:24:55,143
and that will just set the isolation level

511
00:24:55,143 --> 00:24:58,722
for this particular session.

512
00:24:58,722 --> 00:25:00,722
In other words, for
this particular instance

513
00:25:00,722 --> 00:25:02,782
of the query browser.

514
00:25:02,782 --> 00:25:06,762
But I'm going to leave
that at serializable now.

515
00:25:06,762 --> 00:25:08,022
And just for safety,

516
00:25:08,022 --> 00:25:10,333
I'm not sure if I need to do this.

517
00:25:11,603 --> 00:25:13,804
But I'll start a fresh query browser

518
00:25:13,804 --> 00:25:16,264
for my second transaction.

519
00:25:16,264 --> 00:25:18,703
So let's do exactly as we did

520
00:25:18,703 --> 00:25:20,764
on the previous captions.

521
00:25:20,764 --> 00:25:21,743
Here in transaction one,

522
00:25:21,743 --> 00:25:23,923
I'm going to begin a new transaction by

523
00:25:23,923 --> 00:25:25,723
clicking the button there.

524
00:25:25,723 --> 00:25:27,583
And then I'm going to select

525
00:25:27,583 --> 00:25:30,464
all of the columns from the book table,

526
00:25:30,464 --> 00:25:34,463
I may as well go for the
where ID is less than 10.

527
00:25:34,463 --> 00:25:37,844
And executing that,
we've got the Fly Fishing

528
00:25:37,844 --> 00:25:42,663
and the Richard and Judy book as well.

529
00:25:42,663 --> 00:25:46,023
Now remember that this
transaction is still running,

530
00:25:46,023 --> 00:25:48,863
this transaction is
waiting for either a commit

531
00:25:48,863 --> 00:25:50,843
or a rollback.

532
00:25:50,843 --> 00:25:54,204
We're going to switch across
to transaction two now,

533
00:25:54,204 --> 00:25:56,804
which we'll start.

534
00:25:56,804 --> 00:25:59,164
I'll do a full select on that table,

535
00:25:59,164 --> 00:26:00,504
that's not so important,

536
00:26:00,504 --> 00:26:04,184
but in here I'm going to
update the book table,

537
00:26:04,184 --> 00:26:06,564
and I'm going to set the title to,

538
00:26:06,564 --> 00:26:08,865
I think it was,

539
00:26:08,865 --> 00:26:11,644
Fly Hunting,

540
00:26:11,644 --> 00:26:14,644
where the ID is one,

541
00:26:14,644 --> 00:26:16,684
I'll execute that.

542
00:26:16,684 --> 00:26:19,325
And, actually,

543
00:26:19,325 --> 00:26:21,664
notice the mouse pointer

544
00:26:21,664 --> 00:26:25,466
has changed into an hourglass.

545
00:26:25,466 --> 00:26:27,590
Now it's done that because

546
00:26:27,590 --> 00:26:29,791
of the serializable level,

547
00:26:29,791 --> 00:26:31,930
this transaction has basically been told,

548
00:26:31,930 --> 00:26:33,330
"No, you can't do that,

549
00:26:33,330 --> 00:26:36,710
"you have to stop and wait."

550
00:26:36,710 --> 00:26:39,391
And it won't be allowed for this

551
00:26:39,391 --> 00:26:41,531
update to be processed

552
00:26:41,531 --> 00:26:44,810
until this transaction has completed.

553
00:26:44,810 --> 00:26:47,270
So they really are literally

554
00:26:47,270 --> 00:26:49,591
serialized into order.

555
00:26:49,591 --> 00:26:51,570
So I can keep repeating this query

556
00:26:51,570 --> 00:26:53,230
as often as I like and

557
00:26:53,230 --> 00:26:56,331
we're still seeing the Fly Fishing.

558
00:26:56,331 --> 00:26:57,790
Now what just happened there

559
00:26:57,790 --> 00:26:59,190
because I've been talking a bit,

560
00:26:59,190 --> 00:27:02,470
is there is a default timeout set on this.

561
00:27:02,470 --> 00:27:05,992
So, that failed, but I can

562
00:27:05,992 --> 00:27:07,971
attempt, I think, to reissue that,

563
00:27:07,971 --> 00:27:11,272
so notice there the hourglass has changed.

564
00:27:11,272 --> 00:27:15,022
If I now commit this transaction.

565
00:27:16,191 --> 00:27:17,711
Then back to here,

566
00:27:17,711 --> 00:27:21,452
we're now seeing one row is
affected by that command,

567
00:27:21,452 --> 00:27:22,473
and I could now go ahead

568
00:27:22,473 --> 00:27:25,592
and do my insert perfectly safely.

569
00:27:25,592 --> 00:27:28,512
Well in fact, I'm going to
rollback that transaction,

570
00:27:28,512 --> 00:27:31,572
so that the data is as it was before.

571
00:27:31,572 --> 00:27:32,653
And I just want to mention

572
00:27:32,653 --> 00:27:36,153
that this is one reason why
transactions are still valid

573
00:27:36,153 --> 00:27:37,833
and still useful,

574
00:27:37,833 --> 00:27:39,994
even if you're just querying.

575
00:27:39,994 --> 00:27:41,274
It ensures that we see

576
00:27:41,274 --> 00:27:44,214
a consistent snapshot of data

577
00:27:44,214 --> 00:27:46,455
through that transaction.

578
00:27:46,455 --> 00:27:48,276
And I think while I'm
here, I'll experiment

579
00:27:48,276 --> 00:27:49,995
with another isolation level,

580
00:27:49,995 --> 00:27:52,255
I didn't do this on the
first edition of this course,

581
00:27:52,255 --> 00:27:54,035
but it might be good fun.

582
00:27:54,035 --> 00:27:55,916
So I'm going to change the level now,

583
00:27:55,916 --> 00:27:56,935
I'm going to set the

584
00:27:56,935 --> 00:28:01,315
global transaction, love this command,

585
00:28:01,315 --> 00:28:05,277
isolation level to read committed.

586
00:28:05,277 --> 00:28:06,956
You have to spell committed correctly

587
00:28:06,956 --> 00:28:09,717
with two t's and two m's.

588
00:28:09,717 --> 00:28:14,496
And I'll close down the existing sessions.

589
00:28:14,496 --> 00:28:18,497
I'll fire up a new transaction one,

590
00:28:18,497 --> 00:28:21,497
and a new window for transaction two.

591
00:28:21,497 --> 00:28:23,736
And let's just check that we've got the

592
00:28:23,736 --> 00:28:26,727
isolation level,

593
00:28:28,358 --> 00:28:31,597
correct, yes we're now at read committed.

594
00:28:31,597 --> 00:28:35,318
So I'm going to repeat
the exercise from before.

595
00:28:35,318 --> 00:28:37,957
We begin a new transaction,

596
00:28:37,957 --> 00:28:41,437
we do select, and you
can see there Fly Fishing

597
00:28:41,437 --> 00:28:44,617
and my favorite, Richard and Judy.

598
00:28:44,617 --> 00:28:46,477
Over to transaction two,

599
00:28:46,477 --> 00:28:49,017
we begin a new transaction here.

600
00:28:49,017 --> 00:28:50,557
I may as well do a select,

601
00:28:50,557 --> 00:28:53,058
just so I can see what I'm working with.

602
00:28:53,058 --> 00:28:55,037
And we're going to update row one,

603
00:28:55,037 --> 00:28:57,718
so we're going to update the book table.

604
00:28:57,718 --> 00:29:01,718
We're going to set the title to

605
00:29:01,718 --> 00:29:05,698
Fly Hunting, I think it was,

606
00:29:05,698 --> 00:29:08,978
where the ID is one.

607
00:29:08,978 --> 00:29:10,719
I'll execute that, and that's good,

608
00:29:10,719 --> 00:29:12,679
one row affected.

609
00:29:12,679 --> 00:29:15,059
And I'm going to insert

610
00:29:15,059 --> 00:29:17,739
into the book.

611
00:29:17,739 --> 00:29:20,879
We've got set the title and the author,

612
00:29:20,879 --> 00:29:22,960
and the values for this will be,

613
00:29:22,960 --> 00:29:26,379
I think it was War and
Peace on the captions,

614
00:29:26,379 --> 00:29:28,219
I won't bother with an author,

615
00:29:28,219 --> 00:29:30,199
just to keep things quick.

616
00:29:30,199 --> 00:29:31,799
I'll execute that,

617
00:29:31,799 --> 00:29:34,919
and again, one row was affected.

618
00:29:34,919 --> 00:29:38,159
Now, here's something a little
different from the example,

619
00:29:38,159 --> 00:29:41,259
and quite important to recognize.

620
00:29:41,259 --> 00:29:45,440
If I do a select star from book

621
00:29:45,440 --> 00:29:49,319
on this table in this transaction,

622
00:29:49,319 --> 00:29:50,919
then I'm going to see the changes

623
00:29:50,919 --> 00:29:54,219
that I've made here in this transaction.

624
00:29:54,219 --> 00:29:57,559
And that would be true even
if we were serializable

625
00:29:57,559 --> 00:29:59,279
or repeatable read.

626
00:29:59,279 --> 00:30:01,140
The other transaction won't have picked

627
00:30:01,140 --> 00:30:02,441
these changes up yet,

628
00:30:02,441 --> 00:30:05,940
but my view in this
transaction of the data,

629
00:30:05,940 --> 00:30:09,280
is that the changes have been made.

630
00:30:09,280 --> 00:30:12,700
I'm going to commit this transaction here,

631
00:30:12,700 --> 00:30:16,621
and then we go back to first transaction,

632
00:30:16,621 --> 00:30:18,182
and the big difference will be,

633
00:30:18,182 --> 00:30:22,591
if I repeat that select,

634
00:30:22,591 --> 00:30:25,382
then yes, we're picking up the changes,

635
00:30:25,382 --> 00:30:28,421
we're able to read the committed data

636
00:30:28,421 --> 00:30:30,481
from other transactions.

637
00:30:30,481 --> 00:30:33,062
Which means we have a phantom read here

638
00:30:33,062 --> 00:30:34,882
on War and Peace,

639
00:30:34,882 --> 00:30:37,841
and we also have a non repeatable read

640
00:30:37,841 --> 00:30:40,321
on row one.

641
00:30:40,321 --> 00:30:42,241
So big changes there,

642
00:30:42,241 --> 00:30:45,861
just by changing the
default isolation level.

643
00:30:45,861 --> 00:30:48,282
I think I'll leave this example there now

644
00:30:48,282 --> 00:30:50,441
because this is beyond the
scope of the Spring course,

645
00:30:50,441 --> 00:30:53,001
but I want you to get a feel for this,

646
00:30:53,001 --> 00:30:55,761
and of course, you can
experiment yourself,

647
00:30:55,761 --> 00:30:59,881
but I do have one
warning for you in MySQL.

648
00:30:59,881 --> 00:31:04,141
If you set the level to repeatable read,

649
00:31:04,141 --> 00:31:07,401
that's where you will expect phantoms,

650
00:31:07,401 --> 00:31:09,461
you're going to find it's
actually quite difficult

651
00:31:09,461 --> 00:31:12,821
to actually get a phantom read.

652
00:31:12,821 --> 00:31:15,021
And that's because of the way that MySQL

653
00:31:15,021 --> 00:31:17,161
implements isolation.

654
00:31:17,161 --> 00:31:21,281
Technically, they have to
call the level repeatable read

655
00:31:21,281 --> 00:31:23,381
because phantoms are possible,

656
00:31:23,381 --> 00:31:25,661
but they're very, very rare.

657
00:31:25,661 --> 00:31:27,341
So you'll actually see

658
00:31:27,341 --> 00:31:30,581
almost no difference between serializable

659
00:31:30,581 --> 00:31:33,301
and repeatable read in MySQL.

660
00:31:33,301 --> 00:31:34,772
Although the repeatable read

661
00:31:34,772 --> 00:31:37,661
does perform a lot better.

662
00:31:37,661 --> 00:31:40,301
You wouldn't see the lock that we saw,

663
00:31:40,301 --> 00:31:42,681
when we were using serializable.

664
00:31:42,681 --> 00:31:46,121
So that was a long
discussion about isolation,

665
00:31:46,121 --> 00:31:49,821
all good theory but none
of it specific to Spring.

666
00:31:49,821 --> 00:31:51,121
Where does Spring come into this?

667
00:31:51,121 --> 00:31:53,221
Well, as I said in the introduction,

668
00:31:53,221 --> 00:31:55,081
for any method,

669
00:31:55,081 --> 00:31:58,641
we can change the default isolation level.

670
00:31:58,641 --> 00:32:00,201
Now I'm going to stress once more,

671
00:32:00,201 --> 00:32:02,781
this is not something
we would normally do,

672
00:32:02,781 --> 00:32:06,942
it's a very fine grained customization.

673
00:32:06,942 --> 00:32:11,761
Usually we would be accepting
the database defaults.

674
00:32:11,761 --> 00:32:14,662
You can use it on methods that

675
00:32:14,662 --> 00:32:16,701
cause you particular problems.

676
00:32:16,701 --> 00:32:18,162
Now I'm going to use buy book,

677
00:32:18,162 --> 00:32:19,904
just as an example,

678
00:32:19,904 --> 00:32:22,003
I'm not sure it would be a good candidate

679
00:32:22,003 --> 00:32:24,303
to change the isolation level, but,

680
00:32:24,303 --> 00:32:25,823
my favorite example is

681
00:32:25,823 --> 00:32:27,664
if you've got a method,

682
00:32:27,664 --> 00:32:30,383
which is going to take a long time to run

683
00:32:30,383 --> 00:32:33,683
and is doing something
where accuracy is important,

684
00:32:33,683 --> 00:32:36,143
maybe it's doing a report,

685
00:32:36,143 --> 00:32:39,343
and you want to make absolutely
sure that the queries done

686
00:32:39,343 --> 00:32:41,363
at the start of the method

687
00:32:41,363 --> 00:32:43,484
are consistent with the queries done

688
00:32:43,484 --> 00:32:45,423
at the end of the method.

689
00:32:45,423 --> 00:32:47,663
Then that might be a good candidate to

690
00:32:47,663 --> 00:32:50,903
temporarily raise the isolation level,

691
00:32:50,903 --> 00:32:52,923
just for that method.

692
00:32:52,923 --> 00:32:56,263
So, I will use the buy book method

693
00:32:56,263 --> 00:32:57,783
as an example,

694
00:32:57,783 --> 00:33:00,363
and it's actually very easy.

695
00:33:00,363 --> 00:33:05,163
Let's say, the database
default is read committed,

696
00:33:05,163 --> 00:33:06,643
which is good performance,

697
00:33:06,643 --> 00:33:09,124
but can allow phantom reads

698
00:33:09,124 --> 00:33:11,903
and can allow non repeatable reads.

699
00:33:11,903 --> 00:33:14,724
Well I can for the
duration of this method,

700
00:33:14,724 --> 00:33:19,343
set the attribute of isolation,

701
00:33:19,343 --> 00:33:21,704
and we set that equal to,

702
00:33:21,704 --> 00:33:23,924
and there's a class in the
Spring framework called

703
00:33:23,924 --> 00:33:28,405
isolation, and you'll need to import that.

704
00:33:28,405 --> 00:33:30,205
And if you hit the dot on there,

705
00:33:30,205 --> 00:33:34,446
you'll find all four of those
isolation levels available.

706
00:33:34,446 --> 00:33:37,145
There's a default as well,
which is the database default,

707
00:33:37,145 --> 00:33:40,527
which you'd get anyway, so
you don't really need it.

708
00:33:40,527 --> 00:33:43,267
So, I'm going to raise
the level of this method

709
00:33:43,267 --> 00:33:45,547
up to serializable,

710
00:33:45,547 --> 00:33:48,867
just for this transaction.

711
00:33:48,867 --> 00:33:50,767
Now remember that not all databases

712
00:33:50,767 --> 00:33:53,367
support all of these levels so,

713
00:33:53,367 --> 00:33:55,547
if you do specify a level that's

714
00:33:55,547 --> 00:33:57,707
not supported by your database,

715
00:33:57,707 --> 00:34:00,407
then your code will still run,

716
00:34:00,407 --> 00:34:04,987
but Spring will just go
for a best possible match.

717
00:34:04,987 --> 00:34:07,087
Say you're running on Oracle,

718
00:34:07,087 --> 00:34:10,407
which only has serializable
and read committed,

719
00:34:10,407 --> 00:34:12,787
and we ask for repeatable read, say,

720
00:34:12,787 --> 00:34:15,547
then it will go for
the next safest option,

721
00:34:15,547 --> 00:34:19,167
so it would upgrade your
level to serializable.

722
00:34:19,167 --> 00:34:21,247
Now it's actually quite difficult to see

723
00:34:21,247 --> 00:34:24,148
the results of changing this level.

724
00:34:24,148 --> 00:34:27,927
I'll clean the,

725
00:34:27,927 --> 00:34:30,368
(mumbling),

726
00:34:30,368 --> 00:34:33,269
again and run the client

727
00:34:33,269 --> 00:34:35,479
because we've got logging on.

728
00:34:38,448 --> 00:34:40,348
And if I just switch across to the

729
00:34:40,348 --> 00:34:42,509
right-hand side.

730
00:34:42,509 --> 00:34:46,109
If you look here, creating new transaction

731
00:34:46,109 --> 00:34:48,008
for buy book.

732
00:34:48,008 --> 00:34:49,669
Just a little further to the right,

733
00:34:49,669 --> 00:34:51,330
you can see

734
00:34:51,330 --> 00:34:53,250
that propagation is required,

735
00:34:53,250 --> 00:34:57,050
but the isolation is set to serializable.

736
00:34:57,050 --> 00:34:59,911
So, that's quite useful because

737
00:34:59,911 --> 00:35:02,951
we can see that it has taken effect,

738
00:35:02,951 --> 00:35:05,131
and if you really wanted to push that,

739
00:35:05,131 --> 00:35:08,012
you could hold the transaction open

740
00:35:08,012 --> 00:35:10,951
in the debugger, and
then go to the database

741
00:35:10,951 --> 00:35:12,551
and make some changes, but,

742
00:35:12,551 --> 00:35:14,892
I don't think we need to go that far here.

743
00:35:14,892 --> 00:35:17,452
With HSQLDB in file mode anyway,

744
00:35:17,452 --> 00:35:20,631
effectively the whole database gets locked

745
00:35:20,631 --> 00:35:22,671
by this particular application,

746
00:35:22,671 --> 00:35:25,131
so I would think that

747
00:35:25,131 --> 00:35:27,911
running it as an embedded file database,

748
00:35:27,911 --> 00:35:30,132
it's quite hard to get
multiple transactions

749
00:35:30,132 --> 00:35:32,771
running at the same time.

750
00:35:32,771 --> 00:35:35,491
So hopefully you
understand that isolation,

751
00:35:35,491 --> 00:35:37,571
true and full isolation

752
00:35:37,571 --> 00:35:39,851
is a great idea in theory.

753
00:35:39,851 --> 00:35:42,031
But in practice it leads
to poor performance

754
00:35:42,031 --> 00:35:43,993
in your database.

755
00:35:43,993 --> 00:35:46,472
Usually your database
will be configured to run

756
00:35:46,472 --> 00:35:49,172
at a softer isolation level,

757
00:35:49,172 --> 00:35:53,152
one of the four defined
by the ANSI/ISO standard.

758
00:35:53,152 --> 00:35:55,613
And it will usually be repeatable read

759
00:35:55,613 --> 00:35:57,952
or read committed.

760
00:35:57,952 --> 00:36:01,972
It's easy to override
the defaults in Spring.

761
00:36:01,972 --> 00:36:03,792
You won't do this often,

762
00:36:03,792 --> 00:36:07,593
but do look out for potentially
long running methods

763
00:36:07,593 --> 00:36:10,372
where you have select early in the method,

764
00:36:10,372 --> 00:36:13,132
that might need to tally or agree

765
00:36:13,132 --> 00:36:16,692
with selects happening
later in the method.

766
00:36:16,692 --> 00:36:20,672
Reporting queries are
particularly prone to this.

767
00:36:20,672 --> 00:36:24,652
You might want to raise the
isolation just for that method.

768
00:36:24,652 --> 00:36:25,553
While that was optional,

769
00:36:25,553 --> 00:36:28,692
but next it's a full practical session.

770
00:36:28,692 --> 00:36:30,332
A short one, but a crucial one,

771
00:36:30,332 --> 00:36:32,373
so don't miss it.

772
00:36:32,373 --> 00:36:35,463
(upbeat funky music)

1
00:00:00,078 --> 00:00:02,995
(soft dance music)

2
00:00:09,475 --> 00:00:11,172
- [Voiceover] Welcome back to the

3
00:00:11,172 --> 00:00:14,585
Practical Session for transactions.

4
00:00:14,585 --> 00:00:17,039
So as usual, you're now going to switch to

5
00:00:17,039 --> 00:00:20,388
your Customer Relationship
Management System

6
00:00:20,388 --> 00:00:23,108
that you're building for yourself.

7
00:00:23,108 --> 00:00:25,198
Although we've done quite
a lot of theory work

8
00:00:25,198 --> 00:00:27,769
around transactions, there won't be much

9
00:00:27,769 --> 00:00:30,352
coding to do in this Practical.

10
00:00:32,238 --> 00:00:34,681
What you need to do is to make the methods

11
00:00:34,681 --> 00:00:37,514
in your services be transactional.

12
00:00:38,745 --> 00:00:42,361
You should also use logging to ensure

13
00:00:42,361 --> 00:00:45,327
that the changes you've
made are taking effect.

14
00:00:45,327 --> 00:00:47,662
I recommend you pause the video now,

15
00:00:47,662 --> 00:00:49,870
and try this work for yourself.

16
00:00:49,870 --> 00:00:53,764
As always, if you need
any help, if you get stuck

17
00:00:53,764 --> 00:00:57,572
then a full walkthrough
of a solution follows.

18
00:00:57,572 --> 00:01:01,806
However, I will be using
annotations in the walkthrough,

19
00:01:01,806 --> 00:01:05,444
I recommend you go for
annotations yourself,

20
00:01:05,444 --> 00:01:08,846
if you do want to use
the tx namespace then,

21
00:01:08,846 --> 00:01:11,449
I won't be doing that in the walkthrough,

22
00:01:11,449 --> 00:01:15,577
but the help you need will
be in the theory sessions.

23
00:01:15,577 --> 00:01:17,412
So, have a good try at that,

24
00:01:17,412 --> 00:01:21,134
and I'll see you for the walkthrough.

25
00:01:21,134 --> 00:01:22,937
So welcome to this walkthrough,

26
00:01:22,937 --> 00:01:25,167
I hope you didn't have
have too many problems,

27
00:01:25,167 --> 00:01:29,092
but if you have, then this
walkthrough should help.

28
00:01:29,092 --> 00:01:31,353
The first task as always is we'll want

29
00:01:31,353 --> 00:01:34,770
to put our BookStore to one side for now,

30
00:01:35,609 --> 00:01:39,065
so I will close that
project, and close all

31
00:01:39,065 --> 00:01:42,315
of my tabs, and open up the CRM System.

32
00:01:43,716 --> 00:01:47,054
So just to reiterate,
what's been happening so far

33
00:01:47,054 --> 00:01:50,616
in the previous chapters,
is that we've been running

34
00:01:50,616 --> 00:01:53,949
the default auto-commit mode under JDBC,

35
00:01:55,218 --> 00:01:59,385
which works, but it really
is not desirable at all.

36
00:02:00,797 --> 00:02:02,767
We currently have a few operations

37
00:02:02,767 --> 00:02:05,537
here in the client's application,

38
00:02:05,537 --> 00:02:08,694
which I hope should be
enough for this session.

39
00:02:08,694 --> 00:02:11,244
I mean essentially we
have really three steps

40
00:02:11,244 --> 00:02:14,423
to follow to switch transactions on.

41
00:02:14,423 --> 00:02:17,878
We're going to need to go
into the XML file, and we need

42
00:02:17,878 --> 00:02:22,045
to upgrade the namespace to
include the tx namespace,

43
00:02:22,945 --> 00:02:26,636
then we need to set up
our transaction manager

44
00:02:26,636 --> 00:02:30,998
and then we need to
add in our annotations.

45
00:02:30,998 --> 00:02:35,933
So let's start with the worst
of those jobs, the namespace.

46
00:02:35,933 --> 00:02:39,997
Well as usual I'll use the
Reference Manual to do that,

47
00:02:39,997 --> 00:02:44,164
and in this appendix of XML
Schema-based configuration,

48
00:02:45,156 --> 00:02:49,818
there's a sub-chapter
there for the tx schema,

49
00:02:49,818 --> 00:02:53,210
and I won't copy and paste the whole thing

50
00:02:53,210 --> 00:02:55,300
in case I lose something.

51
00:02:55,300 --> 00:02:59,133
I first of all need this
tx namespace element,

52
00:03:00,602 --> 00:03:03,482
and we'll get that into there.

53
00:03:03,482 --> 00:03:06,232
And then for the schema location,

54
00:03:07,884 --> 00:03:10,467
I need these two elements here,

55
00:03:12,700 --> 00:03:16,939
referring to tx, and then
I can put them in there,

56
00:03:16,939 --> 00:03:20,865
really in anywhere inside that string.

57
00:03:20,865 --> 00:03:25,184
Well I hope you enjoyed
that, I certainly didn't.

58
00:03:25,184 --> 00:03:28,128
Now to set up transactions,
the big job to do,

59
00:03:28,128 --> 00:03:31,168
is to declare the transaction manager.

60
00:03:31,168 --> 00:03:33,251
You only to do this once,

61
00:03:34,822 --> 00:03:36,725
but it's slightly painful in that

62
00:03:36,725 --> 00:03:39,225
we need to remember the class.

63
00:03:40,126 --> 00:03:42,733
Now there are different alternatives here,

64
00:03:42,733 --> 00:03:45,482
you'll see that we have a
different transaction manager

65
00:03:45,482 --> 00:03:49,065
for Hibernate, and a
different one for JPA,

66
00:03:50,137 --> 00:03:55,005
but we need the one that
works with just regular JDBC.

67
00:03:55,005 --> 00:03:57,129
Now I could search for an example of that

68
00:03:57,129 --> 00:04:01,364
in the Reference Manual, but
it occurs to me that this is

69
00:04:01,364 --> 00:04:04,927
possibly a good chance to
look at the API documentation,

70
00:04:04,927 --> 00:04:08,564
which we haven't really used
much on the course so far.

71
00:04:08,564 --> 00:04:11,732
And I guess you know what
API documentation is,

72
00:04:11,732 --> 00:04:14,004
this is just a list of all of the classes

73
00:04:14,004 --> 00:04:15,775
in the Spring Framework.

74
00:04:15,775 --> 00:04:17,791
Now there are of course
a lot of classes in the

75
00:04:17,791 --> 00:04:21,993
Spring Framework, but if I do
a Control + F in my browser,

76
00:04:21,993 --> 00:04:25,599
and search for the string,
transaction manager,

77
00:04:25,599 --> 00:04:29,012
that will take you through
some of the classes,

78
00:04:29,012 --> 00:04:32,489
and just through experience,
I know that what I'm looking

79
00:04:32,489 --> 00:04:37,268
for is the class called
PlatformTransactionManager.

80
00:04:37,268 --> 00:04:40,041
And that will give you a list of all

81
00:04:40,041 --> 00:04:43,785
of the implementing classes
that you can choose from.

82
00:04:43,785 --> 00:04:45,118
So for instance you can see

83
00:04:45,118 --> 00:04:48,766
HibernateTransactionManager there, or

84
00:04:48,766 --> 00:04:51,789
there's some fairly complex ones there,

85
00:04:51,789 --> 00:04:54,605
such as the WebLogicItaTransactionManager,

86
00:04:54,605 --> 00:04:56,440
but we need the one that
I mentioned in the theory,

87
00:04:56,440 --> 00:04:59,757
which is the DataSourceTransactionManager.

88
00:04:59,757 --> 00:05:01,869
And I really just did that
just so I could get hold

89
00:05:01,869 --> 00:05:06,036
of the package name which is,
for me, difficult to remember.

90
00:05:07,138 --> 00:05:09,229
I need to plug that into there,

91
00:05:09,229 --> 00:05:10,812
and of course the class name.

92
00:05:10,812 --> 00:05:14,111
Now there is one property
of the TransactionManager

93
00:05:14,111 --> 00:05:18,132
and I can confirm that by
looking in the Java docs.

94
00:05:18,132 --> 00:05:20,151
There is just one method beginning

95
00:05:20,151 --> 00:05:23,984
with set, and that is setDataSource.

96
00:05:23,984 --> 00:05:25,734
So we need to pass in

97
00:05:27,530 --> 00:05:30,363
with a property called dataSource,

98
00:05:32,118 --> 00:05:35,819
we're referring here our bean,
which we've coincidentally

99
00:05:35,819 --> 00:05:39,478
called dataSource, with a lowercase "d".

100
00:05:39,478 --> 00:05:41,899
It's often the case
that the property names,

101
00:05:41,899 --> 00:05:45,494
match the names of the beans
that we've come up with.

102
00:05:45,494 --> 00:05:48,075
So that's a little bit tedious,

103
00:05:48,075 --> 00:05:51,787
but once it's done, it's
done for the project,

104
00:05:51,787 --> 00:05:54,923
and now we can reap the
benefits of using that.

105
00:05:54,923 --> 00:05:57,089
Now, I don't know why it's
just a personal thing,

106
00:05:57,089 --> 00:05:58,892
I tend to define the TransactionManager

107
00:05:58,892 --> 00:06:02,725
here at the top, and
then right at the bottom,

108
00:06:03,585 --> 00:06:06,668
add in the tx:annontation driven tag.

109
00:06:09,483 --> 00:06:11,500
I don't know why I do that really,

110
00:06:11,500 --> 00:06:14,475
but your projects will
have their own taste,

111
00:06:14,475 --> 00:06:18,934
and because I called the
bean, transactionmanager,

112
00:06:18,934 --> 00:06:23,488
I don't need to plug that
in as a property here.

113
00:06:23,488 --> 00:06:25,750
Now I'd like to keep the logging

114
00:06:25,750 --> 00:06:29,644
on my console cleaner, so
from this chapter onwards,

115
00:06:29,644 --> 00:06:32,897
I'm going to remove my AOP Weaving.

116
00:06:32,897 --> 00:06:37,334
You don't need to do that,
but that's up to you.

117
00:06:37,334 --> 00:06:40,071
So we've set annotation driven on,

118
00:06:40,071 --> 00:06:43,154
and really now it's a very simple job.

119
00:06:43,154 --> 00:06:45,904
I just need to go to my Services,

120
00:06:46,740 --> 00:06:49,758
and in this project they're
in separate packages,

121
00:06:49,758 --> 00:06:52,091
we've got the service.calls,

122
00:06:53,609 --> 00:06:56,052
so I'll go into my implementation class.

123
00:06:56,052 --> 00:06:59,924
Now I'm sure I said this
in the theory, but it is

124
00:06:59,924 --> 00:07:03,841
technically possible to
annotate the interface,

125
00:07:04,724 --> 00:07:06,719
and then all of the implementations will

126
00:07:06,719 --> 00:07:09,055
become transactional, but in fact

127
00:07:09,055 --> 00:07:12,031
that doesn't work in some circumstances,

128
00:07:12,031 --> 00:07:14,911
now those circumstances
are quite advanced,

129
00:07:14,911 --> 00:07:17,620
and we don't need to worry
about them for the course,

130
00:07:17,620 --> 00:07:20,329
but the Reference Manual
recommends strongly

131
00:07:20,329 --> 00:07:22,367
that just to avoid problems down the line,

132
00:07:22,367 --> 00:07:26,644
that we only annotate the implementations.

133
00:07:26,644 --> 00:07:30,477
And in any case for me,
transactional behavior

134
00:07:31,377 --> 00:07:34,294
is an aspect of the implementation.

135
00:07:35,359 --> 00:07:37,610
It's only because this
is an implementation

136
00:07:37,610 --> 00:07:42,580
that uses a database DAO,
that we need transactional.

137
00:07:42,580 --> 00:07:45,396
If we did this as an
in-memory implementation

138
00:07:45,396 --> 00:07:47,807
then we wouldn't need the transaction,

139
00:07:47,807 --> 00:07:51,706
so I definitely want to out
this on the implementation.

140
00:07:51,706 --> 00:07:55,205
Anyway, that's the CallHandlingService,

141
00:07:55,205 --> 00:07:58,416
we've also got the
CustomerManagementService,

142
00:07:58,416 --> 00:08:00,576
and here's our production implementation

143
00:08:00,576 --> 00:08:03,409
so that needs to be transactional.

144
00:08:05,989 --> 00:08:09,662
Now we'll need importing, and then finally

145
00:08:09,662 --> 00:08:13,829
we have a third service of
the DiaryManagementService.

146
00:08:22,820 --> 00:08:25,114
Good, that's done.

147
00:08:25,114 --> 00:08:27,162
Now in order to check that this works,

148
00:08:27,162 --> 00:08:30,853
you may have noticed that
in your SFC directory,

149
00:08:30,853 --> 00:08:34,036
we have a log for j.properties file,

150
00:08:34,036 --> 00:08:35,918
but actually I've disabled it,

151
00:08:35,918 --> 00:08:39,085
so I'll need to re-factor, and rename,

152
00:08:40,132 --> 00:08:42,715
we'll get rid of the .disabled,

153
00:08:43,965 --> 00:08:45,397
and we might need to edit it,

154
00:08:45,397 --> 00:08:47,028
I don't know what state it's in.

155
00:08:47,028 --> 00:08:51,364
Yes, I don't know why the version
of the file I've given you

156
00:08:51,364 --> 00:08:55,531
has got the DataSourceTransactionManager
commented out,

157
00:08:56,366 --> 00:08:58,702
I guess I'm testing
you a little bit there.

158
00:08:58,702 --> 00:09:02,073
The one that's enabled is the
HibernateTransactionManager

159
00:09:02,073 --> 00:09:05,998
which we're not using yet, we
will be later in the course,

160
00:09:05,998 --> 00:09:08,153
but we want to uncomment out the

161
00:09:08,153 --> 00:09:11,033
DataSourceTransactionManager.

162
00:09:11,033 --> 00:09:15,097
So I've no idea what state the
database is in at the minute,

163
00:09:15,097 --> 00:09:18,350
if I refresh the project,
I may as well delete

164
00:09:18,350 --> 00:09:22,517
the current database, and I
think the client's application,

165
00:09:23,438 --> 00:09:25,454
yeah it creates a new customer,

166
00:09:25,454 --> 00:09:27,844
and then works with that customer.

167
00:09:27,844 --> 00:09:31,927
So all that remains really
is to give this a run.

168
00:09:34,393 --> 00:09:36,388
And it's the logging that
we want to be checking,

169
00:09:36,388 --> 00:09:40,803
and the first thing to notice
is, great, there is loggings,

170
00:09:40,803 --> 00:09:42,943
the fact that we can
see logging there means

171
00:09:42,943 --> 00:09:45,792
that TransactionManager
is doing some work.

172
00:09:45,792 --> 00:09:48,138
Might not be too much
fun to pick through it,

173
00:09:48,138 --> 00:09:51,786
but you can see, plenty
of initiating commit,

174
00:09:51,786 --> 00:09:54,847
and that's as we performed
the various operations

175
00:09:54,847 --> 00:09:57,684
from the client's application.

176
00:09:57,684 --> 00:10:01,674
So for example we're
seeing a begin about here

177
00:10:01,674 --> 00:10:04,788
before we insert the new customer,

178
00:10:04,788 --> 00:10:07,524
and we're seeing a
commit as control returns

179
00:10:07,524 --> 00:10:10,312
back to the client's application.

180
00:10:10,312 --> 00:10:12,083
I think really importantly though,

181
00:10:12,083 --> 00:10:14,833
we have a recordCall method here,

182
00:10:15,732 --> 00:10:18,473
on the CallHandlingService,

183
00:10:18,473 --> 00:10:21,353
and if you remember the recordCall method

184
00:10:21,353 --> 00:10:25,520
is doing two separate steps
with two separate services,

185
00:10:26,857 --> 00:10:28,756
and the important thing
that we want to see,

186
00:10:28,756 --> 00:10:31,668
is that these two steps are combined

187
00:10:31,668 --> 00:10:34,001
into one single transaction,

188
00:10:35,753 --> 00:10:39,420
and that transaction
will be wrapping around

189
00:10:41,465 --> 00:10:43,465
this call to recordCall.

190
00:10:44,831 --> 00:10:47,988
Now you can check in logging
that that's happening,

191
00:10:47,988 --> 00:10:52,235
if I go back to the console, I did notice

192
00:10:52,235 --> 00:10:54,539
that here in the middle of the process,

193
00:10:54,539 --> 00:10:55,979
we're seeing the logging saying,

194
00:10:55,979 --> 00:10:59,531
Participating in existing transaction,

195
00:10:59,531 --> 00:11:03,499
and that will be the
various steps in recordCall.

196
00:11:03,499 --> 00:11:06,425
If I refresh the project now,

197
00:11:06,425 --> 00:11:07,998
I can look in the database

198
00:11:07,998 --> 00:11:10,980
and I should be able to see
the details of that call,

199
00:11:10,980 --> 00:11:13,331
so we can see a call,

200
00:11:13,331 --> 00:11:16,883
and two actions have been
entered into the system

201
00:11:16,883 --> 00:11:19,507
as a result of that process.

202
00:11:19,507 --> 00:11:22,109
Now what I'll do, is
I'll delete that database

203
00:11:22,109 --> 00:11:25,800
so we start from the same points
again, and this time I just

204
00:11:25,800 --> 00:11:29,629
want to check that rolling
back is working okay.

205
00:11:29,629 --> 00:11:32,387
If I go into recordCall,

206
00:11:32,387 --> 00:11:35,475
what I'll do, a bit like a
I did on the theory session,

207
00:11:35,475 --> 00:11:38,558
is I'll throw a NullPointerException,

208
00:11:40,132 --> 00:11:44,591
to simulate an unpredicted
crash at the end of the process.

209
00:11:44,591 --> 00:11:48,108
So by this point, we will have issued

210
00:11:48,108 --> 00:11:50,608
an insert into the call table,

211
00:11:51,474 --> 00:11:55,641
and we will have issued two
inserts into the diary table.

212
00:11:56,497 --> 00:11:59,356
But the fact now that this
exception gets thrown,

213
00:11:59,356 --> 00:12:03,676
we want to see those
three inserts rolled back.

214
00:12:03,676 --> 00:12:05,593
Let's check that works.

215
00:12:07,431 --> 00:12:11,015
Well it certainly crashed, and
I can see in the logging here

216
00:12:11,015 --> 00:12:14,765
rolling back transaction,
that's a good sign,

217
00:12:15,611 --> 00:12:19,943
but the real proof is if
I refresh the database.

218
00:12:19,943 --> 00:12:22,801
Ah, now we have a little
bit of a problem here.

219
00:12:22,801 --> 00:12:25,660
I've got that locking problem.

220
00:12:25,660 --> 00:12:28,637
Now remember I did handle
that in the BookStore,

221
00:12:28,637 --> 00:12:31,485
but I kinda need to do the
same thing here as well.

222
00:12:31,485 --> 00:12:34,674
Which is a little bit
awkward, I'm sorry about that.

223
00:12:34,674 --> 00:12:36,811
I think the way to handle this is,

224
00:12:36,811 --> 00:12:38,955
we need to open the container,

225
00:12:38,955 --> 00:12:42,208
we need that outside the
scope of the try block,

226
00:12:42,208 --> 00:12:45,642
but basically the whole of this run

227
00:12:45,642 --> 00:12:49,375
is going to be now inside a try block,

228
00:12:49,375 --> 00:12:51,292
and in a finally block,

229
00:12:52,210 --> 00:12:54,793
we want to close the container.

230
00:12:55,980 --> 00:12:58,145
If I do a Control + A
to select all the text,

231
00:12:58,145 --> 00:13:00,790
and then a Control + I, everything will be

232
00:13:00,790 --> 00:13:04,204
tidied up and indented properly.

233
00:13:04,204 --> 00:13:08,037
So I'll need to run this
again, I'll delete my

234
00:13:08,999 --> 00:13:12,832
slightly ruined database,
and we'll run again.

235
00:13:14,942 --> 00:13:17,016
Okay, looks like we've
got the same output,

236
00:13:17,016 --> 00:13:20,014
with a rolling back there in the log.

237
00:13:20,014 --> 00:13:23,427
And now I'll refresh the project.

238
00:13:23,427 --> 00:13:26,531
That looks good, we don't
have a locked database now.

239
00:13:26,531 --> 00:13:29,507
Let's check in the script, fantastic.

240
00:13:29,507 --> 00:13:32,035
We do have the customer inserted,

241
00:13:32,035 --> 00:13:35,267
because that was part
of an earlier use case,

242
00:13:35,267 --> 00:13:38,958
that didn't crash, but
then the three inserts

243
00:13:38,958 --> 00:13:41,763
that should have happened
as part of recording a call

244
00:13:41,763 --> 00:13:45,454
did not go into the
database, which is good.

245
00:13:45,454 --> 00:13:47,779
Just for the purposes of the snapshot

246
00:13:47,779 --> 00:13:50,190
that I take in Practicals and code,

247
00:13:50,190 --> 00:13:53,934
I'll remove that throwing
of the NullPointerException,

248
00:13:53,934 --> 00:13:56,558
and if you want, feel
free to experiment with

249
00:13:56,558 --> 00:14:00,564
propagation rules and maybe
even the isolation levels.

250
00:14:00,564 --> 00:14:02,709
But the important thing
about that Practical is,

251
00:14:02,709 --> 00:14:06,474
it's pretty easy to set
transactions up, but you do need

252
00:14:06,474 --> 00:14:09,557
to understand what's
happening under the hood.

253
00:14:09,557 --> 00:14:12,298
So I hope that was all
okay, if you're still stuck,

254
00:14:12,298 --> 00:14:15,104
of course you can raise a support call

255
00:14:15,104 --> 00:14:18,431
through the Virtual Pair
Programmer's contact page.

256
00:14:18,431 --> 00:14:20,682
If you've done okay
though I'll look forward

257
00:14:20,682 --> 00:14:23,515
to seeing you in the next chapter.

1
00:00:00,240 --> 00:00:05,236
(light music)

2
00:00:10,101 --> 00:00:10,767
- [Voiceover] Welcome back.

3
00:00:10,767 --> 00:00:13,071
In this chapter we're going
to study what was probably

4
00:00:13,071 --> 00:00:16,517
the biggest change that
has happened in Spring

5
00:00:16,517 --> 00:00:18,697
since the start.

6
00:00:18,697 --> 00:00:22,271
Annotations were added in Spring 2.5

7
00:00:22,271 --> 00:00:26,442
and this could completely
change the way that you work.

8
00:00:26,442 --> 00:00:29,492
But we're also going
to look at autowiring.

9
00:00:29,492 --> 00:00:31,988
This has been in Spring since the start.

10
00:00:31,988 --> 00:00:35,251
It can reduce the XML that you write.

11
00:00:35,251 --> 00:00:39,305
But then, the Spring 2.5 annotations.

12
00:00:39,305 --> 00:00:40,952
We'll meet three of them:

13
00:00:40,952 --> 00:00:44,383
Service, Repository and Component.

14
00:00:44,383 --> 00:00:49,215
These can remove most of the
XML from your Spring wiring.

15
00:00:49,215 --> 00:00:52,533
I'll talk about whether
this is a good or bad thing.

16
00:00:52,533 --> 00:00:57,225
In the end it will be up to
you and your project to decide.

17
00:00:57,225 --> 00:00:59,946
I've worked with some
projects that hate annotations

18
00:00:59,946 --> 00:01:02,261
and some that love them.

19
00:01:02,261 --> 00:01:06,164
Finally, Spring has added an
alternative set of annotations

20
00:01:06,164 --> 00:01:09,530
I'm calling them the javax annotations

21
00:01:09,530 --> 00:01:12,169
and you could use these
instead of the above.

22
00:01:12,169 --> 00:01:13,509
I'll tell you why.

23
00:01:15,370 --> 00:01:19,263
Now in some ways this XML
that we've been writing

24
00:01:19,263 --> 00:01:21,578
is a good thing.

25
00:01:21,578 --> 00:01:25,147
It makes you think about what you're doing

26
00:01:25,147 --> 00:01:27,593
and it's almost as if we're building

27
00:01:27,593 --> 00:01:31,135
our own application server from scratch,

28
00:01:31,135 --> 00:01:36,006
such as here where we're
setting up a connection pool

29
00:01:36,006 --> 00:01:40,877
and down here we're configuring
transaction management.

30
00:01:40,877 --> 00:01:43,914
We're doing it all by
ourselves from scratch.

31
00:01:43,914 --> 00:01:46,100
Now, I think that can be a good thing

32
00:01:46,100 --> 00:01:50,322
but doing so can get quite tedious.

33
00:01:50,322 --> 00:01:55,039
This is quite a simple project
and already we're up to,

34
00:01:55,039 --> 00:01:59,963
what I would say, to
screenfulls of XML code

35
00:01:59,963 --> 00:02:04,963
and on real projects the XML
can get really quite big.

36
00:02:05,289 --> 00:02:07,746
One thing I haven't shown
you so far on this course

37
00:02:07,746 --> 00:02:12,623
is that you can split this
file into smaller subfiles

38
00:02:12,623 --> 00:02:15,380
and I'll be doing that in a later chapter,

39
00:02:15,380 --> 00:02:16,905
and that's certainly helpful.

40
00:02:16,905 --> 00:02:20,245
But the point still remains
that on a real project

41
00:02:20,245 --> 00:02:23,572
you can end up with a lot of XML.

42
00:02:23,572 --> 00:02:26,761
In the past the Spring
people have been criticized

43
00:02:26,761 --> 00:02:28,219
quite heavily,

44
00:02:28,219 --> 00:02:31,859
especially by the kind
of competing frameworks,

45
00:02:31,859 --> 00:02:35,739
for the amounts of XML
that is needed in Spring.

46
00:02:35,739 --> 00:02:38,951
So for that reason in later versions

47
00:02:38,951 --> 00:02:41,983
Spring have provided alternative options

48
00:02:41,983 --> 00:02:45,237
that you can use instead of the XML.

49
00:02:45,237 --> 00:02:47,977
Now one of them is called autowiring,

50
00:02:47,977 --> 00:02:52,977
so let's start by seeing what
autowiring can do for us.

51
00:02:53,447 --> 00:02:55,356
I should mention that autowiring

52
00:02:55,356 --> 00:02:57,745
has been in Spring since the start,

53
00:02:57,745 --> 00:03:02,085
so you might see this used
in quite a lot of projects.

54
00:03:02,085 --> 00:03:05,746
So I'm going to find, as an
example, just one of the objects

55
00:03:05,746 --> 00:03:08,765
that we wired together
in earlier chapters,

56
00:03:08,765 --> 00:03:10,792
and I think I'll go for the first of them.

57
00:03:10,792 --> 00:03:14,141
This one here, the transaction manager.

58
00:03:14,141 --> 00:03:16,956
It doesn't really matter
which of the objects we use,

59
00:03:16,956 --> 00:03:20,085
but the point is this transaction manager,

60
00:03:20,085 --> 00:03:22,920
it is a class from the Spring framework.

61
00:03:22,920 --> 00:03:26,506
But we're configuring
that transaction manager

62
00:03:26,506 --> 00:03:31,506
by specifying that the
property called dataSource

63
00:03:31,764 --> 00:03:35,338
inside that object, we want to pass in

64
00:03:35,338 --> 00:03:39,048
as the value to that property the bean

65
00:03:39,048 --> 00:03:41,341
that we've called dataSource.

66
00:03:41,341 --> 00:03:44,802
So it means that we're
injecting this object

67
00:03:44,802 --> 00:03:47,986
into this object as a parameter

68
00:03:47,986 --> 00:03:51,347
and the parameter is called dataSource.

69
00:03:51,347 --> 00:03:54,774
Now you might have noticed
that the property name

70
00:03:54,774 --> 00:03:58,783
is exactly the same as
the name of the bean.

71
00:03:58,783 --> 00:04:01,587
It's sort of a coincidence really

72
00:04:01,587 --> 00:04:03,634
that didn't have to be the case.

73
00:04:03,634 --> 00:04:06,685
I could have called the
datasource a silly name

74
00:04:06,685 --> 00:04:09,252
like that

75
00:04:09,252 --> 00:04:13,452
and, as long as I am
consistent through the XML,

76
00:04:13,452 --> 00:04:18,452
as long as I refer to that
name, and I think annoyingly

77
00:04:18,957 --> 00:04:22,508
we've also referred to it there as well.

78
00:04:22,508 --> 00:04:24,841
I think that's the only reference to it.

79
00:04:24,841 --> 00:04:27,313
I think, even though
we have that silly name

80
00:04:27,313 --> 00:04:28,776
for the bean now,

81
00:04:30,446 --> 00:04:33,815
yeah, the code is still running okay.

82
00:04:33,815 --> 00:04:35,990
So my point is that the name of this bean

83
00:04:35,990 --> 00:04:38,548
is completely arbitrary.

84
00:04:38,548 --> 00:04:41,168
We could choose anything we wanted.

85
00:04:41,168 --> 00:04:44,341
But the property name,
that's the name that Spring

86
00:04:44,341 --> 00:04:47,145
have specified inside this class,

87
00:04:47,145 --> 00:04:50,089
there will be a method in
there called set datasource,

88
00:04:50,089 --> 00:04:53,524
we can't change that because
that's pre-configured.

89
00:04:53,524 --> 00:04:57,272
But it's just that, I'm
going to undo those changes,

90
00:04:57,272 --> 00:05:00,778
it's just that when we
got to the point of naming

91
00:05:00,778 --> 00:05:04,337
this datasource bean, or we
may as well give it the name

92
00:05:04,337 --> 00:05:07,892
datasource, it's just what it is.

93
00:05:07,892 --> 00:05:10,250
So we often end in this situation

94
00:05:10,250 --> 00:05:13,641
where the name of the property is the same

95
00:05:13,641 --> 00:05:16,810
as the name of the bean
that we're referring to.

96
00:05:16,810 --> 00:05:19,700
So with this feature called autowiring

97
00:05:19,700 --> 00:05:22,962
we can save ourselves this typing.

98
00:05:22,962 --> 00:05:27,344
I'm going to remove the
entire property line.

99
00:05:27,344 --> 00:05:32,104
Well, of course, by doing that
I've now broken our system.

100
00:05:32,104 --> 00:05:35,538
The transaction manager
now has a required property

101
00:05:35,538 --> 00:05:38,483
and it's not getting a value for it.

102
00:05:38,483 --> 00:05:41,576
I'm going to do this quite
a lot on this chapter.

103
00:05:41,576 --> 00:05:44,723
I'm going to break the XML and run it

104
00:05:44,723 --> 00:05:46,942
and you can see in that window there

105
00:05:46,942 --> 00:05:49,755
I'm getting a nasty
exception and it's saying

106
00:05:49,755 --> 00:05:52,307
that the property datasource is required.

107
00:05:52,307 --> 00:05:54,824
But what I'm going to
do instead is right here

108
00:05:54,824 --> 00:05:56,573
at the end of the tag.

109
00:05:56,573 --> 00:06:00,888
I'm going to add in this
property called autowire,

110
00:06:00,888 --> 00:06:05,519
equals, and I'm going to plug
in the value in quote marks

111
00:06:05,519 --> 00:06:07,524
"byName".

112
00:06:08,755 --> 00:06:11,507
And in doing so, in
fact, I've not even saved

113
00:06:11,507 --> 00:06:13,224
that property line.

114
00:06:13,224 --> 00:06:16,606
I could, in fact, remove
the closing bean tag,

115
00:06:16,606 --> 00:06:18,654
and as long as I'm careful to add in

116
00:06:18,654 --> 00:06:21,754
the closing forward slash there,

117
00:06:21,754 --> 00:06:24,585
the whole of this transaction
manager declaration

118
00:06:24,585 --> 00:06:28,755
has become just a single line of XML.

119
00:06:29,735 --> 00:06:33,182
And what's happening here is
that when Spring reaches this,

120
00:06:33,182 --> 00:06:37,491
it sees that we've got the
byName flag switched on,

121
00:06:37,491 --> 00:06:40,254
and that tells Spring
that it needs to look

122
00:06:40,254 --> 00:06:41,942
at all of the properties

123
00:06:41,942 --> 00:06:44,942
that are present in the
transaction manager.

124
00:06:44,942 --> 00:06:47,718
There's only property
in transaction manager

125
00:06:47,718 --> 00:06:49,748
but there could have been more.

126
00:06:49,748 --> 00:06:53,535
And for everyone it
finds, it looks for a bean

127
00:06:53,535 --> 00:06:57,471
of the same name in the rest of the XML.

128
00:06:57,471 --> 00:06:59,762
So in our case when it finds the method

129
00:06:59,762 --> 00:07:04,121
inside the transaction
manager called set datasource,

130
00:07:04,121 --> 00:07:07,641
it looks for a bean called datasource

131
00:07:07,641 --> 00:07:11,193
and it uses that as the value.

132
00:07:11,193 --> 00:07:15,438
So here we've saved, I
would say, two lines of XML

133
00:07:15,438 --> 00:07:17,956
that might not look significant

134
00:07:17,956 --> 00:07:21,881
but it will become significant
when we do this repeatedly,

135
00:07:21,881 --> 00:07:26,881
and we do it on beans that
have got multiple properties.

136
00:07:27,065 --> 00:07:28,955
So let's see if that works.

137
00:07:28,955 --> 00:07:31,525
Remember it crashed last time.

138
00:07:32,965 --> 00:07:36,953
And now the code is running successfully.

139
00:07:36,953 --> 00:07:39,470
A minor change in the
number of lines of XML

140
00:07:39,470 --> 00:07:43,097
that we have but a step
in the right direction.

141
00:07:43,097 --> 00:07:46,244
Now that's good if you're
in the lucky situation

142
00:07:46,244 --> 00:07:48,899
where the name of the property

143
00:07:48,899 --> 00:07:51,385
matches the name of the bean.

144
00:07:51,385 --> 00:07:54,895
But let's say that we had
given this datasource bean

145
00:07:54,895 --> 00:07:56,537
a completely different name,

146
00:07:56,537 --> 00:08:00,543
let's say we'd gone for data-source.

147
00:08:00,543 --> 00:08:02,728
That is a legal name in Spring.

148
00:08:02,728 --> 00:08:05,625
You don't tend hyphens in bean names,

149
00:08:05,625 --> 00:08:07,945
but it's certainly possible.

150
00:08:07,945 --> 00:08:12,751
Well, only to make the
same change there, as well.

151
00:08:12,751 --> 00:08:16,803
Now of course, now this
autowiring is not going to work

152
00:08:16,803 --> 00:08:20,259
because the property in
here is called datasource,

153
00:08:20,259 --> 00:08:24,196
all one word, and it won't
find a matching bean.

154
00:08:24,196 --> 00:08:25,497
Let's check that.

155
00:08:26,637 --> 00:08:29,316
So yes, that's causing the code to crash.

156
00:08:29,316 --> 00:08:31,855
Well, if you're in that situation,

157
00:08:31,855 --> 00:08:35,780
then you can use an
alternative form of autowiring.

158
00:08:35,780 --> 00:08:40,713
I'll make the change here to byType.

159
00:08:40,713 --> 00:08:43,550
The difference this time is
that when Spring determines

160
00:08:43,550 --> 00:08:46,559
that this being called transaction manager

161
00:08:46,559 --> 00:08:50,239
has a property called datasource,

162
00:08:50,239 --> 00:08:53,289
it checks the type of that property.

163
00:08:53,289 --> 00:08:56,542
Now the type of that property
will be the Java class

164
00:08:56,542 --> 00:08:59,594
called datasource and it will search

165
00:08:59,594 --> 00:09:02,586
through the whole of this XML file

166
00:09:02,586 --> 00:09:06,632
looking for any beans of that type.

167
00:09:06,632 --> 00:09:10,142
Now this only works if
you've got one and only one,

168
00:09:10,142 --> 00:09:12,978
it must be exactly one bean

169
00:09:12,978 --> 00:09:16,300
in your XML of that type.

170
00:09:16,300 --> 00:09:20,052
But you'll find in most cases,
even on complex projects,

171
00:09:20,052 --> 00:09:21,759
that's exactly what you have.

172
00:09:21,759 --> 00:09:25,375
You'll have one bean of a particular type.

173
00:09:25,375 --> 00:09:29,998
So this time around it's going
to find the datasource bean

174
00:09:29,998 --> 00:09:34,998
and it will be able to use that
automatically as a property.

175
00:09:35,619 --> 00:09:39,369
And now all you can see
the code is now running.

176
00:09:39,369 --> 00:09:42,345
So there is a downside
to autowiring by type

177
00:09:42,345 --> 00:09:45,093
and that is that you must have one

178
00:09:45,093 --> 00:09:47,360
and only one matching bean

179
00:09:47,360 --> 00:09:49,750
but that's usually the case anyway.

180
00:09:49,750 --> 00:09:52,393
If that's not the case then
you might be able to use

181
00:09:52,393 --> 00:09:53,849
autowiring by name.

182
00:09:53,849 --> 00:09:57,717
Usually one of the two will work.

183
00:09:57,717 --> 00:10:01,321
And just for consistency I'm
going to unwind that change,

184
00:10:01,321 --> 00:10:04,958
I'm going to put that back to datasource.

185
00:10:04,958 --> 00:10:09,521
But even so the by type will still work

186
00:10:11,492 --> 00:10:14,481
and there's the code running.

187
00:10:14,481 --> 00:10:18,836
So that's autowiring, we saved,
say, two lines of XML there

188
00:10:18,836 --> 00:10:23,102
but we can now go ahead and
do all of the rest of the XML.

189
00:10:23,102 --> 00:10:25,844
Now the reason I went
for transaction manager

190
00:10:25,844 --> 00:10:27,849
is because if I go to one of,

191
00:10:27,849 --> 00:10:31,732
let's go for my Book Service here,

192
00:10:31,732 --> 00:10:34,739
one of the most important
beans in the system.

193
00:10:34,739 --> 00:10:37,438
This doesn't have a property.

194
00:10:37,438 --> 00:10:41,022
Instead we've been using
constructor arguments.

195
00:10:41,022 --> 00:10:43,014
Well, that's no problem.

196
00:10:43,014 --> 00:10:45,001
I can do exactly the same thing here,

197
00:10:45,001 --> 00:10:50,001
I can remove the explicit
injection of that object

198
00:10:50,735 --> 00:10:53,977
and I can specify autowire

199
00:10:53,977 --> 00:10:56,970
equals constructor.

200
00:10:56,970 --> 00:11:00,278
That tells Spring that it needs to check

201
00:11:00,278 --> 00:11:03,209
the constructor of Book Service.

202
00:11:03,209 --> 00:11:07,516
It will look at the types
of each of the parameters

203
00:11:08,486 --> 00:11:12,460
going into the constructor
and it will find a bean

204
00:11:12,460 --> 00:11:15,412
of matching type in the XML.

205
00:11:15,412 --> 00:11:19,358
So once again we've saved
a little bit of XML there

206
00:11:19,358 --> 00:11:21,513
and if we check that that works,

207
00:11:22,924 --> 00:11:26,963
yes, the Book Service is still working.

208
00:11:26,963 --> 00:11:29,449
And so we've got everything we need now

209
00:11:29,449 --> 00:11:32,884
to use autowiring throughout our XML.

210
00:11:32,884 --> 00:11:35,508
Let's go through each
of the beans in turn.

211
00:11:35,508 --> 00:11:37,300
We've already done transaction manager.

212
00:11:37,300 --> 00:11:40,788
Now we can't do anything
with the datasource bean

213
00:11:40,788 --> 00:11:43,390
because the properties going into here

214
00:11:43,390 --> 00:11:46,559
are kind of value specific
to our application,

215
00:11:46,559 --> 00:11:48,834
there's no way Spring could work out

216
00:11:48,834 --> 00:11:52,030
the username and password automatically.

217
00:11:52,030 --> 00:11:55,785
So there's no autowiring to be done there.

218
00:11:55,785 --> 00:11:57,755
But for this Jdbc template

219
00:11:57,755 --> 00:12:01,015
we are injecting into the costructor,

220
00:12:01,015 --> 00:12:04,010
so we will autowire

221
00:12:08,020 --> 00:12:09,509
using the constructor,

222
00:12:11,479 --> 00:12:14,174
and we can remove the closing bean tag,

223
00:12:14,174 --> 00:12:16,350
and do the whole thing in one line,

224
00:12:16,350 --> 00:12:18,623
and it's getting a bit dull now.

225
00:12:18,623 --> 00:12:21,321
I think it's pretty much the same.

226
00:12:21,321 --> 00:12:23,759
Autowire by constructor.

227
00:12:25,739 --> 00:12:28,052
I can remove that.

228
00:12:28,052 --> 00:12:31,991
Careful to close the tags if
you're following along with me.

229
00:12:31,991 --> 00:12:33,989
The Accounts Service, because it's a mock,

230
00:12:33,989 --> 00:12:36,723
doesn't currently have any properties.

231
00:12:36,723 --> 00:12:38,675
We've already done the Book Service.

232
00:12:38,675 --> 00:12:41,257
And now here is a good
one, the Purchasing Service

233
00:12:41,257 --> 00:12:45,747
has two values being passed
into the constructor.

234
00:12:45,747 --> 00:12:50,499
Well, we can get rid of all of
that and the closing bean tag

235
00:12:50,499 --> 00:12:55,464
as long as we add in autowire

236
00:12:55,464 --> 00:12:57,013
by constructor.

237
00:12:58,993 --> 00:13:02,121
The performance timing advice
doesn't have any properties

238
00:13:02,121 --> 00:13:06,243
so we are now done, and
yeah, I would say we've,

239
00:13:06,243 --> 00:13:09,161
we've certainly made some progress

240
00:13:09,161 --> 00:13:11,721
on cutting down the XML.

241
00:13:11,721 --> 00:13:13,961
We want to make sure that that still runs

242
00:13:13,961 --> 00:13:16,259
so let's check the client.

243
00:13:17,755 --> 00:13:20,230
Yes, it's still running.

244
00:13:20,230 --> 00:13:23,498
So that's autowiring, and you can see

245
00:13:23,498 --> 00:13:27,005
that the XML is now a little but shorter.

246
00:13:27,005 --> 00:13:31,323
We still have to physically
declare each bean

247
00:13:31,323 --> 00:13:34,824
but we can often avoid
declaring the properties

248
00:13:34,824 --> 00:13:37,897
because they get found automatically.

249
00:13:37,897 --> 00:13:39,849
I have to stress before we move on

250
00:13:39,849 --> 00:13:43,358
that you don't have to like this approach.

251
00:13:43,358 --> 00:13:46,430
Some people love it, some people hate it.

252
00:13:46,430 --> 00:13:49,438
On the plus side the
XML is getting smaller

253
00:13:49,438 --> 00:13:52,288
but on the negative side
there is a lot magic

254
00:13:52,288 --> 00:13:56,196
going on in here and it
is harder to understand

255
00:13:56,196 --> 00:14:00,516
what's happening just by looking
at this configuration file.

256
00:14:00,516 --> 00:14:03,070
Now this autowiring has been in Spring

257
00:14:03,070 --> 00:14:05,704
since Spring VersionOne.

258
00:14:05,704 --> 00:14:06,953
But we're now going to move on

259
00:14:06,953 --> 00:14:10,482
to the more sophisticated
support for autowiring

260
00:14:10,482 --> 00:14:14,278
that used annotations
and this was added back

261
00:14:14,278 --> 00:14:16,563
in Spring 2.5.

262
00:14:16,563 --> 00:14:19,102
Now, I'm going to pick one of the beans

263
00:14:19,102 --> 00:14:23,742
to use as an example, and
since I'm on this line,

264
00:14:23,742 --> 00:14:26,266
any will do, but I'm
going to go for this one

265
00:14:26,266 --> 00:14:29,097
called Book DAO.

266
00:14:29,097 --> 00:14:32,284
And the first step in this
process is I'm going to remove

267
00:14:32,284 --> 00:14:35,751
the reference to autowiring.

268
00:14:35,751 --> 00:14:39,209
So, again, I've broken
the configuration now.

269
00:14:39,209 --> 00:14:42,260
If I run the code,

270
00:14:42,260 --> 00:14:45,781
I'm now seeing an exception
because this Book DAO

271
00:14:45,781 --> 00:14:48,435
is not being wired up properly.

272
00:14:48,435 --> 00:14:51,443
Now I was able to remove
it because I can go in

273
00:14:51,443 --> 00:14:55,026
to the implementation class of that Dao,

274
00:14:55,026 --> 00:14:57,907
this is the Book, it was
the one with the silly name,

275
00:14:57,907 --> 00:15:02,433
the BookDaoCleanerJdbcImport.

276
00:15:02,433 --> 00:15:07,376
And instead of specifying
autowire in the XML

277
00:15:08,406 --> 00:15:11,230
I can go to the constructor,

278
00:15:11,230 --> 00:15:14,996
this is where the values
are being passed in,

279
00:15:14,996 --> 00:15:19,486
and I can add an annotation
to the constructor instead.

280
00:15:19,486 --> 00:15:24,486
And that annotation is the
annotation called autowired.

281
00:15:24,884 --> 00:15:29,024
Now that will need to be
imported so Ctrl+Shift and O,

282
00:15:29,024 --> 00:15:30,633
and I'll just check in the import,

283
00:15:30,633 --> 00:15:32,564
this might be important later.

284
00:15:32,564 --> 00:15:35,998
You can see that is coming
from the Spring framework.

285
00:15:35,998 --> 00:15:38,824
There is another option you can use here

286
00:15:38,824 --> 00:15:41,609
and I'll return to that
later in the chapter.

287
00:15:41,609 --> 00:15:44,126
Now, unfortunately, that's
not quite everything

288
00:15:44,126 --> 00:15:48,793
we need to make autowiring
via an annotation work.

289
00:15:48,793 --> 00:15:50,008
I'll just check that,

290
00:15:51,688 --> 00:15:54,451
and yes, it's still crashing.

291
00:15:54,451 --> 00:15:58,899
In order to make this
autowiring by annotation work,

292
00:15:58,899 --> 00:16:02,739
you do need to add one line of XML.

293
00:16:02,739 --> 00:16:05,886
Now I know that may seem counterintuitive

294
00:16:05,886 --> 00:16:08,243
that we're having to add some XML

295
00:16:08,243 --> 00:16:11,281
but this one line of XML is,
in fact, going to allow us

296
00:16:11,281 --> 00:16:14,782
to remove most of the rest of the XML

297
00:16:14,782 --> 00:16:16,819
as we work through the chapter.

298
00:16:16,819 --> 00:16:19,400
Now the tag we need to add is called

299
00:16:19,400 --> 00:16:24,385
context: component-scan,

300
00:16:24,385 --> 00:16:28,723
and that's component, hyphen, scan.

301
00:16:28,723 --> 00:16:33,352
Now this tag is another one
of these directive tags.

302
00:16:33,352 --> 00:16:37,801
When it reaches this tag,
it goes often does something

303
00:16:37,801 --> 00:16:40,637
and in this case it searches

304
00:16:40,637 --> 00:16:44,250
through all of the classes in your project

305
00:16:44,250 --> 00:16:47,932
and it looks for annotations,

306
00:16:47,932 --> 00:16:49,587
and the annotations we're going to use

307
00:16:49,587 --> 00:16:51,454
to configure the beans.

308
00:16:51,454 --> 00:16:54,298
So this is, if we're
moving, we're going to move

309
00:16:54,298 --> 00:16:57,694
the XML in here into the classes,

310
00:16:57,694 --> 00:17:00,756
and this one line of XML tells Spring

311
00:17:00,756 --> 00:17:03,528
to go off and read those classes.

312
00:17:03,528 --> 00:17:06,046
Well, we have an error at the minute

313
00:17:06,046 --> 00:17:09,363
and that error is for two reasons.

314
00:17:09,363 --> 00:17:13,182
And the first of them is
that this component-scan tag

315
00:17:13,182 --> 00:17:18,169
is from another one of
these custom name spaces.

316
00:17:18,169 --> 00:17:20,468
So you'll be well
familiar with doing this.

317
00:17:20,468 --> 00:17:23,945
Now I'm afraid that means
we need to add the context

318
00:17:23,945 --> 00:17:28,776
namespace to the schema
declaration up at the top.

319
00:17:28,776 --> 00:17:30,755
If you go to the Spring reference manual

320
00:17:30,755 --> 00:17:33,310
and do a Ctrl+F, or Command+F,

321
00:17:33,310 --> 00:17:35,773
and search for the context schema,

322
00:17:35,773 --> 00:17:39,102
you will find details on
what you need in there.

323
00:17:39,102 --> 00:17:40,467
And, as always, we're going to need

324
00:17:40,467 --> 00:17:43,923
the namespace declaration from here,

325
00:17:43,923 --> 00:17:47,244
and we'll add that to
the list of namespaces,

326
00:17:47,244 --> 00:17:51,540
and you also need the two
strings separated by space

327
00:17:51,540 --> 00:17:54,578
that refer to context.

328
00:17:54,578 --> 00:17:57,468
This one ending in .xsd.

329
00:17:57,468 --> 00:18:00,519
And you want to add that
to the existing string

330
00:18:00,519 --> 00:18:01,694
that we already have.

331
00:18:01,694 --> 00:18:04,051
Now, maybe if you've skipped
a few chapters on this course

332
00:18:04,051 --> 00:18:06,142
and you've come straight to this chapter

333
00:18:06,142 --> 00:18:08,669
and you don't understand
what I've done there,

334
00:18:08,669 --> 00:18:10,265
then I recommend that you go back

335
00:18:10,265 --> 00:18:13,320
and have a look at the chapter
on transaction management,

336
00:18:13,320 --> 00:18:16,308
for example, where we've done

337
00:18:16,308 --> 00:18:18,558
exactly that before.

338
00:18:18,558 --> 00:18:20,958
And there we will still have an error

339
00:18:20,958 --> 00:18:22,782
and the error is because we're missing

340
00:18:22,782 --> 00:18:26,151
a parameter into this tag.

341
00:18:26,151 --> 00:18:30,550
Now, this parameter is
needed because at the moment

342
00:18:30,550 --> 00:18:34,857
Spring is going to have to
search through every single one

343
00:18:34,857 --> 00:18:37,885
of the classes in our project.

344
00:18:37,885 --> 00:18:39,476
We might not think that's a big deal,

345
00:18:39,476 --> 00:18:43,324
we've only got about 20
classes, but that's not true.

346
00:18:43,324 --> 00:18:48,323
Because we've also got all
of the referenced libraries.

347
00:18:48,323 --> 00:18:50,756
All of these jar files, of course, contain

348
00:18:50,756 --> 00:18:53,957
dozens or hundreds of classes.

349
00:18:53,957 --> 00:18:56,765
And at the moment Spring
has no way of distinguishing

350
00:18:56,765 --> 00:19:01,765
what are our classes and what
are third party libraries.

351
00:19:02,163 --> 00:19:05,225
So it would be really slow for Spring

352
00:19:05,225 --> 00:19:08,499
if it had to go through
all of the classes.

353
00:19:08,499 --> 00:19:12,701
And that's why we're allowed
to specify a parameter here,

354
00:19:12,701 --> 00:19:16,564
which is, I just did a Ctrl+Space
or Command+Space on a Mac,

355
00:19:16,564 --> 00:19:20,510
the required property
here is base-package.

356
00:19:20,510 --> 00:19:24,046
And this basically tells
Spring where to start from.

357
00:19:24,046 --> 00:19:29,041
I use com.virtualPairProgrammers.

358
00:19:30,686 --> 00:19:33,470
That will tell Spring to
search for all classes

359
00:19:33,470 --> 00:19:37,497
in all subpackages of
com.virtualPairProgrammers,

360
00:19:37,497 --> 00:19:40,617
so that means it will pick
up all of the classes here

361
00:19:40,617 --> 00:19:44,371
and it won't take Spring
very long to look down them.

362
00:19:44,371 --> 00:19:48,339
You could do com,

363
00:19:48,339 --> 00:19:50,899
but then it would probably
find too many classes,

364
00:19:50,899 --> 00:19:52,585
it would slow things down a lot.

365
00:19:52,585 --> 00:19:54,984
So we'll go for
com.virtualPairProgrammers,

366
00:19:54,984 --> 00:19:57,502
or whatever package name you've used.

367
00:19:57,502 --> 00:20:01,000
Be careful to type that
correctly, however.

368
00:20:01,000 --> 00:20:05,233
So now that's in place,
Spring should now find

369
00:20:05,233 --> 00:20:09,449
the autowired annotation
here, and therefore,

370
00:20:09,449 --> 00:20:12,505
the required property should be passed in.

371
00:20:12,505 --> 00:20:14,769
Let's see if this runs.

372
00:20:14,769 --> 00:20:18,352
And yes, our code is now
back to running correctly.

373
00:20:18,352 --> 00:20:20,847
Now another potential for cleaning up

374
00:20:20,847 --> 00:20:23,791
with this autowired annotation.

375
00:20:23,791 --> 00:20:26,768
If I go into the implementation class.

376
00:20:26,768 --> 00:20:30,987
At the moment I've put
autowired on the constructor

377
00:20:31,997 --> 00:20:35,738
but you can, in fact, put
the autowired annotation

378
00:20:35,738 --> 00:20:38,927
only attribute itself.

379
00:20:38,927 --> 00:20:43,005
We haven't done anything like
this so far on the course.

380
00:20:43,005 --> 00:20:46,975
It means that Spring is
going to search for a bean

381
00:20:46,975 --> 00:20:51,765
in the Spring container
of type Jdbc template

382
00:20:51,765 --> 00:20:55,227
and it will inject it
straight into the attribute

383
00:20:55,227 --> 00:20:59,763
without calling a set method
or calling the constructor.

384
00:20:59,763 --> 00:21:03,282
We'll actually use reflection to do that.

385
00:21:03,282 --> 00:21:05,842
and that means that you
can remove the constructor

386
00:21:05,842 --> 00:21:09,654
altogether because it's now
going to that parameter,

387
00:21:09,654 --> 00:21:13,842
is now going to be poked
directly into the attribute.

388
00:21:13,842 --> 00:21:16,551
Again, and I've said this many
times on the course so far,

389
00:21:16,551 --> 00:21:20,200
some people hate that,
some people love that.

390
00:21:20,200 --> 00:21:22,506
But it should work

391
00:21:24,796 --> 00:21:26,951
and it does, and I'll leave you to decide

392
00:21:26,951 --> 00:21:30,567
what do you think that is
cleaner than the previous code.

393
00:21:30,567 --> 00:21:33,394
I'm going to undo now
back to where we have

394
00:21:33,394 --> 00:21:38,394
the autowired annotation
on top of the constructor.

395
00:21:38,998 --> 00:21:41,105
But I'm now going to go back into the XML

396
00:21:41,105 --> 00:21:43,239
and I'm now going to complete the job

397
00:21:43,239 --> 00:21:45,416
by going through all of the beans

398
00:21:45,416 --> 00:21:50,004
and removing, where
possible, the autowire field.

399
00:21:50,004 --> 00:21:52,782
Now, I can't do it on this
transaction manager bean

400
00:21:52,782 --> 00:21:54,992
because that's a Spring framework class

401
00:21:54,992 --> 00:21:58,024
and I can't get inside that class

402
00:21:58,024 --> 00:22:00,993
to add the @Autowired annotation.

403
00:22:00,993 --> 00:22:03,435
So I'll leave that in place.

404
00:22:03,435 --> 00:22:07,571
And similarly, I'm not
autowiring the datasource.

405
00:22:07,571 --> 00:22:10,760
And similarly, the Jdbc template

406
00:22:10,760 --> 00:22:13,010
is also a Spring framework class,

407
00:22:13,010 --> 00:22:16,840
so we can't get the annotation into there.

408
00:22:16,840 --> 00:22:18,397
I've already done Book DAO,

409
00:22:18,397 --> 00:22:20,414
tqhe Accounts Service is a mock,

410
00:22:20,414 --> 00:22:24,456
but the Book Service,
that does have autowiring

411
00:22:24,456 --> 00:22:27,319
so I'll remove the autowire by constructor

412
00:22:27,319 --> 00:22:31,158
on the Book Service and I'll find

413
00:22:31,158 --> 00:22:34,696
the Book Service implementation class,

414
00:22:34,696 --> 00:22:37,843
that's Book Service
Production Implementation,

415
00:22:37,843 --> 00:22:40,114
Here is our property and I think again

416
00:22:40,114 --> 00:22:43,495
I'm going to remove the
existing constructor

417
00:22:43,495 --> 00:22:47,251
and just autowire straight
into the parameter.

418
00:22:47,251 --> 00:22:51,379
I just imported that
with Ctrl+Shift and O.

419
00:22:51,379 --> 00:22:54,707
And that leaves the Purchasing Service.

420
00:22:54,707 --> 00:22:58,429
That's autowired by constructor as well.

421
00:22:58,429 --> 00:22:59,993
So I can remove that.

422
00:23:01,983 --> 00:23:04,510
And let's find the Purchasing Service.

423
00:23:07,752 --> 00:23:10,152
And I have a choice: I can
either put autowired here

424
00:23:10,152 --> 00:23:12,767
on the constructor or I can annotate

425
00:23:12,767 --> 00:23:16,509
the two attributes individually.

426
00:23:16,509 --> 00:23:21,499
I prefer to go for the
attributes so I'll do that

427
00:23:23,249 --> 00:23:25,493
and remove the constructor,

428
00:23:25,493 --> 00:23:29,477
and final step, adding the import.

429
00:23:29,477 --> 00:23:31,886
So quite a minor change to the XML there

430
00:23:31,886 --> 00:23:34,738
but that's a required
step in what's coming next

431
00:23:34,738 --> 00:23:37,015
when there's going to
be a dramatic change.

432
00:23:37,015 --> 00:23:39,251
But before I go further
it's worth checking

433
00:23:39,251 --> 00:23:40,738
if this still works.

434
00:23:42,706 --> 00:23:45,298
And yeah, it's all still running fine.

435
00:23:45,298 --> 00:23:48,541
So that was quite a small
improvement in the XML.

436
00:23:48,541 --> 00:23:51,549
I didn't have to explicitly
specify autowired

437
00:23:51,549 --> 00:23:53,757
but the point of doing
that and the big advantage

438
00:23:53,757 --> 00:23:56,830
of using these annotations comes next,

439
00:23:56,830 --> 00:23:59,677
and that is that this component-scan tag

440
00:23:59,677 --> 00:24:03,720
is capable of finding the entire bean

441
00:24:03,720 --> 00:24:05,471
automatically.

442
00:24:05,471 --> 00:24:07,018
Now let me explain.

443
00:24:07,018 --> 00:24:10,495
Let's pick on one of my
beans, I'm going to go

444
00:24:10,495 --> 00:24:14,973
for this Book Service
bean here as an example.

445
00:24:14,973 --> 00:24:18,255
And what I'm going to
do is simply delete it

446
00:24:18,255 --> 00:24:20,744
from the XML altogether.

447
00:24:20,744 --> 00:24:22,493
It's now gone.

448
00:24:22,493 --> 00:24:26,110
Now of course, I've now recked the system.

449
00:24:26,110 --> 00:24:28,527
If I run the client, we've got a big hole

450
00:24:28,527 --> 00:24:30,995
in the system configuration.

451
00:24:32,225 --> 00:24:34,002
Yeah, we're getting a big exception,

452
00:24:34,002 --> 00:24:37,754
it's not even worth looking
at what that exception is.

453
00:24:37,754 --> 00:24:40,542
We have an entire service object

454
00:24:40,542 --> 00:24:43,105
missing from our system.

455
00:24:43,105 --> 00:24:45,224
But now for the magic
and this magic is going

456
00:24:45,224 --> 00:24:46,952
to dramatically improve things.

457
00:24:46,952 --> 00:24:51,059
If I go to my Book Service
Production Implementation,

458
00:24:51,059 --> 00:24:54,830
that's the bean that I've
removed from the configuration.

459
00:24:54,830 --> 00:24:59,005
Now remember that I've got an
autowired annotation in there.

460
00:24:59,005 --> 00:25:03,168
Now, we need that because
we're now no longer providing

461
00:25:03,168 --> 00:25:06,652
any XML at all for this class.

462
00:25:06,652 --> 00:25:08,733
The autowired is needed.

463
00:25:08,733 --> 00:25:11,050
But I'm going to add
one further annotation

464
00:25:11,050 --> 00:25:13,917
and this time it's at the class level.

465
00:25:13,917 --> 00:25:17,559
It's going to be alongside
with transactional annotation

466
00:25:17,559 --> 00:25:19,491
and the annotation I'm going to use

467
00:25:19,491 --> 00:25:24,479
is @Component.

468
00:25:25,728 --> 00:25:27,506
That will need importing,

469
00:25:29,010 --> 00:25:30,696
and let's check the import as usual.

470
00:25:30,696 --> 00:25:33,629
That's coming from the Spring framework.

471
00:25:33,629 --> 00:25:38,239
Now this time around,
when the component scan

472
00:25:38,239 --> 00:25:42,397
is running, when Spring
finds this annotation,

473
00:25:42,397 --> 00:25:46,783
it tells Spring to instantiate
an instance of this class

474
00:25:47,763 --> 00:25:51,379
and to put it into the Spring container.

475
00:25:51,379 --> 00:25:55,763
So that one tag there has replaced the XML

476
00:25:55,763 --> 00:25:58,045
that I've just removed.

477
00:25:58,045 --> 00:26:01,517
Now one minor problem with
this is that by default,

478
00:26:01,517 --> 00:26:04,239
when Spring instantiates this object,

479
00:26:04,239 --> 00:26:07,411
it's got no way of
knowing what name, what ID

480
00:26:07,411 --> 00:26:09,362
we want to give to this bean.

481
00:26:09,362 --> 00:26:12,104
By default it will use the
same as the name of the class

482
00:26:12,104 --> 00:26:16,498
but it will change the first
letter into a lowercase B.

483
00:26:16,498 --> 00:26:18,505
Now first, that's actually okay,

484
00:26:18,505 --> 00:26:20,995
because going back to the client,

485
00:26:20,995 --> 00:26:24,947
we're looking up the Book Service by type.

486
00:26:24,947 --> 00:26:28,904
But if we'd been using the name instead,

487
00:26:28,904 --> 00:26:32,040
and previously the ID of
that bean was Book Service,

488
00:26:32,040 --> 00:26:35,002
just like that, I'm going to need

489
00:26:36,752 --> 00:26:38,082
a type cast in this

490
00:26:38,082 --> 00:26:42,476
since we're now looking
up the bean by name.

491
00:26:42,476 --> 00:26:45,998
Well, now that's going to crash because

492
00:26:48,029 --> 00:26:53,027
there is no such bean
with the name bookService.

493
00:26:53,027 --> 00:26:57,255
As I say that's because it has
instantiated the book service

494
00:26:57,255 --> 00:27:00,135
but it's given it a default name.

495
00:27:00,135 --> 00:27:04,061
So what we can do inside the component tag

496
00:27:04,061 --> 00:27:06,971
is we can specify one parameter

497
00:27:06,971 --> 00:27:10,717
just straighting with the
string, which will be the name,

498
00:27:10,717 --> 00:27:13,810
the default name that
we want to give the bean

499
00:27:13,810 --> 00:27:18,244
when Spring automatically
puts it into the container.

500
00:27:18,244 --> 00:27:20,525
So now let's give that a run.

501
00:27:22,226 --> 00:27:25,549
And that's great, our
client is running again,

502
00:27:25,549 --> 00:27:30,549
even though we're now not
declaring the bean in the XML.

503
00:27:31,016 --> 00:27:33,351
Now this is now a really dramatic change

504
00:27:33,351 --> 00:27:35,920
because I can now pick through the XML

505
00:27:35,920 --> 00:27:40,733
and any classes that I've
written, such as the Book DAO,

506
00:27:40,733 --> 00:27:43,592
the Accounts Service and
the Purchasing Service,

507
00:27:43,592 --> 00:27:46,557
will all now be removed from the XML.

508
00:27:46,557 --> 00:27:49,120
You might remember, we're
going by quite a long way now,

509
00:27:49,120 --> 00:27:54,099
that the Book DAO does have
a special attribute in here,

510
00:27:54,099 --> 00:27:57,681
the init method of createTables.

511
00:27:57,681 --> 00:28:02,273
And the reason for that is if
the database doesn't exist,

512
00:28:03,108 --> 00:28:06,784
I'll just do a quick
refresh on the project

513
00:28:08,004 --> 00:28:10,270
and I'm going to delete the database.

514
00:28:11,549 --> 00:28:16,413
Now that's fine because when
Spring is trying to instantiate

515
00:28:16,413 --> 00:28:20,615
the Book DAO, it sees that
I want to run an init method

516
00:28:20,615 --> 00:28:22,237
called createTables.

517
00:28:22,237 --> 00:28:25,765
That tells Spring to run
the createTables method

518
00:28:25,765 --> 00:28:30,267
in the Book DAO before the
system is up and running.

519
00:28:30,267 --> 00:28:34,988
If you remember the createTables
method, if I can find it,

520
00:28:34,988 --> 00:28:37,272
is here.

521
00:28:37,272 --> 00:28:38,760
It's a private method

522
00:28:38,760 --> 00:28:41,519
but Spring is automatically creating that,

523
00:28:41,519 --> 00:28:43,989
once it's instantiated the DAO

524
00:28:43,989 --> 00:28:46,260
and it's set up the properties.

525
00:28:46,260 --> 00:28:49,268
If I were to remove the XML

526
00:28:51,498 --> 00:28:53,786
declaration of that DAO,

527
00:28:53,786 --> 00:28:55,515
of course, I can go into the DAO now

528
00:28:55,515 --> 00:29:00,486
and use this new annotation of @Component,

529
00:29:01,906 --> 00:29:04,274
and as long as it's imported.

530
00:29:04,274 --> 00:29:05,886
Now that means that Spring is going

531
00:29:05,886 --> 00:29:08,072
to instantiate this object.

532
00:29:08,072 --> 00:29:10,207
But we need some way of also telling it

533
00:29:10,207 --> 00:29:13,992
that createTables needs to be run.

534
00:29:13,992 --> 00:29:18,765
At the moment I'll do another refresh.

535
00:29:18,765 --> 00:29:21,042
Actually my previous run didn't work

536
00:29:21,042 --> 00:29:23,674
so the database hasn't been created.

537
00:29:23,674 --> 00:29:27,442
But at the moment because
Spring now doesn't note to run

538
00:29:27,442 --> 00:29:28,999
init tables,

539
00:29:31,479 --> 00:29:33,528
the code's crashing.

540
00:29:33,528 --> 00:29:35,615
It's saying, "object not found book."

541
00:29:35,615 --> 00:29:40,040
It's effectively saying that
the book table does not exist.

542
00:29:40,040 --> 00:29:42,877
So in this DAO we need
some way of telling Spring

543
00:29:42,877 --> 00:29:46,872
that the createTables method
needs to run automatically

544
00:29:46,872 --> 00:29:50,482
to replace the init method
that we had in the XML.

545
00:29:50,482 --> 00:29:52,370
We just add another annotation,

546
00:29:52,370 --> 00:29:55,017
this time to this private method,

547
00:29:55,017 --> 00:29:59,760
and the annotation is
called PostConstruct.

548
00:30:00,659 --> 00:30:03,218
Of course, that will need to be imported.

549
00:30:03,218 --> 00:30:05,899
And notice this time it's actually

550
00:30:05,899 --> 00:30:09,310
from a standard Java package.

551
00:30:09,310 --> 00:30:11,890
I'll talk about that in a short while.

552
00:30:11,890 --> 00:30:14,514
It's not from the Spring framework.

553
00:30:14,514 --> 00:30:16,997
But this time around, if we now run,

554
00:30:18,227 --> 00:30:20,829
yeah, everything is running okay now

555
00:30:20,829 --> 00:30:23,775
because the init method is working.

556
00:30:23,775 --> 00:30:28,509
So back into the XML, I can
now do one final flourish.

557
00:30:28,509 --> 00:30:33,288
Our Accounts Service I can
remove from the configuration

558
00:30:33,288 --> 00:30:37,392
and instead find the implementation class.

559
00:30:37,392 --> 00:30:40,157
This one's the mock in this case.

560
00:30:40,157 --> 00:30:43,250
I'll add on the component annotation.

561
00:30:46,120 --> 00:30:49,146
And before I try that
I'll go back to the XML,

562
00:30:49,146 --> 00:30:52,255
I can remove the Purchasing
Service, as well,

563
00:30:55,540 --> 00:30:57,500
find the implementation class

564
00:30:57,500 --> 00:31:01,761
and add on the component annotation.

565
00:31:05,064 --> 00:31:07,379
And then back to the XML,
we have just one bean left

566
00:31:07,379 --> 00:31:10,642
and that's the performance timing advice,

567
00:31:10,642 --> 00:31:14,387
and there's actually nothing to stop us

568
00:31:14,387 --> 00:31:19,242
from making that bean be
automatically created, as well.

569
00:31:19,242 --> 00:31:22,536
Again, just the same, as well as @Aspect,

570
00:31:22,536 --> 00:31:26,015
I add in @Component.

571
00:31:27,756 --> 00:31:30,963
So I've made some very
big changes to the XML now

572
00:31:30,963 --> 00:31:35,907
and now we're down to just
about a screenfull of XML

573
00:31:35,907 --> 00:31:39,005
and really most of that is that ugly,

574
00:31:39,005 --> 00:31:43,069
or at least a third of it is
the ugly schema declaration,

575
00:31:43,069 --> 00:31:47,357
and then a few kind of useful
beans, such as our datasource.

576
00:31:47,357 --> 00:31:48,508
Is it still running?

577
00:31:50,493 --> 00:31:55,493
And yes, it's all still
running with a lot less XML.

578
00:31:56,019 --> 00:31:59,000
A slight refinement we can
make to our annotations

579
00:31:59,000 --> 00:32:01,256
is that there are alternatives

580
00:32:01,256 --> 00:32:04,244
to this component annotation.

581
00:32:04,244 --> 00:32:08,146
Here we are in the Book Service
Production Implementation,

582
00:32:08,146 --> 00:32:11,743
and recall we added the
@Component annotation

583
00:32:11,743 --> 00:32:15,688
to make Spring automatically
instantiating instance

584
00:32:15,688 --> 00:32:19,645
of this class and import it
into the Spring container.

585
00:32:19,645 --> 00:32:22,757
Well, it turns out we can
be a little more precise

586
00:32:22,757 --> 00:32:24,008
than that.

587
00:32:24,008 --> 00:32:29,008
There is an alternative
annotation called @Service.

588
00:32:31,207 --> 00:32:35,251
As usual, that will need to
be imported Ctrl+Shift and O

589
00:32:35,251 --> 00:32:38,519
and again, it comes from
the Spring framework.

590
00:32:39,538 --> 00:32:42,034
Now really that doesn't
make much difference.

591
00:32:42,034 --> 00:32:43,761
If I give this code a run,

592
00:32:45,001 --> 00:32:49,020
I'm still seeing everything working okay.

593
00:32:49,020 --> 00:32:52,765
I can do exactly the same
thing on our other services.

594
00:32:52,765 --> 00:32:56,498
So we have our Accounts Service,
which I'm going to change

595
00:32:56,498 --> 00:33:00,755
to @Service, and change the import.

596
00:33:02,024 --> 00:33:02,673
That's good.

597
00:33:02,673 --> 00:33:07,499
And one final service was
the Purchasing Service so.

598
00:33:09,743 --> 00:33:13,223
That one can change there.

599
00:33:13,223 --> 00:33:16,882
So the three services now have
this alternative annotation

600
00:33:16,882 --> 00:33:18,995
of @Service

601
00:33:20,735 --> 00:33:22,245
and all are still running.

602
00:33:22,245 --> 00:33:24,840
So why did I do that and what's changed?

603
00:33:24,840 --> 00:33:28,115
Well, there's really nothing
exciting about this annotation,

604
00:33:28,115 --> 00:33:29,511
to be honest.

605
00:33:29,511 --> 00:33:32,723
It really makes no difference
as to whether you use

606
00:33:32,723 --> 00:33:35,911
@Service or @Component.

607
00:33:35,911 --> 00:33:38,685
According to the user guide of Spring,

608
00:33:38,685 --> 00:33:42,301
the purpose of the @Service annotation

609
00:33:42,301 --> 00:33:45,853
over and above the @Component annotation

610
00:33:45,853 --> 00:33:48,802
is that in future versions of Spring

611
00:33:48,802 --> 00:33:51,192
this @Service annotation

612
00:33:51,192 --> 00:33:54,835
may be given more rich functionality.

613
00:33:54,835 --> 00:33:58,024
So Spring are advising that
you use this annotation

614
00:33:58,024 --> 00:34:00,701
on any Service classes.

615
00:34:00,701 --> 00:34:03,972
It's possible that some
tools might come along later

616
00:34:03,972 --> 00:34:06,451
that rely on that annotation.

617
00:34:06,451 --> 00:34:10,434
Another thing that you could
do is use this annotation

618
00:34:10,434 --> 00:34:13,586
when you're setting up your AOP advice.

619
00:34:13,586 --> 00:34:18,582
You can use that annotation
in the AspectJ syntax

620
00:34:18,582 --> 00:34:21,139
which is a bit easier
than looking for patterns

621
00:34:21,139 --> 00:34:23,058
or package names.

622
00:34:23,058 --> 00:34:26,280
But it's really not an
exciting difference.

623
00:34:26,280 --> 00:34:28,925
But it's worth mentioning
because you're very likely

624
00:34:28,925 --> 00:34:31,592
to see this on a project
and possibly think

625
00:34:31,592 --> 00:34:35,667
that there's something really
magical about @Service.

626
00:34:35,667 --> 00:34:38,253
In a similar way, if I switch across

627
00:34:38,253 --> 00:34:41,773
to our DAO,

628
00:34:41,773 --> 00:34:45,983
this is the Jdbc
implementation of our DAO,

629
00:34:45,983 --> 00:34:49,267
instead of component

630
00:34:49,267 --> 00:34:53,499
Spring recommend the use of
an alternative annotation

631
00:34:53,499 --> 00:34:56,771
which is called Repository.

632
00:34:56,771 --> 00:34:59,688
Again, it needs an import.

633
00:34:59,688 --> 00:35:03,912
But again, it really means
the same as component

634
00:35:03,912 --> 00:35:06,792
but because repository is
quite a commonly used term

635
00:35:06,792 --> 00:35:07,646
in the industry,

636
00:35:07,646 --> 00:35:11,609
by the way, it really
means the same as DAO,

637
00:35:11,609 --> 00:35:14,557
Spring have added this
annotation just really as a way

638
00:35:14,557 --> 00:35:18,215
of allowing you to markup
that this is a special type

639
00:35:18,215 --> 00:35:23,215
of component, in particular,
it's a data repository.

640
00:35:23,454 --> 00:35:26,813
Now let's say there is a small
amount of extra functionality

641
00:35:26,813 --> 00:35:29,336
that you get with this annotation

642
00:35:29,336 --> 00:35:32,480
but it is related to JPA and Hibernate.

643
00:35:32,480 --> 00:35:35,197
Now we haven't covered
that so I'll return to that

644
00:35:35,197 --> 00:35:37,171
a little bit later on.

645
00:35:37,171 --> 00:35:39,004
For now, if you think of repository

646
00:35:39,004 --> 00:35:42,824
it's just being a slightly
more sophisticated alternative

647
00:35:42,824 --> 00:35:46,941
to @Component, you won't go far wrong.

648
00:35:46,941 --> 00:35:49,384
So with that repository changing places

649
00:35:49,384 --> 00:35:52,012
worth checking that
nothing is being broken.

650
00:35:54,302 --> 00:35:56,511
So in general, we recommend its use

651
00:35:56,511 --> 00:36:01,149
the @Repository annotation on DAOs,

652
00:36:01,149 --> 00:36:05,512
the @Service annotation on services,

653
00:36:05,512 --> 00:36:09,907
and for everything else,
such as a performance timing,

654
00:36:09,907 --> 00:36:11,691
that's not a service or a DAO,

655
00:36:11,691 --> 00:36:16,574
so the more general
annotation is @Component.

656
00:36:17,467 --> 00:36:20,012
Now these Component, Service

657
00:36:20,012 --> 00:36:22,742
and Repository annotations,

658
00:36:22,742 --> 00:36:26,521
check the import, you'll see

659
00:36:26,521 --> 00:36:30,387
that those annotations were
all invented by Spring.

660
00:36:30,387 --> 00:36:34,119
They are from the Spring framework.

661
00:36:34,119 --> 00:36:38,930
But at the time that Spring
was designing these annotations

662
00:36:38,930 --> 00:36:40,809
and at the time that the annotations

663
00:36:40,809 --> 00:36:43,264
started to become popular

664
00:36:43,264 --> 00:36:47,734
the JavaEE standard also
decided to do something

665
00:36:47,734 --> 00:36:49,554
similar to Spring.

666
00:36:49,554 --> 00:36:52,673
And what they did was they
invented a set of annotations

667
00:36:52,673 --> 00:36:57,673
under a separate framework called CDI.

668
00:36:57,917 --> 00:37:01,010
Now CDI is beyond the
scope of this course,

669
00:37:01,010 --> 00:37:04,456
it's part of JavaEE,
and I am planning to add

670
00:37:04,456 --> 00:37:08,502
an additional chapter to our JavaEE course

671
00:37:08,502 --> 00:37:10,754
to cover CDI.

672
00:37:10,754 --> 00:37:13,068
You might be interested
in that if you have bought

673
00:37:13,068 --> 00:37:16,086
our JavaEE course, so
I'll pop up on the screen

674
00:37:16,086 --> 00:37:19,271
an estimated release
date for that chapter.

675
00:37:19,271 --> 00:37:22,501
If you have bought
JavaEE through our site,

676
00:37:22,501 --> 00:37:25,032
then you'll find that
just appears as a chapter

677
00:37:25,032 --> 00:37:27,744
on your My Courses page.

678
00:37:27,744 --> 00:37:31,427
So that is part of
JavaEE, but it turns out

679
00:37:31,427 --> 00:37:34,762
that this new framework
called CDI and Spring

680
00:37:34,762 --> 00:37:37,618
do pretty much the same thing,

681
00:37:37,618 --> 00:37:41,512
and it's really down to a
matter of taste for a project

682
00:37:41,512 --> 00:37:45,662
as to whether they use CDI or Spring.

683
00:37:45,662 --> 00:37:49,976
Now roughly, projects that like standards

684
00:37:49,976 --> 00:37:51,899
go for CDI

685
00:37:51,899 --> 00:37:54,718
and projects that like to
be a bit more innovative

686
00:37:54,718 --> 00:37:57,053
go for Spring.

687
00:37:57,053 --> 00:37:59,432
And please don't flame me for saying that,

688
00:37:59,432 --> 00:38:01,544
that was kind of a rough statement,

689
00:38:01,544 --> 00:38:06,279
but I think that's kind
of the general pattern.

690
00:38:06,279 --> 00:38:09,334
But the Spring people
decided that it would perhaps

691
00:38:09,334 --> 00:38:11,848
be a good idea if they also supported

692
00:38:11,848 --> 00:38:16,084
the standard annotations
that come from CDI,

693
00:38:16,084 --> 00:38:18,944
and that would give the
possibility of any projects

694
00:38:18,944 --> 00:38:21,390
that are working in Spring,

695
00:38:21,390 --> 00:38:25,384
if you decide to move to CDI
at some point in the future,

696
00:38:25,384 --> 00:38:27,741
then it would reduce the amount of code

697
00:38:27,741 --> 00:38:30,110
that you would have to change.

698
00:38:30,110 --> 00:38:33,320
So in your projects
you could choose to use

699
00:38:33,320 --> 00:38:36,050
an alternative set of annotations

700
00:38:36,050 --> 00:38:38,465
to the ones that you've seen.

701
00:38:38,465 --> 00:38:42,227
Let's go into one of our
service classes, for example.

702
00:38:42,227 --> 00:38:43,738
Now I'll pull down the imports list.

703
00:38:43,738 --> 00:38:46,546
So at the moment we're using @Service

704
00:38:46,546 --> 00:38:49,394
which comes from the Spring framework,

705
00:38:49,394 --> 00:38:52,499
and also we're using @Autowired.

706
00:38:52,499 --> 00:38:57,237
But you could use instead
these new standard annotations

707
00:38:57,237 --> 00:38:59,741
that CDI have invented.

708
00:38:59,741 --> 00:39:04,609
For autowired you would switch to @Inject,

709
00:39:04,609 --> 00:39:06,517
I'll change both of those,

710
00:39:07,777 --> 00:39:10,479
and instead of @Service

711
00:39:10,479 --> 00:39:15,431
you could use the @Named annotation.

712
00:39:15,431 --> 00:39:18,524
And if I import those two annotations,

713
00:39:18,524 --> 00:39:21,781
check out the big difference here.

714
00:39:21,781 --> 00:39:26,274
Both of them come from
a standard javax package

715
00:39:26,274 --> 00:39:29,839
rather than from the Spring framework.

716
00:39:29,839 --> 00:39:33,458
I must say I really don't
wire the @Named annotation.

717
00:39:33,458 --> 00:39:38,376
It's not nearly as clear
as @Service and @Component,

718
00:39:38,376 --> 00:39:41,693
but that's what the standard specified.

719
00:39:41,693 --> 00:39:45,966
Now the point of doing that
is if I run the code again,

720
00:39:45,966 --> 00:39:48,840
remember we are using
this purchasing service

721
00:39:48,840 --> 00:39:50,246
in the client,

722
00:39:52,756 --> 00:39:57,756
the code still works exactly the same.

723
00:39:57,946 --> 00:40:01,639
So basically, it's a
choice for your project

724
00:40:01,639 --> 00:40:06,078
as to whether you use named and inject

725
00:40:06,078 --> 00:40:08,776
or the Spring framework versions

726
00:40:08,776 --> 00:40:13,086
of @Service and @Autowired.

727
00:40:13,086 --> 00:40:16,500
There is a kind of feeling in the industry

728
00:40:16,500 --> 00:40:21,011
that the Spring framework
versions are a bit legacy

729
00:40:21,011 --> 00:40:25,416
and these are the more modern versions.

730
00:40:25,416 --> 00:40:28,690
Now I find it really quite confusing.

731
00:40:28,690 --> 00:40:32,043
You might expect @Inject to do something

732
00:40:32,043 --> 00:40:35,532
completely different to @Autowired

733
00:40:35,532 --> 00:40:39,760
but they are pretty much equivalent.

734
00:40:39,760 --> 00:40:42,994
You or your project can
choose which to go far,

735
00:40:42,994 --> 00:40:46,009
I would say it's probably
best to be consistent

736
00:40:46,009 --> 00:40:49,651
but either way you're
not really losing out.

737
00:40:49,651 --> 00:40:51,827
For the purposes of practicals in code

738
00:40:51,827 --> 00:40:55,008
I'm going to add a comment here.

739
00:40:56,488 --> 00:41:00,521
Usually you wouldn't mix this.

740
00:41:02,450 --> 00:41:05,500
We've used @Service

741
00:41:09,427 --> 00:41:10,289
elsewhere.

742
00:41:11,999 --> 00:41:16,829
But I wanted to leave in
an example of their use.

743
00:41:16,829 --> 00:41:19,911
So just in case that confuses you,

744
00:41:19,911 --> 00:41:23,527
if you're looking at
the practicals in code.

745
00:41:23,527 --> 00:41:28,247
Back then to XML file, and we've managed

746
00:41:28,247 --> 00:41:31,489
to cut down the amounts
of XML that we've written

747
00:41:31,489 --> 00:41:33,736
by quite a large degree,

748
00:41:33,736 --> 00:41:36,116
and, in fact, as this project goes on

749
00:41:36,116 --> 00:41:39,750
and we start adding more
code, you're going to find

750
00:41:39,750 --> 00:41:43,112
that we probably wouldn't be
adding any more to the XML.

751
00:41:43,112 --> 00:41:45,936
We need transaction manager and datasource

752
00:41:45,936 --> 00:41:48,925
only once for an entire project.

753
00:41:48,925 --> 00:41:53,259
Similarly, we only need one
template for the project.

754
00:41:53,259 --> 00:41:57,170
But after that, as we add
more services and DAOs

755
00:41:57,170 --> 00:41:59,464
and all the rest of
it, we won't be needing

756
00:41:59,464 --> 00:42:02,218
to expand that XML.

757
00:42:02,218 --> 00:42:06,758
Do you like annotations and autowiring?

758
00:42:06,758 --> 00:42:10,005
As I've said many times
now, it's up to you.

759
00:42:10,005 --> 00:42:13,811
The end result is the XML is much simpler.

760
00:42:13,811 --> 00:42:18,761
But let's also be honest, the
complexity that was in the XML

761
00:42:18,761 --> 00:42:21,351
is still in our project,

762
00:42:21,351 --> 00:42:24,328
it's just being transferred to the code,

763
00:42:24,328 --> 00:42:27,083
and I think sometimes it's much harder

764
00:42:27,083 --> 00:42:29,757
to understand our system configuration

765
00:42:29,757 --> 00:42:34,024
by looking at all of these annotations.

766
00:42:34,024 --> 00:42:36,808
Now I want to point out
that with the annotations

767
00:42:36,808 --> 00:42:39,858
we still have a lot of flexibility.

768
00:42:39,858 --> 00:42:42,772
You might think you're
losing some of the control

769
00:42:42,772 --> 00:42:45,203
and some of the dependency injection,

770
00:42:45,203 --> 00:42:49,007
but the key thing is that
the annotations are only read

771
00:42:49,007 --> 00:42:52,239
if this line, this component-scan,

772
00:42:52,239 --> 00:42:54,946
is present in your XML.

773
00:42:54,946 --> 00:42:59,641
If you remove that, then
the annotations are ignored.

774
00:42:59,641 --> 00:43:01,267
I'll prove that.

775
00:43:04,051 --> 00:43:06,920
Yeah, we get an immediate crash.

776
00:43:06,920 --> 00:43:11,007
Now the point of that is that
means that you can decide,

777
00:43:11,007 --> 00:43:13,505
even if you have the annotations in place,

778
00:43:13,505 --> 00:43:15,474
you can decide whether you want to do

779
00:43:15,474 --> 00:43:19,009
everything automatically, or
whether you want to do things

780
00:43:19,009 --> 00:43:21,340
manually, by hand.

781
00:43:21,340 --> 00:43:24,146
For example, you might
want to do some testing

782
00:43:24,146 --> 00:43:26,992
of your system and as part of that testing

783
00:43:26,992 --> 00:43:30,174
you want to not use the production

784
00:43:30,174 --> 00:43:33,042
standard implementations of your classes,

785
00:43:33,042 --> 00:43:36,182
you want to use the mocks instead.

786
00:43:36,182 --> 00:43:37,675
Well, in that case you could write

787
00:43:37,675 --> 00:43:40,967
a second application.xml file,

788
00:43:40,967 --> 00:43:42,991
maybe with a different name,

789
00:43:42,991 --> 00:43:47,001
and in that second application.xml file

790
00:43:47,001 --> 00:43:51,353
you would simply not use
the component-scan tag.

791
00:43:51,353 --> 00:43:54,079
Therefore, the annotations will be ignored

792
00:43:54,079 --> 00:43:58,221
and you could do all of
the XML manually by hand

793
00:43:58,221 --> 00:44:02,114
and that XML could use just
the mock implementations

794
00:44:02,114 --> 00:44:03,688
of the objects.

795
00:44:03,688 --> 00:44:06,362
So just the fact that
you have the annotations

796
00:44:06,362 --> 00:44:10,290
doesn't mean that you must
always use the annotations.

797
00:44:10,290 --> 00:44:12,940
I think it's important to
remember that we still have

798
00:44:12,940 --> 00:44:16,460
the power and flexibility of the XML

799
00:44:16,460 --> 00:44:18,500
if and when we need it.

800
00:44:19,770 --> 00:44:22,424
This, I think, is the
most controversial chapter

801
00:44:22,424 --> 00:44:23,816
on the course.

802
00:44:23,816 --> 00:44:27,071
You can see that using
annotations for your wiring

803
00:44:27,071 --> 00:44:30,741
completely changes your
development approach.

804
00:44:30,741 --> 00:44:34,665
So since Spring 2.5
there're now two camps:

805
00:44:34,665 --> 00:44:38,915
those who use annotations
and those who don't.

806
00:44:38,915 --> 00:44:40,904
You can use a mix of the two though

807
00:44:40,904 --> 00:44:43,634
and I will return to
that in the final chapter

808
00:44:43,634 --> 00:44:47,005
when I give you an overview of Spring MVC.

809
00:44:47,005 --> 00:44:50,978
When I'm working on MVC, I
sometimes use annotations

810
00:44:50,978 --> 00:44:54,440
for the controllers,
but XML for the model.

811
00:44:54,440 --> 00:44:56,998
Well, I'm ahead of myself
there, more on that later,

812
00:44:56,998 --> 00:44:59,517
but the point is this is not necessarily

813
00:44:59,517 --> 00:45:02,370
an all-or-nothing decision.

814
00:45:02,370 --> 00:45:06,012
So autowiring has been
in Spring from the start.

815
00:45:06,012 --> 00:45:09,960
It can reduce the XML, but
it is a little bit magic.

816
00:45:09,960 --> 00:45:13,801
You can use these new
annotations to pretty much reduce

817
00:45:13,801 --> 00:45:17,704
the XML to almost nothing.

818
00:45:17,704 --> 00:45:21,608
This does depend on autowiring to work.

819
00:45:21,608 --> 00:45:25,221
And to confuse things they've
added the javax annotations,

820
00:45:25,221 --> 00:45:27,703
as well, to do the same job.

821
00:45:27,703 --> 00:45:29,500
They're still fitting with standard,

822
00:45:29,500 --> 00:45:32,985
so I hope you know now that
it's not really a big deal.

823
00:45:32,985 --> 00:45:35,778
It is a bit strange that we
have two sets of annotations

824
00:45:35,778 --> 00:45:37,752
for the same things.

825
00:45:37,752 --> 00:45:40,397
Okay, then well, if you
want to use annotations,

826
00:45:40,397 --> 00:45:42,437
and remember it's your choice,

827
00:45:42,437 --> 00:45:44,499
you can do the Practical Session 6

828
00:45:44,499 --> 00:45:48,510
where you'll do all of
this in your CRM system.

1
00:00:00,420 --> 00:00:03,753
(relaxing lounge music)

2
00:00:10,291 --> 00:00:12,991
- [Voiceover] This practical
is an optional practical.

3
00:00:12,991 --> 00:00:15,351
You do not need to follow it

4
00:00:15,351 --> 00:00:17,771
to complete the rest of the course.

5
00:00:17,771 --> 00:00:19,491
And basically, you only need to do it

6
00:00:19,491 --> 00:00:23,451
if you're interested in using annotations

7
00:00:23,451 --> 00:00:24,868
on your projects.

8
00:00:26,291 --> 00:00:29,351
And the requirements for the
practical are very simple.

9
00:00:29,351 --> 00:00:32,091
You just need to convert
your CRM system to

10
00:00:32,091 --> 00:00:34,674
use annotations and autowiring.

11
00:00:36,571 --> 00:00:39,071
I'm going to recommend that you do this

12
00:00:39,071 --> 00:00:44,031
in a second copy of your
application dot xml file.

13
00:00:44,031 --> 00:00:46,131
Of course you can call
it anything you want

14
00:00:46,131 --> 00:00:48,431
but I'm going to suggest that you call it

15
00:00:48,431 --> 00:00:52,598
something like application
hyphen annotations dot xml.

16
00:00:54,031 --> 00:00:56,711
Make sure you change the reference to that

17
00:00:56,711 --> 00:00:59,091
in your client application.

18
00:00:59,091 --> 00:01:01,191
Then you'll end up with
a copy of each of them

19
00:01:01,191 --> 00:01:04,151
and you can compare and
contrast the two of them

20
00:01:04,151 --> 00:01:05,931
and you could switch them around

21
00:01:05,931 --> 00:01:09,311
if you wanted to, later on in the course.

22
00:01:09,311 --> 00:01:11,571
So as always, try this for yourself.

23
00:01:11,571 --> 00:01:13,111
A full walkthrough will follow.

24
00:01:13,111 --> 00:01:14,778
Good luck with this.

25
00:01:17,451 --> 00:01:21,534
First job will be to close
the bookstore project.

26
00:01:22,711 --> 00:01:24,961
And re-open our CRM system.

27
00:01:28,011 --> 00:01:30,191
And at the moment we're working with

28
00:01:30,191 --> 00:01:32,608
the application dot xml file.

29
00:01:34,031 --> 00:01:37,471
And as suggested I'm going to create

30
00:01:37,471 --> 00:01:40,091
a second copy of this xml file.

31
00:01:40,091 --> 00:01:42,811
And I'm going to reference
that one for my client.

32
00:01:42,811 --> 00:01:44,491
So this one is going to be called

33
00:01:44,491 --> 00:01:47,158
application annotations dot xml.

34
00:01:48,791 --> 00:01:51,151
You can call it anything you want.

35
00:01:51,151 --> 00:01:54,051
Of course the code won't run at the moment

36
00:01:54,051 --> 00:01:55,851
and I think probably the easiest way

37
00:01:55,851 --> 00:01:57,766
is I'll just take a copy of the existing

38
00:01:57,766 --> 00:02:01,933
application dot xml, and
paste it into the same folder

39
00:02:03,672 --> 00:02:07,755
and rename it as application
annotations dot xml.

40
00:02:11,072 --> 00:02:14,152
Now I'll come on to adding
the schemer declaration

41
00:02:14,152 --> 00:02:15,752
in a short while.

42
00:02:15,752 --> 00:02:18,132
But I'll do the job very
similar to what we did

43
00:02:18,132 --> 00:02:20,132
on the theory session.

44
00:02:20,132 --> 00:02:22,752
The transaction manager
is provided by spring

45
00:02:22,752 --> 00:02:25,552
and we won't be able to
use annotations for that

46
00:02:25,552 --> 00:02:28,512
but we can use auto wiring.

47
00:02:28,512 --> 00:02:32,262
So I'll set this up so
that it is auto wired.

48
00:02:33,972 --> 00:02:35,992
We can either go with by name or by type

49
00:02:35,992 --> 00:02:37,812
it doesn't really matter.

50
00:02:37,812 --> 00:02:40,732
And that will automatically
pick up the data source

51
00:02:40,732 --> 00:02:43,312
and inject it as a property.

52
00:02:43,312 --> 00:02:46,532
We can't do anything with the
data source, unfortunately

53
00:02:46,532 --> 00:02:49,592
and the template is a spring class

54
00:02:49,592 --> 00:02:52,472
so we can't use annotations
for that one either.

55
00:02:52,472 --> 00:02:55,972
But again, we can use auto wiring by name.

56
00:03:01,272 --> 00:03:04,189
And don't forget to close that tag.

57
00:03:05,192 --> 00:03:06,025
But then for the rest of it

58
00:03:06,025 --> 00:03:07,692
the DAOs and the services

59
00:03:07,692 --> 00:03:09,609
we can use auto wiring.

60
00:03:10,492 --> 00:03:13,140
And I'll pick through them one by one.

61
00:03:13,140 --> 00:03:15,390
We've got the customer DAO.

62
00:03:18,270 --> 00:03:20,970
I can find the implementation of that.

63
00:03:20,970 --> 00:03:24,190
It's the one using the JDBC template.

64
00:03:24,190 --> 00:03:26,230
I'm going to use the annotations here.

65
00:03:26,230 --> 00:03:30,147
We know that this is one
of those repositories.

66
00:03:32,990 --> 00:03:35,907
So I'll annotate it with repository

67
00:03:38,390 --> 00:03:41,890
and I think I'm gonna go for an auto wired

68
00:03:43,870 --> 00:03:45,453
on the constructor.

69
00:03:48,130 --> 00:03:52,190
I could have added auto
wire to the attribute there

70
00:03:52,190 --> 00:03:54,530
which is a little bit more direct.

71
00:03:54,530 --> 00:03:58,350
But I think I'm going to
go for that way around.

72
00:03:58,350 --> 00:04:01,975
And don't forget that I
could have used the Javacs

73
00:04:01,975 --> 00:04:06,142
annotations that would be at
named and at inject on there.

74
00:04:07,135 --> 00:04:10,016
That's really up to
your own personal taste.

75
00:04:10,016 --> 00:04:13,435
Now we won't create tables
to automatically run

76
00:04:13,435 --> 00:04:16,715
after the constructor has run.

77
00:04:16,715 --> 00:04:20,132
So I'll use the post construct annotation

78
00:04:22,914 --> 00:04:25,955
which will need to be imported

79
00:04:25,955 --> 00:04:27,855
and that's all okay.

80
00:04:27,855 --> 00:04:31,015
So that's the configuration of the DAO.

81
00:04:31,015 --> 00:04:34,348
And we can now remove that from our xml.

82
00:04:35,294 --> 00:04:37,094
On, then, to the next DAO.

83
00:04:37,094 --> 00:04:39,427
This one is the actions DAO.

84
00:04:41,215 --> 00:04:43,755
Again going for the implementation class

85
00:04:43,755 --> 00:04:46,174
exactly the same process here.

86
00:04:46,174 --> 00:04:48,674
We need repository at the top.

87
00:04:51,255 --> 00:04:54,838
I'll put the auto wired
on the constructor.

88
00:04:56,175 --> 00:04:59,925
And for create tables
another post construct.

89
00:05:03,115 --> 00:05:05,234
All three will be imported

90
00:05:05,234 --> 00:05:07,317
and that one is now done.

91
00:05:08,374 --> 00:05:11,375
Now we can remove that from the xml.

92
00:05:11,375 --> 00:05:13,335
And now there's three services

93
00:05:13,335 --> 00:05:16,418
so starting with the customer service

94
00:05:19,514 --> 00:05:20,794
be careful to go for the

95
00:05:20,794 --> 00:05:23,895
production standard implementation here.

96
00:05:23,895 --> 00:05:27,815
So we'll add in the
service annotation there

97
00:05:27,815 --> 00:05:31,482
the auto wired annotation
to the constructor

98
00:05:33,814 --> 00:05:35,195
and the job is done.

99
00:05:35,195 --> 00:05:37,915
I'll just complete that
with control shift and O

100
00:05:37,915 --> 00:05:41,095
or command shift and O on a Mac.

101
00:05:41,095 --> 00:05:42,994
That's all piling just fine.

102
00:05:42,994 --> 00:05:45,955
And we can remove that service from our

103
00:05:45,955 --> 00:05:47,705
annotations xml file.

104
00:05:48,655 --> 00:05:51,822
The next one will be the diary service

105
00:05:52,814 --> 00:05:55,615
which is in a separate package.

106
00:05:55,615 --> 00:05:58,774
Again going for the
production implementation

107
00:05:58,774 --> 00:06:00,191
this is a service

108
00:06:01,334 --> 00:06:03,084
and it is auto wired.

109
00:06:07,934 --> 00:06:09,434
Add in the imports

110
00:06:10,475 --> 00:06:13,915
and I'm back to the annotations
version of the xml file

111
00:06:13,915 --> 00:06:17,394
and I can remove the diary service.

112
00:06:17,394 --> 00:06:21,561
And all that remains now is
the call handling service.

113
00:06:28,235 --> 00:06:31,355
We make the constructor be auto wired

114
00:06:31,355 --> 00:06:33,435
and the job is done.

115
00:06:33,435 --> 00:06:36,315
And that's quite a significant
saving in xml there.

116
00:06:36,315 --> 00:06:40,835
We've got four lines of
xml removed from there.

117
00:06:40,835 --> 00:06:43,815
So that's the easy part of the job.

118
00:06:43,815 --> 00:06:46,635
We now just need to trigger
off these annotations

119
00:06:46,635 --> 00:06:50,802
and we do that using the
context colon component scan.

120
00:06:52,535 --> 00:06:55,736
And remember we need to
specify the base package.

121
00:06:55,736 --> 00:06:58,752
This is going to be exactly
the same as on the theory.

122
00:06:58,752 --> 00:07:01,292
It's going to be virtual pair programmers

123
00:07:01,292 --> 00:07:04,125
and we can leave it at that level.

124
00:07:05,351 --> 00:07:09,131
We're going to need to
add in context name space

125
00:07:09,131 --> 00:07:11,092
and you know by now where to find that

126
00:07:11,092 --> 00:07:12,171
in the reference manual.

127
00:07:12,171 --> 00:07:14,831
So I'm going to copy and paste this from

128
00:07:14,831 --> 00:07:17,112
another window off camera.

129
00:07:17,112 --> 00:07:20,651
The first element is
the name space element

130
00:07:20,651 --> 00:07:24,232
then the schema location I'll
add to the end of the string

131
00:07:24,232 --> 00:07:25,149
just there.

132
00:07:26,151 --> 00:07:28,552
So that's all looking good.

133
00:07:28,552 --> 00:07:32,792
And we can now check if the client works.

134
00:07:32,792 --> 00:07:36,625
As usual, I think I'm
going to need to refresh

135
00:07:37,579 --> 00:07:38,640
and delete the database

136
00:07:38,640 --> 00:07:40,740
because of that key problem

137
00:07:40,740 --> 00:07:42,720
the ID problem.

138
00:07:42,720 --> 00:07:44,782
But now if I run the client again

139
00:07:44,782 --> 00:07:48,660
I'm sure I've made some mistakes
somewhere along the line.

140
00:07:48,660 --> 00:07:49,493
I have.

141
00:07:50,920 --> 00:07:52,640
Now without looking too deeply

142
00:07:52,640 --> 00:07:55,440
it's telling me there's
some kind of xml error

143
00:07:55,440 --> 00:07:58,440
and it's complaining about
angle brackets and so on

144
00:07:58,440 --> 00:08:02,040
so fairly clearly I've made a mistake.

145
00:08:02,040 --> 00:08:03,940
And in fact the editor's helping me here

146
00:08:03,940 --> 00:08:05,773
I have a red blob here

147
00:08:07,280 --> 00:08:08,614
on this line.

148
00:08:08,614 --> 00:08:10,494
And actually it just
looks like I should have

149
00:08:10,494 --> 00:08:12,254
put a space there.

150
00:08:12,254 --> 00:08:15,671
And made sure that the closing tag symbol

151
00:08:16,554 --> 00:08:19,634
is alongside the forward slash.

152
00:08:19,634 --> 00:08:21,967
Very simple mistake to make.

153
00:08:23,734 --> 00:08:25,984
Let's run the client again.

154
00:08:27,694 --> 00:08:31,194
And everything is running as it should be.

155
00:08:31,194 --> 00:08:32,444
Now I wanted to

156
00:08:33,674 --> 00:08:36,194
make you write two versions

157
00:08:36,194 --> 00:08:38,933
of the application dot xml file

158
00:08:38,933 --> 00:08:40,873
just to remind you that just because we've

159
00:08:40,873 --> 00:08:43,033
added these annotations

160
00:08:43,033 --> 00:08:44,734
there's nothing to stop us using

161
00:08:44,734 --> 00:08:47,814
the old fashioned xml approach.

162
00:08:47,814 --> 00:08:50,055
If we have a version of the file

163
00:08:50,055 --> 00:08:51,222
in fact let me

164
00:08:52,575 --> 00:08:53,635
go back to my client.

165
00:08:53,635 --> 00:08:56,655
And I'm going to switch to using the old

166
00:08:56,655 --> 00:08:59,255
application dot xml file.

167
00:08:59,255 --> 00:09:01,035
This time around

168
00:09:01,035 --> 00:09:04,115
because the annotations
are now not being read

169
00:09:04,115 --> 00:09:06,295
we don't have that context

170
00:09:06,295 --> 00:09:08,735
co-long component scan

171
00:09:08,735 --> 00:09:10,735
in that xml file.

172
00:09:10,735 --> 00:09:14,318
This time around it's
using the manual xml.

173
00:09:15,195 --> 00:09:16,975
So by switching that file around

174
00:09:16,975 --> 00:09:18,975
we can effectively choose whether to use

175
00:09:18,975 --> 00:09:22,015
manual or automatic wiring.

176
00:09:22,015 --> 00:09:23,775
And if we do use manual wiring

177
00:09:23,775 --> 00:09:25,275
then we've got the freedom

178
00:09:25,275 --> 00:09:28,015
to switch around the
implementation classes

179
00:09:28,015 --> 00:09:29,098
as we desire.

180
00:09:31,188 --> 00:09:32,213
So in a way

181
00:09:32,213 --> 00:09:35,956
you get the best of both worlds
by using the annotations.

182
00:09:35,956 --> 00:09:39,116
Don't feel that you've
lost any flexibility.

183
00:09:39,116 --> 00:09:41,656
Anyways that was quite
the simple practical.

184
00:09:41,656 --> 00:09:43,696
As always I'm going to leave it up to you

185
00:09:43,696 --> 00:09:47,236
to decide whether you prefer
annotations to the xml.

186
00:09:47,236 --> 00:09:48,956
I need to make a decision as to

187
00:09:48,956 --> 00:09:51,856
which version to use for
the rest of this course.

188
00:09:51,856 --> 00:09:53,616
So what I've decided to do is

189
00:09:53,616 --> 00:09:56,816
on the theory sessions when
we're doing the book system

190
00:09:56,816 --> 00:09:59,736
I'll continue to use annotations.

191
00:09:59,736 --> 00:10:02,296
But when we go across to the CRM system

192
00:10:02,296 --> 00:10:05,556
I'm going to switch
back to the manual XML.

193
00:10:05,556 --> 00:10:07,856
That will just give me a chance
to work with both of them

194
00:10:07,856 --> 00:10:09,856
so you continue to get the feel

195
00:10:09,856 --> 00:10:12,439
the difference between the two.

1
00:00:00,049 --> 00:00:04,223
(lively music)

2
00:00:10,325 --> 00:00:11,259
- [Voiceover] Welcome back.

3
00:00:11,259 --> 00:00:12,831
This is the first of three chapters

4
00:00:12,831 --> 00:00:14,973
where we're going to look at how Spring

5
00:00:14,973 --> 00:00:19,095
integrates with so-called ORM systems.

6
00:00:19,095 --> 00:00:22,831
That means object-relational mapping.

7
00:00:22,831 --> 00:00:24,699
Roughly these are frameworks that work

8
00:00:24,699 --> 00:00:27,960
at a higher level than JDBC.

9
00:00:27,960 --> 00:00:29,248
This is optional.

10
00:00:29,248 --> 00:00:32,005
If you're not planning on using ORM,

11
00:00:32,005 --> 00:00:35,372
you can skip this chapter quite safely.

12
00:00:35,372 --> 00:00:37,822
First up, Hibernates.

13
00:00:37,822 --> 00:00:40,935
I know that many of you
will be new to Hibernate.

14
00:00:40,935 --> 00:00:45,291
It's a big topic, but I can
at least give you an overview.

15
00:00:45,291 --> 00:00:47,005
The important thing is to show you

16
00:00:47,005 --> 00:00:49,992
how Spring integrates with Hibernate.

17
00:00:49,992 --> 00:00:53,558
And one way is by using
the HibernateTemplates.

18
00:00:53,558 --> 00:00:55,936
We'll have a good look at that.

19
00:00:55,936 --> 00:00:57,200
I have to warn you.

20
00:00:57,200 --> 00:00:59,645
Because we're bringing
in a new implementation

21
00:00:59,645 --> 00:01:02,084
of our DAO, we're all going to have

22
00:01:02,084 --> 00:01:04,233
to do some more wiring,

23
00:01:04,233 --> 00:01:07,329
but that will be good practice, I hope.

24
00:01:09,339 --> 00:01:11,466
For this chapter, I'm going to assume

25
00:01:11,466 --> 00:01:14,075
that you know a little
bit about Hibernates

26
00:01:14,075 --> 00:01:17,709
and JPA already, and
that your requirements

27
00:01:17,709 --> 00:01:20,859
is that you want to know
how Spring integrates

28
00:01:20,859 --> 00:01:23,157
with those frameworks.

29
00:01:23,157 --> 00:01:26,993
JPA and Hibernate is a really
big topic in its own right,

30
00:01:26,993 --> 00:01:30,599
which is why we've got a really big course

31
00:01:30,599 --> 00:01:33,998
covering just Hibernate, and
you can find details of that

32
00:01:33,998 --> 00:01:37,951
at the URL you can see on the screen now.

33
00:01:37,951 --> 00:01:40,057
Having said that, I know that some of you

34
00:01:40,057 --> 00:01:42,449
will not have met Hibernate before,

35
00:01:42,449 --> 00:01:45,009
but you're curious about how it works

36
00:01:45,009 --> 00:01:47,631
so you're dropping into this chapter.

37
00:01:47,631 --> 00:01:50,125
Well, that's fine, but
you might not understand

38
00:01:50,125 --> 00:01:52,344
everything that I do here.

39
00:01:52,344 --> 00:01:55,353
Although I will try to give
a little bit of background

40
00:01:55,353 --> 00:01:58,751
just in case you are a complete novice.

41
00:01:58,751 --> 00:02:02,659
So very quickly, Hibernate
is a very popular framework

42
00:02:02,659 --> 00:02:05,674
for automating SQL.

43
00:02:05,674 --> 00:02:10,207
In the previous chapters, we
coded our data access object,

44
00:02:10,207 --> 00:02:13,452
which you can see here from our bookstore,

45
00:02:13,452 --> 00:02:17,839
and we had to write all
of the SQL statements

46
00:02:17,839 --> 00:02:19,914
for ourselves.

47
00:02:19,914 --> 00:02:22,013
Not particularly difficult,

48
00:02:22,013 --> 00:02:24,706
but could be potentially quite tedious

49
00:02:24,706 --> 00:02:26,826
on a bigger project, whether it would be

50
00:02:26,826 --> 00:02:30,286
a lot more SQL statements.

51
00:02:30,286 --> 00:02:34,104
So one of the features
of Hibernate is that

52
00:02:34,104 --> 00:02:38,810
it can generate these SQL
statements automatically.

53
00:02:38,810 --> 00:02:40,357
And by the end of this chapter,

54
00:02:40,357 --> 00:02:44,092
we will have written a
second version of this DAO.

55
00:02:44,092 --> 00:02:47,052
We'll still keep this DAO, but we'll write

56
00:02:47,052 --> 00:02:49,265
a second version of it,

57
00:02:49,265 --> 00:02:53,095
and that second version
will have the same methods,

58
00:02:53,095 --> 00:02:56,811
but we won't have to have
written any of the SQL.

59
00:02:56,811 --> 00:02:59,544
I promise to give you a
little bit of background

60
00:02:59,544 --> 00:03:00,600
on Hibernate.

61
00:03:00,600 --> 00:03:05,330
So to do that, I've decided
to create a separate project,

62
00:03:05,330 --> 00:03:08,760
just to test Hibernate
out so I can show you

63
00:03:08,760 --> 00:03:11,182
some of the features of Hibernate.

64
00:03:11,182 --> 00:03:14,838
So, I'm going to close the
BookStore project temporarily.

65
00:03:14,838 --> 00:03:17,553
Now we'll be returning to it shortly.

66
00:03:17,553 --> 00:03:21,252
And the project for
Hibernate has always been

67
00:03:21,252 --> 00:03:22,442
in this workspace.

68
00:03:22,442 --> 00:03:25,045
It's just that I haven't opened it up yet.

69
00:03:25,045 --> 00:03:28,220
So if I got to File, New, Java Project,

70
00:03:28,220 --> 00:03:33,091
the name of the project
is Hello Hibernate.

71
00:03:33,091 --> 00:03:36,901
And if you're following along
and you don't have to here,

72
00:03:36,901 --> 00:03:39,796
because it's only a short
hello world example,

73
00:03:39,796 --> 00:03:42,566
but if you want to open it up, you can,

74
00:03:42,566 --> 00:03:45,349
you should see as usual the wizard

75
00:03:45,349 --> 00:03:47,820
will automatically configure the JRE

76
00:03:47,820 --> 00:03:50,576
and you just have to click on Finish,

77
00:03:50,576 --> 00:03:52,729
and you should have a new project

78
00:03:52,729 --> 00:03:56,032
called Hello Hibernate,
and you can explore

79
00:03:56,032 --> 00:03:59,471
the source code of it as usual.

80
00:03:59,471 --> 00:04:01,300
Now in this project, I'm showing you

81
00:04:01,300 --> 00:04:06,084
how both Hibernate and JPA works.

82
00:04:06,084 --> 00:04:10,153
And to start with, I've
created a domain class

83
00:04:10,153 --> 00:04:12,099
in this package called domain.

84
00:04:12,099 --> 00:04:15,424
It's actually the Book
class that we've using

85
00:04:15,424 --> 00:04:16,562
in the BookStore.

86
00:04:16,562 --> 00:04:19,943
I've borrowed it from the other projects.

87
00:04:19,943 --> 00:04:22,776
But notice there is a slight difference.

88
00:04:22,776 --> 00:04:25,970
I have added some annotations.

89
00:04:27,210 --> 00:04:30,222
Now Hibernate uses these annotations

90
00:04:30,222 --> 00:04:34,868
to help it generate the SQL statements.

91
00:04:34,868 --> 00:04:36,655
You don't need many annotations.

92
00:04:36,655 --> 00:04:38,965
I got just three here.

93
00:04:38,965 --> 00:04:42,542
One called Entity, at
the top of the class.

94
00:04:42,542 --> 00:04:45,914
And then an annotation called id,

95
00:04:45,914 --> 00:04:48,867
on the field that I want Hibernate to use

96
00:04:48,867 --> 00:04:52,850
as its kind of internal identification.

97
00:04:52,850 --> 00:04:55,935
And I want the database to automatically

98
00:04:55,935 --> 00:04:57,825
generate those ids.

99
00:04:57,825 --> 00:05:02,488
So the third annotation
is @GeneratedValue.

100
00:05:02,488 --> 00:05:04,982
So there, in fact, all of the annotations

101
00:05:04,982 --> 00:05:07,889
that I need for Hibernate to be able

102
00:05:07,889 --> 00:05:11,664
to generate all of the SQL for this class.

103
00:05:11,664 --> 00:05:14,215
If you were to go further with Hibernate,

104
00:05:14,215 --> 00:05:16,788
such as I don't know, using

105
00:05:16,788 --> 00:05:19,169
many-to-many relationships, for example,

106
00:05:19,169 --> 00:05:22,872
then you would need more
annotations in this class

107
00:05:22,872 --> 00:05:25,382
to help Hibernate understand

108
00:05:25,382 --> 00:05:28,202
the structure of your database.

109
00:05:28,202 --> 00:05:29,921
So that's a simple domain class,

110
00:05:29,921 --> 00:05:31,821
and what I'd like to be able to do

111
00:05:31,821 --> 00:05:34,863
is create a few instances
of this Book class

112
00:05:34,863 --> 00:05:37,776
and then save them to the database.

113
00:05:37,776 --> 00:05:41,287
So to demonstrate that, I've
written a clients application.

114
00:05:41,287 --> 00:05:43,666
Well, in fact, I've got two of them here.

115
00:05:43,666 --> 00:05:45,486
One to show you how Hibernate works

116
00:05:45,486 --> 00:05:48,945
and then I'll be using
that to demonstrate JPA

117
00:05:48,945 --> 00:05:50,959
in the next chapter.

118
00:05:50,959 --> 00:05:54,302
But if I open up this HibernateClient,

119
00:05:54,302 --> 00:05:57,763
there is quite a lot of code in here,

120
00:05:57,763 --> 00:06:01,280
but almost all of it is what I call

121
00:06:01,280 --> 00:06:03,790
boilerplate code.

122
00:06:03,790 --> 00:06:07,886
Now that just means tedious
and repetitive code.

123
00:06:07,886 --> 00:06:10,052
And once that code is done then,

124
00:06:10,052 --> 00:06:14,199
we can reuse it time
and time and time again.

125
00:06:14,199 --> 00:06:16,768
So what I'm not going to talk through

126
00:06:16,768 --> 00:06:19,818
on this course is what this method here,

127
00:06:19,818 --> 00:06:23,036
called getSessionFactory, is doing,

128
00:06:23,036 --> 00:06:25,010
other than to say that's just kind

129
00:06:25,010 --> 00:06:27,589
of the bootstrap for Hibernate.

130
00:06:27,589 --> 00:06:30,844
It's the code that just
starts Hibernate up.

131
00:06:30,844 --> 00:06:32,505
You only need to write it once

132
00:06:32,505 --> 00:06:36,577
and you kind of hide that away
on your project somewhere.

133
00:06:36,577 --> 00:06:40,302
And similarly, this method
called closeSessionFactory

134
00:06:40,302 --> 00:06:43,842
is the method that will
close Hibernate down.

135
00:06:43,842 --> 00:06:46,600
Again, you only need to write it once.

136
00:06:46,600 --> 00:06:49,682
If you are experts in Hibernate,
you'll understand that.

137
00:06:49,682 --> 00:06:52,693
If you're not, then you can just ignore it

138
00:06:52,693 --> 00:06:55,250
for the purposes of this course.

139
00:06:55,250 --> 00:06:59,168
So all we really have
here is a main method.

140
00:06:59,168 --> 00:07:01,507
And what I want to do in this main method

141
00:07:01,507 --> 00:07:05,320
is create a new book,
which I'm doing here,

142
00:07:05,320 --> 00:07:08,075
perfectly plain regular Java.

143
00:07:08,075 --> 00:07:10,847
And then I'll want to save
the book in the database

144
00:07:10,847 --> 00:07:14,488
and then maybe do a few
updates to the book.

145
00:07:14,488 --> 00:07:18,321
Well again, we have a little
bit more boilerplate code here.

146
00:07:18,321 --> 00:07:20,723
These three lines of code.

147
00:07:20,723 --> 00:07:24,235
Again, I can't talk about
the deep technicalities

148
00:07:24,235 --> 00:07:26,373
of what's going on here, other than

149
00:07:26,373 --> 00:07:28,583
to say what we're doing
here is we're starting

150
00:07:28,583 --> 00:07:32,692
a new so-called session with Hibernate.

151
00:07:32,692 --> 00:07:34,832
You'll notice that one of the objects

152
00:07:34,832 --> 00:07:38,349
that I've created here
is indeed called session.

153
00:07:38,349 --> 00:07:40,656
And you have to do this every time

154
00:07:40,656 --> 00:07:43,440
you do something with Hibernates.

155
00:07:43,440 --> 00:07:45,349
And I'll tell you what, if you are new

156
00:07:45,349 --> 00:07:47,615
to Hibernate, then if
you think of a session

157
00:07:47,615 --> 00:07:50,143
as being roughly the scope

158
00:07:50,143 --> 00:07:53,033
of a single database transaction,

159
00:07:53,033 --> 00:07:57,041
then you won't go far longer
at least to get you started.

160
00:07:57,041 --> 00:07:58,786
On our full Hibernate course, we go

161
00:07:58,786 --> 00:08:01,944
into a lot of detail about
how session can get longer

162
00:08:01,944 --> 00:08:05,509
and shorter, but let's
not worry about that now.

163
00:08:05,509 --> 00:08:07,854
So this is a little bit
painful to be honest.

164
00:08:07,854 --> 00:08:10,564
We need these three lines of code

165
00:08:10,564 --> 00:08:13,192
to set up the Hibernate session.

166
00:08:13,192 --> 00:08:14,591
I'll come back onto the next couple

167
00:08:14,591 --> 00:08:16,574
of lines in a moment, but basically,

168
00:08:16,574 --> 00:08:18,215
once we finish doing the work,

169
00:08:18,215 --> 00:08:20,811
we then need to call this method here

170
00:08:20,811 --> 00:08:23,648
to commit to the database transaction,

171
00:08:23,648 --> 00:08:25,400
and then I need to call this method

172
00:08:25,400 --> 00:08:27,997
to close that session.

173
00:08:27,997 --> 00:08:30,650
So in a typical
application, I'll be opening

174
00:08:30,650 --> 00:08:34,720
and closing lots and lots
and lots of sessions.

175
00:08:34,720 --> 00:08:37,748
But then the final line of
code, this closeSessionFactory,

176
00:08:37,748 --> 00:08:40,661
is completely terminating Hibernate

177
00:08:40,661 --> 00:08:44,963
and that should close all
of our database connections.

178
00:08:44,963 --> 00:08:47,467
So there is quite a lot of code there,

179
00:08:47,467 --> 00:08:50,213
but what I love about Hibernate is

180
00:08:50,213 --> 00:08:53,397
that when you've actually
got it up and running,

181
00:08:53,397 --> 00:08:55,189
when you're working with your object,

182
00:08:55,189 --> 00:08:58,200
it's really quite simple
and straightforward.

183
00:08:58,200 --> 00:09:01,164
We haven't had to write any SQL at all.

184
00:09:01,164 --> 00:09:05,089
We just take the object
that we created earlier

185
00:09:05,089 --> 00:09:06,996
that was called newBook.

186
00:09:06,996 --> 00:09:11,075
And if I call the method called
session.save on the book,

187
00:09:11,075 --> 00:09:15,901
that will generate an
SQL insert statement.

188
00:09:15,901 --> 00:09:17,585
The save method is telling Hibernate

189
00:09:17,585 --> 00:09:21,093
that this is a new object
that doesn't currently exist

190
00:09:21,093 --> 00:09:25,777
in the database and we want
to make it persistence.

191
00:09:25,777 --> 00:09:27,040
Now that line of code is going

192
00:09:27,040 --> 00:09:29,826
to generate an insert statement.

193
00:09:29,826 --> 00:09:31,937
But after doing the insert, we've decided

194
00:09:31,937 --> 00:09:34,843
that we want to change
the name of the book.

195
00:09:34,843 --> 00:09:37,886
So, I've changed the title just by calling

196
00:09:37,886 --> 00:09:41,037
a set method on the Book class.

197
00:09:41,037 --> 00:09:44,388
And I just want to, if I
go into the Book class,

198
00:09:44,388 --> 00:09:46,444
I just want to be really clear here

199
00:09:46,444 --> 00:09:49,769
that now set method, which is here,

200
00:09:49,769 --> 00:09:51,581
is really nothing special at all.

201
00:09:51,581 --> 00:09:54,186
It's a regular Java method,

202
00:09:54,186 --> 00:09:57,417
and certainly no SQL or
any database operations

203
00:09:57,417 --> 00:09:59,039
in there at all.

204
00:09:59,039 --> 00:10:01,727
Now the big magic in Hibernate is

205
00:10:01,727 --> 00:10:03,721
that when we come to this commit,

206
00:10:03,721 --> 00:10:05,439
that's when we're, of course,

207
00:10:05,439 --> 00:10:08,125
committing the database transaction,

208
00:10:08,125 --> 00:10:10,309
Hibernate's clever enough to check

209
00:10:10,309 --> 00:10:14,101
all of the objects that you've
worked with in this session,

210
00:10:14,101 --> 00:10:18,253
and Hibernate checks if
those objects have changed.

211
00:10:18,253 --> 00:10:21,128
And if they've changed,
Hibernate will issue

212
00:10:21,128 --> 00:10:24,581
an update statement to the database

213
00:10:24,581 --> 00:10:26,820
to reflect those changes.

214
00:10:26,820 --> 00:10:29,071
So you don't have to worry about

215
00:10:29,071 --> 00:10:31,203
what work you've done in a session.

216
00:10:31,203 --> 00:10:34,624
You don't have to worry
about what SQL to issue.

217
00:10:34,624 --> 00:10:36,280
Now there is some configurations

218
00:10:36,280 --> 00:10:38,500
to worry about in Hibernate.

219
00:10:38,500 --> 00:10:40,607
Again, this is something that I won't go

220
00:10:40,607 --> 00:10:42,240
into deep detail on.

221
00:10:42,240 --> 00:10:43,707
You'd learn about this if you were

222
00:10:43,707 --> 00:10:45,386
to do a full Hibernate course,

223
00:10:45,386 --> 00:10:50,309
but here in the hibernate.cfg.xml file,

224
00:10:50,309 --> 00:10:53,762
by the way, that file
is in the src folder.

225
00:10:53,762 --> 00:10:56,239
This contains all of the
database configuration

226
00:10:56,239 --> 00:10:58,909
that Hibernate needs to know about.

227
00:10:58,909 --> 00:11:02,632
The driver class, the URL,
the username and password,

228
00:11:02,632 --> 00:11:06,648
and there are a couple of
properties here that we can set.

229
00:11:06,648 --> 00:11:09,080
The show_sql property will tell Hibernate

230
00:11:09,080 --> 00:11:12,283
to log all the SQL statements

231
00:11:12,283 --> 00:11:14,908
that it's generating to the console.

232
00:11:14,908 --> 00:11:16,025
So, that's really useful.

233
00:11:16,025 --> 00:11:19,176
Hibernate's doing a lot of stuff
magically in the background

234
00:11:19,176 --> 00:11:23,116
and this will help us to
understand what it's doing.

235
00:11:23,116 --> 00:11:26,215
But now for a really useful property,

236
00:11:26,215 --> 00:11:30,585
this one called hbm2ddl.auto,

237
00:11:30,585 --> 00:11:32,740
if you set this property to update,

238
00:11:32,740 --> 00:11:36,362
then that tells Hibernate to automatically

239
00:11:36,362 --> 00:11:41,061
create any tables that are
needed in the database.

240
00:11:41,061 --> 00:11:44,026
Now I'm going to be
starting on this session

241
00:11:44,026 --> 00:11:45,175
with a blank database.

242
00:11:45,175 --> 00:11:48,835
I currently don't have
a database of that file.

243
00:11:48,835 --> 00:11:52,898
So that will be needed
to create the table.

244
00:11:52,898 --> 00:11:55,094
Now there's 1/3 the piece of configuration

245
00:11:55,094 --> 00:11:56,663
and that is in Hibernate.

246
00:11:56,663 --> 00:11:59,120
We need to list all of the classes

247
00:11:59,120 --> 00:12:01,641
that we want Hibernate to work with.

248
00:12:01,641 --> 00:12:04,863
So I've just used here, mapping class,

249
00:12:04,863 --> 00:12:08,167
followed by the fully qualified class name

250
00:12:08,167 --> 00:12:11,613
of my domain class that I'm working with.

251
00:12:11,613 --> 00:12:14,659
So you think of this
hibernate.cfg.xml file

252
00:12:14,659 --> 00:12:17,929
as a kind of global configuration file

253
00:12:17,929 --> 00:12:20,149
for Hibernate.

254
00:12:20,149 --> 00:12:23,663
To summarize, there is a
lot of boilerplate code,

255
00:12:23,663 --> 00:12:26,962
that's the copy and paste
code, but that's fine.

256
00:12:26,962 --> 00:12:29,688
We can kind of hide that on a project.

257
00:12:29,688 --> 00:12:31,918
Then when we want to do something,

258
00:12:31,918 --> 00:12:35,236
we have to set up this
thing called a session

259
00:12:35,236 --> 00:12:36,814
and we have to remember to commit

260
00:12:36,814 --> 00:12:39,494
the transaction and close that session.

261
00:12:39,494 --> 00:12:41,386
Now that's a little bit tedious as well,

262
00:12:41,386 --> 00:12:44,742
bu the stuff in the middle is really neat.

263
00:12:44,742 --> 00:12:47,755
We just work with our
objects and Hibernate

264
00:12:47,755 --> 00:12:51,890
will issue any necessary
updates to the database.

265
00:12:51,890 --> 00:12:53,978
I'm going to see if this runs now.

266
00:12:53,978 --> 00:12:55,346
If you're following along with me

267
00:12:55,346 --> 00:12:57,693
and you opened up this
project, then it should

268
00:12:57,693 --> 00:13:01,446
just run as a regular
standalone Java application.

269
00:13:01,446 --> 00:13:04,946
You shouldn't need to do
any other configuration.

270
00:13:04,946 --> 00:13:08,254
And yes, that's the kind
of output I was expecting.

271
00:13:08,254 --> 00:13:10,310
These are the lines of
logging that we're getting

272
00:13:10,310 --> 00:13:14,498
because we set the
property, show_sql, to true.

273
00:13:14,498 --> 00:13:17,302
And we can see that
there is indeed an insert

274
00:13:17,302 --> 00:13:21,646
and an update statement
being issued to the database.

275
00:13:21,646 --> 00:13:24,574
And if I check the database script,

276
00:13:24,574 --> 00:13:27,781
as usual, refresh that project,

277
00:13:27,781 --> 00:13:30,159
and then look in the script file.

278
00:13:30,159 --> 00:13:31,816
I can check down at the bottom.

279
00:13:31,816 --> 00:13:33,347
And be careful here.

280
00:13:33,347 --> 00:13:35,204
You might have been expecting an insert

281
00:13:35,204 --> 00:13:38,614
and an update statement
here in the database.

282
00:13:38,614 --> 00:13:40,972
But remember that the database script

283
00:13:40,972 --> 00:13:43,415
just contains the SQL statements

284
00:13:43,415 --> 00:13:46,789
that are needed to
restore the database back

285
00:13:46,789 --> 00:13:50,424
to the state it was in when
the program finished running.

286
00:13:50,424 --> 00:13:53,116
Now if we have a look at our code,

287
00:13:53,116 --> 00:13:57,856
the book originally have the
title, Spring Fundamentals,

288
00:13:57,856 --> 00:14:01,790
which would have been present
in the insert statement.

289
00:14:01,790 --> 00:14:06,031
But then I changed the
title to Spring Advanced,

290
00:14:06,031 --> 00:14:09,652
which was then sent to
the update statements.

291
00:14:09,652 --> 00:14:12,723
Spring Advanced is being stored away

292
00:14:12,723 --> 00:14:15,868
in the script file as an insert statement

293
00:14:15,868 --> 00:14:18,067
so that next time we run the program,

294
00:14:18,067 --> 00:14:20,706
the book is in the state
of Spring Advanced.

295
00:14:20,706 --> 00:14:22,808
So that's actually correct.

296
00:14:22,808 --> 00:14:26,864
The key thing is I didn't write any SQL

297
00:14:26,864 --> 00:14:28,781
for that to work.

298
00:14:28,781 --> 00:14:30,247
I'll show you a few other things

299
00:14:30,247 --> 00:14:32,295
that we can do with Hibernate.

300
00:14:32,295 --> 00:14:34,430
We now have that book in the database

301
00:14:34,430 --> 00:14:36,690
and it has an ID of one.

302
00:14:36,690 --> 00:14:39,001
So on our second run, I could remove

303
00:14:39,001 --> 00:14:43,223
this save and setTitle, and instead,

304
00:14:43,223 --> 00:14:46,983
oh, and I can also remove
the creating the new book,

305
00:14:46,983 --> 00:14:48,591
because what I'm going to do this time

306
00:14:48,591 --> 00:14:51,618
is I'm going to use the
session object again.

307
00:14:51,618 --> 00:14:55,806
Inside the session, there's
a method called get.

308
00:14:55,806 --> 00:14:58,274
And what this allows me
to do is to first of all,

309
00:14:58,274 --> 00:15:01,988
specify which class I want
to find an object from,

310
00:15:01,988 --> 00:15:04,038
and in this case, it's the Book class.

311
00:15:04,038 --> 00:15:07,114
So, we use Book.class.

312
00:15:07,114 --> 00:15:09,070
And then for the second parameter,

313
00:15:09,070 --> 00:15:12,270
the ID of the book we're looking for,

314
00:15:12,270 --> 00:15:14,984
which for us will be one.

315
00:15:14,984 --> 00:15:18,133
And that's going to return us a book

316
00:15:18,133 --> 00:15:20,183
from the database.

317
00:15:20,183 --> 00:15:23,380
I'm going to call this foundBook.

318
00:15:23,380 --> 00:15:26,110
Rather annoyingly, this is
quite an old-fashioned API.

319
00:15:26,110 --> 00:15:29,358
I have to do a type cast

320
00:15:29,358 --> 00:15:32,238
back to the Book object.

321
00:15:32,238 --> 00:15:34,935
But anyway, that one line of code is going

322
00:15:34,935 --> 00:15:38,535
to generate the SQL I need to do a select,

323
00:15:38,535 --> 00:15:40,303
and I think most importantly,

324
00:15:40,303 --> 00:15:42,799
it will do all of the
hard work of converting

325
00:15:42,799 --> 00:15:46,582
that book into a regular Java object.

326
00:15:46,582 --> 00:15:50,625
So I can do something
like System.out.println,

327
00:15:50,625 --> 00:15:53,498
and I can output the details of that book,

328
00:15:53,498 --> 00:15:58,123
but also while I'm here,
is I can take the book.

329
00:15:58,123 --> 00:15:59,845
I can call one of the set methods.

330
00:15:59,845 --> 00:16:02,709
Well, I only have a setTitle
method on this object

331
00:16:02,709 --> 00:16:05,007
at the moment, so I'm
going to change the title

332
00:16:05,007 --> 00:16:07,526
of the book to, let's make it

333
00:16:07,526 --> 00:16:11,226
Java Fundamentals.

334
00:16:11,226 --> 00:16:14,631
Now again, this is a big
feature of Hibernate.

335
00:16:14,631 --> 00:16:18,250
Because this book is
what Hibernate considers

336
00:16:18,250 --> 00:16:21,462
a persistence object, because I found it

337
00:16:21,462 --> 00:16:23,843
inside a Hibernate session,

338
00:16:23,843 --> 00:16:26,357
Hibernate will know that it needs to check

339
00:16:26,357 --> 00:16:29,120
and it does it when it
gets to the commits here.

340
00:16:29,120 --> 00:16:31,551
It will check the state of this book.

341
00:16:31,551 --> 00:16:34,278
It will see that the title has changed,

342
00:16:34,278 --> 00:16:38,695
and therefore, it will
issue and update statements.

343
00:16:38,695 --> 00:16:40,514
Let's see if that's true.

344
00:16:44,160 --> 00:16:47,622
So starting from the top,
there's a select statement.

345
00:16:47,622 --> 00:16:49,530
That's where we printed out the details

346
00:16:49,530 --> 00:16:52,925
of the book, which was
called Spring Advanced,

347
00:16:52,925 --> 00:16:56,703
but then I did a setTitle, so Hibernate

348
00:16:56,703 --> 00:16:59,302
has generated an update statement

349
00:16:59,302 --> 00:17:01,161
to reflect that change.

350
00:17:01,161 --> 00:17:03,330
We check the database script.

351
00:17:03,330 --> 00:17:06,794
There you can see the title
now stored in the database

352
00:17:06,794 --> 00:17:10,369
is Java Fundamentals.

353
00:17:10,369 --> 00:17:12,668
So I've just done that
little demonstration

354
00:17:12,668 --> 00:17:15,776
to show you the basics of Hibernate

355
00:17:15,776 --> 00:17:17,868
so that you'll have a better feel

356
00:17:17,868 --> 00:17:19,170
for what I'm doing when I switch

357
00:17:19,170 --> 00:17:21,715
across to our Spring application.

358
00:17:21,715 --> 00:17:23,966
So what we're going to
do next is have a look

359
00:17:23,966 --> 00:17:27,411
at how we integrate Hibernate into Spring

360
00:17:27,411 --> 00:17:29,458
if you want to use Hibernate as part

361
00:17:29,458 --> 00:17:31,958
of your Spring application.

362
00:17:31,958 --> 00:17:36,494
We are going to need this
hibernate.cfg.xml file,

363
00:17:36,494 --> 00:17:40,331
and we're going to need to rework our DAO.

364
00:17:40,331 --> 00:17:44,874
So, I'm going to close all of
the tabs from that project,

365
00:17:44,874 --> 00:17:47,565
but I think I will keep the projects open,

366
00:17:47,565 --> 00:17:49,287
because I'm going to be borrowing some

367
00:17:49,287 --> 00:17:51,543
of the files from there shortly.

368
00:17:51,543 --> 00:17:54,817
Now let's go back to our BookStore.

369
00:17:54,817 --> 00:17:57,160
Now before we go any further,

370
00:17:57,160 --> 00:17:58,352
one thing we're going to have to do

371
00:17:58,352 --> 00:18:01,536
before we start doing any
Hibernate on this project

372
00:18:01,536 --> 00:18:04,059
is we have to upgrade this Book class

373
00:18:04,059 --> 00:18:07,040
to be usable under Hibernate.

374
00:18:07,040 --> 00:18:09,826
There are really just
a small number of rules

375
00:18:09,826 --> 00:18:12,752
that we need to follow
for any domain class

376
00:18:12,752 --> 00:18:15,651
that we're going to use
as a Hibernate class.

377
00:18:15,651 --> 00:18:16,892
They're pretty simple rules.

378
00:18:16,892 --> 00:18:20,603
First of all, we have to
add the @Entity annotation

379
00:18:20,603 --> 00:18:23,554
to the top of the class.

380
00:18:23,554 --> 00:18:26,470
That will need to be
imported and be careful here.

381
00:18:26,470 --> 00:18:28,968
If you're following along,
and certainly you'll need

382
00:18:28,968 --> 00:18:31,835
to be careful in the
practicals, you must choose

383
00:18:31,835 --> 00:18:35,252
the one from javax.persistence.

384
00:18:35,252 --> 00:18:37,747
The Hibernate annotation,

385
00:18:37,747 --> 00:18:40,157
which would have assumed
would be the right one,

386
00:18:40,157 --> 00:18:42,150
has been deprecated.

387
00:18:42,150 --> 00:18:45,735
So, it's javax.persistence.

388
00:18:45,735 --> 00:18:49,398
The next rule is we need
to have one of the fields

389
00:18:49,398 --> 00:18:52,533
as a unique identifier for the class.

390
00:18:52,533 --> 00:18:54,659
That's really for Hibernate internal

391
00:18:54,659 --> 00:18:56,687
housekeeping purposes.

392
00:18:56,687 --> 00:18:58,665
Now we could use the ISBN for that,

393
00:18:58,665 --> 00:19:00,589
but I'm not that comfortable with it,

394
00:19:00,589 --> 00:19:03,478
because ISBN doesn't feel that unique.

395
00:19:03,478 --> 00:19:05,695
So what's very common in Hibernate is

396
00:19:05,695 --> 00:19:09,114
to add in what's called a synthetic key.

397
00:19:09,114 --> 00:19:12,507
It's actually pretty good
database style as well.

398
00:19:12,507 --> 00:19:14,708
I just have a private int id.

399
00:19:14,708 --> 00:19:17,507
I'm not really going to
do anything with that id,

400
00:19:17,507 --> 00:19:20,691
but it will always be a unique identifier.

401
00:19:20,691 --> 00:19:23,964
And we have to annotate that with @Id.

402
00:19:23,964 --> 00:19:26,144
Again, that will need to be imported

403
00:19:26,144 --> 00:19:29,924
and that too comes from the
javax.persistence package.

404
00:19:29,924 --> 00:19:31,432
We covered this in a lot more detail

405
00:19:31,432 --> 00:19:34,202
on the Hibernate course,
but if we're not going

406
00:19:34,202 --> 00:19:37,204
to give the id a value,
then we can generate

407
00:19:37,204 --> 00:19:39,694
the value using the at, actually,

408
00:19:39,694 --> 00:19:43,059
it's @GeneratedValue.

409
00:19:43,059 --> 00:19:45,615
Again, that will be imported.

410
00:19:45,615 --> 00:19:46,764
Let me just check that, yeah,

411
00:19:46,764 --> 00:19:49,068
that's from javax.persistence as well.

412
00:19:49,068 --> 00:19:51,309
And by specifying as a parameter,

413
00:19:51,309 --> 00:19:54,650
strategy=

414
00:19:54,650 --> 00:19:57,630
GenerationType.

415
00:19:57,630 --> 00:20:00,062
and just select AUTO.

416
00:20:00,062 --> 00:20:04,051
That will ask Hibernate to use whatever

417
00:20:04,051 --> 00:20:08,972
generation strategy our
particular database supports.

418
00:20:08,972 --> 00:20:10,823
Now that varies across databases,

419
00:20:10,823 --> 00:20:15,377
but that kind of make its
database vendor independence.

420
00:20:15,377 --> 00:20:18,166
We'll need one final thing and this is for

421
00:20:18,166 --> 00:20:20,566
a kind of internal Hibernate reason,

422
00:20:20,566 --> 00:20:23,394
we do need a default constructor.

423
00:20:23,394 --> 00:20:26,444
That means a constructor
with no arguments.

424
00:20:26,444 --> 00:20:29,689
We have what I call the
business constructor here.

425
00:20:29,689 --> 00:20:34,146
But Hibernate needs to be
able to create a blank object.

426
00:20:34,146 --> 00:20:35,972
So simple rules.

427
00:20:35,972 --> 00:20:37,865
Once that's done, it's done,

428
00:20:37,865 --> 00:20:41,625
and you can now use this
class under Hibernate.

429
00:20:41,625 --> 00:20:45,037
So at the moment, we have a DAO

430
00:20:45,037 --> 00:20:47,972
that we wrote using JDBC,

431
00:20:47,972 --> 00:20:49,763
and what I want to do now is show you

432
00:20:49,763 --> 00:20:53,237
how we could write an alternative DAO,

433
00:20:53,237 --> 00:20:56,454
but using Hibernate instead.

434
00:20:56,454 --> 00:20:59,873
So I'm going to start
from the obvious place.

435
00:20:59,873 --> 00:21:02,152
We'll create New, Class.

436
00:21:02,152 --> 00:21:03,544
And I'm going to call this class

437
00:21:03,544 --> 00:21:07,106
the BookDaoHibernate version.

438
00:21:08,406 --> 00:21:10,395
And we need to implement an interface

439
00:21:10,395 --> 00:21:12,269
and of course, that's going to be

440
00:21:12,269 --> 00:21:15,629
the bookdao interface.

441
00:21:15,629 --> 00:21:18,640
And I want to make sure that
the method stubs creation

442
00:21:18,640 --> 00:21:22,182
for inherited abstract
methods is switched on,

443
00:21:22,182 --> 00:21:25,442
and then in our new class, we will get

444
00:21:25,442 --> 00:21:29,825
stub implementations,
starting implementations,

445
00:21:29,825 --> 00:21:33,416
if you like, of all of the
methods in the interface.

446
00:21:33,416 --> 00:21:37,301
Now I think I'll start with
this create method in here.

447
00:21:37,301 --> 00:21:41,796
If we were to use Hibernate
to create a new book

448
00:21:41,796 --> 00:21:44,682
without having to write SQL, I guess

449
00:21:44,682 --> 00:21:48,110
what you could do, if I just refer back

450
00:21:48,110 --> 00:21:51,185
to our Hello Hibernate project

451
00:21:51,185 --> 00:21:54,788
and go back to the clients
application of that,

452
00:21:54,788 --> 00:21:57,456
I could basically copy

453
00:21:57,456 --> 00:22:00,486
the three lines here,

454
00:22:00,486 --> 00:22:02,712
and then do session.save.

455
00:22:02,712 --> 00:22:06,119
And then I would have to
do a commit and a close.

456
00:22:06,119 --> 00:22:08,544
That will be really
tedious to have to do that

457
00:22:08,544 --> 00:22:13,043
for every single one of our DAO methods.

458
00:22:13,043 --> 00:22:15,806
So Spring have decided to allow us

459
00:22:15,806 --> 00:22:18,903
to integrate Hibernate into this DAO

460
00:22:18,903 --> 00:22:22,731
without us having to write
much Hibernate code at all.

461
00:22:22,731 --> 00:22:25,456
And the way they've done
that, in a very similar way

462
00:22:25,456 --> 00:22:29,061
to JDBC, you'll remember that in JDBC,

463
00:22:29,061 --> 00:22:32,719
we use and if I could look
at the JDBC implementation,

464
00:22:32,719 --> 00:22:36,250
we used this class called JdbcTemplate.

465
00:22:36,250 --> 00:22:38,746
And that was provided by Spring.

466
00:22:38,746 --> 00:22:41,245
And that template hid away all

467
00:22:41,245 --> 00:22:44,900
of the routine boilerplate
code that we needed

468
00:22:44,900 --> 00:22:47,340
to do time and time again.

469
00:22:47,340 --> 00:22:50,503
And that basically made
it so that our methods

470
00:22:50,503 --> 00:22:53,935
became kind of like one line methods.

471
00:22:53,935 --> 00:22:58,684
In the Hibernate version, we
have exactly the same thing.

472
00:22:58,684 --> 00:23:02,715
We have a class called
the HibernateTemplate.

473
00:23:02,715 --> 00:23:05,915
I'm just going to call
the object template.

474
00:23:05,915 --> 00:23:09,301
And if I import that on
this version of Spring,

475
00:23:09,301 --> 00:23:12,433
on Spring 4, they've now added support

476
00:23:12,433 --> 00:23:14,387
for Hibernate 4.

477
00:23:14,387 --> 00:23:16,836
So there's two versions
of the Hibernate Template.

478
00:23:16,836 --> 00:23:20,008
One for Hibernate 3 and
one for Hibernate 4.

479
00:23:20,008 --> 00:23:21,980
So if you're using this on a project,

480
00:23:21,980 --> 00:23:26,446
be careful to choose the
right version of Hibernate.

481
00:23:26,446 --> 00:23:30,246
And for this project,
we're using Hibernate 4.

482
00:23:30,246 --> 00:23:33,647
So choose the Hibernate 4 package.

483
00:23:33,647 --> 00:23:35,440
And so, what the template's going

484
00:23:35,440 --> 00:23:37,779
to allow us to do is to
call any of the methods

485
00:23:37,779 --> 00:23:40,949
on the Hibernate session without us having

486
00:23:40,949 --> 00:23:44,398
to do any of the setup and teardown

487
00:23:44,398 --> 00:23:46,448
of that session.

488
00:23:46,448 --> 00:23:49,058
So for example, if I go
into the create method,

489
00:23:49,058 --> 00:23:51,752
all I have to do is call the

490
00:23:51,752 --> 00:23:55,510
template.save method

491
00:23:55,510 --> 00:23:57,511
and basically you'll
find all of the methods

492
00:23:57,511 --> 00:24:01,903
that you find in the Hibernate
session on this template.

493
00:24:01,903 --> 00:24:05,442
And I can press in that newBook.

494
00:24:05,442 --> 00:24:07,642
So in your minds, you might like

495
00:24:07,642 --> 00:24:10,999
to imagine that inside that save method

496
00:24:10,999 --> 00:24:15,248
are the lines of what I keep
calling boilerplate code

497
00:24:15,248 --> 00:24:18,935
that you see here and here.

498
00:24:18,935 --> 00:24:22,115
So what's really nice and clean.

499
00:24:22,115 --> 00:24:24,201
And I'll go through the
rest of the methods.

500
00:24:24,201 --> 00:24:26,268
Now you all need a little
bit of Hibernate knowledge

501
00:24:26,268 --> 00:24:28,692
to understand how to do all of this.

502
00:24:28,692 --> 00:24:31,037
For instance, for the allBooks method,

503
00:24:31,037 --> 00:24:34,406
you need to understand how
to do a Hibernate query.

504
00:24:34,406 --> 00:24:36,464
There is a query language in Hibernate,

505
00:24:36,464 --> 00:24:40,169
which is kind of a
simplified version of SQL,

506
00:24:40,169 --> 00:24:43,105
which retains all of the
power of an SQL query

507
00:24:43,105 --> 00:24:47,145
without some of the
slightly difficult syntax.

508
00:24:47,145 --> 00:24:49,605
So I can call on here the

509
00:24:49,605 --> 00:24:53,939
template.find method

510
00:24:53,939 --> 00:24:56,223
and the query string.

511
00:24:56,223 --> 00:24:57,860
You might be wondering why Hibernate

512
00:24:57,860 --> 00:24:59,720
has a query language when it's supposed

513
00:24:59,720 --> 00:25:03,671
to generate the SQL, but
it's a lot simpler than SQL.

514
00:25:03,671 --> 00:25:07,260
If I just say from Book,
that tells Hibernate

515
00:25:07,260 --> 00:25:11,124
to find all of the
objects that are present

516
00:25:11,124 --> 00:25:13,190
in the Book class.

517
00:25:13,190 --> 00:25:15,073
I don't need the second parameter.

518
00:25:15,073 --> 00:25:18,673
That is just if there are
any parameters in the query.

519
00:25:18,673 --> 00:25:21,502
Now that's going to return a list of books

520
00:25:21,502 --> 00:25:24,756
so I just need to include
a return statement there.

521
00:25:24,756 --> 00:25:26,089
Now we have a bit of a problem here

522
00:25:26,089 --> 00:25:28,688
with this version of Spring.

523
00:25:28,688 --> 00:25:32,460
They've changed the API of
the template a little bit,

524
00:25:32,460 --> 00:25:34,510
and it turns out that when you call one

525
00:25:34,510 --> 00:25:36,271
of these find methods, you are going

526
00:25:36,271 --> 00:25:39,629
to have to cast the return type back

527
00:25:39,629 --> 00:25:43,659
to the type of list that you're expecting.

528
00:25:43,659 --> 00:25:45,728
Now we won't go into any
further detail on this.

529
00:25:45,728 --> 00:25:47,228
It's a little bit tedious.

530
00:25:47,228 --> 00:25:49,264
It relates to generics.

531
00:25:49,264 --> 00:25:53,527
And certainly as long
as this query returns

532
00:25:53,527 --> 00:25:56,317
a list of books and we know it's going to,

533
00:25:56,317 --> 00:25:59,065
then this will definitely work okay.

534
00:25:59,065 --> 00:26:01,250
We will have a warning and the warning

535
00:26:01,250 --> 00:26:03,098
is essentially saying be careful

536
00:26:03,098 --> 00:26:06,086
that you've got the cast correct here.

537
00:26:06,086 --> 00:26:08,123
But we know the cast is correct

538
00:26:08,123 --> 00:26:10,615
so all should be well.

539
00:26:10,615 --> 00:26:12,463
Now I'm going to continue through

540
00:26:12,463 --> 00:26:15,028
and now this one is going
to be a little bit different

541
00:26:15,028 --> 00:26:18,741
because of the way that I
designed the interfaces.

542
00:26:18,741 --> 00:26:21,081
Defined by ISBN method is assuming

543
00:26:21,081 --> 00:26:24,520
that only one book is
going to be returned.

544
00:26:24,520 --> 00:26:26,377
There's some reason in this bookstore,

545
00:26:26,377 --> 00:26:28,830
the ISBNs are unique.

546
00:26:28,830 --> 00:26:30,206
Now there's various different ways

547
00:26:30,206 --> 00:26:31,364
of handling that, but I'm going

548
00:26:31,364 --> 00:26:32,856
to do this quite quickly.

549
00:26:32,856 --> 00:26:35,512
I'm going to get a list of books,

550
00:26:35,512 --> 00:26:37,894
which is going to be the results.

551
00:26:37,894 --> 00:26:41,189
I'll use the template, and I'm going

552
00:26:41,189 --> 00:26:43,770
to perform a find, and this query

553
00:26:43,770 --> 00:26:46,129
is going to be from book where

554
00:26:46,129 --> 00:26:50,071
the ISBN matches a particular value,

555
00:26:50,071 --> 00:26:52,305
and what you can do
with the question marks

556
00:26:52,305 --> 00:26:53,872
or the question mark here is going

557
00:26:53,872 --> 00:26:57,689
to be the parameter that
we're passing into the query.

558
00:26:57,689 --> 00:26:59,560
That's going to be the ISBN.

559
00:26:59,560 --> 00:27:02,944
And you just pass that
in as a second parameter.

560
00:27:02,944 --> 00:27:05,909
And if you had three
or four question marks,

561
00:27:05,909 --> 00:27:09,276
you would just add them
as for the parameters.

562
00:27:09,276 --> 00:27:10,841
Now again, I'll have an error there,

563
00:27:10,841 --> 00:27:13,633
because I've got to do the type cast

564
00:27:13,633 --> 00:27:17,362
to a list of books on the
right-hand side as well.

565
00:27:17,362 --> 00:27:20,067
Now what I'm going to
do for simplicity here

566
00:27:20,067 --> 00:27:22,867
is I'm simply going to return

567
00:27:22,867 --> 00:27:27,110
the first element of the results.

568
00:27:27,110 --> 00:27:28,906
Now in a real project, I'd need to think

569
00:27:28,906 --> 00:27:30,889
about that a little bit more.

570
00:27:30,889 --> 00:27:33,650
If the results had more than one element,

571
00:27:33,650 --> 00:27:35,330
then maybe that's an error

572
00:27:35,330 --> 00:27:37,365
and we'd want to throw an exception.

573
00:27:37,365 --> 00:27:38,959
Well, actually thinking about it,

574
00:27:38,959 --> 00:27:42,160
we can throw BookNotFoundException.

575
00:27:42,160 --> 00:27:46,067
So we could say, if results, or we could

576
00:27:46,067 --> 00:27:48,715
just call it .isEmpty.

577
00:27:48,715 --> 00:27:51,705
If the results are
empty, then we can throw

578
00:27:51,705 --> 00:27:54,774
a BookNotFoundException.

579
00:27:55,934 --> 00:28:00,292
Otherwise, we just return the
first book that was returned.

580
00:28:00,292 --> 00:28:01,760
Okay, just two to go then.

581
00:28:01,760 --> 00:28:05,776
So for the delete method,
Hibernate's a little awkward

582
00:28:05,776 --> 00:28:09,884
in that it does have a delete method.

583
00:28:09,884 --> 00:28:12,808
But the problem with the
delete method is you do have

584
00:28:12,808 --> 00:28:16,537
to pass in a so-called persistence object,

585
00:28:16,537 --> 00:28:20,036
and by persistence object, they mean

586
00:28:20,036 --> 00:28:22,709
object that you have previously found

587
00:28:22,709 --> 00:28:24,664
from the Hibernate session.

588
00:28:24,664 --> 00:28:26,170
Now this book that's being passed in

589
00:28:26,170 --> 00:28:28,871
as a parameter, this redundant book,

590
00:28:28,871 --> 00:28:30,798
is just a regular object.

591
00:28:30,798 --> 00:28:34,227
It's not a persistence Hibernate object.

592
00:28:34,227 --> 00:28:37,299
So what we have to do first is we have

593
00:28:37,299 --> 00:28:39,969
to find the book.

594
00:28:39,969 --> 00:28:42,901
So I can do a get on that.

595
00:28:42,901 --> 00:28:45,150
We know we're looking for a book,

596
00:28:45,150 --> 00:28:47,594
but for the id, I would just say

597
00:28:47,594 --> 00:28:50,994
redundantBook,

598
00:28:50,994 --> 00:28:52,755
and we'll call the getId method.

599
00:28:52,755 --> 00:28:55,169
Well, I don't have a getId method,

600
00:28:55,169 --> 00:28:57,850
but I can very easily implement one.

601
00:28:57,850 --> 00:28:59,996
So, I'll do that with a quick fix.

602
00:29:02,199 --> 00:29:04,075
Add the method in and we're just going

603
00:29:04,075 --> 00:29:07,165
to return the id.

604
00:29:07,165 --> 00:29:09,739
And I'll change the return type on there,

605
00:29:09,739 --> 00:29:12,457
because I know it's going to be an int.

606
00:29:12,457 --> 00:29:15,316
Now this is a little bit of kind of oddity

607
00:29:15,316 --> 00:29:17,628
about Hibernate in that there's no method

608
00:29:17,628 --> 00:29:21,178
in Hibernate to delete by id,

609
00:29:21,178 --> 00:29:22,568
which I'd much prefer.

610
00:29:22,568 --> 00:29:23,896
It's a little bit inefficient.

611
00:29:23,896 --> 00:29:28,009
It's going to do a search
or I should say a select

612
00:29:28,009 --> 00:29:30,149
and then it's going to do a delete.

613
00:29:30,149 --> 00:29:31,631
But it's no big deal.

614
00:29:31,631 --> 00:29:33,675
Hopefully, that should work.

615
00:29:33,675 --> 00:29:35,904
Now we have just 1/3 of the query to do

616
00:29:35,904 --> 00:29:37,820
and it will give me a chance to show you

617
00:29:37,820 --> 00:29:41,880
a little bit more of
how this template works.

618
00:29:41,880 --> 00:29:43,398
To find books by author, again,

619
00:29:43,398 --> 00:29:47,440
I'm going to be returning a list of books.

620
00:29:47,440 --> 00:29:50,530
So I'll do the type cast right now,

621
00:29:50,530 --> 00:29:54,105
and I'll use the template
again to do a find.

622
00:29:55,615 --> 00:29:57,514
And this is going to be from book

623
00:29:57,514 --> 00:29:59,669
where the author equals, and again,

624
00:29:59,669 --> 00:30:03,093
I'm gonna use the equal
mark just temporarily.

625
00:30:03,093 --> 00:30:06,548
And we pass in the
author as the parameter.

626
00:30:06,548 --> 00:30:09,037
So that's all okay, but
there is an alternative form

627
00:30:09,037 --> 00:30:12,681
of the find method, and it's called,

628
00:30:12,681 --> 00:30:14,579
I'll just use the suggestion there.

629
00:30:14,579 --> 00:30:18,662
It's called findByNamedParameter

630
00:30:18,662 --> 00:30:20,881
and this is a little bit more elegant

631
00:30:20,881 --> 00:30:23,367
than using the find method.

632
00:30:23,367 --> 00:30:26,194
I just messed things
up a little bit there.

633
00:30:26,194 --> 00:30:28,502
The first parameter into findByNamedParam

634
00:30:28,502 --> 00:30:30,932
is the query string as usual.

635
00:30:30,932 --> 00:30:32,578
But instead of the question mark,

636
00:30:32,578 --> 00:30:34,678
we can use so-called named parameters

637
00:30:34,678 --> 00:30:36,693
that you might have seen before.

638
00:30:36,693 --> 00:30:39,478
I just use a colon followed by

639
00:30:39,478 --> 00:30:42,556
whatever I want to call a parameter.

640
00:30:42,556 --> 00:30:44,821
So this is an arbitrary string.

641
00:30:44,821 --> 00:30:47,981
I could have used any string I like there,

642
00:30:47,981 --> 00:30:51,703
but I then reference in the parameter name

643
00:30:51,703 --> 00:30:54,136
that the author is going to be

644
00:30:54,136 --> 00:30:57,146
of value author.

645
00:30:57,146 --> 00:30:59,469
And then if I had further named parameters

646
00:30:59,469 --> 00:31:01,919
in the query, then I could just go ahead

647
00:31:01,919 --> 00:31:05,917
and add further pairs of names and values.

648
00:31:05,917 --> 00:31:08,043
So I think that's a
little bit easier to read,

649
00:31:08,043 --> 00:31:10,514
possibly than just these question marks,

650
00:31:10,514 --> 00:31:13,144
but you can just choose
the one you prefer.

651
00:31:13,144 --> 00:31:16,442
So what we've done then
is we've now completed

652
00:31:16,442 --> 00:31:20,718
implementing a Hibernate
base data access object

653
00:31:20,718 --> 00:31:25,380
and to compare with our previous JDBC DAO,

654
00:31:25,380 --> 00:31:28,619
it's not actually a lot shorter.

655
00:31:28,619 --> 00:31:30,366
It's very similar in many ways,

656
00:31:30,366 --> 00:31:33,482
but the differences this
time, we have not had

657
00:31:33,482 --> 00:31:37,533
to write the SQL ourselves

658
00:31:37,533 --> 00:31:39,444
and also, do you remember from quite

659
00:31:39,444 --> 00:31:41,819
a long time ago now, with JDBC,

660
00:31:41,819 --> 00:31:44,431
we had to write this map of class

661
00:31:44,431 --> 00:31:47,400
to convert rows into objects.

662
00:31:47,400 --> 00:31:49,072
Well, in the Hibernate version,

663
00:31:49,072 --> 00:31:50,693
we don't need to worry about that

664
00:31:50,693 --> 00:31:52,756
and Hibernate's handling it.

665
00:31:52,756 --> 00:31:55,743
And in fact, the entire
class from top to bottom,

666
00:31:55,743 --> 00:31:59,978
excluding the imports, is
only just filling a screenful.

667
00:31:59,978 --> 00:32:02,385
Now I know that a true DAO would possibly

668
00:32:02,385 --> 00:32:05,807
be a bit bigger than this, but really,

669
00:32:05,807 --> 00:32:07,381
I think it's quite impressive

670
00:32:07,381 --> 00:32:10,286
just how simple this DAO can be.

671
00:32:10,286 --> 00:32:12,622
So the HibernateTemplate is useful,

672
00:32:12,622 --> 00:32:14,924
but there is one slight problem with it

673
00:32:14,924 --> 00:32:18,252
and that is it needs to be configured.

674
00:32:18,252 --> 00:32:20,879
If you remember from much
earlier in the course

675
00:32:20,879 --> 00:32:24,163
when we use the JDBC template,

676
00:32:24,163 --> 00:32:26,566
we configured that in our

677
00:32:26,566 --> 00:32:29,276
application.xml.

678
00:32:29,276 --> 00:32:30,393
Here it is.

679
00:32:30,393 --> 00:32:33,047
But it did take a single property,

680
00:32:33,047 --> 00:32:35,389
which was the datasource
that you're using.

681
00:32:35,389 --> 00:32:38,255
So, that was the way
that the JDBC template

682
00:32:38,255 --> 00:32:40,971
could see the database.

683
00:32:40,971 --> 00:32:44,822
Now for Hibernate, it's pretty similar.

684
00:32:44,822 --> 00:32:46,495
We're going to need to configure

685
00:32:46,495 --> 00:32:49,245
a bean for the HibernateTemplate,

686
00:32:49,245 --> 00:32:51,489
but it does need a little bit more setup.

687
00:32:51,489 --> 00:32:53,773
So, I think I'm going to
go across to a caption

688
00:32:53,773 --> 00:32:56,670
to show you how to figure this template.

689
00:32:56,670 --> 00:33:00,072
Now it is at first an
alarming amount of XML,

690
00:33:00,072 --> 00:33:02,996
but actually, it's fairly simple.

691
00:33:02,996 --> 00:33:04,128
Let's start from the top.

692
00:33:04,128 --> 00:33:07,963
We're going to need a bean
for this HibernateTemplate.

693
00:33:07,963 --> 00:33:10,587
I've called it hibernateTemplate.

694
00:33:10,587 --> 00:33:12,575
And the class it comes from is

695
00:33:12,575 --> 00:33:16,495
org.springframework.orm.

696
00:33:16,495 --> 00:33:18,851
and you'll need to choose hibernate3

697
00:33:18,851 --> 00:33:23,076
or hibernate4 here, depending
on which version you're using,

698
00:33:23,076 --> 00:33:25,411
.HibernateTemplate.

699
00:33:25,411 --> 00:33:27,866
As always, don't try to remember that.

700
00:33:27,866 --> 00:33:31,518
I copied that from the
Spring reference manual.

701
00:33:31,518 --> 00:33:34,435
Now similar to the JDBC template,

702
00:33:34,435 --> 00:33:37,678
the template only takes one property.

703
00:33:37,678 --> 00:33:40,458
But this time instead of the datasource,

704
00:33:40,458 --> 00:33:43,996
the property is a session factory.

705
00:33:43,996 --> 00:33:47,391
And what's effectively
happening here is that Spring

706
00:33:47,391 --> 00:33:50,663
is managing the session factory for you.

707
00:33:50,663 --> 00:33:52,785
Now in Hibernate, you need one

708
00:33:52,785 --> 00:33:56,057
and only one instance
of the session factory,

709
00:33:56,057 --> 00:33:58,435
and you need it to be created at the start

710
00:33:58,435 --> 00:34:01,626
of the application and
you need it to be closed

711
00:34:01,626 --> 00:34:04,068
at the ended of the application.

712
00:34:04,068 --> 00:34:08,290
So by making the session
factory be a Spring bean,

713
00:34:08,290 --> 00:34:10,947
we're basically letting Spring manage

714
00:34:10,947 --> 00:34:13,675
the lifetime of the session factory.

715
00:34:13,675 --> 00:34:17,114
It's a bit tedious to configure
as you'll see in a minute,

716
00:34:17,114 --> 00:34:19,157
but the great thing is you now never need

717
00:34:19,157 --> 00:34:23,112
to see the session factory in your code.

718
00:34:23,112 --> 00:34:26,918
So this session factory is
going to be a bean itself,

719
00:34:26,918 --> 00:34:29,147
and I've created it here.

720
00:34:29,147 --> 00:34:31,710
The class, again, a little bit awkward.

721
00:34:31,710 --> 00:34:34,425
It comes from the package
you can see there.

722
00:34:34,425 --> 00:34:37,550
Again, choose Hibernate three or four

723
00:34:37,550 --> 00:34:41,812
and the class name is called
LocalSessionFactoryBean.

724
00:34:41,812 --> 00:34:46,226
Well, it looks like there's
a lot of XML inside the bean,

725
00:34:46,226 --> 00:34:49,000
but there's really just three properties.

726
00:34:49,000 --> 00:34:52,093
The first property is the datasource.

727
00:34:52,093 --> 00:34:53,891
So, we're reusing the datasource

728
00:34:53,891 --> 00:34:55,766
from earlier on in the course.

729
00:34:55,766 --> 00:34:58,060
We're now making this
session factory connect

730
00:34:58,060 --> 00:35:01,467
to our existing connection pool.

731
00:35:01,467 --> 00:35:02,949
So, that's easy.

732
00:35:02,949 --> 00:35:04,792
The next property is telling Hibernate

733
00:35:04,792 --> 00:35:07,857
what classes we want to be persistence.

734
00:35:07,857 --> 00:35:09,994
Now in a non-Spring application,

735
00:35:09,994 --> 00:35:13,200
you have to put this in
the Hibernate config file,

736
00:35:13,200 --> 00:35:14,761
but we can now make it be part

737
00:35:14,761 --> 00:35:17,152
of the Spring config file.

738
00:35:17,152 --> 00:35:18,892
There's a couple of alternatives here.

739
00:35:18,892 --> 00:35:21,624
You can list the classes individually,

740
00:35:21,624 --> 00:35:23,650
but I find that a bit tedious

741
00:35:23,650 --> 00:35:26,331
and usually all of your
persistence classes

742
00:35:26,331 --> 00:35:29,186
are in a single package,

743
00:35:29,186 --> 00:35:33,058
or at least sub-packages
of a single package.

744
00:35:33,058 --> 00:35:35,690
So, this packagesToScan is really useful,

745
00:35:35,690 --> 00:35:38,863
because I can just specify the value of,

746
00:35:38,863 --> 00:35:42,291
in my case, my domain package name,

747
00:35:42,291 --> 00:35:44,322
and then it will find all of the classes

748
00:35:44,322 --> 00:35:46,393
inside that package

749
00:35:46,393 --> 00:35:49,383
and in any sub-packages.

750
00:35:49,383 --> 00:35:51,391
And the final property at the bottom

751
00:35:51,391 --> 00:35:53,919
is just any additional
Hibernate properties

752
00:35:53,919 --> 00:35:56,143
that I want to be switched on.

753
00:35:56,143 --> 00:35:58,931
Now I would like to be able to see the SQL

754
00:35:58,931 --> 00:36:00,885
that's being generated so I've set

755
00:36:00,885 --> 00:36:05,189
the hibernate.show_sql flag to true,

756
00:36:05,189 --> 00:36:06,817
and I also want Hibernate to create

757
00:36:06,817 --> 00:36:09,600
any tables if they don't already exist.

758
00:36:09,600 --> 00:36:11,635
So the key we need is the

759
00:36:11,635 --> 00:36:15,100
hbm2ddl.auto

760
00:36:15,100 --> 00:36:18,393
and if we set it to the value of update,

761
00:36:18,393 --> 00:36:20,584
then it will update any tables,

762
00:36:20,584 --> 00:36:23,969
but it will also create
them if they don't exist.

763
00:36:23,969 --> 00:36:26,213
By the way, we haven't seen this props

764
00:36:26,213 --> 00:36:29,626
and this property style of coding

765
00:36:29,626 --> 00:36:31,407
in Hibernate before.

766
00:36:31,407 --> 00:36:35,213
It's just a way of setting
up a list of properties.

767
00:36:35,213 --> 00:36:37,266
So there was quite a bit of XML,

768
00:36:37,266 --> 00:36:38,914
but you can probably guess by now

769
00:36:38,914 --> 00:36:41,548
that this is in fact a one-off job,

770
00:36:41,548 --> 00:36:43,258
even on a very complex project,

771
00:36:43,258 --> 00:36:45,336
you'd only ever need to do this once

772
00:36:45,336 --> 00:36:48,596
and then basically you'd forget about it.

773
00:36:48,596 --> 00:36:49,832
So, let's swallow the pain,

774
00:36:49,832 --> 00:36:52,126
and we'll go across to our XML file

775
00:36:52,126 --> 00:36:54,640
and get these configurations in place.

776
00:36:54,640 --> 00:36:56,055
For this addition of the course,

777
00:36:56,055 --> 00:36:58,629
I'm going to explicitly type this in,

778
00:36:58,629 --> 00:37:00,680
which I know can be a little bit tedious

779
00:37:00,680 --> 00:37:01,937
when you're watching the video.

780
00:37:01,937 --> 00:37:03,698
Of course, you can forward wind.

781
00:37:03,698 --> 00:37:05,572
But if you're following along yourself,

782
00:37:05,572 --> 00:37:07,609
you can always copy from the video screen

783
00:37:07,609 --> 00:37:10,095
or use the practicals in code folder.

784
00:37:10,095 --> 00:37:12,068
So my first job is I'm
going to create a bean

785
00:37:12,068 --> 00:37:15,016
called hibernateTemplate

786
00:37:15,016 --> 00:37:17,429
and the class, well, as I recommended,

787
00:37:17,429 --> 00:37:19,142
use the reference manual for this,

788
00:37:19,142 --> 00:37:21,688
but I'm going to pivot from my caption.

789
00:37:21,688 --> 00:37:26,622
It's org.springframework.orm.hibernate4.

790
00:37:27,682 --> 00:37:30,412
Be careful there if
you're using Hibernate 3.

791
00:37:30,412 --> 00:37:33,821
And the class is called HibernateTemplate.

792
00:37:35,001 --> 00:37:38,418
Now I've agonized before
recording this session

793
00:37:38,418 --> 00:37:41,726
whether to use the autowiring or whether

794
00:37:41,726 --> 00:37:44,923
to return back to my previous XML

795
00:37:44,923 --> 00:37:47,761
where I was doing everything manually.

796
00:37:47,761 --> 00:37:50,912
Well, I've decided to
continue with autowiring here

797
00:37:50,912 --> 00:37:53,384
simply because I think it might be useful

798
00:37:53,384 --> 00:37:55,816
to have a little bit more practice at it.

799
00:37:55,816 --> 00:37:58,454
And as a compromise, in
the practical session

800
00:37:58,454 --> 00:38:01,087
where we got to our CRM system,

801
00:38:01,087 --> 00:38:03,838
I'll switch back to
using the manual wiring.

802
00:38:03,838 --> 00:38:05,652
So, I don't know which you prefer,

803
00:38:05,652 --> 00:38:07,881
but autowiring for this.

804
00:38:07,881 --> 00:38:11,335
So, you can add in property name

805
00:38:11,335 --> 00:38:16,093
equals sessionFactory, or we can just say

806
00:38:16,093 --> 00:38:20,840
autowire byType,

807
00:38:20,840 --> 00:38:23,298
because we know there's one property

808
00:38:23,298 --> 00:38:25,599
in this HibernateTemplate

809
00:38:25,599 --> 00:38:28,763
and it's of type sessionFactory.

810
00:38:28,763 --> 00:38:30,533
So as long as I've set up somewhere

811
00:38:30,533 --> 00:38:34,980
in my XML a bean of type sessionFactory,

812
00:38:34,980 --> 00:38:38,760
then this bean will be
automatically injected

813
00:38:38,760 --> 00:38:41,188
into the HibernateTemplate.

814
00:38:41,188 --> 00:38:43,272
So the class that we're
looking for this time

815
00:38:43,272 --> 00:38:44,632
is another mouthful,

816
00:38:44,632 --> 00:38:49,582
org.springframework.orm.hibernate4.LocalSessionFactoryBean.

817
00:38:56,007 --> 00:38:57,631
We can't do any autowiring here,

818
00:38:57,631 --> 00:39:01,509
because all of the values
need to be specified by us.

819
00:39:01,509 --> 00:39:04,017
The first thing is we have a,

820
00:39:04,017 --> 00:39:06,553
well, actually we could
have autowired this one.

821
00:39:06,553 --> 00:39:09,387
The datasource we're referring to the bean

822
00:39:09,387 --> 00:39:13,323
called dataSource, so yeah,
we could have avoided that

823
00:39:13,323 --> 00:39:17,580
by using autowire byType there.

824
00:39:17,580 --> 00:39:20,088
I'll leave in since I've added it now,

825
00:39:20,088 --> 00:39:23,383
but the other two properties
we can't autowire.

826
00:39:23,383 --> 00:39:26,454
The first one is the packagesToScan.

827
00:39:26,454 --> 00:39:29,680
Now this one is going to take a list,

828
00:39:29,680 --> 00:39:32,302
but we're only supplying one value

829
00:39:32,302 --> 00:39:35,615
and that's the name of our
top level domain package,

830
00:39:35,615 --> 00:39:40,267
which on this project is
virtualpairprogrammers,

831
00:39:40,267 --> 00:39:42,570
I'm bound to type this wrong,

832
00:39:42,570 --> 00:39:45,121
.avalon.domain.

833
00:39:45,121 --> 00:39:48,314
Of course, if you've used a
different package structure,

834
00:39:48,314 --> 00:39:50,892
then make the appropriate change there.

835
00:39:50,892 --> 00:39:52,912
And the final property

836
00:39:55,674 --> 00:39:57,671
is called hibernateProperties,

837
00:39:57,671 --> 00:40:00,621
and this just gives us a chance to set up

838
00:40:00,621 --> 00:40:04,248
any other specific Hibernate
features that we want

839
00:40:04,248 --> 00:40:06,865
and it's this props,

840
00:40:08,446 --> 00:40:10,812
and it's going to be prop key.

841
00:40:10,812 --> 00:40:13,918
And again, I'm assuming here
some Hibernate knowledge.

842
00:40:13,918 --> 00:40:15,708
The key names are

843
00:40:15,708 --> 00:40:19,788
hibernate.show_sql,

844
00:40:19,788 --> 00:40:21,410
for example, and we're going to set that

845
00:40:21,410 --> 00:40:24,353
to the value of true so we can see

846
00:40:24,353 --> 00:40:28,003
the SQL being issued and we also have

847
00:40:28,003 --> 00:40:32,932
hibernate.hbm2ddl,

848
00:40:32,932 --> 00:40:36,340
which in case you're
curious, it basically means

849
00:40:36,340 --> 00:40:40,645
Hibernate mapping to
data definition language,

850
00:40:40,645 --> 00:40:43,348
which means creating tables.

851
00:40:43,348 --> 00:40:45,768
So I think that's it then for creating

852
00:40:45,768 --> 00:40:48,121
the HibernateTemplate.

853
00:40:48,121 --> 00:40:50,110
The next job is we need to make sure

854
00:40:50,110 --> 00:40:53,402
that the template is being injected

855
00:40:53,402 --> 00:40:56,462
into the DAO.

856
00:40:56,462 --> 00:40:59,065
Now if we were using manual wiring,

857
00:40:59,065 --> 00:41:01,833
we'd need to provide
either a set of method

858
00:41:01,833 --> 00:41:05,185
or a constructor to allow
this to be injected,

859
00:41:05,185 --> 00:41:07,104
but as I say, for this session,

860
00:41:07,104 --> 00:41:10,361
I'm going to use the
autowiring and the annotation.

861
00:41:10,361 --> 00:41:13,425
So we can just add on autowired

862
00:41:13,425 --> 00:41:15,905
to the template.

863
00:41:15,905 --> 00:41:20,050
And I could also have used
the at inject annotation

864
00:41:20,050 --> 00:41:22,809
if I prefer the standard annotations.

865
00:41:22,809 --> 00:41:26,368
And now this is a big leap forward.

866
00:41:26,368 --> 00:41:30,121
I'm going to make this class now become

867
00:41:30,121 --> 00:41:32,331
the repository.

868
00:41:34,349 --> 00:41:38,410
So because we're doing
the annotation scanning,

869
00:41:38,410 --> 00:41:40,629
Spring will know it
starts up that it needs

870
00:41:40,629 --> 00:41:43,883
to create an instance of this DAO

871
00:41:43,883 --> 00:41:46,505
and it's this DAO that we want now

872
00:41:46,505 --> 00:41:49,892
to become injected to our service class.

873
00:41:49,892 --> 00:41:53,350
So that means and this is
kind of the easiest way

874
00:41:53,350 --> 00:41:57,339
of working, if I got
back to my JDBC version,

875
00:41:57,339 --> 00:41:59,872
I don't want this to be used anymore.

876
00:41:59,872 --> 00:42:03,007
So it's easy case of just taking off

877
00:42:03,007 --> 00:42:05,065
the repository annotation.

878
00:42:05,065 --> 00:42:06,891
I hope I haven't lost you at this point.

879
00:42:06,891 --> 00:42:08,763
I realized that when I'm working

880
00:42:08,763 --> 00:42:11,670
in the XML file and just
changing things around

881
00:42:11,670 --> 00:42:14,165
and moving annotations, it can get

882
00:42:14,165 --> 00:42:17,790
a little bit confusion as
to exactly what we're doing.

883
00:42:17,790 --> 00:42:20,383
Now I am sort of assuming
that by this point

884
00:42:20,383 --> 00:42:23,859
in the course you're familiar
with dependency injection

885
00:42:23,859 --> 00:42:26,609
and all of the concepts
associated with it.

886
00:42:26,609 --> 00:42:28,434
But just to make sure, I haven't gone

887
00:42:28,434 --> 00:42:30,358
too fast at this point.

888
00:42:30,358 --> 00:42:32,771
This caption is the
state we were in before

889
00:42:32,771 --> 00:42:34,804
I changed the annotations.

890
00:42:34,804 --> 00:42:37,961
We have a BookService, which remember

891
00:42:37,961 --> 00:42:40,973
is now the transaction layer,

892
00:42:40,973 --> 00:42:43,106
and the BookService is currently connected

893
00:42:43,106 --> 00:42:46,195
to a JDBCDao.

894
00:42:46,195 --> 00:42:49,388
And because we're using the
annotation-based approach,

895
00:42:49,388 --> 00:42:53,495
that happened because we had
the @Repository annotation

896
00:42:53,495 --> 00:42:55,292
on that DAO.

897
00:42:55,292 --> 00:42:57,807
But the change I just made was I removed

898
00:42:57,807 --> 00:43:02,547
the annotation from the
JDBCDao and I moved it

899
00:43:02,547 --> 00:43:06,205
to the HibernateDao instead.

900
00:43:06,205 --> 00:43:09,374
And what this means is
when Spring starts up,

901
00:43:09,374 --> 00:43:12,671
it will no longer be
connecting the JDBCDao

902
00:43:12,671 --> 00:43:14,619
to the BookService.

903
00:43:14,619 --> 00:43:17,998
Instead it will be picking
up the new HibernateDao.

904
00:43:17,998 --> 00:43:20,729
So we've effectively made the HibernateDao

905
00:43:20,729 --> 00:43:24,383
be the live implementation of the DAO.

906
00:43:24,383 --> 00:43:26,126
Now there are other ways of doing this

907
00:43:26,126 --> 00:43:28,701
and as I say, in the practical session,

908
00:43:28,701 --> 00:43:32,433
you'll be able to practice
with the XML-based approach,

909
00:43:32,433 --> 00:43:34,246
if that's what you prefer.

910
00:43:34,246 --> 00:43:36,296
Now there is one thing
that I mustn't forget

911
00:43:36,296 --> 00:43:38,646
before we try to run the code,

912
00:43:38,646 --> 00:43:41,789
and that is the transaction manager.

913
00:43:41,789 --> 00:43:44,759
Remember in the previous
chapter on transactions,

914
00:43:44,759 --> 00:43:46,984
this was the bean that we configured

915
00:43:46,984 --> 00:43:50,595
in our XML file that contains the begin

916
00:43:50,595 --> 00:43:52,873
and commits advice.

917
00:43:52,873 --> 00:43:54,544
Without the transaction manager,

918
00:43:54,544 --> 00:43:56,037
Spring wouldn't know what to do

919
00:43:56,037 --> 00:43:59,516
at the beginning and the
end of each transaction.

920
00:43:59,516 --> 00:44:01,302
Well, because transactions are handled

921
00:44:01,302 --> 00:44:04,040
completely differently in Hibernate,

922
00:44:04,040 --> 00:44:05,977
it's a different API.

923
00:44:05,977 --> 00:44:08,380
We have to make sure that
because we're changing

924
00:44:08,380 --> 00:44:11,274
the data access strategy, we also have

925
00:44:11,274 --> 00:44:14,568
to remember to change
the transaction manager.

926
00:44:14,568 --> 00:44:17,093
If we don't this, we'll get quite

927
00:44:17,093 --> 00:44:20,043
an obscure looking error.

928
00:44:20,043 --> 00:44:21,811
Well, actually before I make the change,

929
00:44:21,811 --> 00:44:23,159
I'm going to try to run the code

930
00:44:23,159 --> 00:44:25,718
to show you what the error will look like

931
00:44:25,718 --> 00:44:28,297
just in case you meet it on a project.

932
00:44:28,297 --> 00:44:30,086
So here we are back in the code then

933
00:44:30,086 --> 00:44:33,528
and as a quick review, XML file,

934
00:44:33,528 --> 00:44:36,137
we have a datasource configured.

935
00:44:36,137 --> 00:44:38,203
That's the connection pool,

936
00:44:38,203 --> 00:44:41,307
which we're connecting
to our sessionFactory,

937
00:44:41,307 --> 00:44:44,633
which is going to be the grand organizer

938
00:44:44,633 --> 00:44:47,547
of all of the Hibernate operations.

939
00:44:47,547 --> 00:44:50,568
And that's being sent
into a HibernateTemplate,

940
00:44:50,568 --> 00:44:54,246
which is being picked up by our DAO.

941
00:44:54,246 --> 00:44:58,103
It can get quite complicated,
these chains of operations,

942
00:44:58,103 --> 00:45:00,014
but as I said, the one thing we do need

943
00:45:00,014 --> 00:45:03,783
to change is the transaction manager here.

944
00:45:03,783 --> 00:45:06,348
The datasource transaction
manager is intended

945
00:45:06,348 --> 00:45:09,591
for JDBC operations.

946
00:45:09,591 --> 00:45:12,375
So I'm not expecting this code to work.

947
00:45:12,375 --> 00:45:14,519
But let's go back to our clients.

948
00:45:14,519 --> 00:45:16,711
Now it isn't the Hibernate client.

949
00:45:16,711 --> 00:45:20,548
That comes from the standalone
separate project that we had.

950
00:45:20,548 --> 00:45:24,763
We want our regular Spring clients.

951
00:45:24,763 --> 00:45:27,582
Now the state of the
clients at the moment is

952
00:45:27,582 --> 00:45:29,629
that we're testing the purchasing service.

953
00:45:29,629 --> 00:45:30,854
I think we were doing that back

954
00:45:30,854 --> 00:45:33,325
in the chapter on transactions.

955
00:45:33,325 --> 00:45:37,581
But because I've just been
upgrading the BookService DAO,

956
00:45:37,581 --> 00:45:39,783
I think I'm going to remove the code

957
00:45:39,783 --> 00:45:42,142
that we have in there

958
00:45:42,142 --> 00:45:45,795
and I'm going to do some
slightly more basic operations.

959
00:45:45,795 --> 00:45:49,625
I'm going to use bookService
just to register a new book

960
00:45:50,685 --> 00:45:54,795
and we'll make this book have the ISBN

961
00:45:54,795 --> 00:45:56,653
of whatever.

962
00:45:56,653 --> 00:45:59,353
The title can be Java Programming.

963
00:45:59,353 --> 00:46:00,924
I'm very uninspired today.

964
00:46:00,924 --> 00:46:03,069
This can be by Josh Bloch

965
00:46:03,069 --> 00:46:07,152
and the price can be any random amount.

966
00:46:07,152 --> 00:46:10,459
And then what I will do is
I will do a query method.

967
00:46:10,459 --> 00:46:12,582
I will get a list of books.

968
00:46:13,962 --> 00:46:16,636
And again, we'll use the bookService

969
00:46:18,717 --> 00:46:21,432
and the method is called
getEntireCatalogue.

970
00:46:21,432 --> 00:46:24,370
So remember these are the
methods on the service class,

971
00:46:24,370 --> 00:46:26,050
but they are being delegated down

972
00:46:26,050 --> 00:46:29,751
to our new DAO implementation.

973
00:46:29,751 --> 00:46:32,122
And I'll list all of the books

974
00:46:36,003 --> 00:46:40,092
so we can check that they
made it into the database.

975
00:46:44,300 --> 00:46:47,251
Okay, now I think for a clean start,

976
00:46:47,251 --> 00:46:49,830
I'll refresh the project

977
00:46:49,830 --> 00:46:53,107
and delete the existing database.

978
00:46:53,107 --> 00:46:55,085
The big difference in this chapter is

979
00:46:55,085 --> 00:46:56,673
that because we're using Hibernate,

980
00:46:56,673 --> 00:47:00,641
we really need to use proper database IDs.

981
00:47:00,641 --> 00:47:03,484
So there is going to be a
change to the database scheme

982
00:47:03,484 --> 00:47:05,537
and I think it's just safer to start

983
00:47:05,537 --> 00:47:08,049
from a completely clean slate.

984
00:47:08,049 --> 00:47:10,402
So remember we're not
expecting this to work,

985
00:47:10,402 --> 00:47:11,857
because we haven't yet done the work

986
00:47:11,857 --> 00:47:14,765
of changing that transaction manager,

987
00:47:14,765 --> 00:47:18,571
but we might have a few other
errors as well so let's see.

988
00:47:22,269 --> 00:47:24,188
Okay and a nice big crash,

989
00:47:24,188 --> 00:47:27,317
which I had predicted, but I just wanted

990
00:47:27,317 --> 00:47:30,235
to show you this exception,
because it is quite,

991
00:47:30,235 --> 00:47:32,483
you know, it's one of
those types of exceptions

992
00:47:32,483 --> 00:47:35,838
that if you saw it on a project
and it was Friday afternoon

993
00:47:35,838 --> 00:47:38,166
and you wanted to get away early

994
00:47:38,166 --> 00:47:41,928
and you see it just says, write
operations are not allowed

995
00:47:41,928 --> 00:47:44,550
in read-only mode FlushMode.MANUAL,

996
00:47:44,550 --> 00:47:47,773
I mean this sounds like a terrifying error

997
00:47:47,773 --> 00:47:51,040
and it's really complaining
about read-only markers,

998
00:47:51,040 --> 00:47:52,769
and I think it would be quite hard

999
00:47:52,769 --> 00:47:55,108
to work out that this was due to

1000
00:47:55,108 --> 00:47:58,076
your transaction manager being incorrect.

1001
00:47:58,076 --> 00:47:59,792
But actually, there is a clue there.

1002
00:47:59,792 --> 00:48:02,360
It mentions transactions
and it's quite hard

1003
00:48:02,360 --> 00:48:04,282
to explain why we get this error,

1004
00:48:04,282 --> 00:48:07,112
but it's basically because
the transaction mode

1005
00:48:07,112 --> 00:48:10,350
for Hibernate has to be set correctly.

1006
00:48:10,350 --> 00:48:12,727
If it isn't, then it will crash horribly.

1007
00:48:12,727 --> 00:48:16,127
And because we've got the
wrong transaction manager on,

1008
00:48:16,127 --> 00:48:19,951
the transaction mode definitely
isn't being set correctly.

1009
00:48:19,951 --> 00:48:23,025
So we need to find the
correct transaction manager

1010
00:48:23,025 --> 00:48:24,992
for Hibernate.

1011
00:48:24,992 --> 00:48:27,698
If we look back in the
application.xml file,

1012
00:48:27,698 --> 00:48:32,114
we currently have the
DataSourceTransactionManager.

1013
00:48:32,114 --> 00:48:33,428
You could use the reference manual

1014
00:48:33,428 --> 00:48:35,537
to find out what the transaction manager

1015
00:48:35,537 --> 00:48:37,434
for Hibernate should be,

1016
00:48:37,434 --> 00:48:40,963
but another way would
be to go into the API.

1017
00:48:40,963 --> 00:48:44,240
And here is the class of
DataSourceTransactionManager,

1018
00:48:44,240 --> 00:48:46,246
the one that we're currently using.

1019
00:48:46,246 --> 00:48:47,907
And you might be able to guess that

1020
00:48:47,907 --> 00:48:50,737
all of the transaction managers in Spring

1021
00:48:50,737 --> 00:48:52,931
all implement the same interface

1022
00:48:52,931 --> 00:48:57,353
so they're all extending
the same base class.

1023
00:48:57,353 --> 00:49:00,020
So here is the inheritance hierarchy

1024
00:49:00,020 --> 00:49:03,046
for DataSourceTransactionManager.

1025
00:49:03,046 --> 00:49:05,374
I can go up a level to

1026
00:49:05,374 --> 00:49:08,468
the AbstractPlatformTransactionManager.

1027
00:49:08,468 --> 00:49:10,959
And if you look there at
the direct known subclasses,

1028
00:49:10,959 --> 00:49:13,540
you can see there's quite a variety

1029
00:49:13,540 --> 00:49:16,026
of different transaction managers.

1030
00:49:16,026 --> 00:49:19,693
One of which is
HibernateTransactionManager,

1031
00:49:19,693 --> 00:49:21,585
which is exactly what we need.

1032
00:49:21,585 --> 00:49:23,368
There are some others
that we won't be seeing

1033
00:49:23,368 --> 00:49:25,449
on this course, but we will be using

1034
00:49:25,449 --> 00:49:29,678
the JpaTransactionManager later on.

1035
00:49:29,678 --> 00:49:32,279
Now one slight problem is you'll notice

1036
00:49:32,279 --> 00:49:35,606
there are two
HibernateTransactionManagers.

1037
00:49:35,606 --> 00:49:38,693
You can probably guess
why that's the case.

1038
00:49:38,693 --> 00:49:40,523
If I look at the first of them,

1039
00:49:40,523 --> 00:49:43,364
that's the one from
the Hibernate 3 package

1040
00:49:43,364 --> 00:49:44,705
and the other one, of course,

1041
00:49:44,705 --> 00:49:47,390
is from the Hibernate 4 package.

1042
00:49:47,390 --> 00:49:49,924
So we're just going to
need this package name

1043
00:49:49,924 --> 00:49:53,036
and I'm going to replace the
existing transaction manager

1044
00:49:53,036 --> 00:49:55,815
with this new package name

1045
00:49:55,815 --> 00:49:59,452
and the class name is
HibernateTransactionManager.

1046
00:49:59,452 --> 00:50:03,648
Just take one property and
that's the session manager.

1047
00:50:03,648 --> 00:50:07,264
But because we've got autowire
byType on there already,

1048
00:50:07,264 --> 00:50:10,861
that will pick up our sessionFactory

1049
00:50:10,861 --> 00:50:12,592
that we've defined here.

1050
00:50:12,592 --> 00:50:14,179
So we don't need to do any further work

1051
00:50:14,179 --> 00:50:15,990
on that transaction manager.

1052
00:50:15,990 --> 00:50:18,883
And if I try to run my code again now,

1053
00:50:21,415 --> 00:50:23,148
and we have a crash again,

1054
00:50:23,148 --> 00:50:25,682
and this wasn't a deliberate error,

1055
00:50:25,682 --> 00:50:28,173
but I think it's worth keeping in.

1056
00:50:28,173 --> 00:50:30,927
It's effectively saying that the object

1057
00:50:30,927 --> 00:50:33,293
of book is not found and it really means

1058
00:50:33,293 --> 00:50:35,611
because this is a database error.

1059
00:50:35,611 --> 00:50:38,940
It really means that the table called book

1060
00:50:38,940 --> 00:50:41,438
cannot be found in database.

1061
00:50:41,438 --> 00:50:43,786
Well, I did promise you that Hibernate

1062
00:50:43,786 --> 00:50:47,049
will automatically create the tables

1063
00:50:47,049 --> 00:50:49,277
if you ask it to do so.

1064
00:50:50,507 --> 00:50:55,004
I set this property,
hbm2ddl, to be update.

1065
00:50:55,004 --> 00:50:58,023
Now that should create the tables.

1066
00:50:58,023 --> 00:51:01,220
Well, all it is, I didn't
read my own caption.

1067
00:51:01,220 --> 00:51:02,780
If we look back at the caption,

1068
00:51:02,780 --> 00:51:04,680
the property is actually

1069
00:51:04,680 --> 00:51:08,240
hbm2ddl.auto.

1070
00:51:08,240 --> 00:51:10,023
I've missed the .auto,

1071
00:51:10,023 --> 00:51:11,851
which I can, of course, easily add in,

1072
00:51:11,851 --> 00:51:13,944
but I thought that was
worth leaving on the course,

1073
00:51:13,944 --> 00:51:16,113
because if you do see any problems

1074
00:51:16,113 --> 00:51:18,676
with the database schema
and you expected it

1075
00:51:18,676 --> 00:51:21,123
to be generated, then often times

1076
00:51:21,123 --> 00:51:23,858
the course will be just
because you've not set

1077
00:51:23,858 --> 00:51:26,105
the property up correctly.

1078
00:51:26,105 --> 00:51:28,177
Oh, let's try again.

1079
00:51:30,009 --> 00:51:31,896
It's very common to have lots of errors

1080
00:51:31,896 --> 00:51:35,013
when you're running a Hibernate
app for the first time.

1081
00:51:37,827 --> 00:51:41,004
Excellent, the first run
without any red text.

1082
00:51:41,004 --> 00:51:43,050
Now I've got quite a lot
of logging going on here

1083
00:51:43,050 --> 00:51:44,861
because I've still got my performance

1084
00:51:44,861 --> 00:51:46,881
timing advice going on.

1085
00:51:46,881 --> 00:51:48,527
But the key things to look at are

1086
00:51:48,527 --> 00:51:51,544
that we can see an insert statement there.

1087
00:51:51,544 --> 00:51:54,016
We can see a select statement here,

1088
00:51:54,016 --> 00:51:55,742
which must be when we're getting

1089
00:51:55,742 --> 00:51:57,921
the entire catalogue, and at present,

1090
00:51:57,921 --> 00:51:59,837
we only have one book in the system,

1091
00:51:59,837 --> 00:52:03,326
Java Programming by Josh Bloch,

1092
00:52:03,326 --> 00:52:06,884
which is great and it's worth checking

1093
00:52:06,884 --> 00:52:08,652
with a Refresh.

1094
00:52:09,852 --> 00:52:12,354
Have a little look inside the database

1095
00:52:13,587 --> 00:52:15,091
and that's great.

1096
00:52:15,091 --> 00:52:18,039
The book, Java Programming,
is right there.

1097
00:52:18,039 --> 00:52:19,773
So let's try a few other operations

1098
00:52:19,773 --> 00:52:22,820
just to make sure everything's okay.

1099
00:52:22,820 --> 00:52:26,115
Instead of the getEntireCatalogue,

1100
00:52:26,115 --> 00:52:29,410
I'm going to try the

1101
00:52:29,410 --> 00:52:32,285
getAllBooksByAuthor method,

1102
00:52:32,285 --> 00:52:36,231
and I'm going to look for
the author called Josh Bloch.

1103
00:52:36,231 --> 00:52:37,918
Now remember that this line of code here

1104
00:52:37,918 --> 00:52:41,240
is going to add another
book to our existing books.

1105
00:52:41,240 --> 00:52:44,059
So let's make this be
a difference of that.

1106
00:52:44,059 --> 00:52:48,208
This one can be Gary Cornell.

1107
00:52:48,208 --> 00:52:50,196
So we're going to expect one result

1108
00:52:50,196 --> 00:52:52,884
from this getAllBooksByAuthor.

1109
00:52:54,494 --> 00:52:56,195
Yep, that's good.

1110
00:52:56,195 --> 00:52:58,344
Now I could go ahead and
try the other methods

1111
00:52:58,344 --> 00:52:59,812
in this service, but the thing I wanted

1112
00:52:59,812 --> 00:53:01,377
to achieve from this session was

1113
00:53:01,377 --> 00:53:04,995
to show you how Hibernate
integrates with Spring.

1114
00:53:04,995 --> 00:53:06,778
I'm sorry that we can't
show you everything

1115
00:53:06,778 --> 00:53:08,658
about Hibernate, but that's why we have

1116
00:53:08,658 --> 00:53:12,204
a 20-plus hour course
available on Hibernate.

1117
00:53:12,204 --> 00:53:14,232
It's a massive subject.

1118
00:53:14,232 --> 00:53:15,505
But the key things to take away

1119
00:53:15,505 --> 00:53:16,944
from the work we've done here is

1120
00:53:16,944 --> 00:53:21,267
that our resulting DAO is relatively clean

1121
00:53:21,267 --> 00:53:23,298
and straightforward or at least as long

1122
00:53:23,298 --> 00:53:26,604
as you understand the
Hibernate aspects of it.

1123
00:53:26,604 --> 00:53:29,155
We didn't have to write any SQL

1124
00:53:29,155 --> 00:53:30,471
and we didn't have to worry

1125
00:53:30,471 --> 00:53:34,232
about converting rows into objects.

1126
00:53:34,232 --> 00:53:37,214
Now we did have to do a
little bit of configuration,

1127
00:53:37,214 --> 00:53:40,108
but this configuration is a one-shot job

1128
00:53:40,108 --> 00:53:42,602
and applies to the entire system.

1129
00:53:42,602 --> 00:53:44,540
And really all we've done with configuring

1130
00:53:44,540 --> 00:53:47,779
this session factory is we have replaced,

1131
00:53:47,779 --> 00:53:49,689
if I go back to earlier project

1132
00:53:49,689 --> 00:53:52,574
where we were running
Hibernate standalone,

1133
00:53:52,574 --> 00:53:57,038
we had to have a hibernate.cfg.xml file,

1134
00:53:57,038 --> 00:53:58,923
which contain details of the database,

1135
00:53:58,923 --> 00:54:01,684
URL, username and password,

1136
00:54:01,684 --> 00:54:05,223
and any properties that we
have as part of Hibernate.

1137
00:54:05,223 --> 00:54:07,972
We don't need that on a Spring project,

1138
00:54:07,972 --> 00:54:11,501
because all of that's handled
in the application.xml

1139
00:54:11,501 --> 00:54:15,647
and that's all that we
really have in there.

1140
00:54:15,647 --> 00:54:18,948
So in this chapter, just a
quick overview of Hibernate,

1141
00:54:18,948 --> 00:54:22,023
and I hope I've given you
at least the flavor of it.

1142
00:54:22,023 --> 00:54:25,349
It is quite complicated but powerful.

1143
00:54:25,349 --> 00:54:27,236
We've used the Hibernate template,

1144
00:54:27,236 --> 00:54:28,951
which is a helper class,

1145
00:54:28,951 --> 00:54:32,229
to make Hibernate operations easy to call.

1146
00:54:32,229 --> 00:54:35,201
I have to mention there
is another way of working,

1147
00:54:35,201 --> 00:54:37,702
which is to inject the session factory

1148
00:54:37,702 --> 00:54:39,809
straight into the DAO.

1149
00:54:39,809 --> 00:54:41,839
But we're going to do
something very similar

1150
00:54:41,839 --> 00:54:44,474
to that in the next chapter.

1151
00:54:44,474 --> 00:54:47,195
The Hibernate template
needs a bit of wiring,

1152
00:54:47,195 --> 00:54:50,014
but once it's injected into the DAO,

1153
00:54:50,014 --> 00:54:51,960
it's pretty easy to use,

1154
00:54:51,960 --> 00:54:55,128
as long as you already
understand Hibernate.

1155
00:54:55,128 --> 00:54:58,507
Well, the next chapter
covers a very similar topic,

1156
00:54:58,507 --> 00:55:00,685
this time, JPA.

1157
00:55:00,685 --> 00:55:03,698
Although you're going
to see that in Spring 4,

1158
00:55:03,698 --> 00:55:06,792
we can't use a template for that.

1159
00:55:06,792 --> 00:55:08,888
So there will be some differences.

1160
00:55:08,888 --> 00:55:12,852
(lively music)

1
00:00:00,063 --> 00:00:03,480
(jazzy electronic music)

2
00:00:09,893 --> 00:00:12,513
- [Voiceover] Welcome back to chapter 25,

3
00:00:12,513 --> 00:00:15,346
and this time it's Spring and JPA.

4
00:00:16,374 --> 00:00:19,461
JPA is very similar to Hibernate,

5
00:00:19,461 --> 00:00:21,565
so similar in fact that it's sometimes

6
00:00:21,565 --> 00:00:24,263
hard to tell them apart.

7
00:00:24,263 --> 00:00:25,596
If you're new to JPA,

8
00:00:25,596 --> 00:00:28,867
the first seven minutes
or so of this chapter

9
00:00:28,867 --> 00:00:32,534
will be spent on an
overview of what JPA is.

10
00:00:33,539 --> 00:00:38,093
After that, I need to
explain that the JpaTemplate,

11
00:00:38,093 --> 00:00:41,197
which you might have expected to be used,

12
00:00:41,197 --> 00:00:44,376
is not present in Spring anymore.

13
00:00:44,376 --> 00:00:46,723
We covered it on the first
edition of the course,

14
00:00:46,723 --> 00:00:48,223
but now it's gone.

15
00:00:49,165 --> 00:00:50,925
I'll try to explain why

16
00:00:50,925 --> 00:00:54,179
and then I'll show you
the replacement for it,

17
00:00:54,179 --> 00:00:58,262
which is an annotation
called PersistenceContext.

18
00:01:00,529 --> 00:01:03,833
Now we've seen now how
to integrate Hibernate

19
00:01:03,833 --> 00:01:06,105
into a Spring project.

20
00:01:06,105 --> 00:01:07,662
The classic way of doing that

21
00:01:07,662 --> 00:01:10,412
was to use the HibernateTemplate.

22
00:01:11,395 --> 00:01:12,996
Well, a few years after Hiberate,

23
00:01:12,996 --> 00:01:16,579
came along another framework called JPA,

24
00:01:16,579 --> 00:01:20,803
which stands for the Java Persistence API.

25
00:01:20,803 --> 00:01:23,662
Now it is a very long story.

26
00:01:23,662 --> 00:01:26,246
We do expand on this in
our Hibernate course,

27
00:01:26,246 --> 00:01:30,413
but JPA is really just a
standardized form of Hibernate.

28
00:01:33,007 --> 00:01:35,098
That's to put it very simply.

29
00:01:35,098 --> 00:01:38,949
Hibernate is open source
but it is kind of managed

30
00:01:38,949 --> 00:01:41,711
by a company called JBoss,

31
00:01:41,711 --> 00:01:45,660
whereas JPA is an official Java standard

32
00:01:45,660 --> 00:01:48,081
and it's governed by a JSR.

33
00:01:48,081 --> 00:01:50,289
That's the process that Java uses

34
00:01:50,289 --> 00:01:53,532
to standardize its libraries.

35
00:01:53,532 --> 00:01:57,063
So anybody, an individual, a company,

36
00:01:57,063 --> 00:01:59,036
or an open source project

37
00:01:59,036 --> 00:02:03,772
can produce their own working
implementations of JPA.

38
00:02:03,772 --> 00:02:07,334
Now lots of projects
like being able to work

39
00:02:07,334 --> 00:02:09,670
against official standards,

40
00:02:09,670 --> 00:02:13,837
so some projects prefer to
use JPA instead of Hibernate.

41
00:02:15,569 --> 00:02:18,982
The confusing thing though is that JPA

42
00:02:18,982 --> 00:02:22,214
is really similar to Hibernate.

43
00:02:22,214 --> 00:02:24,955
The reason for that is
really that the people

44
00:02:24,955 --> 00:02:28,785
who were on the committee
that produced JPA

45
00:02:28,785 --> 00:02:33,702
were some of the same people
who had created Hibernate.

46
00:02:33,702 --> 00:02:37,073
So in terms of its
architecture, its structure,

47
00:02:37,073 --> 00:02:40,998
the way it works, the whole
thought process behind JPA,

48
00:02:40,998 --> 00:02:44,572
it's very, very similar to Hibernate.

49
00:02:44,572 --> 00:02:46,459
As a demonstration,
remember that we've got

50
00:02:46,459 --> 00:02:49,841
this side project called Hello Hibernate.

51
00:02:49,841 --> 00:02:52,742
We won't be using it
again after this chapter,

52
00:02:52,742 --> 00:02:54,491
but I've just written this to show you

53
00:02:54,491 --> 00:02:57,991
the mechanisms that JPA and Hibernate use.

54
00:02:58,950 --> 00:03:02,683
So in previous chapters we
saw the Hibernate client

55
00:03:02,683 --> 00:03:05,009
and there was a lot of boilerplate code.

56
00:03:05,009 --> 00:03:06,587
There were two static methods

57
00:03:06,587 --> 00:03:09,702
that I didn't even want to look at.

58
00:03:09,702 --> 00:03:12,806
But you'll remember that in
order to work with an object,

59
00:03:12,806 --> 00:03:16,423
we had to get this object
called SessionFactory,

60
00:03:16,423 --> 00:03:19,848
and from the SessionFactory
we obtained sessions.

61
00:03:19,848 --> 00:03:21,963
It was these sessions that enabled us

62
00:03:21,963 --> 00:03:23,840
to work with Hibernate.

63
00:03:23,840 --> 00:03:28,556
Well, in a separate client
the file called JPAClient,

64
00:03:28,556 --> 00:03:32,723
I've rewritten that code but
this time using the JPA API.

65
00:03:34,733 --> 00:03:36,962
I think the first thing
that jumps out at me

66
00:03:36,962 --> 00:03:38,402
is there is less code in here.

67
00:03:38,402 --> 00:03:41,772
We don't need those
two big static methods.

68
00:03:41,772 --> 00:03:45,954
That's just because JPA
has a bootstrap mechanism,

69
00:03:45,954 --> 00:03:48,812
which is this first line of code here.

70
00:03:48,812 --> 00:03:50,893
Once we've gone through that,

71
00:03:50,893 --> 00:03:54,893
we have this object called
EntityManagerFactory,

72
00:03:56,254 --> 00:04:00,581
which is identical in
structure and operation

73
00:04:00,581 --> 00:04:03,323
to the previous Hibernate version

74
00:04:03,323 --> 00:04:05,638
where we had a SessionFactory.

75
00:04:05,638 --> 00:04:10,267
Then we obtain this object
called an EntityManager.

76
00:04:10,267 --> 00:04:13,267
Well, that is identical in operation

77
00:04:14,960 --> 00:04:17,043
to the Hibernate Session.

78
00:04:19,184 --> 00:04:20,642
So it's going to be the story

79
00:04:20,642 --> 00:04:22,861
for the whole of the rest of this code.

80
00:04:22,861 --> 00:04:25,336
It works in exactly the same way.

81
00:04:25,336 --> 00:04:27,405
It's just that the
classes that you work with

82
00:04:27,405 --> 00:04:29,336
have been renamed.

83
00:04:29,336 --> 00:04:32,163
So once we have this EntityManager object,

84
00:04:32,163 --> 00:04:35,151
we have transaction management
built into here as well,

85
00:04:35,151 --> 00:04:36,186
which as you know now,

86
00:04:36,186 --> 00:04:39,302
Spring is going to be able
to manage automatically.

87
00:04:39,302 --> 00:04:43,024
Well, when we want to, for
example, create a newBook,

88
00:04:43,024 --> 00:04:46,460
we just pass that Book the EntityManager.

89
00:04:46,460 --> 00:04:48,082
Instead of calling save,

90
00:04:48,082 --> 00:04:50,033
which is what we did in classic Hibernate,

91
00:04:50,033 --> 00:04:53,244
we now call the method called persist,

92
00:04:53,244 --> 00:04:57,411
but again it's the same
method, it does the same thing.

93
00:04:58,289 --> 00:05:00,552
Exactly the same as in Hibernate,

94
00:05:00,552 --> 00:05:02,450
if I make a change to an object,

95
00:05:02,450 --> 00:05:04,872
which has been saved in the database,

96
00:05:04,872 --> 00:05:08,309
then those changes will
be automatically picked up

97
00:05:08,309 --> 00:05:10,677
when we commit the transaction.

98
00:05:10,677 --> 00:05:12,287
So I want to check that runs.

99
00:05:12,287 --> 00:05:14,463
I can't remember the
state of the database,

100
00:05:14,463 --> 00:05:17,620
so I'm going to delete the database.

101
00:05:17,620 --> 00:05:20,181
I'm going to start completely at fresh.

102
00:05:20,181 --> 00:05:21,876
Oh, before I run this I should mention

103
00:05:21,876 --> 00:05:25,709
that in JPA we also have
a configuration file.

104
00:05:26,655 --> 00:05:27,935
Remember for classic Hibernate

105
00:05:27,935 --> 00:05:30,602
it was called hibernate.cfg.xml?

106
00:05:31,647 --> 00:05:36,575
It just contained details such
as the name of the database,

107
00:05:36,575 --> 00:05:39,338
the username and password and so on.

108
00:05:39,338 --> 00:05:42,495
Well, that file isn't used in JPA.

109
00:05:42,495 --> 00:05:46,932
Instead a file called
persistence.xml is used,

110
00:05:46,932 --> 00:05:49,591
but notice it's in a subfolder,

111
00:05:49,591 --> 00:05:52,485
and that folder's called META-INF.

112
00:05:52,485 --> 00:05:54,064
It's just one of the rules

113
00:05:54,064 --> 00:05:57,061
that the committee decided to apply.

114
00:05:57,061 --> 00:05:59,781
It's a bit awkward but we
just have to follow it.

115
00:05:59,781 --> 00:06:03,909
But the contents of
persistence.xml are very similar

116
00:06:03,909 --> 00:06:08,076
to the contents of the former
hibernate.cfg.xml file,

117
00:06:09,552 --> 00:06:13,147
the URL of the database, the
username and the password

118
00:06:13,147 --> 00:06:15,941
and a few other properties.

119
00:06:15,941 --> 00:06:18,364
So let's just check that that runs then,

120
00:06:18,364 --> 00:06:20,550
so we have a completely clean database

121
00:06:20,550 --> 00:06:22,801
or at least Hibernate's going to create

122
00:06:22,801 --> 00:06:24,551
a brand new database.

123
00:06:26,726 --> 00:06:31,229
As in the previous chapter we
have an insert and an update.

124
00:06:31,229 --> 00:06:34,821
Oh I should mention here,
I forgot to say this.

125
00:06:34,821 --> 00:06:38,849
Notice that the logging
is mentioning Hibernate,

126
00:06:38,849 --> 00:06:42,743
and that's because Hibernate is itself

127
00:06:42,743 --> 00:06:45,601
an implementation of JPA.

128
00:06:45,601 --> 00:06:49,388
Now it's quite confusing this
that you can be using JPA,

129
00:06:49,388 --> 00:06:53,708
but also be using
Hibernate at the same time.

130
00:06:53,708 --> 00:06:55,404
The difference is though
that when we're working

131
00:06:55,404 --> 00:06:58,071
with the JPA API as we are here,

132
00:06:58,999 --> 00:07:02,412
if you wanted to for some
reason in the future,

133
00:07:02,412 --> 00:07:04,780
just by changing the JAR files,

134
00:07:04,780 --> 00:07:09,057
you could get a different
implementation of JPA.

135
00:07:09,057 --> 00:07:12,887
There are implementations out
there such as EclipseLink.

136
00:07:12,887 --> 00:07:16,023
EclipseLink is probably
the leading competitor

137
00:07:16,023 --> 00:07:18,156
against Hibernate.

138
00:07:18,156 --> 00:07:20,876
But yes it is quite
confusing that Hibernate

139
00:07:20,876 --> 00:07:24,311
is almost two frameworks in one.

140
00:07:24,311 --> 00:07:27,447
It's both the so-called classic Hibernate

141
00:07:27,447 --> 00:07:30,947
and also the more modern standardized JPA.

142
00:07:32,225 --> 00:07:34,338
Okay, so as in the Hibernate chapter,

143
00:07:34,338 --> 00:07:35,881
I'm going to show you now how to

144
00:07:35,881 --> 00:07:38,964
integrate a JPA approach with Spring.

145
00:07:40,745 --> 00:07:44,948
So I'll close down the
Hello Hibernate project,

146
00:07:44,948 --> 00:07:47,668
and we'll go back to our BookStore.

147
00:07:47,668 --> 00:07:49,343
So I'll be following the usual approach.

148
00:07:49,343 --> 00:07:53,728
I'm going to create a new
implementation of the BookDao,

149
00:07:53,728 --> 00:07:56,213
but this time using JPA.

150
00:07:56,213 --> 00:07:58,742
Before I do that though
I want to look back

151
00:07:58,742 --> 00:08:01,462
on our previous work on Hibernate.

152
00:08:01,462 --> 00:08:03,712
The key thing that you'll remember

153
00:08:03,712 --> 00:08:05,728
is that to integrate with Hibernate,

154
00:08:05,728 --> 00:08:09,419
we use this class called
HibernateTemplate,

155
00:08:09,419 --> 00:08:12,907
sort of a helper class provided by Spring.

156
00:08:12,907 --> 00:08:14,443
It contained all of the methods

157
00:08:14,443 --> 00:08:17,600
that you expect to see
in a Hibernate session,

158
00:08:17,600 --> 00:08:20,683
but it hid away the housekeeping work,

159
00:08:20,683 --> 00:08:24,246
in particular, opening
and closing the session.

160
00:08:24,246 --> 00:08:28,534
While you might expect
that when working with JPA,

161
00:08:28,534 --> 00:08:30,005
we're going to do the same thing.

162
00:08:30,005 --> 00:08:32,838
We're going to have a JpaTemplate.

163
00:08:34,083 --> 00:08:37,309
Well, until recently
that was absolutely true.

164
00:08:37,309 --> 00:08:41,425
There was indeed a
class called JpaTemplate

165
00:08:41,425 --> 00:08:43,420
that you set up in exactly the same way

166
00:08:43,420 --> 00:08:44,998
as the HibernateTemplate,

167
00:08:44,998 --> 00:08:48,765
and then you proceeded
to use it in the same way

168
00:08:48,765 --> 00:08:50,834
as the HibernateTemplate.

169
00:08:50,834 --> 00:08:55,661
The problem is however that
the class was deprecated

170
00:08:55,661 --> 00:08:58,490
back in Spring version 3.

171
00:08:58,490 --> 00:09:02,658
Deprecate means that
they marked it as a class

172
00:09:02,658 --> 00:09:05,201
that you shouldn't use anymore.

173
00:09:05,201 --> 00:09:09,368
To my surprise in Spring 4
it has indeed been removed.

174
00:09:11,715 --> 00:09:13,753
I'll just check that.

175
00:09:13,753 --> 00:09:15,918
I mean I wouldn't use
it this class anyway.

176
00:09:15,918 --> 00:09:19,751
But if I were to just
to reference it in here,

177
00:09:20,675 --> 00:09:23,258
and then if I try to import it,

178
00:09:25,841 --> 00:09:29,797
I think actually it was a
lowercase p and lowercase a.

179
00:09:29,797 --> 00:09:33,964
But yeah, I'm getting no
suggestions for that class.

180
00:09:36,219 --> 00:09:40,533
It doesn't exist anymore
in the Spring Framework.

181
00:09:40,533 --> 00:09:44,700
Now the reasons for this
is, well, it's a long story.

182
00:09:45,789 --> 00:09:47,645
Basically the people behind JPA

183
00:09:47,645 --> 00:09:50,707
thought that the JpaTemplate
wasn't a good class

184
00:09:50,707 --> 00:09:54,113
and it wasn't a good idea to use it.

185
00:09:54,113 --> 00:09:56,799
Feel free to have a search yourself

186
00:09:56,799 --> 00:09:59,541
if you want to see any
of the details of that.

187
00:09:59,541 --> 00:10:02,656
I've just done a random Google off-camera,

188
00:10:02,656 --> 00:10:04,307
and I found this rather old thread now

189
00:10:04,307 --> 00:10:05,807
from back in 2007.

190
00:10:07,308 --> 00:10:10,465
But the post you can see
here comes from Gavin King

191
00:10:10,465 --> 00:10:13,857
who is, in fact, the creator of Hibernate

192
00:10:13,857 --> 00:10:18,024
and probably the most powerful
person on the JPA committee.

193
00:10:19,405 --> 00:10:22,055
I know I'm going to get
complaints for doing this,

194
00:10:22,055 --> 00:10:26,207
and Gavin King in particular
will probably not be happy

195
00:10:26,207 --> 00:10:28,756
at me dragging this up,

196
00:10:28,756 --> 00:10:30,921
but I just wanted to point out

197
00:10:30,921 --> 00:10:34,588
that he explicitly
called this a public spat

198
00:10:35,465 --> 00:10:38,008
between the Hibernate and Spring teams.

199
00:10:38,008 --> 00:10:39,896
It was Gavin King's opinion

200
00:10:39,896 --> 00:10:43,146
that the JpaTemplate was not necessary.

201
00:10:45,443 --> 00:10:49,026
So the Spring team
decided to reflect that,

202
00:10:50,018 --> 00:10:52,698
and that's why they've
gone so far as removing it

203
00:10:52,698 --> 00:10:54,309
from the Spring Framework.

204
00:10:54,309 --> 00:10:57,605
It's a very rare thing
for classes to be removed

205
00:10:57,605 --> 00:10:59,781
from the Spring Framework.

206
00:10:59,781 --> 00:11:03,248
I can't really think of
any other examples really.

207
00:11:03,248 --> 00:11:06,309
But I personally think it's a real shame

208
00:11:06,309 --> 00:11:09,256
because when we had the JpaTemplate,

209
00:11:09,256 --> 00:11:13,012
it made everything
symmetrical and well balanced.

210
00:11:13,012 --> 00:11:17,179
If you wanted to simplify
JDBC, you used JdbcTemplate.

211
00:11:18,156 --> 00:11:20,025
If you wanted to simplify Hibernate,

212
00:11:20,025 --> 00:11:22,702
then you used the HibernateTemplate.

213
00:11:22,702 --> 00:11:26,859
If you want to simplify JPA,
you used the JpaTemplate.

214
00:11:26,859 --> 00:11:30,140
But as you know now, that's not available.

215
00:11:30,140 --> 00:11:33,766
Spring introduced a new way of
doing this back in Spring 3,

216
00:11:33,766 --> 00:11:36,017
and now it's the only option available

217
00:11:36,017 --> 00:11:38,546
if you want to work with JPA.

218
00:11:38,546 --> 00:11:41,063
So to show you this new
approach, I'm going to go in

219
00:11:41,063 --> 00:11:44,917
and create a new
implementation of BookDao,

220
00:11:44,917 --> 00:11:46,917
but this time using JPA.

221
00:11:47,978 --> 00:11:52,061
We'll call this one the
BookDaoJpaImplementation.

222
00:11:54,799 --> 00:11:58,632
The interface will be,
of course, the BookDao,

223
00:11:59,502 --> 00:12:03,152
and make sure Inherited
abstract methods is clicked on,

224
00:12:03,152 --> 00:12:05,381
so that we get a skeleton implementation

225
00:12:05,381 --> 00:12:07,141
of each of the methods.

226
00:12:07,141 --> 00:12:08,976
So recall then that with Hibernate

227
00:12:08,976 --> 00:12:11,258
we used a HibernateTemplate.

228
00:12:11,258 --> 00:12:13,370
The dramatic change with JPA

229
00:12:13,370 --> 00:12:16,711
is that we can work
with the EntityManager.

230
00:12:16,711 --> 00:12:21,032
Remember this is JPA's
equivalent of the Session.

231
00:12:21,032 --> 00:12:25,857
We can work with that
object directly in the DAO.

232
00:12:25,857 --> 00:12:28,724
We don't need any kind of template.

233
00:12:28,724 --> 00:12:31,722
If I import that we will just verify

234
00:12:31,722 --> 00:12:34,026
that this doesn't come from Spring,

235
00:12:34,026 --> 00:12:37,109
it comes from the JPA library itself.

236
00:12:38,346 --> 00:12:40,022
Now to make this work,

237
00:12:40,022 --> 00:12:42,390
we're going to have to do
a dependency injection,

238
00:12:42,390 --> 00:12:45,547
but it's a very easy dependency injection.

239
00:12:45,547 --> 00:12:47,958
We annotate the EntityManager

240
00:12:47,958 --> 00:12:51,458
with annotation called PersistenceContext.

241
00:12:52,993 --> 00:12:56,736
Now that is quite the jargony term.

242
00:12:56,736 --> 00:12:59,660
If I import it I want to point out

243
00:12:59,660 --> 00:13:02,993
that it also comes from the JPA library.

244
00:13:04,301 --> 00:13:06,947
Now actually PersistenceContext comes from

245
00:13:06,947 --> 00:13:08,947
the full JavaEE library.

246
00:13:10,083 --> 00:13:14,051
It is used by EJBs and
what Spring is doing here

247
00:13:14,051 --> 00:13:18,218
is they're just borrowing
industry standard annotations.

248
00:13:19,076 --> 00:13:21,977
So it's not the nicest
annotation in the world,

249
00:13:21,977 --> 00:13:24,282
but it's very powerful.

250
00:13:24,282 --> 00:13:26,533
This means that without any further work,

251
00:13:26,533 --> 00:13:28,304
we can just dive straight in

252
00:13:28,304 --> 00:13:31,397
and start using that EntityManager.

253
00:13:31,397 --> 00:13:34,727
Now I'm going to do a little
bit of a technical point.

254
00:13:34,727 --> 00:13:37,767
If you're just on this
session because you're curious

255
00:13:37,767 --> 00:13:40,348
about JPA and you've never used it before,

256
00:13:40,348 --> 00:13:43,006
then this might be a little
bit complicated for you.

257
00:13:43,006 --> 00:13:45,491
But it is a point that
anybody who has used

258
00:13:45,491 --> 00:13:49,299
Hibernate and JPA will want clearing up.

259
00:13:49,299 --> 00:13:53,448
Bear in mind that by
default all of the objects

260
00:13:53,448 --> 00:13:55,987
that we work with in
Spring are singletons,

261
00:13:55,987 --> 00:14:00,019
so we're going to have a
single instance of the BookDao.

262
00:14:00,019 --> 00:14:03,325
However, Spring is
going to be very careful

263
00:14:03,325 --> 00:14:06,623
to ensure that there is
a separate EntityManager

264
00:14:06,623 --> 00:14:10,540
for every single thread
that uses this program.

265
00:14:12,052 --> 00:14:15,487
That means that if we've
got, say, a hundred users

266
00:14:15,487 --> 00:14:18,319
all accessing the system at the same time,

267
00:14:18,319 --> 00:14:22,069
they will all be calling
the same DAO object,

268
00:14:23,085 --> 00:14:26,701
but they will all have
their own private copy

269
00:14:26,701 --> 00:14:28,985
of the EntityManager.

270
00:14:28,985 --> 00:14:30,606
Now that's a crucial point,

271
00:14:30,606 --> 00:14:33,881
it's really important
that that's the case.

272
00:14:33,881 --> 00:14:37,690
The EntityManager by design
should never be shared

273
00:14:37,690 --> 00:14:39,190
by multiple users.

274
00:14:40,197 --> 00:14:43,346
But that's okay because
Spring have dealt with that

275
00:14:43,346 --> 00:14:45,831
and it is completely safe to use

276
00:14:45,831 --> 00:14:48,754
in a multi-threaded application.

277
00:14:48,754 --> 00:14:52,658
Now I'm sorry if that was a
little bit too deep for now.

278
00:14:52,658 --> 00:14:55,143
If you're just exploring
JPA for the first time,

279
00:14:55,143 --> 00:14:57,298
then we can get now get working.

280
00:14:57,298 --> 00:15:01,051
I'll jump to the easiest
method, the create method.

281
00:15:01,051 --> 00:15:04,833
The wonderful thing is we
don't have to learn a new API.

282
00:15:04,833 --> 00:15:06,830
If you know how the EntityManager works,

283
00:15:06,830 --> 00:15:10,285
we can just call the
regular persist method,

284
00:15:10,285 --> 00:15:13,868
passing in the newBook,
which is wonderful.

285
00:15:15,092 --> 00:15:17,598
Spring transparently behind the scenes

286
00:15:17,598 --> 00:15:19,251
is going to deal with the details

287
00:15:19,251 --> 00:15:22,835
of opening and closing that EntityManager.

288
00:15:22,835 --> 00:15:24,179
So now we can go ahead

289
00:15:24,179 --> 00:15:27,358
and do the rest of the implementations.

290
00:15:27,358 --> 00:15:31,262
The allBooks, we're going
to want to return an em.,

291
00:15:31,262 --> 00:15:35,012
and in JPA the method
we want is createQuery.

292
00:15:36,371 --> 00:15:41,078
Now the query language in JPA
is a little bit different.

293
00:15:41,078 --> 00:15:43,787
You're gonna have to be a
little bit more explicit.

294
00:15:43,787 --> 00:15:47,370
I have to do select
book from Book as book.

295
00:15:50,144 --> 00:15:51,861
I know that sounds a little odd,

296
00:15:51,861 --> 00:15:55,136
but all of those elements
are required in this query,

297
00:15:55,136 --> 00:15:58,742
but that should find all
of the books in the system.

298
00:15:58,742 --> 00:15:59,948
That's not quite enough.

299
00:15:59,948 --> 00:16:04,115
You then have to call a further
method called getResultList.

300
00:16:06,614 --> 00:16:07,862
You will get a warning here.

301
00:16:07,862 --> 00:16:09,633
It's similar to the
warning from Hibernate,

302
00:16:09,633 --> 00:16:11,809
and it's just warning you to check

303
00:16:11,809 --> 00:16:15,217
that you really do have
the correct types here.

304
00:16:15,217 --> 00:16:17,499
Does the type of object
that you're expecting back

305
00:16:17,499 --> 00:16:20,518
from this query match the type

306
00:16:20,518 --> 00:16:22,299
that you have in your signature?

307
00:16:22,299 --> 00:16:23,761
Well, yes it does, so we don't need

308
00:16:23,761 --> 00:16:26,043
to worry about that warning.

309
00:16:26,043 --> 00:16:27,152
This next method is the one

310
00:16:27,152 --> 00:16:30,589
that we're expecting to
return a single book,

311
00:16:30,589 --> 00:16:34,756
so we can do the same query
or a similar query rather.

312
00:16:37,187 --> 00:16:41,623
We're going to be selecting
from Book as book,

313
00:16:41,623 --> 00:16:43,723
but this time we have a where clause.

314
00:16:43,723 --> 00:16:47,890
We have to specify the alias
here so that's book.isbn

315
00:16:49,867 --> 00:16:53,536
equals whatever value is being passed in.

316
00:16:53,536 --> 00:16:57,536
Now we need to plug in the
actual value into this query.

317
00:16:57,536 --> 00:16:59,253
That means the string that's come in here

318
00:16:59,253 --> 00:17:02,336
needs to be bound to that parameter.

319
00:17:02,336 --> 00:17:04,384
We do that by calling a further method,

320
00:17:04,384 --> 00:17:06,476
and notice we chain these methods together

321
00:17:06,476 --> 00:17:08,748
into a single statement.

322
00:17:08,748 --> 00:17:11,331
There is a setParameter method,

323
00:17:12,730 --> 00:17:16,602
and that allows me to specify
the name of the parameter,

324
00:17:16,602 --> 00:17:21,361
so this string here is
matching the phrase there.

325
00:17:21,361 --> 00:17:23,730
Then for the second argument,

326
00:17:23,730 --> 00:17:27,190
we just pass in the actual value.

327
00:17:27,190 --> 00:17:29,480
Now that just creates the query.

328
00:17:29,480 --> 00:17:30,920
Now because on this project

329
00:17:30,920 --> 00:17:33,640
we're expecting ISBNs to be unique,

330
00:17:33,640 --> 00:17:36,890
we can call the getSingleResult method.

331
00:17:38,238 --> 00:17:39,998
Now that will throw an exception

332
00:17:39,998 --> 00:17:42,612
if we get more than one
result from that query,

333
00:17:42,612 --> 00:17:45,908
so we have to be sure
that's what we really want.

334
00:17:45,908 --> 00:17:49,771
Because that's going to return
just an anonymous object,

335
00:17:49,771 --> 00:17:52,715
we are going to have to
convert it or typecast it

336
00:17:52,715 --> 00:17:54,851
back into a book.

337
00:17:54,851 --> 00:17:58,043
That was a little bit heavy
but hopefully that works.

338
00:17:58,043 --> 00:18:01,876
Then we can very quickly
do the delete method.

339
00:18:03,344 --> 00:18:06,918
Here's a good example of how
Hibernate works the same way

340
00:18:06,918 --> 00:18:09,990
but has different methods to JPA.

341
00:18:09,990 --> 00:18:13,446
In Hibernate it was called delete,

342
00:18:13,446 --> 00:18:15,613
in JPA it's called remove.

343
00:18:16,509 --> 00:18:19,966
But again, as in Hibernate,
unfortunately we do have

344
00:18:19,966 --> 00:18:23,466
to pass in a persistence object to delete,

345
00:18:24,833 --> 00:18:26,526
which means we're going
to have to first of all

346
00:18:26,526 --> 00:18:27,776
find that book.

347
00:18:28,639 --> 00:18:31,743
So I'll do that using the
em. and the equivalent

348
00:18:31,743 --> 00:18:34,869
to the get method is the find method.

349
00:18:34,869 --> 00:18:38,369
So I'm looking for Book and its Id will be

350
00:18:41,059 --> 00:18:44,164
the Id of the Book that was passed in.

351
00:18:44,164 --> 00:18:46,063
Always find that a bit awkward.

352
00:18:46,063 --> 00:18:50,230
We've got just one more to go,
not very exciting this one.

353
00:18:52,175 --> 00:18:53,755
We're going to need a list here,

354
00:18:53,755 --> 00:18:57,422
so the EntityManager
we will create a query,

355
00:18:59,313 --> 00:19:01,730
select book from Book as book

356
00:19:03,198 --> 00:19:06,615
where the book.author equals a parameter.

357
00:19:12,064 --> 00:19:16,231
We need to set that parameter,
we called it author,

358
00:19:18,424 --> 00:19:20,239
and it will be whatever was passed in.

359
00:19:20,239 --> 00:19:25,028
Then finally on that chain
we call getResultList.

360
00:19:25,028 --> 00:19:28,878
So I hope that's okay, I did
go quite quickly through that.

361
00:19:28,878 --> 00:19:31,438
I'm assuming that you know JPA already

362
00:19:31,438 --> 00:19:33,177
and the important thing here is

363
00:19:33,177 --> 00:19:36,729
that we're able to write
a DAO quite quickly.

364
00:19:36,729 --> 00:19:38,799
We can use the EntityManager directly

365
00:19:38,799 --> 00:19:41,082
without worrying about creating it,

366
00:19:41,082 --> 00:19:43,783
and once you've got that EntityManager,

367
00:19:43,783 --> 00:19:47,030
the rest of the code
should flow quite easily.

368
00:19:47,030 --> 00:19:48,979
Well, this code isn't
going to run on its own

369
00:19:48,979 --> 00:19:53,146
because as always we've got to
configure this EntityManager.

370
00:19:54,344 --> 00:19:56,392
Now we do it in a very similar way

371
00:19:56,392 --> 00:19:59,475
to how we worked in Hibernate.

372
00:19:59,475 --> 00:20:01,097
Remember when we were
working with Hibernate,

373
00:20:01,097 --> 00:20:04,702
we had to configure a SessionFactory.

374
00:20:04,702 --> 00:20:07,455
Well, we are going to have
to replace the configuration

375
00:20:07,455 --> 00:20:11,444
of the SessionFactory with
the equivalent configuration

376
00:20:11,444 --> 00:20:14,537
for an EntityManagerFactory.

377
00:20:14,537 --> 00:20:16,489
Exactly the same as before,

378
00:20:16,489 --> 00:20:19,391
it's tedious XML but a one-shot job,

379
00:20:19,391 --> 00:20:22,452
so let's have a look at that on a caption.

380
00:20:22,452 --> 00:20:24,961
Configuring an
EntityManagerFactory in Spring

381
00:20:24,961 --> 00:20:29,559
is almost the same as
configuring a SessionFactory.

382
00:20:29,559 --> 00:20:31,983
We use a Spring helper class called the,

383
00:20:31,983 --> 00:20:34,204
and here's a big mouthful for you,

384
00:20:34,204 --> 00:20:37,787
the
LocalContainerEntityManagerFactoryBean.

385
00:20:39,057 --> 00:20:41,777
One of the longer class names in Spring,

386
00:20:41,777 --> 00:20:43,079
and notice it comes from the package

387
00:20:43,079 --> 00:20:45,996
called org.springframework.orm.jpa.

388
00:20:48,327 --> 00:20:49,511
Now the properties in here

389
00:20:49,511 --> 00:20:51,741
are pretty much the
same types of properties

390
00:20:51,741 --> 00:20:55,074
as we saw when we worked with Hibernate.

391
00:20:56,256 --> 00:20:58,067
It's classic Hibernate.

392
00:20:58,067 --> 00:21:00,233
Notice for instance
there is a property here

393
00:21:00,233 --> 00:21:02,409
called dataSource which needs to point

394
00:21:02,409 --> 00:21:05,779
to your connection pool, that's easy.

395
00:21:05,779 --> 00:21:10,516
The only other required property
is the JpaVendorAdapter.

396
00:21:10,516 --> 00:21:13,281
All this is is a property that enables you

397
00:21:13,281 --> 00:21:17,142
to plug in any properties
that are specific

398
00:21:17,142 --> 00:21:19,642
to your implementation of JPA.

399
00:21:20,576 --> 00:21:24,064
For example, we know that
our implementation of JPA

400
00:21:24,064 --> 00:21:27,481
can show SQL and can generate the tables.

401
00:21:28,374 --> 00:21:31,681
So we need to tell Spring
that we want those features on

402
00:21:31,681 --> 00:21:35,848
by specifying showSql to
true and generateDdl to true.

403
00:21:37,366 --> 00:21:40,011
I always find that configuration
a little bit awkward,

404
00:21:40,011 --> 00:21:43,424
and I always have to work from
the reference manual there

405
00:21:43,424 --> 00:21:48,065
because the value for
the property is an object

406
00:21:48,065 --> 00:21:50,998
and the object needs to be from the class

407
00:21:50,998 --> 00:21:53,748
called HibernateJpaVendorAdapter.

408
00:21:55,339 --> 00:21:56,865
If you want to go deep here,

409
00:21:56,865 --> 00:22:01,241
the idea is that if you use
other implementations of JPA,

410
00:22:01,241 --> 00:22:05,446
for example, Eclipse made
an implementation of JPA,

411
00:22:05,446 --> 00:22:07,910
then you would just change
the VendorAdapter here

412
00:22:07,910 --> 00:22:11,643
and that would enable you to
specify any specific properties

413
00:22:11,643 --> 00:22:15,131
that are supported by that implementation.

414
00:22:15,131 --> 00:22:17,126
It's a bit awkward and I'd probably want

415
00:22:17,126 --> 00:22:20,690
to copy and paste this
from the reference manual.

416
00:22:20,690 --> 00:22:22,761
Now we'll go and get this
into Eclipse in a moment,

417
00:22:22,761 --> 00:22:25,385
but a few notes down here at the bottom.

418
00:22:25,385 --> 00:22:27,381
First of all, don't
forget that you will need

419
00:22:27,381 --> 00:22:29,514
to change the transaction manager.

420
00:22:29,514 --> 00:22:32,832
If you're changing your
data access approach,

421
00:22:32,832 --> 00:22:35,317
then you need a specific
transaction manager

422
00:22:35,317 --> 00:22:37,621
for the approach you're using.

423
00:22:37,621 --> 00:22:39,850
That should be easy to do though.

424
00:22:39,850 --> 00:22:43,978
Now if you're using
autowiring with annotations,

425
00:22:43,978 --> 00:22:47,414
as we are in the BookStore at the moment,

426
00:22:47,414 --> 00:22:49,868
then everything is now finished.

427
00:22:49,868 --> 00:22:53,003
The EntityManager will
be automatically created

428
00:22:53,003 --> 00:22:55,532
and injected into the DAO,

429
00:22:55,532 --> 00:22:58,604
and we don't need to
think about it anymore.

430
00:22:58,604 --> 00:23:02,870
However, if you're not using
annotations and autowiring,

431
00:23:02,870 --> 00:23:07,693
then you are going to need an
additional tag in your XML.

432
00:23:07,693 --> 00:23:10,435
It's another one of these directives.

433
00:23:10,435 --> 00:23:13,602
It's called context:annotation-config.

434
00:23:14,873 --> 00:23:17,049
That just tells Spring to look

435
00:23:17,049 --> 00:23:21,113
for that @PersistenceContext annotation.

436
00:23:21,113 --> 00:23:25,923
Without that tag in place,
PersistenceContext won't work.

437
00:23:25,923 --> 00:23:28,612
However, for this project on this video

438
00:23:28,612 --> 00:23:30,937
we're already using annotations,

439
00:23:30,937 --> 00:23:35,630
so we could put that tag in
but it would just be ignored.

440
00:23:35,630 --> 00:23:38,380
Back then to our XML wiring file.

441
00:23:39,301 --> 00:23:41,802
I'm still in this state
from the previous chapter

442
00:23:41,802 --> 00:23:45,959
where I have a Hibernate, a
classic hibernateTemplate,

443
00:23:45,959 --> 00:23:49,014
and a classic Hibernate sessionFactory.

444
00:23:49,014 --> 00:23:50,656
I'm going to remove those beans.

445
00:23:50,656 --> 00:23:52,843
I could keep them in my wiring.

446
00:23:52,843 --> 00:23:55,906
It's absolutely fine to do
that and they'd still be around

447
00:23:55,906 --> 00:23:58,306
if I wanted to reactivate them later,

448
00:23:58,306 --> 00:24:01,037
but just to keep things clean and tidy,

449
00:24:01,037 --> 00:24:02,626
I'm going to remove them.

450
00:24:02,626 --> 00:24:05,047
And similarly I have a jdbcTemplate

451
00:24:05,047 --> 00:24:08,590
from earlier in the course
which I'm going to remove

452
00:24:08,590 --> 00:24:10,957
because I'm not using it right now.

453
00:24:10,957 --> 00:24:13,187
Now I could type in what you've just seen

454
00:24:13,187 --> 00:24:14,509
on the previous caption,

455
00:24:14,509 --> 00:24:17,082
but I'm quite conscious of boring you.

456
00:24:17,082 --> 00:24:20,219
So I think this is a
particularly difficult one

457
00:24:20,219 --> 00:24:21,541
to type in correctly,

458
00:24:21,541 --> 00:24:26,342
so I've copied the code in
from my previous caption.

459
00:24:26,342 --> 00:24:28,134
I normally like to type these things in,

460
00:24:28,134 --> 00:24:31,451
but I find the JpaVendorAdapter

461
00:24:31,451 --> 00:24:35,399
having a wrapped kind of inner objects

462
00:24:35,399 --> 00:24:38,388
a little bit confusing
and awkward to type out.

463
00:24:38,388 --> 00:24:40,349
So of course you can pause the video

464
00:24:40,349 --> 00:24:41,768
and copy what you see here

465
00:24:41,768 --> 00:24:44,509
or if you prefer you can dig this code out

466
00:24:44,509 --> 00:24:47,080
from the practicals and code folder

467
00:24:47,080 --> 00:24:49,736
for this particular chapter.

468
00:24:49,736 --> 00:24:53,309
It's not complicated, it's
just a little bit tedious.

469
00:24:53,309 --> 00:24:55,603
But the great thing is once that's in,

470
00:24:55,603 --> 00:24:57,853
I don't have to now create templates

471
00:24:57,853 --> 00:25:00,872
and I don't have to do
any further injection.

472
00:25:00,872 --> 00:25:04,680
The fact that I'm using
the component scanning,

473
00:25:04,680 --> 00:25:07,369
that means I'm using annotations,

474
00:25:07,369 --> 00:25:11,536
means that Spring will
automatically use this object

475
00:25:12,820 --> 00:25:16,945
to inject EntityManagers into any classes

476
00:25:16,945 --> 00:25:21,057
that have got
@PersistenceContext in place.

477
00:25:21,057 --> 00:25:22,732
There is one further job I'll need to do

478
00:25:22,732 --> 00:25:24,428
before running this code.

479
00:25:24,428 --> 00:25:27,372
At the moment I've created this class

480
00:25:27,372 --> 00:25:30,444
but I haven't asked Spring
to make this a bean.

481
00:25:30,444 --> 00:25:33,762
So I'm going to add on
the @Repository annotation

482
00:25:33,762 --> 00:25:36,344
to the top of that class,

483
00:25:36,344 --> 00:25:39,065
and that will need to be imported.

484
00:25:39,065 --> 00:25:43,524
I need to be careful to go
back to my previous class,

485
00:25:43,524 --> 00:25:46,372
which was the Hibernate version.

486
00:25:46,372 --> 00:25:49,083
Now that currently has the
Repository annotation on.

487
00:25:49,083 --> 00:25:50,821
Well, I don't want to use that anymore,

488
00:25:50,821 --> 00:25:53,819
so I'm going to take that Repository off.

489
00:25:53,819 --> 00:25:57,986
So that's almost like I've
powered down that implementation.

490
00:25:58,896 --> 00:26:00,391
That won't be used anymore.

491
00:26:00,391 --> 00:26:03,477
Instead this DAO will be used.

492
00:26:03,477 --> 00:26:04,935
Let me just absolutely prove

493
00:26:04,935 --> 00:26:08,318
that this JPA implementation
is now in use.

494
00:26:08,318 --> 00:26:10,901
I'm going to put a line
into the create method

495
00:26:10,901 --> 00:26:13,920
because I know I'm calling that.

496
00:26:13,920 --> 00:26:16,970
I'm going to put using JPA in there

497
00:26:16,970 --> 00:26:18,826
just so we really are sure

498
00:26:18,826 --> 00:26:22,101
that our changes have taken place.

499
00:26:22,101 --> 00:26:25,909
So I do like the fact
that it's pretty simple

500
00:26:25,909 --> 00:26:28,737
to configure these PersistenceContexts.

501
00:26:28,737 --> 00:26:31,158
I do think it's a shame
that the JpaTemplate

502
00:26:31,158 --> 00:26:34,380
isn't even an option anymore.

503
00:26:34,380 --> 00:26:36,001
But enough about that.

504
00:26:36,001 --> 00:26:38,231
Let's see if this works now.

505
00:26:38,231 --> 00:26:41,064
Let's find our client application,

506
00:26:42,365 --> 00:26:44,968
and as always because I can't remember

507
00:26:44,968 --> 00:26:49,470
the state of the database,
we'll start from a clean sheet.

508
00:26:49,470 --> 00:26:51,470
So let's run the client.

509
00:26:54,665 --> 00:26:57,557
Oh, and I have an exception.

510
00:26:57,557 --> 00:26:59,530
Now I'll focus on this line here,

511
00:26:59,530 --> 00:27:02,570
"No persistence units parsed from".

512
00:27:02,570 --> 00:27:06,657
Notice it's mentioning that
file called persistence.xml.

513
00:27:06,657 --> 00:27:10,871
That's the config file that's
in the META-INF folder.

514
00:27:10,871 --> 00:27:15,863
If you remember back to our
earlier Hello Hibernate project,

515
00:27:15,863 --> 00:27:17,997
that was the configuration
file that contained

516
00:27:17,997 --> 00:27:21,869
all the details of the driver
class, the URL, and so on.

517
00:27:21,869 --> 00:27:24,429
Well, we certainly don't
need any of the information

518
00:27:24,429 --> 00:27:27,287
in that XML file anymore
because all of that

519
00:27:27,287 --> 00:27:29,485
is being handled by Spring.

520
00:27:29,485 --> 00:27:33,652
But the rule is in the JPA that
that file must still exist,

521
00:27:34,554 --> 00:27:38,304
otherwise as you can
see the program crashes.

522
00:27:39,323 --> 00:27:43,269
So what I suggest we do
here is we grab that folder,

523
00:27:43,269 --> 00:27:47,793
and I'm going to copy it
across to the BookStore,

524
00:27:47,793 --> 00:27:50,228
and it needs to be in the src folder.

525
00:27:50,228 --> 00:27:52,137
Now I'm holding down the Control key here

526
00:27:52,137 --> 00:27:56,267
and it will be the Command
key on the Macintosh.

527
00:27:56,267 --> 00:28:00,725
Notice the icon there
has turned into a plus.

528
00:28:00,725 --> 00:28:03,306
So I don't want to move
it, I want to copy it.

529
00:28:03,306 --> 00:28:06,891
So although these
properties aren't being used

530
00:28:06,891 --> 00:28:10,444
by our project, we still
need the file there.

531
00:28:10,444 --> 00:28:12,844
Well, we want to remove the properties,

532
00:28:12,844 --> 00:28:15,194
otherwise things will foul up.

533
00:28:15,194 --> 00:28:19,361
So it's the entire properties
tag that needs to be removed.

534
00:28:20,367 --> 00:28:23,814
We still leave the
persistence-unit tag in place,

535
00:28:23,814 --> 00:28:25,767
but there's nothing in there.

536
00:28:25,767 --> 00:28:27,410
I know that feels awkward

537
00:28:27,410 --> 00:28:29,503
and a lot of people complain about this,

538
00:28:29,503 --> 00:28:32,170
but everything that was in there

539
00:28:32,170 --> 00:28:35,658
is being handled in our application.xml.

540
00:28:35,658 --> 00:28:39,626
For instance, the driver
class name and the URL.

541
00:28:39,626 --> 00:28:41,834
If you prefer there is
an alternative version

542
00:28:41,834 --> 00:28:43,946
of this configuration where you can point

543
00:28:43,946 --> 00:28:48,113
the entityManagerFactory
to the persistence.xml file

544
00:28:49,363 --> 00:28:50,946
if you prefer that.

545
00:28:52,101 --> 00:28:53,840
I prefer to have all of my configuration

546
00:28:53,840 --> 00:28:56,257
in the Spring wiring however.

547
00:28:57,188 --> 00:29:01,039
So with that file in place
be careful to make sure

548
00:29:01,039 --> 00:29:04,945
that the META-INF folder is under src.

549
00:29:04,945 --> 00:29:07,695
We can run our client code again,

550
00:29:09,577 --> 00:29:11,296
and ow, another exception.

551
00:29:11,296 --> 00:29:13,323
I can see automatically
there's something wrong

552
00:29:13,323 --> 00:29:15,809
with the transactionManager,

553
00:29:15,809 --> 00:29:19,066
and I forgot to take my own advice here.

554
00:29:19,066 --> 00:29:20,507
You'll remember that I advised you

555
00:29:20,507 --> 00:29:22,779
that you have to change
the transactionManager

556
00:29:22,779 --> 00:29:26,096
if you're changing data access strategy,

557
00:29:26,096 --> 00:29:29,190
so we don't really need
to look in any more detail

558
00:29:29,190 --> 00:29:31,281
at the crash to be honest.

559
00:29:31,281 --> 00:29:33,746
If we go back to the XML file,

560
00:29:33,746 --> 00:29:36,585
remember we've got our transactionManager,

561
00:29:36,585 --> 00:29:39,637
that's doing all of the
begins and the commits,

562
00:29:39,637 --> 00:29:41,354
but we're currently using the Hibernate

563
00:29:41,354 --> 00:29:43,706
for HibernateTransactionManager.

564
00:29:43,706 --> 00:29:46,023
Well, that's never going to work.

565
00:29:46,023 --> 00:29:47,815
We need to change it.

566
00:29:47,815 --> 00:29:51,303
Now of course you should
look in the reference manual

567
00:29:51,303 --> 00:29:54,876
for details of what the
JpaTransactionManager is,

568
00:29:54,876 --> 00:29:56,904
but you know what, I think I'm gonna have

569
00:29:56,904 --> 00:29:59,059
an educated guess here.

570
00:29:59,059 --> 00:30:03,226
The package route is bound to
be org.springframework.orm,

571
00:30:04,744 --> 00:30:06,675
is for object relational mapping,

572
00:30:06,675 --> 00:30:08,787
so that will still be valid.

573
00:30:08,787 --> 00:30:12,947
I think we're just going to
change hibernate4 to jpa,

574
00:30:12,947 --> 00:30:14,629
and I think we're gonna change

575
00:30:14,629 --> 00:30:19,546
HibernateTransactionManager
to JpaTransactionManager,

576
00:30:19,546 --> 00:30:21,046
as simple as that.

577
00:30:21,967 --> 00:30:25,007
Again, because we're using autowire here,

578
00:30:25,007 --> 00:30:27,749
it will pick up its required property,

579
00:30:27,749 --> 00:30:30,554
which is, in fact, the
entityManagerFactory.

580
00:30:30,554 --> 00:30:33,083
Okay, well, I did tell
you not to forget that,

581
00:30:33,083 --> 00:30:35,910
and then I went and forgot it myself.

582
00:30:35,910 --> 00:30:37,357
Errors are always expected

583
00:30:37,357 --> 00:30:39,605
when you're doing this
major reconfiguration,

584
00:30:39,605 --> 00:30:42,954
but once it's working,
and that's looking good.

585
00:30:42,954 --> 00:30:46,463
The code is running through just fine.

586
00:30:46,463 --> 00:30:50,378
As always it's worth
checking the database,

587
00:30:50,378 --> 00:30:52,405
and yeah we've got the insert

588
00:30:52,405 --> 00:30:55,734
going correctly into the system.

589
00:30:55,734 --> 00:30:58,403
Now my client at the moment
is doing a registerNewBook

590
00:30:58,403 --> 00:31:01,005
with the author of Gary Cornell.

591
00:31:01,005 --> 00:31:03,213
That was one of the changes I
made in the previous chapter,

592
00:31:03,213 --> 00:31:06,841
but we're doing
getAllBooksByAuthor of Josh Bloch.

593
00:31:06,841 --> 00:31:08,953
So that won't be returning any results,

594
00:31:08,953 --> 00:31:12,281
so let's change that to Gary Cornell.

595
00:31:12,281 --> 00:31:14,928
I think I'll also comment out
the creating of the newBook

596
00:31:14,928 --> 00:31:17,093
but that's just so we
don't end up with two books

597
00:31:17,093 --> 00:31:18,676
with the same ISBN.

598
00:31:20,037 --> 00:31:24,204
I just want to make sure
that my query method works.

599
00:31:25,170 --> 00:31:26,877
Indeed, it does!

600
00:31:26,877 --> 00:31:31,044
So that's it for writing a
JPA implementation of a DAO.

601
00:31:33,125 --> 00:31:35,990
In many ways there isn't much of a change

602
00:31:35,990 --> 00:31:39,959
between this approach and
working with Hibernate.

603
00:31:39,959 --> 00:31:43,532
The big difference is that
from Spring 4 onwards,

604
00:31:43,532 --> 00:31:47,615
you have to use this
@PersistenceContext approach

605
00:31:48,503 --> 00:31:53,409
because there is no longer a
template available for JPA.

606
00:31:53,409 --> 00:31:54,657
I think it's a shame,

607
00:31:54,657 --> 00:31:57,474
but well, it's not the end of the world,

608
00:31:57,474 --> 00:31:59,885
and it's pretty easy to configure.

609
00:31:59,885 --> 00:32:01,144
Once you've got it working,

610
00:32:01,144 --> 00:32:04,900
you've got full access to the JPA API.

611
00:32:04,900 --> 00:32:06,853
So I hope that's been a good start for you

612
00:32:06,853 --> 00:32:09,040
in using JPA and Spring.

613
00:32:09,040 --> 00:32:10,736
As I've mentioned many times before,

614
00:32:10,736 --> 00:32:12,784
I can't go too deep into JPA

615
00:32:12,784 --> 00:32:15,237
because that's for another course.

616
00:32:15,237 --> 00:32:17,957
But hopefully you've now got a good idea

617
00:32:17,957 --> 00:32:22,525
of how to integrate the
two frameworks together.

618
00:32:22,525 --> 00:32:25,063
So if you needed an overview of JPA,

619
00:32:25,063 --> 00:32:27,293
we've seen that it's a more modern,

620
00:32:27,293 --> 00:32:31,517
standardized version of the Hibernate API.

621
00:32:31,517 --> 00:32:35,741
It has the same structure
and philosophy as Hibernate,

622
00:32:35,741 --> 00:32:38,877
but different class and method names.

623
00:32:38,877 --> 00:32:41,309
There's no JpaTemplate.

624
00:32:41,309 --> 00:32:45,469
It was in Spring 1 and 2, but not 3 or 4.

625
00:32:45,469 --> 00:32:48,306
That's a shame in my opinion

626
00:32:48,306 --> 00:32:50,791
because it made everything symmetrical.

627
00:32:50,791 --> 00:32:53,298
No matter which strategy you were using,

628
00:32:53,298 --> 00:32:55,272
you use the Template.

629
00:32:55,272 --> 00:32:57,586
But for whatever reason, it's gone now

630
00:32:57,586 --> 00:33:00,753
and we need to use PersistenceContext.

631
00:33:01,643 --> 00:33:03,520
Having said all of that,

632
00:33:03,520 --> 00:33:08,010
the PersistenceContext is
really clean and elegant.

633
00:33:08,010 --> 00:33:10,420
You get to work with the EntityManager

634
00:33:10,420 --> 00:33:12,788
directly in your DAO,

635
00:33:12,788 --> 00:33:14,943
you don't have to worry about the opening

636
00:33:14,943 --> 00:33:17,693
and closing of the EntityManager.

637
00:33:18,527 --> 00:33:21,333
The EntityManager, by the
way, will open and close

638
00:33:21,333 --> 00:33:25,500
at the same time as your
transaction begins and commits.

639
00:33:26,623 --> 00:33:29,477
We have one further ORM to look at,

640
00:33:29,477 --> 00:33:31,494
and that's called MyBatis.

641
00:33:31,494 --> 00:33:34,643
But first we'll do a
Practical Session on JPA

642
00:33:34,643 --> 00:33:37,810
if you're interested
in using JPA, that is,

643
00:33:37,810 --> 00:33:39,707
and that's coming up next.

644
00:33:39,707 --> 00:33:43,124
(jazzy electronic music)

1
00:00:00,139 --> 00:00:02,722
(upbeat music)

2
00:00:10,531 --> 00:00:12,443
- [Voiceover] And now
for the practical session

3
00:00:12,443 --> 00:00:16,483
for Spring and object relational mapping.

4
00:00:16,483 --> 00:00:19,583
This practical session is optional.

5
00:00:19,583 --> 00:00:22,649
If you're not interested
in Hibernate or JPA

6
00:00:22,649 --> 00:00:25,982
then you can safely skip this practical.

7
00:00:27,302 --> 00:00:31,234
If you do choose this
practical, then the job is

8
00:00:31,234 --> 00:00:33,067
to in your CRM System,

9
00:00:34,325 --> 00:00:37,325
change your JDBC data access classes

10
00:00:39,545 --> 00:00:42,128
to use either JPA or Hibernate.

11
00:00:44,071 --> 00:00:47,414
The choice of which
one you go for is yours

12
00:00:47,414 --> 00:00:51,581
but in the practical
walkthrough, I'm going to us JPA.

13
00:00:52,879 --> 00:00:54,838
If you do decide to go for Hibernate

14
00:00:54,838 --> 00:00:58,301
then you should be able
to work out how to do it

15
00:00:58,301 --> 00:01:01,682
using the previous theory video.

16
00:01:01,682 --> 00:01:04,169
But what I will do in the walkthrough

17
00:01:04,169 --> 00:01:08,499
is I'm going to use the
manual wiring approach

18
00:01:08,499 --> 00:01:12,499
rather than using auto
wiring using annotations.

19
00:01:13,760 --> 00:01:16,613
That's just to give us a
little bit more of a chance

20
00:01:16,613 --> 00:01:19,280
to practice using manual wiring.

21
00:01:20,158 --> 00:01:22,483
So as usual, you'll need
to remember to close

22
00:01:22,483 --> 00:01:26,723
the bookstore project that
we're using for the videos

23
00:01:26,723 --> 00:01:29,806
and open up your CRM system projects.

24
00:01:31,181 --> 00:01:35,871
Now you'll recall that in
the client's application

25
00:01:35,871 --> 00:01:40,038
we're currently opening up the
file called application.xml.

26
00:01:40,895 --> 00:01:45,152
But we have two version of
the application.xml file.

27
00:01:45,152 --> 00:01:48,927
The one that's currently being
opened in my live client's

28
00:01:48,927 --> 00:01:52,790
application is the one
called application.xml

29
00:01:52,790 --> 00:01:56,957
which is, in fact, the
full manual wiring version,

30
00:01:58,135 --> 00:02:00,440
where we've done everything by hand.

31
00:02:00,440 --> 00:02:03,119
If you want to use the
annotations, then you can always

32
00:02:03,119 --> 00:02:07,816
open the applicationAnnotations.xml
file instead.

33
00:02:07,816 --> 00:02:11,275
That's the one where the
component scan was being used.

34
00:02:11,275 --> 00:02:14,155
But I need to warn you, before
you start, if you do decide

35
00:02:14,155 --> 00:02:17,527
to go for the manual
wiring, so the one where

36
00:02:17,527 --> 00:02:21,164
we've wired all of the beans explicitly,

37
00:02:21,164 --> 00:02:25,331
you are going to have to add
the context colon annotation

38
00:02:27,259 --> 00:02:28,932
config tag.

39
00:02:28,932 --> 00:02:32,856
And that's to ensure that
the annotation of persistence

40
00:02:32,856 --> 00:02:36,185
context is picked up by Spring.

41
00:02:36,185 --> 00:02:39,189
Now unfortunately, at the
moment, we don't have the context

42
00:02:39,189 --> 00:02:43,216
namespace defined, so that's
going to be one of your first

43
00:02:43,216 --> 00:02:44,133
jobs to do.

44
00:02:46,108 --> 00:02:50,988
Also if you're using JPA, you
will need a persistence.xml

45
00:02:50,988 --> 00:02:55,155
file and that will need to be
in a folder called meta-inf.

46
00:02:56,050 --> 00:02:59,480
Now we did do that on the
video so you can borrow

47
00:02:59,480 --> 00:03:03,190
that folder and the file
from the bookstore project

48
00:03:03,190 --> 00:03:05,532
from the completed bookstore projects.

49
00:03:05,532 --> 00:03:08,162
Or if you prefer, you can
use the Hello Hibernate

50
00:03:08,162 --> 00:03:09,441
project.

51
00:03:09,441 --> 00:03:11,754
And if you drill into the SRC folder,

52
00:03:11,754 --> 00:03:14,549
you can borrow the one that's in there.

53
00:03:14,549 --> 00:03:18,716
Make sure you take the entire
folder and drag it to SRC.

54
00:03:19,768 --> 00:03:22,289
If you are going to use the
one from Hello Hibernate,

55
00:03:22,289 --> 00:03:25,246
once you've copied the file,
you will want to delete

56
00:03:25,246 --> 00:03:29,566
the properties tag because
all of these properties

57
00:03:29,566 --> 00:03:33,307
are now going to be handled
by our connection pool

58
00:03:33,307 --> 00:03:34,224
and Spring.

59
00:03:35,456 --> 00:03:39,203
Now there is further information
in the PDF Practicals Guide

60
00:03:39,203 --> 00:03:42,246
and in particular, we give
you the queries you need

61
00:03:42,246 --> 00:03:44,223
for some of the methods.

62
00:03:44,223 --> 00:03:48,185
In the data access object,
for instance, you're going

63
00:03:48,185 --> 00:03:52,352
to have to implement a method
called GetFullCustomerDetail.

64
00:03:54,152 --> 00:03:57,802
Now to do that in JPA and
Hibernate, you need something

65
00:03:57,802 --> 00:03:59,885
called a left join fetch.

66
00:04:01,637 --> 00:04:04,471
So if you're not an expert
in JPA, you will need

67
00:04:04,471 --> 00:04:07,395
to check out the PDF practical guide.

68
00:04:07,395 --> 00:04:10,692
Also in that PDF practical
guide is some information

69
00:04:10,692 --> 00:04:15,338
on how to implemented the
updates and delete methods.

70
00:04:15,338 --> 00:04:18,139
The problem with these is
that they do rely on some

71
00:04:18,139 --> 00:04:21,475
slightly more advanced JPA
than we were able to cover

72
00:04:21,475 --> 00:04:23,281
on the theory video.

73
00:04:23,281 --> 00:04:26,535
So you can copy the
implementations from the PDF.

74
00:04:26,535 --> 00:04:29,941
Or if you prefer, you can
just leave the implementations

75
00:04:29,941 --> 00:04:32,366
of these methods blank.

76
00:04:32,366 --> 00:04:35,999
As this isn't a JPA course,
it really doesn't matter

77
00:04:35,999 --> 00:04:40,606
if we don't do everything
that's possible in JPA.

78
00:04:40,606 --> 00:04:43,812
This is, I think, quite
a complicated practical

79
00:04:43,812 --> 00:04:46,970
and probably the hardest
one on the course so far.

80
00:04:46,970 --> 00:04:49,388
So don't worry if you have problems.

81
00:04:49,388 --> 00:04:52,071
Try to solve the problems
yourself but if you get stuck

82
00:04:52,071 --> 00:04:55,823
in any way then, of course,
the walkthrough follows

83
00:04:55,823 --> 00:04:57,656
in just a few seconds.

84
00:04:59,468 --> 00:05:01,569
Welcome back to the walkthrough then.

85
00:05:01,569 --> 00:05:03,780
And the first thing I'm
going to have to solve

86
00:05:03,780 --> 00:05:07,199
as I mentioned in the introduction is

87
00:05:07,199 --> 00:05:11,220
that my application.xml file,
and this is the one where

88
00:05:11,220 --> 00:05:14,347
we're doing all of the manual wiring.

89
00:05:14,347 --> 00:05:18,406
I am going to have to
include the context colon

90
00:05:18,406 --> 00:05:20,682
annotation config.

91
00:05:20,682 --> 00:05:25,243
If you decided to go for
the automatic wiring file,

92
00:05:25,243 --> 00:05:28,617
then you won't need that
because you get the annotation

93
00:05:28,617 --> 00:05:32,649
config free but this is needed
to pick up the persistence

94
00:05:32,649 --> 00:05:37,296
context annotation if
you're using manual wiring.

95
00:05:37,296 --> 00:05:41,084
So I need to add the
context namespace to the top

96
00:05:41,084 --> 00:05:44,748
and I'm sure you're completely
sick of me doing that by now,

97
00:05:44,748 --> 00:05:47,406
so I am going to do that
by copying and pasting

98
00:05:47,406 --> 00:05:48,739
from off camera,

99
00:05:50,001 --> 00:05:54,783
that's the namespace and
that's the schema location.

100
00:05:54,783 --> 00:05:58,533
And now I'm not seeing
any error on that tag.

101
00:05:59,448 --> 00:06:02,955
And before I go any further,
I want to mention that

102
00:06:02,955 --> 00:06:06,227
in the domain package
where we have action call

103
00:06:06,227 --> 00:06:07,310
and customer.

104
00:06:08,404 --> 00:06:10,015
I'll start with customer.

105
00:06:10,015 --> 00:06:13,524
Notice that you've always had
these tags, these annotations,

106
00:06:13,524 --> 00:06:18,224
the entity, ID and generated
value added to the classes.

107
00:06:18,224 --> 00:06:21,932
Now, we've been ignoring them
through the course so far.

108
00:06:21,932 --> 00:06:24,318
If you look back on any of
the earlier videos, you won't

109
00:06:24,318 --> 00:06:27,359
see them there because actually
I've just added them now

110
00:06:27,359 --> 00:06:30,802
off camera and I will have
copied these files back

111
00:06:30,802 --> 00:06:33,191
to your starting code folder.

112
00:06:33,191 --> 00:06:35,086
So you will have had them
throughout the course

113
00:06:35,086 --> 00:06:38,249
but they will have been
having no effect so far.

114
00:06:38,249 --> 00:06:41,544
So I've done that just
because that's really part

115
00:06:41,544 --> 00:06:44,722
of the JPA course and we
don't want to worry about

116
00:06:44,722 --> 00:06:46,805
adding those annotations.

117
00:06:47,969 --> 00:06:51,459
Okay, so the job is then were
going to have to implement

118
00:06:51,459 --> 00:06:54,459
the action DAO and the customer DAO.

119
00:06:55,540 --> 00:06:58,567
We've already got JDBC
implementations but we want

120
00:06:58,567 --> 00:07:02,734
to switch them for more
sophisticated JPA versions.

121
00:07:03,667 --> 00:07:07,450
I'm going to start with the
customer DAO so we're going

122
00:07:07,450 --> 00:07:09,658
to go for a new class.

123
00:07:09,658 --> 00:07:13,075
And I'll call this one CustomerDaoJPAImpl

124
00:07:14,271 --> 00:07:18,422
and the interface to
implement is going to be

125
00:07:18,422 --> 00:07:19,422
customer DAO

126
00:07:21,587 --> 00:07:25,071
and as always, we want
inherited abstract methods

127
00:07:25,071 --> 00:07:26,404
to be ticked on.

128
00:07:27,823 --> 00:07:31,068
And then we get lovely
skeletons to work with.

129
00:07:31,068 --> 00:07:34,944
So I think the first
step in doing this is to

130
00:07:34,944 --> 00:07:36,694
create an attributes.

131
00:07:37,540 --> 00:07:39,760
And because I'm working with
JPA, this is going to be

132
00:07:39,760 --> 00:07:44,533
the entity manager, which
will need to be imported.

133
00:07:44,533 --> 00:07:48,033
And the magic annotation is at persistence

134
00:07:49,936 --> 00:07:52,714
and I can do Ctrl or command space there

135
00:07:52,714 --> 00:07:55,195
to auto complete it.

136
00:07:55,195 --> 00:07:57,871
Just so you're not confused,
although I'm using manual

137
00:07:57,871 --> 00:08:01,536
wiring for JPA, we have
to use the annotation now,

138
00:08:01,536 --> 00:08:03,786
pretty much have to use it.

139
00:08:05,406 --> 00:08:09,514
And that will be picked up
because of the context annotation

140
00:08:09,514 --> 00:08:12,264
config tag that we added earlier.

141
00:08:13,231 --> 00:08:16,936
Okay, so now we've got
hold of the entity manager,

142
00:08:16,936 --> 00:08:19,810
it's not just the case of running through

143
00:08:19,810 --> 00:08:21,733
and using the entity manager.

144
00:08:21,733 --> 00:08:25,900
So for the create method,
this is going to be a persist.

145
00:08:27,568 --> 00:08:30,735
We want to persist the customer, done.

146
00:08:32,003 --> 00:08:36,170
For get by ID, this is going
to be an em.createQuery.

147
00:08:38,170 --> 00:08:41,585
And the query string, while
I'm working here from the

148
00:08:41,585 --> 00:08:45,252
PDF practicals guide,
so this is going to be

149
00:08:46,406 --> 00:08:48,011
select

150
00:08:48,011 --> 00:08:49,370
customer

151
00:08:49,370 --> 00:08:50,453
from customer

152
00:08:52,095 --> 00:08:53,493
where

153
00:08:53,493 --> 00:08:55,160
customer.customerID

154
00:08:59,170 --> 00:09:01,837
matches a particular value.

155
00:09:01,837 --> 00:09:04,304
I'll call that customer ID.

156
00:09:04,304 --> 00:09:07,463
And we'll continue to
set a parameter there.

157
00:09:07,463 --> 00:09:12,203
And the parameter name is
customerID and the value

158
00:09:12,203 --> 00:09:16,194
is whatever has been
passed in as a parameter

159
00:09:16,194 --> 00:09:19,278
so that's going to be customerID.

160
00:09:19,278 --> 00:09:23,445
I'm then going to call the
Get-- or actually in JPA,

161
00:09:24,287 --> 00:09:26,620
there is a get first result,

162
00:09:27,988 --> 00:09:31,571
or even better, get single results.

163
00:09:31,571 --> 00:09:35,890
We are expecting only one
result to be returned from

164
00:09:35,890 --> 00:09:36,807
that query.

165
00:09:38,723 --> 00:09:41,447
Now whatever comes back from
that, I'm going to need to

166
00:09:41,447 --> 00:09:44,864
return and I also need to do a type cast

167
00:09:47,084 --> 00:09:49,718
to get it back to the correct type.

168
00:09:49,718 --> 00:09:52,259
Well that line went a little
bit ugly and you're going

169
00:09:52,259 --> 00:09:55,171
to find it's quite common with
this long chain of methods

170
00:09:55,171 --> 00:09:56,687
in JPA.

171
00:09:56,687 --> 00:09:59,820
It's quite common to put
carriage returns after each

172
00:09:59,820 --> 00:10:00,820
of the dots.

173
00:10:01,718 --> 00:10:04,886
So you can see how the methods stack up.

174
00:10:04,886 --> 00:10:07,225
Now it doesn't matter
if you didn't do this,

175
00:10:07,225 --> 00:10:11,250
but the get single result
method will throw an exception

176
00:10:11,250 --> 00:10:13,500
if no results was returned.

177
00:10:14,910 --> 00:10:18,780
Now that exception, of
course I can catch it,

178
00:10:18,780 --> 00:10:22,753
it is unchecked exception and
do I don't have to catch it.

179
00:10:22,753 --> 00:10:26,920
But if I do catch it, it's
called the no result exception.

180
00:10:29,368 --> 00:10:33,103
Notice it's from Javax.persistence.

181
00:10:33,103 --> 00:10:36,932
Now if that unchecked exception is thrown

182
00:10:36,932 --> 00:10:38,765
then I can re-throw it

183
00:10:39,928 --> 00:10:43,345
as one of my record not found exceptions.

184
00:10:46,285 --> 00:10:49,526
And the client will be forced
to deal with that problem.

185
00:10:49,526 --> 00:10:52,240
It doesn't matter if you
didn't do that, the purpose

186
00:10:52,240 --> 00:10:55,159
is to check that JPA's working okay.

187
00:10:55,159 --> 00:10:57,341
That's the kind of thing
that you might possibly do

188
00:10:57,341 --> 00:10:59,067
in real life.

189
00:10:59,067 --> 00:11:02,399
Okay, then well, the next
method should be a little easier

190
00:11:02,399 --> 00:11:06,018
because this is going to return a list.

191
00:11:06,018 --> 00:11:09,768
So this time around it
will be em.createQuery

192
00:11:10,632 --> 00:11:13,793
and again working from
the practicals guide,

193
00:11:13,793 --> 00:11:17,274
I'm going to be selecting
customer from customer

194
00:11:17,274 --> 00:11:21,441
where the customers, now I
think this is the company name,

195
00:11:24,509 --> 00:11:28,509
matches the company name
passed into the method.

196
00:11:29,392 --> 00:11:31,663
I got a bit confused
there, I hope you didn't

197
00:11:31,663 --> 00:11:35,195
because yet my name isn't
a very good method name

198
00:11:35,195 --> 00:11:38,116
it really should be get by company name.

199
00:11:38,116 --> 00:11:40,909
But never mind, I can do
the same thing as before.

200
00:11:40,909 --> 00:11:43,615
I can set the parameter.

201
00:11:43,615 --> 00:11:46,365
Just going to be company name

202
00:11:46,365 --> 00:11:50,584
is going to be set to the
parameter of the name passed in

203
00:11:50,584 --> 00:11:54,042
and then finally I'm going
to get the result list

204
00:11:54,042 --> 00:11:56,898
and my method is complete.

205
00:11:56,898 --> 00:11:59,990
Now as mentioned in the
practicals guide, we didn't cover

206
00:11:59,990 --> 00:12:03,484
how to do updates on the session.

207
00:12:03,484 --> 00:12:07,097
Now this is quite a
complicated topic in JPA.

208
00:12:07,097 --> 00:12:11,016
We cover it in a lot more
detail on the full JPA course.

209
00:12:11,016 --> 00:12:15,183
But as advised in the
handout, if we called em.merge

210
00:12:16,617 --> 00:12:20,496
and pass in that customer
to update, then that will

211
00:12:20,496 --> 00:12:23,088
effectively update the customer.

212
00:12:23,088 --> 00:12:26,118
Now it doesn't quite do the job correctly

213
00:12:26,118 --> 00:12:30,193
because if this customer
is a brand new customer

214
00:12:30,193 --> 00:12:33,361
really we should be passing
it into the create method.

215
00:12:33,361 --> 00:12:37,361
But actually this method
called merge is sort of

216
00:12:38,559 --> 00:12:40,226
a update or insert.

217
00:12:41,877 --> 00:12:44,267
So it's a bit kind of
unusual in the update.

218
00:12:44,267 --> 00:12:47,363
We'll double up now as a
create method but I don't

219
00:12:47,363 --> 00:12:48,555
personally mind.

220
00:12:48,555 --> 00:12:51,805
It's a bit worrying that the
method might throw a record

221
00:12:51,805 --> 00:12:55,972
not found exception but actually
that that can't now happen.

222
00:12:57,678 --> 00:13:00,353
Anyway, I hope you don't
mind that too much.

223
00:13:00,353 --> 00:13:03,066
Again we have a problem with
the delete method as mentioned

224
00:13:03,066 --> 00:13:04,833
in the handout.

225
00:13:04,833 --> 00:13:07,425
Again, we need a little
bit more JPA knowledge

226
00:13:07,425 --> 00:13:09,885
to be able to implement this properly.

227
00:13:09,885 --> 00:13:12,680
The thing is that the old
customer, this customer being

228
00:13:12,680 --> 00:13:16,807
passed in from the clients,
is not a persistent object,

229
00:13:16,807 --> 00:13:19,193
it's a regular object.

230
00:13:19,193 --> 00:13:21,492
And what we need to do is
we need to make the object

231
00:13:21,492 --> 00:13:23,887
be persistent again.

232
00:13:23,887 --> 00:13:28,054
And actually the easiest way
to do that, is to merge it.

233
00:13:28,997 --> 00:13:31,710
Now, merge really means make this object

234
00:13:31,710 --> 00:13:34,014
be persistent again.

235
00:13:34,014 --> 00:13:37,032
Then we can make any changes to it.

236
00:13:37,032 --> 00:13:39,469
And the change we're going
to make to it is that we're

237
00:13:39,469 --> 00:13:42,878
going to call the remove method on it.

238
00:13:42,878 --> 00:13:47,324
So it's potentially a little
bit awkward doing that.

239
00:13:47,324 --> 00:13:49,883
I'd rather that we could just remove by ID

240
00:13:49,883 --> 00:13:52,921
but that's one way of doing
it and it will certainly work

241
00:13:52,921 --> 00:13:54,112
for here.

242
00:13:54,112 --> 00:13:57,022
Get all customers should be easy.

243
00:13:57,022 --> 00:13:58,855
We just need to return

244
00:14:00,990 --> 00:14:02,939
creating the query of

245
00:14:02,939 --> 00:14:05,606
select from customer as customer

246
00:14:08,726 --> 00:14:11,143
and then get the result list.

247
00:14:13,383 --> 00:14:15,023
I like that one.

248
00:14:15,023 --> 00:14:16,946
Now get full customer detail is one

249
00:14:16,946 --> 00:14:19,881
that I was worrying about.

250
00:14:19,881 --> 00:14:23,123
Again, I've given you this
in the practical guide.

251
00:14:23,123 --> 00:14:26,280
We need something called
a left join fetch here.

252
00:14:26,280 --> 00:14:30,876
And that's because with a
regular query, all Hibernate

253
00:14:30,876 --> 00:14:34,709
or JPA will do is return
the top level object.

254
00:14:36,288 --> 00:14:40,391
So with all of these select
from customer, in fact,

255
00:14:40,391 --> 00:14:43,755
it's just populating the customer objects

256
00:14:43,755 --> 00:14:48,243
and not the calls that are
linked to the customer.

257
00:14:48,243 --> 00:14:50,919
Now with this method, we want the customer

258
00:14:50,919 --> 00:14:53,391
and/or the calls.

259
00:14:53,391 --> 00:14:58,041
And to do that, we do so
called left joined fetch.

260
00:14:58,041 --> 00:15:00,797
Exactly as in the practical
guide, we're going to select

261
00:15:00,797 --> 00:15:04,784
customer-- oh I've just
realized in my previous quiery,

262
00:15:04,784 --> 00:15:08,153
yeah they were okay, but
in this one I've missed out

263
00:15:08,153 --> 00:15:09,070
a customer.

264
00:15:09,962 --> 00:15:11,815
So anyway, back to this one.

265
00:15:11,815 --> 00:15:15,232
Select customer from customer as customer

266
00:15:18,808 --> 00:15:20,058
left join fetch

267
00:15:22,639 --> 00:15:23,889
customer.calls.

268
00:15:25,841 --> 00:15:30,195
Now this really translates
to the SQL statement

269
00:15:30,195 --> 00:15:34,370
that gets generated from here
will contain a left outer join

270
00:15:34,370 --> 00:15:37,298
on the calls table if you're interested

271
00:15:37,298 --> 00:15:39,972
in the underlying SQL query.

272
00:15:39,972 --> 00:15:43,305
Oh, we also need to add
in where clause here

273
00:15:43,305 --> 00:15:47,472
and this is going to be where
the customer's customerID

274
00:15:48,910 --> 00:15:51,910
matches whatever value was passed in

275
00:15:53,555 --> 00:15:55,888
and I'll add a set parameter

276
00:15:58,873 --> 00:16:02,540
customerID is going to
be set to customerID.

277
00:16:04,309 --> 00:16:08,476
And then finally, and we're
only expecting one result

278
00:16:09,485 --> 00:16:13,568
from this method, so well
call get single result.

279
00:16:16,122 --> 00:16:17,955
That will need a cast.

280
00:16:20,768 --> 00:16:24,642
And again, I could do the
business of trying and catching

281
00:16:24,642 --> 00:16:28,145
and if we catch the exception,
we throw record not found

282
00:16:28,145 --> 00:16:32,007
exception, I'm not going to
do that here purely for speed.

283
00:16:32,007 --> 00:16:34,803
I'm kind of conscious of the
fact that this is a little bit

284
00:16:34,803 --> 00:16:36,778
of a tedious exercise.

285
00:16:36,778 --> 00:16:39,445
You must be bored watching
this so I'll miss out

286
00:16:39,445 --> 00:16:41,216
the try catch block there.

287
00:16:41,216 --> 00:16:45,733
Add call is probably the hardest
of the methods to implement

288
00:16:45,733 --> 00:16:48,975
which is why I only gave
you a hint in the handout,

289
00:16:48,975 --> 00:16:51,840
want you to think about
how to do this one.

290
00:16:51,840 --> 00:16:55,132
The clue is really that
we've got a customer ID

291
00:16:55,132 --> 00:16:57,441
but only a customer ID.

292
00:16:57,441 --> 00:17:00,312
And we want to attach a
call to that particular

293
00:17:00,312 --> 00:17:02,299
customer object.

294
00:17:02,299 --> 00:17:06,325
So really all we can do is
we're gonna have to get hold

295
00:17:06,325 --> 00:17:09,648
of the full customer object some how.

296
00:17:09,648 --> 00:17:11,906
So we'll call that customer.

297
00:17:11,906 --> 00:17:15,643
And of course we can do that
easily using the find method

298
00:17:15,643 --> 00:17:17,726
because find works by ID.

299
00:17:18,606 --> 00:17:22,145
We're looking for a customer object

300
00:17:22,145 --> 00:17:25,440
and we can pass in the customer ID.

301
00:17:25,440 --> 00:17:28,108
I just want to mentioned
before I go any further here

302
00:17:28,108 --> 00:17:31,691
that the find method
only works with field,

303
00:17:33,132 --> 00:17:36,140
if I go into the customer
class, it only works with

304
00:17:36,140 --> 00:17:40,307
the field that you have
annotated with the at ID tag.

305
00:17:42,835 --> 00:17:45,879
So I couldn't do this for company
name or email or telephone

306
00:17:45,879 --> 00:17:47,296
or anything else.

307
00:17:48,540 --> 00:17:51,867
So we've got the customer object.

308
00:17:51,867 --> 00:17:54,714
Now that's a persistent
object now because it's been

309
00:17:54,714 --> 00:17:56,964
found by an entity manager.

310
00:17:57,847 --> 00:18:02,134
And what, for me, is the best
feature of JPA and Hibernate

311
00:18:02,134 --> 00:18:06,217
by far, is that if I now do
something to that object,

312
00:18:06,217 --> 00:18:09,549
such as call the add call method,

313
00:18:09,549 --> 00:18:12,019
I can pass in this new call.

314
00:18:12,019 --> 00:18:14,815
In other words, just update the object

315
00:18:14,815 --> 00:18:17,661
when the entity manager
closes, and remember Spring

316
00:18:17,661 --> 00:18:21,740
is going to do that for
us, the entity manager

317
00:18:21,740 --> 00:18:24,256
will carefully check the object

318
00:18:24,256 --> 00:18:26,565
and check if it's changed.

319
00:18:26,565 --> 00:18:29,396
And the fact that it has a
new element in one of its

320
00:18:29,396 --> 00:18:32,154
collections, means it's changed.

321
00:18:32,154 --> 00:18:36,237
And JPA will diligently
issue the appropriate SQL

322
00:18:37,617 --> 00:18:41,971
to update the database,
which I think is fantastic.

323
00:18:41,971 --> 00:18:45,027
So im sure I've got some errors here.

324
00:18:45,027 --> 00:18:47,414
I'm reading from a script,
I'm implementing this

325
00:18:47,414 --> 00:18:50,918
exactly as I would on a
real project, so we're about

326
00:18:50,918 --> 00:18:53,724
to see some errors at run time.

327
00:18:53,724 --> 00:18:57,990
But well okay we can deal
with that when and if

328
00:18:57,990 --> 00:18:58,907
it happens.

329
00:18:59,970 --> 00:19:02,161
But before we run, of course,
we've got to implement

330
00:19:02,161 --> 00:19:04,691
the action DAO as well.

331
00:19:04,691 --> 00:19:07,632
So this is going to be new class.

332
00:19:07,632 --> 00:19:11,549
This will be the action
DAO JPA implementation.

333
00:19:12,995 --> 00:19:16,216
Of course, if you didn't have
any problems with action DAO

334
00:19:16,216 --> 00:19:18,829
you can always forward wind through this

335
00:19:18,829 --> 00:19:21,501
because it's going to be
quite boring, frankly.

336
00:19:21,501 --> 00:19:23,023
It's going to be the same process.

337
00:19:23,023 --> 00:19:27,190
In this DAO, we're going
to have an entity manager

338
00:19:28,488 --> 00:19:31,285
which we usually call em.

339
00:19:31,285 --> 00:19:35,452
And we'll annotate that
with at persistence context

340
00:19:39,645 --> 00:19:41,579
which will be imported.

341
00:19:41,579 --> 00:19:44,228
And then we'll run through the method.

342
00:19:44,228 --> 00:19:47,478
So creating an action is an em.persist.

343
00:19:50,150 --> 00:19:55,139
Get incomplete actions,
this is going to be a query.

344
00:19:55,139 --> 00:19:59,827
So we need to create that
query and it's going to be

345
00:19:59,827 --> 00:20:03,238
and I'm working again
from the PDF guide here,

346
00:20:03,238 --> 00:20:06,155
select action from action as action

347
00:20:08,173 --> 00:20:10,506
where the actions.owninguser

348
00:20:13,141 --> 00:20:14,832
matches a particular value,

349
00:20:14,832 --> 00:20:17,104
I'm just going to call it user

350
00:20:17,104 --> 00:20:21,104
and the action.complete
fleid is equal to false.

351
00:20:22,985 --> 00:20:25,660
It's worth mentioning here if
you haven't seen this query

352
00:20:25,660 --> 00:20:29,423
language before, that will map to whatever

353
00:20:29,423 --> 00:20:33,590
your database's representation
of true and false is.

354
00:20:34,436 --> 00:20:38,560
I think on HSQLDB it uses
a bit, which will be zero

355
00:20:38,560 --> 00:20:41,938
or one, but we won't have
to worry that, we can just

356
00:20:41,938 --> 00:20:43,521
use true and false.

357
00:20:45,647 --> 00:20:50,375
So I'm going to need to
set a parameter for the

358
00:20:50,375 --> 00:20:51,375
owning user.

359
00:20:53,314 --> 00:20:56,408
So that's going to be, in this system,

360
00:20:56,408 --> 00:20:59,254
the users are just strings.

361
00:20:59,254 --> 00:21:02,088
If they had been objects,
by the way, you can pass

362
00:21:02,088 --> 00:21:05,755
an entire object as a
parameter into a query

363
00:21:07,327 --> 00:21:09,549
which I still find quite amazing.

364
00:21:09,549 --> 00:21:12,560
What Hibernate or JPA
will do is it will convert

365
00:21:12,560 --> 00:21:17,403
the object into whatever
ID or foreign key it is.

366
00:21:17,403 --> 00:21:19,298
We don't need it here
though, we just need to set

367
00:21:19,298 --> 00:21:23,245
that parameter and then
get the result list.

368
00:21:23,245 --> 00:21:26,872
We've got the usual warning
there, which we can ignore.

369
00:21:26,872 --> 00:21:29,455
And then for the update method,

370
00:21:31,139 --> 00:21:33,001
we know now that this one's easy.

371
00:21:33,001 --> 00:21:37,168
This is going to be that
strange method name merge.

372
00:21:39,871 --> 00:21:41,231
And that's good.

373
00:21:41,231 --> 00:21:43,607
And finally for the delete, well again,

374
00:21:43,607 --> 00:21:45,913
we have the same problem.

375
00:21:45,913 --> 00:21:48,675
and again, as advised by the
practical guide, I'm going

376
00:21:48,675 --> 00:21:51,849
to follow the pattern as before.

377
00:21:51,849 --> 00:21:55,753
We create a kind of new persistent action

378
00:21:55,753 --> 00:21:58,794
by calling the em.merge method

379
00:21:58,794 --> 00:22:02,739
on the action passed in from the client.

380
00:22:02,739 --> 00:22:06,906
And then we call em.remove
on that persistence action.

381
00:22:09,195 --> 00:22:11,659
As this isn't a JPA course,
I'm not entirely sure

382
00:22:11,659 --> 00:22:14,040
if that's the most
efficient way of doing it

383
00:22:14,040 --> 00:22:17,046
but it's the way that
I'm going to do it here.

384
00:22:17,046 --> 00:22:20,005
Now I've just realized as I
was talking that in my previous

385
00:22:20,005 --> 00:22:23,672
implementation, I didn't
quite do that right

386
00:22:24,982 --> 00:22:26,474
on this one here.

387
00:22:26,474 --> 00:22:27,724
I actually need

388
00:22:29,189 --> 00:22:30,022
to assign

389
00:22:32,833 --> 00:22:37,557
the results, the return
from em.merge to the object

390
00:22:37,557 --> 00:22:39,283
that I'm removing.

391
00:22:39,283 --> 00:22:42,245
So I could've said customer persistent

392
00:22:42,245 --> 00:22:44,679
customer equals et cetera.

393
00:22:44,679 --> 00:22:46,652
But it's quite common to, if you like,

394
00:22:46,652 --> 00:22:50,190
overwrite the reference
to the previous object.

395
00:22:50,190 --> 00:22:51,873
I'm sorry if that's a little bit awkward.

396
00:22:51,873 --> 00:22:54,884
It's kind of a nasty part of JPA.

397
00:22:54,884 --> 00:22:57,729
If you didn't understand
that then I don't mind if you

398
00:22:57,729 --> 00:23:01,017
don't bother implementing
the delete methods.

399
00:23:01,017 --> 00:23:03,192
Really doesn't matter for this course.

400
00:23:03,192 --> 00:23:05,035
What does matter for this
course is we've now got

401
00:23:05,035 --> 00:23:07,785
two complete data access objects.

402
00:23:08,928 --> 00:23:11,678
And now we have to do the wiring.

403
00:23:15,050 --> 00:23:16,391
So the wiring is going to be

404
00:23:16,391 --> 00:23:19,391
the worst part of this job, I think.

405
00:23:20,453 --> 00:23:25,016
And the first job is to create
an entity manager factory.

406
00:23:25,016 --> 00:23:27,760
Now I hope you don't mind me
doing this, but because it's

407
00:23:27,760 --> 00:23:30,708
a very tedious typing
job, I've simply borrowed

408
00:23:30,708 --> 00:23:34,875
I've just pasted in there,
exactly the same entity manager

409
00:23:35,817 --> 00:23:38,771
factory that I used on the bookstore.

410
00:23:38,771 --> 00:23:41,290
So you can either borrow
that from practicals and code

411
00:23:41,290 --> 00:23:45,253
or you can pause the video
and copy it from the screen.

412
00:23:45,253 --> 00:23:46,794
It's tedious.

413
00:23:46,794 --> 00:23:49,700
The worst bit is getting
that class name correct.

414
00:23:49,700 --> 00:23:51,653
Remember we're telling
it that we want in JPA

415
00:23:51,653 --> 00:23:54,760
to see the SQL, we want
the table to be generated

416
00:23:54,760 --> 00:23:58,427
and we're hooking up
to our connection pool.

417
00:23:59,359 --> 00:24:03,160
Now before I forget, I am
going to also change the

418
00:24:03,160 --> 00:24:05,243
transaction manager here.

419
00:24:06,611 --> 00:24:09,971
Transaction manager, and again
I'm working from my video, I

420
00:24:09,971 --> 00:24:14,138
think
was
org.springframework.orm.jpa.jpatransactionmanager

421
00:24:20,922 --> 00:24:24,089
and because I'm doing all
of this by hand this time,

422
00:24:24,089 --> 00:24:26,914
I'm not using auto wiring,

423
00:24:26,914 --> 00:24:30,950
this version of the
transaction manager takes in

424
00:24:30,950 --> 00:24:33,117
the entity manager factory

425
00:24:34,737 --> 00:24:37,070
rather than the data source.

426
00:24:38,306 --> 00:24:41,800
Now if you want a bit of background there,

427
00:24:41,800 --> 00:24:45,880
the transaction manager needs
to talk to the entity manager

428
00:24:45,880 --> 00:24:50,047
factory so that it can begin
and commit the transactions

429
00:24:51,055 --> 00:24:55,000
because that work is
done through the JPA API.

430
00:24:55,000 --> 00:24:56,825
That's only if you're interested.

431
00:24:56,825 --> 00:25:00,275
You don't need to pass in the data source.

432
00:25:00,275 --> 00:25:04,761
Okay so we've got the top
level bit of JPA working.

433
00:25:04,761 --> 00:25:07,499
We've switched on the
entity manager factory

434
00:25:07,499 --> 00:25:11,558
but now we need to make the DAOs be live.

435
00:25:11,558 --> 00:25:13,755
So if we go through
the rest of the wiring,

436
00:25:13,755 --> 00:25:17,950
first of all, this template
is now no longer needed.

437
00:25:17,950 --> 00:25:20,456
We were using that for JDBC.

438
00:25:20,456 --> 00:25:23,446
So I'm going to remove that from my xml.

439
00:25:23,446 --> 00:25:26,565
By the way, if yo want to keep
an old copy of this xml file,

440
00:25:26,565 --> 00:25:28,197
that's fine.

441
00:25:28,197 --> 00:25:31,845
And it's very common for projects
to have multiple xml files

442
00:25:31,845 --> 00:25:34,921
with different configurations.

443
00:25:34,921 --> 00:25:38,070
But I need to switch these
around now, my customer DAO

444
00:25:38,070 --> 00:25:39,570
is now going to be

445
00:25:41,083 --> 00:25:45,250
from the data access package
the customerDAOJPAImpl

446
00:25:47,713 --> 00:25:51,693
and we do not need the
init method anymore.

447
00:25:51,693 --> 00:25:56,330
Because remember JPA can create
the tables all by itself.

448
00:25:56,330 --> 00:26:00,727
We are not using a template
anymore so we can remove

449
00:26:00,727 --> 00:26:03,174
the constructor argument.

450
00:26:03,174 --> 00:26:06,032
There are no parameters
to the customer DAO

451
00:26:06,032 --> 00:26:09,358
because the only parameter
that we need to inject

452
00:26:09,358 --> 00:26:13,891
is the entity manager, which
Spring does automatically

453
00:26:13,891 --> 00:26:17,455
because of the tag that we've added here.

454
00:26:17,455 --> 00:26:20,363
Same job then for the action DAO.

455
00:26:20,363 --> 00:26:22,280
This is going to be the

456
00:26:24,271 --> 00:26:25,604
actionDAOJPAImpl

457
00:26:29,460 --> 00:26:32,210
and we can remove the init method

458
00:26:33,985 --> 00:26:35,690
and the constructor argument.

459
00:26:35,690 --> 00:26:38,800
But then, I think everything is as before.

460
00:26:38,800 --> 00:26:42,502
We've got our service
classes which are picking up

461
00:26:42,502 --> 00:26:45,117
this new version of the DAO

462
00:26:45,117 --> 00:26:47,026
and we're done.

463
00:26:47,026 --> 00:26:50,317
Now because I'm not using
auto wiring, I can use

464
00:26:50,317 --> 00:26:52,183
the beans graph.

465
00:26:52,183 --> 00:26:55,313
And although the bean
graph looks disconnected,

466
00:26:55,313 --> 00:26:57,656
it looks a bit worrying at first,

467
00:26:57,656 --> 00:26:59,276
it's only disconnected because remember

468
00:26:59,276 --> 00:27:03,046
the DAOs are going to get
entity manager objects

469
00:27:03,046 --> 00:27:06,825
which Spring automatically
creates from the manager factory

470
00:27:06,825 --> 00:27:07,825
at run time.

471
00:27:09,139 --> 00:27:13,039
So you're not seeing a direct
connection from here to here

472
00:27:13,039 --> 00:27:15,935
but there is a kind of
implicit connection.

473
00:27:15,935 --> 00:27:19,050
The important thing is
the services are connected

474
00:27:19,050 --> 00:27:20,178
to the DAOs.

475
00:27:20,178 --> 00:27:21,469
All good.

476
00:27:21,469 --> 00:27:25,820
So there is absolutely no
way that this is going to run

477
00:27:25,820 --> 00:27:27,361
for the first time.

478
00:27:27,361 --> 00:27:29,536
We always expect exceptions here.

479
00:27:29,536 --> 00:27:33,028
But we haven't seen the
CRM system for a while

480
00:27:33,028 --> 00:27:35,939
and I just want to mention
that the client's test

481
00:27:35,939 --> 00:27:39,255
that we were using before
is completely unchanged.

482
00:27:39,255 --> 00:27:43,569
All we've done is changed the
back end data access objects.

483
00:27:43,569 --> 00:27:46,760
We would expect the
creating of a new customer,

484
00:27:46,760 --> 00:27:50,927
adding calls and so on, to
work just fine without change.

485
00:27:53,191 --> 00:27:57,217
So I think as usual for
simplicity, I'm going to start

486
00:27:57,217 --> 00:27:59,050
with a clean database.

487
00:28:02,204 --> 00:28:05,358
We're going to be doing a
chapter on integration testing

488
00:28:05,358 --> 00:28:07,642
shortly where I won't
need to be fiddling around

489
00:28:07,642 --> 00:28:10,804
with deleting databases anymore.

490
00:28:10,804 --> 00:28:13,206
And let's run the app now.

491
00:28:13,206 --> 00:28:16,816
There's bound to be an exception here.

492
00:28:16,816 --> 00:28:18,725
And yes of course, there is.

493
00:28:18,725 --> 00:28:21,132
And already I can see, I have
forgotten one of the things

494
00:28:21,132 --> 00:28:22,810
I warned you about.

495
00:28:22,810 --> 00:28:26,655
We do need a persistence.xml
file even though

496
00:28:26,655 --> 00:28:30,139
it's going to be pretty much empty.

497
00:28:30,139 --> 00:28:32,630
So I suggested, I'm going
to borrow it from the

498
00:28:32,630 --> 00:28:35,362
Hello Hibernate project.

499
00:28:35,362 --> 00:28:38,012
I'm going to copy, as I'm
holding down the command

500
00:28:38,012 --> 00:28:42,179
or ctrl key, I'm going to
copy that folder to SRC.

501
00:28:44,320 --> 00:28:48,487
And then I'll edit the file to
remove all of the properties.

502
00:28:49,761 --> 00:28:51,807
This file becomes meaningless.

503
00:28:51,807 --> 00:28:55,974
We won't need to maintain
it or anything like that.

504
00:28:57,048 --> 00:28:59,215
It just needs to be there.

505
00:29:00,400 --> 00:29:01,733
Let's run again.

506
00:29:03,973 --> 00:29:07,467
And I seem to be having a complete run

507
00:29:07,467 --> 00:29:09,082
which is good.

508
00:29:09,082 --> 00:29:12,230
Now, you might've had some other problems.

509
00:29:12,230 --> 00:29:15,058
Hopefully the steps I've
followed, if you've followed them

510
00:29:15,058 --> 00:29:17,707
carefully, might help you out.

511
00:29:17,707 --> 00:29:19,704
If you really are stuck,
of course, you can always

512
00:29:19,704 --> 00:29:22,180
raise a support call.

513
00:29:22,180 --> 00:29:24,891
I think this was the trickiest
exercise in the whole

514
00:29:24,891 --> 00:29:25,724
of the course.

515
00:29:25,724 --> 00:29:29,224
Notice one pit fall is back on the client.

516
00:29:31,382 --> 00:29:35,549
If we were to attempt to
add the same customer again,

517
00:29:37,559 --> 00:29:42,012
because we're using the
customer ID as literally an ID

518
00:29:42,012 --> 00:29:45,804
in the database, it
does need to be unique.

519
00:29:45,804 --> 00:29:48,971
So if I were to run this client again.

520
00:29:50,076 --> 00:29:54,165
Yeah I'm getting an integrity
constraint violation.

521
00:29:54,165 --> 00:29:56,744
So if you've had that
problem, then it might just be

522
00:29:56,744 --> 00:30:01,482
because you're trying to
insert the same customer twice.

523
00:30:01,482 --> 00:30:03,848
I'll tell you what I could
do, very quickly though,

524
00:30:03,848 --> 00:30:07,786
I must admit, I was a bit
worried with my implementations

525
00:30:07,786 --> 00:30:10,152
of the delete methods.

526
00:30:10,152 --> 00:30:13,402
So I could just do the customer service

527
00:30:15,877 --> 00:30:17,794
delete customer method.

528
00:30:18,828 --> 00:30:21,081
It's a bit awkward though,
I have to pass in the whole

529
00:30:21,081 --> 00:30:22,831
customer object here.

530
00:30:24,054 --> 00:30:25,727
I think that would be much
better if it were just

531
00:30:25,727 --> 00:30:28,541
customer ID to be honest but never mind.

532
00:30:28,541 --> 00:30:30,905
I can find the customer first.

533
00:30:30,905 --> 00:30:32,905
So customer old customer

534
00:30:33,925 --> 00:30:38,698
equals, this is going to
be the customer service

535
00:30:38,698 --> 00:30:41,511
dot find by customer ID.

536
00:30:41,511 --> 00:30:45,261
I'm looking for the same
ID that I had there.

537
00:30:50,670 --> 00:30:53,122
Now both of these I guess might throw?

538
00:30:53,122 --> 00:30:55,156
Yeah the customer not found exception

539
00:30:55,156 --> 00:30:57,739
which I can handle very easily.

540
00:30:59,771 --> 00:31:01,438
And try catch block.

541
00:31:06,851 --> 00:31:09,018
Which will be a trivial...

542
00:31:10,582 --> 00:31:12,249
Sorry, that customer

543
00:31:14,620 --> 00:31:15,787
doesn't exist.

544
00:31:18,473 --> 00:31:21,460
Now before I run this, I
want to remind you about

545
00:31:21,460 --> 00:31:23,377
how the database works.

546
00:31:26,207 --> 00:31:28,625
So I'll refresh it first.

547
00:31:28,625 --> 00:31:32,987
Here's the database script so
we should see at the bottom

548
00:31:32,987 --> 00:31:36,404
there's an insert there for the customer.

549
00:31:38,707 --> 00:31:41,990
The next insert there is for a link table

550
00:31:41,990 --> 00:31:45,355
that's linking the customers to the calls.

551
00:31:45,355 --> 00:31:47,151
We didn't have that in our JDBC version

552
00:31:47,151 --> 00:31:50,888
but it is the default
for the way JPA works.

553
00:31:50,888 --> 00:31:54,971
But the important one is
the customer line there.

554
00:31:55,833 --> 00:31:57,916
And if I run this client,

555
00:32:00,228 --> 00:32:03,561
I wouldn't be surprised if this crashes.

556
00:32:04,594 --> 00:32:05,924
And it has.

557
00:32:05,924 --> 00:32:09,119
This is a query exception and
whenever you see it saying

558
00:32:09,119 --> 00:32:13,523
unable to resolve path,
it essentially means

559
00:32:13,523 --> 00:32:17,413
that there's something
wrong with my query.

560
00:32:17,413 --> 00:32:21,059
I think this must be
when we're getting by ID.

561
00:32:21,059 --> 00:32:24,181
So I can't of gone too far
wrong because this came from

562
00:32:24,181 --> 00:32:25,799
the practicals guide.

563
00:32:25,799 --> 00:32:28,613
Here is the query: select
customer from customer

564
00:32:28,613 --> 00:32:31,566
and I've missed off the as customer.

565
00:32:31,566 --> 00:32:35,719
I do find these JPA queries
quite annoying the way you've

566
00:32:35,719 --> 00:32:39,504
got to refer to customer
or whatever three times.

567
00:32:39,504 --> 00:32:43,314
If you've been doing
this as just Hibernate,

568
00:32:43,314 --> 00:32:46,918
you can get away with
just saying from customer

569
00:32:46,918 --> 00:32:49,001
where customer ID equals.

570
00:32:50,361 --> 00:32:53,444
Hibernate is a little bit less fussy.

571
00:32:55,399 --> 00:32:59,399
Okay so I'm assuming then
we won't have seen the

572
00:33:00,845 --> 00:33:05,414
row deleted from the database
so we'll run the client again.

573
00:33:05,414 --> 00:33:07,285
Oh looks pretty good.

574
00:33:07,285 --> 00:33:10,365
Can you see there, that
there's a delete from customer

575
00:33:10,365 --> 00:33:14,532
but it's also deleted the calls
for that customer as well?

576
00:33:15,564 --> 00:33:18,186
Now that's a feature called cascading.

577
00:33:18,186 --> 00:33:21,462
You can tune that by
switching it on and off.

578
00:33:21,462 --> 00:33:26,162
But the set up that we have,
it's one of the annotations

579
00:33:26,162 --> 00:33:30,444
in fact, in the customer class
is to cascade the deletes.

580
00:33:30,444 --> 00:33:34,483
And that means if we check
the database script now,

581
00:33:34,483 --> 00:33:38,555
notice the inserts have been
removed for that customer

582
00:33:38,555 --> 00:33:39,471
and calls.

583
00:33:39,471 --> 00:33:42,966
The actions are still there,
but the customer and calls

584
00:33:42,966 --> 00:33:44,383
are now all gone.

585
00:33:45,323 --> 00:33:49,509
So it does look like my
deleting of the customer worked.

586
00:33:49,509 --> 00:33:51,913
I'm sure I probably
have some syntax errors

587
00:33:51,913 --> 00:33:54,326
in the rest of the
queries but I'm conscious

588
00:33:54,326 --> 00:33:57,649
that this walkthrough's gone
on for quite a long time now.

589
00:33:57,649 --> 00:34:00,714
So I think I'm going
to stop working there.

590
00:34:00,714 --> 00:34:03,374
As I mentioned, if you had
any problems that have not

591
00:34:03,374 --> 00:34:05,611
been resolved by this
walkthrough, don't forget

592
00:34:05,611 --> 00:34:07,611
to raise a support call.

1
00:00:00,107 --> 00:00:03,344
(bouncy jazz music)

2
00:00:10,693 --> 00:00:11,680
- [Voiceover] One final chapter

3
00:00:11,680 --> 00:00:14,251
on object relational mapping,

4
00:00:14,251 --> 00:00:16,160
and this time we're covering a framework

5
00:00:16,160 --> 00:00:18,719
that isn't nearly as popular

6
00:00:18,719 --> 00:00:21,268
as JPA or Hibernate.

7
00:00:21,268 --> 00:00:25,444
But I think myBatis is
a really good option

8
00:00:25,444 --> 00:00:29,332
if you don't want the complexity of JPA.

9
00:00:29,332 --> 00:00:32,889
So, we'll start with
an overview of myBatis.

10
00:00:32,889 --> 00:00:34,595
And one thing I will need to explain

11
00:00:34,595 --> 00:00:37,681
is what happened to iBatis.

12
00:00:38,587 --> 00:00:40,919
That's the old name for myBatis,

13
00:00:40,919 --> 00:00:42,967
and it was what we covered
on the first edition

14
00:00:42,967 --> 00:00:44,940
of this course.

15
00:00:44,940 --> 00:00:46,304
The key thing in my Batis

16
00:00:46,304 --> 00:00:50,155
is that you do rightly SQL.

17
00:00:50,155 --> 00:00:52,714
It's not autogenerated.

18
00:00:52,714 --> 00:00:54,154
Well, don't panic.

19
00:00:54,154 --> 00:00:57,920
myBatis uses something
called an SQL Mapper,

20
00:00:57,920 --> 00:01:00,768
and it's really elegant to use.

21
00:01:00,768 --> 00:01:03,275
As with our other chapters on ORM,

22
00:01:03,275 --> 00:01:07,754
this chapter is an optional
chapter you can safely skip it

23
00:01:07,754 --> 00:01:10,708
if you're not interested.

24
00:01:10,708 --> 00:01:13,268
Back in the first edition of this course

25
00:01:13,268 --> 00:01:18,142
we covered how to integrate
with a tool called iBatis.

26
00:01:18,142 --> 00:01:21,065
Now, I love iBatis.

27
00:01:21,065 --> 00:01:24,563
I think of it as a middle ground solution.

28
00:01:24,563 --> 00:01:28,625
JDBC is low-level, fiddly,

29
00:01:28,625 --> 00:01:30,593
and a nightmare to work with.

30
00:01:30,593 --> 00:01:33,446
I would never use it directly

31
00:01:33,446 --> 00:01:35,739
on a serious project.

32
00:01:35,739 --> 00:01:39,339
Although of course the
Spring JDBC template

33
00:01:39,339 --> 00:01:41,488
improves JDBC,

34
00:01:41,488 --> 00:01:44,384
and I do use the JDBC template

35
00:01:44,384 --> 00:01:46,928
on some projects.

36
00:01:46,928 --> 00:01:50,992
It is still quite low-level
though and if I can remind you

37
00:01:50,992 --> 00:01:54,427
of the one that we wrote much
earlier on in the course,

38
00:01:54,427 --> 00:01:57,647
here's our JDBC implementation.

39
00:01:57,647 --> 00:02:01,242
And I would say the biggest
thing about the template is

40
00:02:01,242 --> 00:02:03,386
we still have to do mapping.

41
00:02:03,386 --> 00:02:07,813
We still have to take the
rows returned from JDBC

42
00:02:07,813 --> 00:02:11,279
and we have to, if you
like, manually convert them

43
00:02:11,279 --> 00:02:14,319
back into regular objects.

44
00:02:14,319 --> 00:02:16,675
So, on the other extreme we've got

45
00:02:16,675 --> 00:02:18,889
Hibernate and JPA.

46
00:02:18,889 --> 00:02:22,323
And these are really
popular in the Java world.

47
00:02:22,323 --> 00:02:25,086
But they are really complex.

48
00:02:25,086 --> 00:02:27,902
We spend 20 or more hours

49
00:02:27,902 --> 00:02:29,822
going into deep detail

50
00:02:29,822 --> 00:02:32,286
on our Hibernate JPA course.

51
00:02:32,286 --> 00:02:35,134
And there's still more to learn.

52
00:02:35,134 --> 00:02:38,056
Projects using Hibernate often report that

53
00:02:38,056 --> 00:02:40,851
they're baffled about
what Hibernate is doing

54
00:02:40,851 --> 00:02:42,121
under the hood.

55
00:02:42,121 --> 00:02:45,822
And sometimes it all
feels really quite random.

56
00:02:45,822 --> 00:02:48,028
I've been using Hibernate now

57
00:02:48,028 --> 00:02:50,716
since 2005.

58
00:02:50,716 --> 00:02:53,649
So, I've had a lot of
years experience at it,

59
00:02:53,649 --> 00:02:57,105
and I can still lose a few days of work

60
00:02:57,105 --> 00:02:59,772
debugging some obscure problem.

61
00:02:59,772 --> 00:03:01,702
Sometimes it's just a matter of learning

62
00:03:01,702 --> 00:03:03,516
about how Hibernate works

63
00:03:03,516 --> 00:03:05,809
but it is a vast tool.

64
00:03:05,809 --> 00:03:09,339
So, iBatis for many sits
right in the middle.

65
00:03:09,339 --> 00:03:12,336
It can do some really
sophisticated things.

66
00:03:12,336 --> 00:03:16,763
For example, you don't have
to do this converting of rows

67
00:03:16,763 --> 00:03:20,666
into objects like you do in JDBC.

68
00:03:20,666 --> 00:03:23,984
But you also retain control.

69
00:03:23,984 --> 00:03:26,677
Most obviously, you still write

70
00:03:26,677 --> 00:03:29,418
the SQL statements.

71
00:03:29,418 --> 00:03:31,946
iBatis doesn't generate them,

72
00:03:31,946 --> 00:03:33,801
and a lot of people like that.

73
00:03:33,801 --> 00:03:36,937
You tend to feel a little
bit more in control

74
00:03:36,937 --> 00:03:40,767
when you're able to
write the SQL statements.

75
00:03:40,767 --> 00:03:42,523
But the problem with iBatis

76
00:03:42,523 --> 00:03:47,291
is it's just not nearly
as popular as Hibernate.

77
00:03:47,291 --> 00:03:50,761
iBatis is a bit like Cinderella
locked in the basement

78
00:03:50,761 --> 00:03:53,035
and cruelly ignored.

79
00:03:53,035 --> 00:03:56,032
Now, I suspect one reason why
people don't seem attracted

80
00:03:56,032 --> 00:04:00,619
to iBatis is its rubbish,
meaningless name.

81
00:04:00,619 --> 00:04:05,167
It's just sounds less
appealing than Hibernate.

82
00:04:05,167 --> 00:04:08,991
I made a similar disparaging
comment about the name iBatis

83
00:04:08,991 --> 00:04:11,135
on the first edition of this course.

84
00:04:11,135 --> 00:04:12,917
And I did have letters.

85
00:04:12,917 --> 00:04:15,307
Well, okay I had a letter saying,

86
00:04:15,307 --> 00:04:19,253
"Well, why don't you tell us
where the name comes from."

87
00:04:19,253 --> 00:04:21,344
It actually took quite
a little bit of research

88
00:04:21,344 --> 00:04:25,242
but it turns out that the
original author of iBatis

89
00:04:25,242 --> 00:04:29,162
originally was working
on security software.

90
00:04:29,162 --> 00:04:32,276
And apparently, I didn't know this,

91
00:04:32,276 --> 00:04:34,762
but there is a word Abatis,

92
00:04:34,762 --> 00:04:36,970
here's it's Wikipedia page,

93
00:04:36,970 --> 00:04:40,266
which apparently is a term for

94
00:04:40,266 --> 00:04:45,002
a kind of fortification used in war.

95
00:04:45,002 --> 00:04:47,119
And he used that name because he was

96
00:04:47,119 --> 00:04:49,892
working on security software

97
00:04:49,892 --> 00:04:53,412
and he called it iBatis as a kind of pun.

98
00:04:53,412 --> 00:04:56,345
And over time he moved away from that

99
00:04:56,345 --> 00:04:59,289
and he moved into object
relational mapping.

100
00:04:59,289 --> 00:05:01,540
So, a very obscure name.

101
00:05:01,540 --> 00:05:04,729
And don't say you haven't
learnt anything on this course

102
00:05:04,729 --> 00:05:06,905
but I'd be amazed if
you ever get asked that

103
00:05:06,905 --> 00:05:08,761
in an interview.

104
00:05:08,761 --> 00:05:11,897
Anyway, I still think it's a rubbish name

105
00:05:11,897 --> 00:05:14,031
but it's a great product.

106
00:05:14,031 --> 00:05:17,277
And I wish it was used more on projects.

107
00:05:18,493 --> 00:05:20,110
Now, unfortunately since we recorded

108
00:05:20,110 --> 00:05:22,169
the first edition of this course

109
00:05:22,169 --> 00:05:24,259
some things have changed.

110
00:05:24,259 --> 00:05:27,581
And most notable is that for some reason

111
00:05:27,581 --> 00:05:31,609
they have renamed the tool to myBatis.

112
00:05:31,609 --> 00:05:34,467
So, it just has a slightly
different rubbish,

113
00:05:34,467 --> 00:05:36,505
meaningless name.

114
00:05:36,505 --> 00:05:37,998
Now, that happened because the project

115
00:05:37,998 --> 00:05:41,454
was originally maintained by Apache.

116
00:05:41,454 --> 00:05:44,232
But myBatis was a fork

117
00:05:44,232 --> 00:05:46,798
from the original iBatis.

118
00:05:46,798 --> 00:05:49,049
But the original project sadly ended,

119
00:05:49,049 --> 00:05:52,739
so I can only assume there
was some kind of politics

120
00:05:52,739 --> 00:05:55,545
at the Apache Software Foundation.

121
00:05:55,545 --> 00:05:57,380
Well the point is that now myBatis

122
00:05:57,380 --> 00:06:00,398
is the only viable upgrade path

123
00:06:00,398 --> 00:06:04,121
if you're wanting to
continue working with it.

124
00:06:04,121 --> 00:06:07,438
Unfortunately, I haven't
really sensed any improvement

125
00:06:07,438 --> 00:06:09,917
in myBatis' fortunes

126
00:06:09,917 --> 00:06:12,850
since this radical rebranding.

127
00:06:13,778 --> 00:06:15,745
And it's a long time since I've been asked

128
00:06:15,745 --> 00:06:18,594
to use it on a project.

129
00:06:18,594 --> 00:06:21,815
The other big difference since
we recorded the first edition

130
00:06:21,815 --> 00:06:24,514
of this course is that, on the face of it,

131
00:06:24,514 --> 00:06:29,047
myBatis isn't even
supported by Spring anymore.

132
00:06:29,047 --> 00:06:31,511
If you check out the reference manual

133
00:06:31,511 --> 00:06:35,692
you won't find any mention of it anywhere.

134
00:06:35,692 --> 00:06:37,015
Now the reason for this is that

135
00:06:37,015 --> 00:06:39,266
as Spring was being released

136
00:06:39,266 --> 00:06:41,847
myBatis was still in beta,

137
00:06:41,847 --> 00:06:44,534
And the Spring team
didn't want to intergrate

138
00:06:44,534 --> 00:06:46,138
with beta software.

139
00:06:46,138 --> 00:06:48,257
So, they kind of missed the boat there

140
00:06:48,257 --> 00:06:50,816
and the integration was sadly abandoned.

141
00:06:50,816 --> 00:06:53,878
And I can't see any sign
of it becoming a full part

142
00:06:53,878 --> 00:06:57,035
of the Spring framework in the future.

143
00:06:57,035 --> 00:06:59,200
So, in writing this second edition

144
00:06:59,200 --> 00:07:02,144
I did consider dropping this chapter.

145
00:07:02,144 --> 00:07:04,022
But when I mentioned
that to a few customers,

146
00:07:04,022 --> 00:07:05,419
I did get some complaints.

147
00:07:05,419 --> 00:07:08,927
And it seems that there are
plenty of projects out there

148
00:07:08,927 --> 00:07:11,018
who want to integrate with it.

149
00:07:11,018 --> 00:07:12,735
So, here it is.

150
00:07:12,735 --> 00:07:14,826
This is our upgraded chapter

151
00:07:14,826 --> 00:07:17,215
where we're going to cover what you can do

152
00:07:17,215 --> 00:07:21,113
if you want to use Spring with myBatis.

153
00:07:21,113 --> 00:07:23,125
And I've written this
chapter really for everyone.

154
00:07:23,125 --> 00:07:24,703
If you've seen the first edition

155
00:07:24,703 --> 00:07:26,421
and want to know what's changed,

156
00:07:26,421 --> 00:07:28,224
then this will be good for you.

157
00:07:28,224 --> 00:07:30,986
Or if you're curious about myBatis

158
00:07:30,986 --> 00:07:32,010
and you've never seen it,

159
00:07:32,010 --> 00:07:35,828
then this should be a great
introduction to the tool.

160
00:07:35,828 --> 00:07:39,796
Of course, I can't cover
myBatis in great depth.

161
00:07:39,796 --> 00:07:42,889
And I doubt we will ever
release a full course on it

162
00:07:42,889 --> 00:07:46,323
but it will be at least
a good start for you.

163
00:07:46,323 --> 00:07:47,976
So, the first thing is that

164
00:07:47,976 --> 00:07:51,688
integration with myBatis is still possible

165
00:07:51,688 --> 00:07:55,656
but it's via a third party project.

166
00:07:55,656 --> 00:07:59,656
In fact, it's a subproject of myBatis

167
00:07:59,656 --> 00:08:02,974
rather than a sub-project of Spring.

168
00:08:02,974 --> 00:08:05,971
So, here I am at the myBatis site

169
00:08:05,971 --> 00:08:08,200
the URL you can see here.

170
00:08:08,200 --> 00:08:10,727
And it's a sub-folder

171
00:08:10,727 --> 00:08:12,913
called Spring.

172
00:08:12,913 --> 00:08:15,639
There's a little bit of
information about the background

173
00:08:15,639 --> 00:08:19,938
behind why it's not a full
part of Spring anymore.

174
00:08:19,938 --> 00:08:21,165
But the upshot is that you will need to

175
00:08:21,165 --> 00:08:24,279
download two JAR files.

176
00:08:24,279 --> 00:08:26,978
Or of course you'll be adding a dependency

177
00:08:26,978 --> 00:08:29,069
to your Maven Repository.

178
00:08:29,069 --> 00:08:31,394
In the practicals and code
folder for the course,

179
00:08:31,394 --> 00:08:33,314
I have already downloaded

180
00:08:33,314 --> 00:08:35,287
what was the current version at the time

181
00:08:35,287 --> 00:08:36,759
that I recorded this course

182
00:08:36,759 --> 00:08:40,304
which was version 3.2.5

183
00:08:40,304 --> 00:08:42,064
of myBatis.

184
00:08:42,064 --> 00:08:45,221
And the other JAR is sort
of just the bridge between

185
00:08:45,221 --> 00:08:47,248
myBatis and Spring.

186
00:08:47,248 --> 00:08:49,147
And don't be put off
by the version number.

187
00:08:49,147 --> 00:08:53,189
That's just the version
number of the integration.

188
00:08:53,189 --> 00:08:56,543
So at the time of recording 1.2.2

189
00:08:56,543 --> 00:08:58,443
was the latest.

190
00:08:58,443 --> 00:09:00,927
So if you want to follow
along in this chapter,

191
00:09:00,927 --> 00:09:03,210
then you'll need to
dig out those JAR files

192
00:09:03,210 --> 00:09:07,342
and transfer them both
into your lib directory.

193
00:09:08,607 --> 00:09:10,356
So, I'm going to do that right now

194
00:09:10,356 --> 00:09:12,330
on my projects.

195
00:09:12,330 --> 00:09:14,580
I'll just paste them into there.

196
00:09:14,580 --> 00:09:16,169
And you're also going to need to make them

197
00:09:16,169 --> 00:09:18,121
part of your build path.

198
00:09:18,121 --> 00:09:20,137
So, I'll just do that by highlighting them

199
00:09:20,137 --> 00:09:22,136
and Build path

200
00:09:22,136 --> 00:09:24,788
and Add to BuildPath.

201
00:09:24,788 --> 00:09:28,116
So, I've now go myBatis
live and available,

202
00:09:28,116 --> 00:09:30,996
and the integration as well.

203
00:09:30,996 --> 00:09:32,478
So, where do we start with myBatis?

204
00:09:32,478 --> 00:09:35,423
Well before I start on
the details of myBatis,

205
00:09:35,423 --> 00:09:37,233
I'll do all of the background,

206
00:09:37,233 --> 00:09:39,026
housekeeping work first of all,

207
00:09:39,026 --> 00:09:41,361
the kind of routine work.

208
00:09:41,361 --> 00:09:43,712
And naturally the first thing
we're going to want to do

209
00:09:43,712 --> 00:09:46,986
is write a new data access object.

210
00:09:46,986 --> 00:09:49,557
We're not going to be
using the JPA, Hibernate,

211
00:09:49,557 --> 00:09:51,208
or JDBC 1.

212
00:09:51,208 --> 00:09:53,115
We're going to switch now to

213
00:09:53,115 --> 00:09:55,952
a new implementation.

214
00:09:55,952 --> 00:09:57,322
This time it's going to be the

215
00:09:57,322 --> 00:10:00,095
BookDaoMyBatis.Impl.

216
00:10:01,957 --> 00:10:06,099
Implementing the BookDAO interface.

217
00:10:07,475 --> 00:10:10,640
Check for inherited abstract methods.

218
00:10:10,640 --> 00:10:13,603
And we're going to be putting
all of our myBatis code

219
00:10:13,603 --> 00:10:15,395
into here.

220
00:10:15,395 --> 00:10:17,624
There is one really boring
job that we need to do

221
00:10:17,624 --> 00:10:19,811
in the XML file.

222
00:10:19,811 --> 00:10:21,505
If you followed the chapter

223
00:10:21,505 --> 00:10:23,958
on Hibernate or JPA,

224
00:10:23,958 --> 00:10:26,838
you'll remember that you had
to create this bean called

225
00:10:26,838 --> 00:10:29,537
entity manager factory.

226
00:10:29,537 --> 00:10:33,067
Well you have to do something
very similar with myBatis.

227
00:10:33,067 --> 00:10:35,766
It's another one of these
tedious, boiler plate,

228
00:10:35,766 --> 00:10:37,441
copy-and-paste jobs.

229
00:10:37,441 --> 00:10:39,788
Let me show you that on a caption.

230
00:10:39,788 --> 00:10:41,558
We'll it really is similar to Hibernate

231
00:10:41,558 --> 00:10:43,205
in that the bean is called

232
00:10:43,205 --> 00:10:46,458
an SQL Session Factory.

233
00:10:46,458 --> 00:10:48,074
Now the SQL Session Factory

234
00:10:48,074 --> 00:10:50,480
is one of the sort of important,

235
00:10:50,480 --> 00:10:54,874
grand configuration classes in myBatis.

236
00:10:54,874 --> 00:10:57,008
But as with Hibernate and JPA,

237
00:10:57,008 --> 00:10:58,704
when we're integrating with Spring,

238
00:10:58,704 --> 00:11:02,725
we will never need to work
with that class directly.

239
00:11:02,725 --> 00:11:05,808
We just have to refer to it in our wiring.

240
00:11:05,808 --> 00:11:07,856
So, here I'm creating a bean.

241
00:11:07,856 --> 00:11:10,938
I can give the ID any name I like.

242
00:11:10,938 --> 00:11:14,288
And the class I'm working here
from the reference manual.

243
00:11:14,288 --> 00:11:18,437
The reference manual provided
by the myBatis integration.

244
00:11:18,437 --> 00:11:19,440
And it happens to be

245
00:11:19,440 --> 00:11:23,479
org.mybatis.spring.SqlSessionFactoryBean.

246
00:11:24,574 --> 00:11:26,696
It only takes a single property,

247
00:11:26,696 --> 00:11:28,605
and that's the data source.

248
00:11:28,605 --> 00:11:31,922
So, really easy and quick to set up.

249
00:11:31,922 --> 00:11:33,437
There is one more thing.

250
00:11:33,437 --> 00:11:35,432
We need to change the transaction manager

251
00:11:35,432 --> 00:11:37,308
but this is quite easy.

252
00:11:37,308 --> 00:11:39,634
The transaction manager we use in myBatis

253
00:11:39,634 --> 00:11:41,351
isn't a special one.

254
00:11:41,351 --> 00:11:45,415
It's the regular datasource
transaction manager.

255
00:11:45,415 --> 00:11:46,578
I don't know if you remember that

256
00:11:46,578 --> 00:11:49,131
but that's the same one that we used

257
00:11:49,131 --> 00:11:51,798
back when we did JDBC.

258
00:11:51,798 --> 00:11:54,044
Now I'm not going to be
using any Hibernate or JPA

259
00:11:54,044 --> 00:11:57,526
so I can remove the
entity manager factory.

260
00:11:57,526 --> 00:11:58,922
And we can create the

261
00:11:58,922 --> 00:12:02,928
SQL Session Factory.

262
00:12:02,928 --> 00:12:05,136
So, if I can remember
the class name it's from

263
00:12:05,136 --> 00:12:09,791
org.mybatis.spring.SqlSessionFactoryBean.

264
00:12:17,418 --> 00:12:19,429
Now of course I was reading
from my own caption there.

265
00:12:19,429 --> 00:12:21,797
Don't try to remember that.

266
00:12:21,797 --> 00:12:24,293
And the only property we're working with

267
00:12:24,293 --> 00:12:26,393
is the datasource

268
00:12:27,838 --> 00:12:29,950
which is going to be
referring to my existing

269
00:12:29,950 --> 00:12:32,574
datasource object here.

270
00:12:32,574 --> 00:12:33,943
And if you prefer,

271
00:12:33,943 --> 00:12:36,151
you could have done an autowire

272
00:12:36,151 --> 00:12:37,986
of that property.

273
00:12:37,986 --> 00:12:40,418
Mustn't forget then to change
the transaction manager

274
00:12:40,418 --> 00:12:43,554
at the moment I've got it set up to be

275
00:12:43,554 --> 00:12:46,178
the JPA transaction manager.

276
00:12:46,178 --> 00:12:47,995
You might need to look back a few chapters

277
00:12:47,995 --> 00:12:50,678
to remember the name of
the regular datasource

278
00:12:50,678 --> 00:12:52,357
transaction manager.

279
00:12:53,488 --> 00:12:56,075
The name of the class is
datasource transaction manager.

280
00:12:56,075 --> 00:12:57,974
And the package it comes from is

281
00:12:57,974 --> 00:13:01,669
org.springframework.jdbc.datasource.

282
00:13:07,770 --> 00:13:09,461
Okay, so no errors there.

283
00:13:09,461 --> 00:13:11,904
So, that's some boring housekeeping work

284
00:13:11,904 --> 00:13:13,686
where we're just stepping up this sort of

285
00:13:13,686 --> 00:13:16,928
global configuration of myBatis.

286
00:13:16,928 --> 00:13:21,056
It's now ready and available
for us to work with.

287
00:13:21,056 --> 00:13:22,774
The next step I would suggest

288
00:13:22,774 --> 00:13:26,725
is to write the SQL statements.

289
00:13:26,725 --> 00:13:30,283
Now there are two ways
of supplying myBatis

290
00:13:30,283 --> 00:13:32,676
with the SQL statements.

291
00:13:32,676 --> 00:13:35,679
For instance, we're going to
need the Select All Columns

292
00:13:35,679 --> 00:13:37,553
from the book table

293
00:13:37,553 --> 00:13:40,455
in order to return all of the books.

294
00:13:40,455 --> 00:13:41,747
In the original iBatis,

295
00:13:41,747 --> 00:13:43,245
the only way you could do this

296
00:13:43,245 --> 00:13:46,615
was by writing an XML file

297
00:13:46,615 --> 00:13:49,553
and then imbedding the SQL statement

298
00:13:49,553 --> 00:13:51,991
into that XML file.

299
00:13:51,991 --> 00:13:54,284
Now that approach is still available

300
00:13:54,284 --> 00:13:57,026
and still completely supported.

301
00:13:57,026 --> 00:13:59,906
But there is a second
way that we can do it now

302
00:13:59,906 --> 00:14:02,391
and I think it's really elegant.

303
00:14:02,391 --> 00:14:04,834
And it's using some annotations.

304
00:14:04,834 --> 00:14:05,901
So for this edition,

305
00:14:05,901 --> 00:14:08,833
I'm going to concentrate
on the annotations.

306
00:14:08,833 --> 00:14:11,426
What we can do is we can write a class

307
00:14:11,426 --> 00:14:14,359
and I'm probably going
to put it right here

308
00:14:14,359 --> 00:14:16,471
in our data package.

309
00:14:16,471 --> 00:14:19,116
Perhaps, a sub-package
might be more appropriate

310
00:14:19,116 --> 00:14:21,783
but I'll let you determine
that on your projects.

311
00:14:21,783 --> 00:14:24,407
I'm gonna put it here for now.

312
00:14:24,407 --> 00:14:26,402
And it's actually not a class,

313
00:14:26,402 --> 00:14:28,801
it's an interface.

314
00:14:28,801 --> 00:14:30,796
And you're going to see
why we write an interface

315
00:14:30,796 --> 00:14:32,695
in a short while.

316
00:14:32,695 --> 00:14:37,297
Now these interfaces are
commonly called mappers.

317
00:14:37,297 --> 00:14:38,368
And they're called mappers because

318
00:14:38,368 --> 00:14:41,206
it's the way that we define how we want

319
00:14:41,206 --> 00:14:44,800
myBatis to convert the SQL statements

320
00:14:44,800 --> 00:14:47,659
into JAVA objects.

321
00:14:47,659 --> 00:14:49,515
So, I'm going to call this the

322
00:14:49,515 --> 00:14:53,967
BookSQLMapper.

323
00:14:53,967 --> 00:14:55,978
You can call it anything you'd like.

324
00:14:55,978 --> 00:14:59,183
And we don't have to extend
any existing interfaces

325
00:14:59,183 --> 00:15:00,309
or anything like that.

326
00:15:00,309 --> 00:15:02,404
It's just a plain

327
00:15:02,404 --> 00:15:04,889
JAVA interface.

328
00:15:04,889 --> 00:15:07,317
Now I just want to be clear here.

329
00:15:07,317 --> 00:15:10,005
When I first started working
with this version of myBatis

330
00:15:10,005 --> 00:15:10,954
I got a bit confused.

331
00:15:10,954 --> 00:15:13,092
I began thinking that this is

332
00:15:13,092 --> 00:15:15,593
my data access object.

333
00:15:15,593 --> 00:15:16,457
It really isn't.

334
00:15:16,457 --> 00:15:19,401
Remember, we've got a data access object

335
00:15:19,401 --> 00:15:22,836
that we're about to start writing here.

336
00:15:22,836 --> 00:15:25,022
And that contains all
of our regular methods

337
00:15:25,022 --> 00:15:27,905
such as all books.

338
00:15:28,929 --> 00:15:33,355
Now this mapper is just a container

339
00:15:33,355 --> 00:15:36,732
to hold our SQL statements.

340
00:15:36,732 --> 00:15:40,672
So one of the SQL statements
we're going to need to write

341
00:15:40,672 --> 00:15:44,492
is the SQL statement that
selects all of the books.

342
00:15:44,492 --> 00:15:46,607
So, let me show you how to do that.

343
00:15:46,607 --> 00:15:50,089
There's an annotation called ATSelect.

344
00:15:52,809 --> 00:15:54,661
It will need to be imported.

345
00:15:54,661 --> 00:15:56,847
Well, Ecliplse isn't letting me import it

346
00:15:56,847 --> 00:15:58,607
because I haven't written a,

347
00:15:58,607 --> 00:16:02,073
I think because I haven't
written a method yet.

348
00:16:02,073 --> 00:16:04,217
So, I'm going to go
ahead without the import,

349
00:16:04,217 --> 00:16:06,233
and I'll put it in afterwards.

350
00:16:06,233 --> 00:16:08,953
But what we do then as a
parameter to the annotation

351
00:16:08,953 --> 00:16:10,905
is very simple.

352
00:16:10,905 --> 00:16:13,966
We provide the SQL statements.

353
00:16:13,966 --> 00:16:18,190
Now this is going to be the
selecting of all the books.

354
00:16:18,190 --> 00:16:21,024
So, it's all columns from the book table

355
00:16:21,024 --> 00:16:23,841
with no particular where clause.

356
00:16:23,841 --> 00:16:25,878
I'll try to import again.

357
00:16:25,878 --> 00:16:27,809
And no, it's still not letting me do that

358
00:16:27,809 --> 00:16:29,322
and that's because, of course,

359
00:16:29,322 --> 00:16:32,683
in an interface we have to
provide some kind of methods.

360
00:16:32,683 --> 00:16:35,498
Now, here's the really clever bit.

361
00:16:35,498 --> 00:16:38,948
I can't stress how much I love

362
00:16:38,948 --> 00:16:40,746
what they've done here.

363
00:16:40,746 --> 00:16:43,013
What we do under the annotation

364
00:16:43,013 --> 00:16:46,080
is we provide a method signature.

365
00:16:46,080 --> 00:16:48,068
And the method signature

366
00:16:48,068 --> 00:16:50,650
is used by myBatis

367
00:16:50,650 --> 00:16:53,982
to convert the rows into objects.

368
00:16:55,102 --> 00:16:59,428
Now we want myBatis to
convert these book rows

369
00:16:59,428 --> 00:17:02,681
into a list of books.

370
00:17:02,681 --> 00:17:06,931
So I'm going to make that be
the return type of this method,

371
00:17:06,931 --> 00:17:08,279
a list of books.

372
00:17:09,306 --> 00:17:11,624
Now, of course, we need a method name.

373
00:17:11,624 --> 00:17:14,696
And the method name is
really not important.

374
00:17:14,696 --> 00:17:17,896
This is just going to
be a meaningful label

375
00:17:17,896 --> 00:17:21,800
that we attach to this SQL statement.

376
00:17:21,800 --> 00:17:24,232
So, I'm going to call this method

377
00:17:24,232 --> 00:17:26,718
find all books

378
00:17:26,718 --> 00:17:29,876
SQL statement.

379
00:17:29,876 --> 00:17:32,873
Now I'm being a little wordy there.

380
00:17:32,873 --> 00:17:35,636
I think often times people
will call it something like

381
00:17:35,636 --> 00:17:36,841
just find all books.

382
00:17:36,841 --> 00:17:38,668
But I want to remind you

383
00:17:38,668 --> 00:17:41,839
that this method has no connection

384
00:17:41,839 --> 00:17:44,156
to the methods in our DAO.

385
00:17:44,156 --> 00:17:46,577
They don't have to have the same names.

386
00:17:46,577 --> 00:17:49,000
They're not implementing
the same interface

387
00:17:49,000 --> 00:17:50,566
or anything like that.

388
00:17:50,566 --> 00:17:53,220
This is just a label that we're applying

389
00:17:53,220 --> 00:17:55,674
to that SQL statement.

390
00:17:55,674 --> 00:17:57,957
So for this project I'm going
to follow that convention.

391
00:17:57,957 --> 00:18:00,112
I'm going to put SQLStatement

392
00:18:00,112 --> 00:18:02,576
on the end of each method name.

393
00:18:02,576 --> 00:18:05,147
Now, of course, we need parameters.

394
00:18:05,147 --> 00:18:06,500
Now because there's no parameters

395
00:18:06,500 --> 00:18:08,964
going into this SQL Statement,

396
00:18:08,964 --> 00:18:12,420
I'm just going to leave this
method without parameters.

397
00:18:12,420 --> 00:18:14,212
And then I'm done.

398
00:18:14,212 --> 00:18:17,487
Now hopefully the imports
are going to work now.

399
00:18:17,487 --> 00:18:20,058
So, I need to import book.

400
00:18:20,058 --> 00:18:22,500
I need to import Java.util to the list.

401
00:18:22,500 --> 00:18:23,834
And yeah, that's good.

402
00:18:23,834 --> 00:18:27,610
I'm now seeing the import
of the select annotation

403
00:18:27,610 --> 00:18:30,202
from iBatis.

404
00:18:30,202 --> 00:18:32,687
And because this is an interface

405
00:18:32,687 --> 00:18:33,658
we're now finished.

406
00:18:33,658 --> 00:18:36,239
We don't have to provide
a body for this method.

407
00:18:36,239 --> 00:18:38,394
You might have been worrying
that we're going to have to

408
00:18:38,394 --> 00:18:40,767
provide the code to convert the

409
00:18:40,767 --> 00:18:43,156
SQL rows into objects.

410
00:18:43,156 --> 00:18:44,575
But we don't.

411
00:18:44,575 --> 00:18:46,687
All we need to do now is to continue

412
00:18:46,687 --> 00:18:49,493
with the rest of our statements.

413
00:18:49,493 --> 00:18:51,028
Now I should say before I move on

414
00:18:51,028 --> 00:18:53,988
how it actually does this.

415
00:18:53,988 --> 00:18:56,904
Really the select* there is saying

416
00:18:56,904 --> 00:19:00,205
select, ISBN, title,

417
00:19:00,205 --> 00:19:04,793
author, and price from book.

418
00:19:04,793 --> 00:19:09,047
And what myBatis will do
when its got the rows back

419
00:19:09,047 --> 00:19:13,997
is it will look for
matching attribute names

420
00:19:13,997 --> 00:19:16,333
in the book class.

421
00:19:16,333 --> 00:19:19,607
So in a way it's not really
doing anything clever

422
00:19:19,607 --> 00:19:22,050
but it's certainly pretty elegant.

423
00:19:22,050 --> 00:19:24,812
I'll return it back to select* though

424
00:19:24,812 --> 00:19:27,863
just because it's easier
to write that way.

425
00:19:27,863 --> 00:19:32,293
And similarly, if I go onto
the next select statement,

426
00:19:32,293 --> 00:19:35,498
we need a select statement
that selects all of the books

427
00:19:35,498 --> 00:19:38,091
by a particular author.

428
00:19:38,091 --> 00:19:39,648
So, this one is going to be,

429
00:19:39,648 --> 00:19:44,068
again I can use select* from book

430
00:19:44,068 --> 00:19:47,162
where the author matches

431
00:19:47,162 --> 00:19:49,668
a particular value.

432
00:19:49,668 --> 00:19:52,314
Now in previous chapters we've used things

433
00:19:52,314 --> 00:19:54,494
such as question marks

434
00:19:54,494 --> 00:19:58,540
or named parameters such as this.

435
00:19:58,540 --> 00:20:01,320
myBatis is slightly different.

436
00:20:01,320 --> 00:20:05,367
It's going to be a one of those symbols.

437
00:20:05,367 --> 00:20:07,026
I'll zoom in on it a little bit.

438
00:20:07,026 --> 00:20:09,074
It's a bit hard for me
to use the name of it

439
00:20:09,074 --> 00:20:11,048
because it's called so
many different things

440
00:20:11,048 --> 00:20:12,562
around the world.

441
00:20:12,562 --> 00:20:15,581
In the UK we call that the hash symbol.

442
00:20:15,581 --> 00:20:18,130
In the US it's called the pound symbol.

443
00:20:18,130 --> 00:20:20,829
And it probably has other names as well.

444
00:20:20,829 --> 00:20:23,692
And then curly brackets

445
00:20:23,692 --> 00:20:26,792
followed by just some label.

446
00:20:26,792 --> 00:20:30,045
I'm going to use the label of value.

447
00:20:30,045 --> 00:20:34,781
I think in the previous versions of iBatis

448
00:20:34,781 --> 00:20:36,476
we didn't use the curly brackets,

449
00:20:36,476 --> 00:20:38,961
it was just this hash or pound symbol

450
00:20:38,961 --> 00:20:42,119
on both sides of value.

451
00:20:42,119 --> 00:20:43,888
And where does it get the value from?

452
00:20:43,888 --> 00:20:46,608
Well again the magic is in the signature.

453
00:20:46,608 --> 00:20:50,656
We know that we're going
to expect a list of books.

454
00:20:50,656 --> 00:20:53,115
We can call the statement
anything we want.

455
00:20:53,115 --> 00:20:53,870
So I'm going to call this

456
00:20:53,870 --> 00:20:55,954
find by author

457
00:20:55,954 --> 00:20:58,839
SQL statement.

458
00:20:58,839 --> 00:21:01,421
But now I'm going to pass a parameter in

459
00:21:01,421 --> 00:21:04,461
and I'm calling the parameter value.

460
00:21:04,461 --> 00:21:06,951
So myBatis is intelligent enough

461
00:21:06,951 --> 00:21:08,471
to find the value

462
00:21:08,471 --> 00:21:11,607
from whatever we've passed in.

463
00:21:11,607 --> 00:21:14,119
Looking back to the data access object,

464
00:21:14,119 --> 00:21:16,049
we're also going to have to support

465
00:21:16,049 --> 00:21:18,679
a find by ISBN method

466
00:21:18,679 --> 00:21:20,354
that returns a single book.

467
00:21:20,354 --> 00:21:21,976
So, we'll need some SQL for that

468
00:21:21,976 --> 00:21:25,559
so that will be our
final select statement.

469
00:21:25,559 --> 00:21:28,365
We're selecting pull columns from book

470
00:21:28,365 --> 00:21:31,217
where the ISBN

471
00:21:31,217 --> 00:21:34,213
matches a particular value.

472
00:21:35,642 --> 00:21:38,294
The slight difference this
time will be in the signature.

473
00:21:38,294 --> 00:21:41,067
So, this time around myBatis knows

474
00:21:41,067 --> 00:21:44,150
we're only expecting a single book.

475
00:21:44,150 --> 00:21:45,077
So, this is going to be

476
00:21:45,077 --> 00:21:48,836
find by ISBN SQL statement.

477
00:21:51,951 --> 00:21:55,050
And I'll be passing in
a value for that ISBN.

478
00:21:55,050 --> 00:21:57,972
And we need to be able to support

479
00:21:57,972 --> 00:22:00,265
creating a book.

480
00:22:00,265 --> 00:22:03,028
So you might have guessed that
we have further annotations.

481
00:22:03,028 --> 00:22:06,348
We have an ATInsert annotation.

482
00:22:07,246 --> 00:22:09,735
And that allows me to specify

483
00:22:09,735 --> 00:22:12,295
an insert statement.

484
00:22:12,295 --> 00:22:16,045
So we're inserting into
book the values of ISBN,

485
00:22:16,045 --> 00:22:18,331
title, author,

486
00:22:18,331 --> 00:22:20,379
and price.

487
00:22:20,379 --> 00:22:23,440
But again we specify the values

488
00:22:23,440 --> 00:22:27,094
using exactly the same syntax as here.

489
00:22:27,094 --> 00:22:29,281
So first of all, we're
going to pass in a value

490
00:22:29,281 --> 00:22:30,764
for the ISBN.

491
00:22:30,764 --> 00:22:34,849
Secondly, we'll be passing
in a value for the title.

492
00:22:34,849 --> 00:22:37,881
And then we'll be passing
in a value for the author.

493
00:22:38,888 --> 00:22:41,624
And then the price.

494
00:22:43,006 --> 00:22:46,285
I think that's all correct.

495
00:22:47,667 --> 00:22:50,238
And another really smart feature here

496
00:22:50,238 --> 00:22:52,468
is if I put the signature in,

497
00:22:52,468 --> 00:22:54,654
because this is a create method,

498
00:22:54,654 --> 00:22:57,737
it's not going to return any values.

499
00:22:57,737 --> 00:22:59,998
I'm going to call the method

500
00:22:59,998 --> 00:23:02,194
create book

501
00:23:02,194 --> 00:23:04,967
SQL statement.

502
00:23:04,967 --> 00:23:06,392
And another feature I love is

503
00:23:06,392 --> 00:23:08,165
I can pass into this

504
00:23:08,165 --> 00:23:11,525
a full book object

505
00:23:11,525 --> 00:23:14,294
and I don't need to do any further work.

506
00:23:14,294 --> 00:23:17,483
Again, myBatis will use its intelligence

507
00:23:17,483 --> 00:23:20,006
to pull out of the book

508
00:23:20,006 --> 00:23:21,345
the ISBN, the title,

509
00:23:21,345 --> 00:23:23,233
author and price

510
00:23:23,233 --> 00:23:25,852
because the get methods in the book class

511
00:23:25,852 --> 00:23:29,397
are matching the names of the parameters

512
00:23:29,397 --> 00:23:31,456
that I've specified here.

513
00:23:31,456 --> 00:23:34,571
And I don't know how many
more SQL statements I need.

514
00:23:34,571 --> 00:23:37,803
We have one defined
for that one, that one,

515
00:23:37,803 --> 00:23:39,126
and the create method.

516
00:23:39,126 --> 00:23:41,120
We'll need one for the delete,

517
00:23:41,120 --> 00:23:43,925
and that will be our last SQL statement.

518
00:23:43,925 --> 00:23:47,317
So we have a delete

519
00:23:47,317 --> 00:23:51,221
this is going to be delete from book

520
00:23:51,221 --> 00:23:55,029
where the ISBN matches.

521
00:23:55,029 --> 00:23:57,952
And again I use the syntax to
specify this is going to be

522
00:23:57,952 --> 00:24:01,227
a property inside the object

523
00:24:01,227 --> 00:24:04,427
that's being passed into the method here.

524
00:24:04,427 --> 00:24:08,655
So this is the delete book SQL statement.

525
00:24:09,642 --> 00:24:12,959
And a book will be passed in.

526
00:24:12,959 --> 00:24:16,095
myBatis will interrogate that object

527
00:24:16,095 --> 00:24:19,349
to find the ISBN value to plug in.

528
00:24:19,349 --> 00:24:23,637
I think I just need to
import the delete statement.

529
00:24:23,637 --> 00:24:26,549
Now, I do need one further statement

530
00:24:26,549 --> 00:24:28,959
because myBatis isn't intelligent enough

531
00:24:28,959 --> 00:24:31,743
to automatically create the tables.

532
00:24:31,743 --> 00:24:33,461
If the tables don't already exist,

533
00:24:33,461 --> 00:24:35,669
I want them to be created.

534
00:24:35,669 --> 00:24:39,530
So, going to do this
via an update statement.

535
00:24:39,530 --> 00:24:41,599
I don't think there's a special annotation

536
00:24:41,599 --> 00:24:43,754
for creating tables.

537
00:24:43,754 --> 00:24:47,641
So this is just going to
be a create table book.

538
00:24:49,226 --> 00:24:51,785
And I'm sorry if this SQL
is a little bit boring

539
00:24:51,785 --> 00:24:55,615
but I wanted to type
all of this in manually

540
00:24:55,615 --> 00:24:58,612
so you could see every step along the way.

541
00:24:58,612 --> 00:25:01,002
So we need to create an ISBN column,

542
00:25:01,002 --> 00:25:02,670
a title column.

543
00:25:04,521 --> 00:25:08,087
And I'm just giving these

544
00:25:08,087 --> 00:25:09,266
basic settings.

545
00:25:09,266 --> 00:25:13,143
An author column which
will make a voucher.

546
00:25:13,143 --> 00:25:16,565
And I'll make the price
column be a double.

547
00:25:18,232 --> 00:25:21,082
Now the good thing about this statement

548
00:25:21,082 --> 00:25:22,917
is that it's not going to return anything

549
00:25:22,917 --> 00:25:25,029
so we can make it void.

550
00:25:25,029 --> 00:25:27,397
And it doesn't take any parameters.

551
00:25:27,397 --> 00:25:29,946
So it's parameter-less.

552
00:25:29,946 --> 00:25:31,646
So as I said in the introduction,

553
00:25:31,646 --> 00:25:33,400
my aim here isn't to teach you

554
00:25:33,400 --> 00:25:36,440
the deep details of myBatis.

555
00:25:36,440 --> 00:25:39,885
But I hope you can see
the general flavor here is

556
00:25:39,885 --> 00:25:42,157
it's almost like we
have a config file here

557
00:25:42,157 --> 00:25:45,688
containing our SQL statements.

558
00:25:45,688 --> 00:25:49,122
And clearly, myBatis is
going to be doing some magic

559
00:25:49,122 --> 00:25:51,469
to convert the results

560
00:25:51,469 --> 00:25:53,741
to and from the SQL.

561
00:25:53,741 --> 00:25:55,512
If you prefer to have these statements

562
00:25:55,512 --> 00:25:57,016
outside of your code then,

563
00:25:57,016 --> 00:26:01,133
as I mentioned, you can
put them in an XML file.

564
00:26:01,133 --> 00:26:03,042
Once I've defined this interface,

565
00:26:03,042 --> 00:26:04,504
the last piece of housekeeping is

566
00:26:04,504 --> 00:26:06,808
we need to declare this mapper

567
00:26:06,808 --> 00:26:09,848
in the application.xml file.

568
00:26:09,848 --> 00:26:10,936
And it's quite simple really,

569
00:26:10,936 --> 00:26:14,466
we just create a bean for the mapper.

570
00:26:14,466 --> 00:26:17,304
So I'm going to call
this bean the bookmapper.

571
00:26:17,304 --> 00:26:19,704
But the odd thing here is

572
00:26:19,704 --> 00:26:22,437
I can't put anything in for the class name

573
00:26:22,437 --> 00:26:25,157
because we haven't created a class.

574
00:26:25,157 --> 00:26:27,883
We've only created an interface.

575
00:26:27,883 --> 00:26:31,635
It's effectively going to be myBatis' job

576
00:26:31,635 --> 00:26:33,646
to create on the fly

577
00:26:33,646 --> 00:26:37,352
an implementation of
that mapper interface.

578
00:26:37,352 --> 00:26:40,377
So, where given, it's another
one of these proxy classes

579
00:26:40,377 --> 00:26:43,044
if you're familiar with the proxy jargon

580
00:26:43,044 --> 00:26:44,835
that we used before.

581
00:26:44,835 --> 00:26:47,907
We plug into here a stock class

582
00:26:47,907 --> 00:26:50,072
from Spring-myBatis.

583
00:26:50,072 --> 00:26:51,410
And the class is

584
00:26:51,410 --> 00:26:56,146
org.myBatis.spring.mapper.mapperfactorybean.

585
00:27:00,355 --> 00:27:04,419
Another one of those slightly
overly complex class names.

586
00:27:04,419 --> 00:27:05,132
But as I say,

587
00:27:05,132 --> 00:27:08,396
it's job is to take the
interface that we've just written

588
00:27:08,396 --> 00:27:11,628
and it creates an
implementation of that interface

589
00:27:11,628 --> 00:27:15,223
that can do all of the SQL magic.

590
00:27:15,223 --> 00:27:18,241
We need to specify two properties.

591
00:27:18,241 --> 00:27:19,610
The first property

592
00:27:20,875 --> 00:27:23,545
the name is mapper interface.

593
00:27:24,868 --> 00:27:27,743
And for the value, very easy.

594
00:27:27,743 --> 00:27:30,805
This is just going to be
the fully qualified name

595
00:27:30,805 --> 00:27:33,461
of our interface.

596
00:27:33,461 --> 00:27:36,910
So we need to specify the
package that it lives in.

597
00:27:39,338 --> 00:27:41,056
Followed by,

598
00:27:41,056 --> 00:27:43,327
I might as well type the name in manually

599
00:27:43,327 --> 00:27:45,804
bookSQLmapper.

600
00:27:47,720 --> 00:27:49,949
There is then a further property

601
00:27:49,949 --> 00:27:54,434
we have to hook in the
SQL Session Factory.

602
00:27:54,434 --> 00:27:58,109
You could do this using
autowire if you prefer.

603
00:27:58,109 --> 00:28:02,152
The property name is SQL Session Factory.

604
00:28:02,152 --> 00:28:05,032
And we're going to refer to the bean

605
00:28:05,032 --> 00:28:06,677
that we created earlier.

606
00:28:09,478 --> 00:28:11,675
Now I know that when
I'm talking through this

607
00:28:11,675 --> 00:28:13,787
for the first time it can sometimes feel

608
00:28:13,787 --> 00:28:15,558
a little bit long-winded and difficult.

609
00:28:15,558 --> 00:28:18,854
But really the work we've
done has been quite simple.

610
00:28:18,854 --> 00:28:21,200
We've just created some SQL Statements

611
00:28:21,200 --> 00:28:24,592
and associated them with method names,

612
00:28:24,592 --> 00:28:28,816
and then we've declared
that mapper here in the XML.

613
00:28:28,816 --> 00:28:30,747
And one we've done that

614
00:28:30,747 --> 00:28:32,742
that's the hard work out of the way.

615
00:28:32,742 --> 00:28:36,336
I absolutely adore what comes next.

616
00:28:36,336 --> 00:28:37,872
Here in our DAO,

617
00:28:37,872 --> 00:28:40,219
which is of course where
we're doing the work,

618
00:28:40,219 --> 00:28:43,408
what we do is we declare as an attribute

619
00:28:43,408 --> 00:28:48,113
an instance of our book SQL mapper.

620
00:28:48,113 --> 00:28:51,472
And I'm going to call the object mapper.

621
00:28:51,472 --> 00:28:54,138
Now it depends on whether
you're using autowiring

622
00:28:54,138 --> 00:28:57,349
or whether you're using manual wiring.

623
00:28:57,349 --> 00:28:59,109
If you're using manual wiring

624
00:28:59,109 --> 00:29:02,405
then you would just inject as a property

625
00:29:02,405 --> 00:29:05,914
the mapper that we just
created in the XML file.

626
00:29:05,914 --> 00:29:07,728
Or if you're using autowiring

627
00:29:07,728 --> 00:29:11,440
then we can just annotate
it with autowired.

628
00:29:11,440 --> 00:29:14,523
Now once the mapper has been injected.

629
00:29:14,523 --> 00:29:17,125
And now for the big dramatic flourish.

630
00:29:17,125 --> 00:29:18,522
Here's my all books method,

631
00:29:18,522 --> 00:29:22,745
and I want to execute that SQL statement.

632
00:29:22,745 --> 00:29:24,263
And I can call,

633
00:29:24,263 --> 00:29:28,093
this is going to be the find all books

634
00:29:28,093 --> 00:29:29,734
SQL statements.

635
00:29:30,748 --> 00:29:33,900
And even though we haven't
written that method

636
00:29:33,900 --> 00:29:36,182
we only declared it in the interface,

637
00:29:36,182 --> 00:29:37,996
it will be available for us

638
00:29:37,996 --> 00:29:41,409
and we can return the value from it.

639
00:29:41,409 --> 00:29:42,565
And it makes the DAO

640
00:29:42,565 --> 00:29:45,605
an absolute JITer code

641
00:29:45,605 --> 00:29:47,828
because now I can

642
00:29:49,648 --> 00:29:51,162
in less than a minute probably

643
00:29:51,162 --> 00:29:53,040
this is Find by ISBN

644
00:29:53,040 --> 00:29:57,296
and calling the ISBN SQL statement.

645
00:29:57,296 --> 00:29:59,450
I really should deal with the case

646
00:29:59,450 --> 00:30:01,818
if no books are returned from there.

647
00:30:01,818 --> 00:30:04,144
But I think I'll leave
that as an exercise for you

648
00:30:04,144 --> 00:30:08,880
because the objective here
is to get a feel for myBatis.

649
00:30:08,880 --> 00:30:10,643
For the create method,

650
00:30:12,484 --> 00:30:14,137
I'm just going to call the mapper

651
00:30:14,137 --> 00:30:17,171
and call the create book SQL statement.

652
00:30:19,513 --> 00:30:21,256
For the delete,

653
00:30:22,937 --> 00:30:24,019
same thing.

654
00:30:27,939 --> 00:30:30,093
Passing a now redundant book.

655
00:30:30,093 --> 00:30:31,885
And one more.

656
00:30:31,885 --> 00:30:33,874
This is find all books by author.

657
00:30:38,807 --> 00:30:41,335
Find by author SQL statement,

658
00:30:41,335 --> 00:30:43,127
passing in the author.

659
00:30:43,127 --> 00:30:45,890
And that's the DAO coded.

660
00:30:45,890 --> 00:30:48,418
There is one further method
I need to add to here

661
00:30:48,418 --> 00:30:51,714
and that's that create tables method

662
00:30:51,714 --> 00:30:53,207
which I'm not going to call.

663
00:30:53,207 --> 00:30:56,717
I'm going to ask Spring
to call this automatically

664
00:30:56,717 --> 00:30:58,717
when this object is instantiated.

665
00:30:59,895 --> 00:31:03,666
So I'll call the method create tables.

666
00:31:03,666 --> 00:31:06,845
And it's just going to be
a case of using the mapper

667
00:31:06,845 --> 00:31:09,586
to call create tables.

668
00:31:09,586 --> 00:31:13,566
Now a little bit as in the
earlier chapter on JDBC

669
00:31:13,566 --> 00:31:16,243
this might throw an exception.

670
00:31:16,243 --> 00:31:19,101
And it will throw, as before,

671
00:31:19,101 --> 00:31:22,391
the standard Spring bad

672
00:31:22,391 --> 00:31:26,259
SQL grammar exception,

673
00:31:26,259 --> 00:31:28,669
if the table already exists.

674
00:31:28,669 --> 00:31:30,899
So we'll just assume that's okay.

675
00:31:30,899 --> 00:31:33,360
We'll assume

676
00:31:33,360 --> 00:31:36,817
the table already exists.

677
00:31:38,443 --> 00:31:40,107
If you've used manual wiring

678
00:31:40,107 --> 00:31:42,571
then where you've declared your DAO

679
00:31:42,571 --> 00:31:44,583
in the XML file,

680
00:31:44,583 --> 00:31:48,086
you will add in a reference
to an int x method.

681
00:31:48,086 --> 00:31:51,187
Since I'm using automatic wiring here,

682
00:31:51,187 --> 00:31:52,236
I use the

683
00:31:52,236 --> 00:31:56,849
at Post Construct annotation.

684
00:31:56,849 --> 00:31:58,823
So we'll run this method

685
00:31:58,823 --> 00:32:01,238
after the constructor.

686
00:32:01,238 --> 00:32:02,684
And my final job is

687
00:32:02,684 --> 00:32:05,191
I want to make this DAO be live.

688
00:32:05,191 --> 00:32:09,836
So I'm going to add the
repository annotation

689
00:32:09,836 --> 00:32:10,963
to the top.

690
00:32:10,963 --> 00:32:14,419
And I need to remember to remove it.

691
00:32:14,419 --> 00:32:18,504
I think the one that I
currently have in operation,

692
00:32:18,504 --> 00:32:23,074
yeah, it's the JPA
implementation of the DAO.

693
00:32:23,074 --> 00:32:26,151
So I need to remove the
annotation from there.

694
00:32:26,151 --> 00:32:28,541
As always, if you prefer
the manual wiring,

695
00:32:28,541 --> 00:32:31,741
then you would just change the XML file.

696
00:32:31,741 --> 00:32:34,023
So, we've achieved an awful lot there.

697
00:32:34,023 --> 00:32:36,285
I think I probably implemented that DAO

698
00:32:36,285 --> 00:32:40,040
in not much more than a minute.

699
00:32:40,040 --> 00:32:42,717
The interface took awhile to write

700
00:32:42,717 --> 00:32:45,245
but that's because the SQL is
always a little bit awkward,

701
00:32:45,245 --> 00:32:49,192
and I bet I have some
syntax errors in there.

702
00:32:49,192 --> 00:32:52,114
Anyway, as usual on these chapters

703
00:32:52,114 --> 00:32:54,930
I'm going to refresh the projects.

704
00:32:54,930 --> 00:32:57,106
And delete the existing database

705
00:32:57,106 --> 00:32:58,386
so that we're starting fresh.

706
00:32:58,386 --> 00:33:01,704
And I want to check that
the create tables works.

707
00:33:01,704 --> 00:33:03,970
And I'll close those files

708
00:33:03,970 --> 00:33:06,679
and go back to my clients.

709
00:33:06,679 --> 00:33:09,714
I can't remember what
state the clients is in.

710
00:33:09,714 --> 00:33:10,925
It depends on what I was doing

711
00:33:10,925 --> 00:33:12,317
at the end of the last chapter.

712
00:33:12,317 --> 00:33:15,080
Looks like I commented out the
registering of the new books.

713
00:33:15,080 --> 00:33:16,776
So, I'll bring that in.

714
00:33:16,776 --> 00:33:19,474
So, what we're expecting
to see as part of this run

715
00:33:19,474 --> 00:33:21,885
is that we create a new book.

716
00:33:21,885 --> 00:33:23,997
Then we find that book by the author,

717
00:33:23,997 --> 00:33:27,293
and it should be printed to the console.

718
00:33:27,293 --> 00:33:29,057
We'll let's see if this works.

719
00:33:32,178 --> 00:33:34,386
We'll I think that's really quite amazing.

720
00:33:34,386 --> 00:33:37,565
And I haven't rehearsed this chapter.

721
00:33:37,565 --> 00:33:41,277
And I'm not particularly
experienced with myBatis,

722
00:33:41,277 --> 00:33:43,272
and yet I managed to get it to run

723
00:33:44,822 --> 00:33:46,930
on the first time of asking.

724
00:33:46,930 --> 00:33:49,885
Whereas when I was working
with Hibernate and JPA

725
00:33:49,885 --> 00:33:52,093
I had several exceptions to get through

726
00:33:52,093 --> 00:33:54,141
before it all worked.

727
00:33:54,141 --> 00:33:55,411
So, that's really quite nice.

728
00:33:55,411 --> 00:33:58,109
So yes, the register
new book worked there.

729
00:33:58,109 --> 00:34:02,348
And it did output the author Gary Cornell.

730
00:34:02,348 --> 00:34:04,872
I think I ought to probably check

731
00:34:04,872 --> 00:34:06,610
some other things as well.

732
00:34:06,610 --> 00:34:09,629
I'm comment out the
registering of the new book.

733
00:34:09,629 --> 00:34:12,556
And we'll try to call

734
00:34:12,556 --> 00:34:15,826
the delete from stock method.

735
00:34:15,826 --> 00:34:18,706
Now, I do need to pass in
a full book object to that.

736
00:34:18,706 --> 00:34:21,900
So we'll need to

737
00:34:21,900 --> 00:34:23,531
find the book first.

738
00:34:26,791 --> 00:34:29,041
I'll get it by ISBN.

739
00:34:36,451 --> 00:34:39,666
Now, of course, that might throw

740
00:34:39,666 --> 00:34:42,066
a book not found exception

741
00:34:42,066 --> 00:34:45,174
even though I haven't yet
coded the logic for that.

742
00:34:47,496 --> 00:34:49,725
But the client doesn't know that.

743
00:34:49,725 --> 00:34:52,279
So, we'll have to handle that gracefully.

744
00:34:55,964 --> 00:34:57,164
Okay.

745
00:34:58,055 --> 00:35:01,890
I must have got some
errors in my SQL, surely.

746
00:35:04,061 --> 00:35:08,002
Okay, well that appeared okay.

747
00:35:08,002 --> 00:35:10,141
So, we can see from the AOP logging

748
00:35:10,141 --> 00:35:12,466
that it was calling all of the methods.

749
00:35:12,466 --> 00:35:14,674
It didn't output any books
at the end of the run

750
00:35:14,674 --> 00:35:17,277
so I will assume that means that

751
00:35:17,277 --> 00:35:19,852
the book was deleted from the database.

752
00:35:20,701 --> 00:35:23,915
I guess it's worth having a
peak in the database to check.

753
00:35:25,479 --> 00:35:28,295
Yep, certainly no books inserted there.

754
00:35:28,295 --> 00:35:31,531
And I think one method we haven't tried is

755
00:35:31,531 --> 00:35:32,657
get all books.

756
00:35:32,657 --> 00:35:36,266
So, let's reinstate the
registering of that book.

757
00:35:37,565 --> 00:35:39,538
I'll take that line out.

758
00:35:39,538 --> 00:35:41,739
And I'll change this to

759
00:35:43,143 --> 00:35:46,514
get entire catalog which
ultimately calls out

760
00:35:46,514 --> 00:35:49,110
get all books DAO method.

761
00:35:50,140 --> 00:35:51,063
Let's try that.

762
00:35:52,743 --> 00:35:53,511
And that looks good.

763
00:35:53,511 --> 00:35:56,370
It's returning the book we inserted.

764
00:35:56,370 --> 00:35:59,381
So, a very high level overview there

765
00:35:59,381 --> 00:36:01,543
of how myBatis works.

766
00:36:01,543 --> 00:36:04,285
We have more control in
that we have to write

767
00:36:04,285 --> 00:36:06,322
the SQL Statements.

768
00:36:06,322 --> 00:36:09,554
There's less magic going on under the hood

769
00:36:09,554 --> 00:36:12,615
but it's still doing an
awful lot of work for us

770
00:36:12,615 --> 00:36:14,493
in particular.

771
00:36:14,493 --> 00:36:16,402
For example here,

772
00:36:16,402 --> 00:36:20,167
it's converting the
columns into the values

773
00:36:20,167 --> 00:36:23,389
and the attributes in our objects.

774
00:36:23,389 --> 00:36:26,578
Now there is a lot more to
myBatis then we've seen here

775
00:36:26,578 --> 00:36:28,882
but I hope I've given you a flavor.

776
00:36:28,882 --> 00:36:31,463
And I hope I've also
shown you how easy it is

777
00:36:31,463 --> 00:36:34,568
to integrate myBatis with Spring.

778
00:36:34,568 --> 00:36:39,101
I guess the one sort of downside is that

779
00:36:39,101 --> 00:36:42,909
the integration is provided
by a third party project

780
00:36:42,909 --> 00:36:45,789
which you might be a
little bit nervous about.

781
00:36:45,789 --> 00:36:48,135
That third party project
is a first class part

782
00:36:48,135 --> 00:36:49,437
of myBatis though.

783
00:36:49,437 --> 00:36:53,377
So, hopefully that's not too bad.

784
00:36:53,377 --> 00:36:55,111
So, if you're new to myBatis

785
00:36:55,111 --> 00:36:56,625
you've seen what is now.

786
00:36:56,625 --> 00:36:59,687
And although I can't cover it in detail,

787
00:36:59,687 --> 00:37:03,122
one of the objectives
was to kind of sell it.

788
00:37:03,122 --> 00:37:07,058
I think a lot of projects
don't need the heavy complexity

789
00:37:07,058 --> 00:37:09,650
of JPA or Hibernate.

790
00:37:09,650 --> 00:37:12,039
We needed a 23-hour training course

791
00:37:12,039 --> 00:37:14,599
to get to grips with JPA.

792
00:37:14,599 --> 00:37:18,877
But with myBatis you
retain a lot of control.

793
00:37:18,877 --> 00:37:19,901
Don't get me wrong,

794
00:37:19,901 --> 00:37:23,378
it's still a powerful and elegant tool.

795
00:37:23,378 --> 00:37:25,469
Unfortunately, for one reason or another

796
00:37:25,469 --> 00:37:29,339
it doesn't seem to be
as popular as Hibernate.

797
00:37:29,339 --> 00:37:32,027
And recently, they rebranded to myBatis

798
00:37:32,027 --> 00:37:35,931
which has perhaps confused things further.

799
00:37:35,931 --> 00:37:38,715
Anyway, it is still supported in Spring

800
00:37:38,715 --> 00:37:42,130
using a third party integration library.

801
00:37:42,130 --> 00:37:44,754
I love writing those SQL mappers.

802
00:37:44,754 --> 00:37:47,026
It just feels so natural.

803
00:37:47,026 --> 00:37:49,159
Okay, you still have to write the SQL

804
00:37:49,159 --> 00:37:52,370
but a lot of projects appreciate that.

805
00:37:52,370 --> 00:37:54,642
It keeps you in control.

806
00:37:54,642 --> 00:37:58,493
I'd much rather do that
than use the JDBC template.

807
00:37:58,493 --> 00:37:59,933
As good as that template is

808
00:37:59,933 --> 00:38:03,325
it is not as elegant as myBatis.

809
00:38:03,325 --> 00:38:05,895
Well, that's it for ORM on the course.

810
00:38:05,895 --> 00:38:07,399
Just a few topics to go.

811
00:38:07,399 --> 00:38:11,228
And the next one was a
new addition to Spring 3.

812
00:38:11,228 --> 00:38:13,927
It's called the Expression Language,

813
00:38:13,927 --> 00:38:16,018
and that's coming up next.

814
00:38:16,018 --> 00:38:20,492
(bouncy jazz music)

1
00:00:00,105 --> 00:00:03,772
- [Voiceover] (theme music)

2
00:00:10,337 --> 00:00:12,580
In this chapter a quick overview

3
00:00:12,580 --> 00:00:15,413
of the Spring Expression Language.

4
00:00:16,401 --> 00:00:20,568
(mumbles) you will often see
this feature written as S-P-E-L

5
00:00:22,322 --> 00:00:26,780
and I don't know about anyone
else but I call it SpEL.

6
00:00:26,780 --> 00:00:30,160
The same as I did in Spring
three and it allows you

7
00:00:30,160 --> 00:00:33,660
to execute Java expressions from your XML.

8
00:00:34,619 --> 00:00:37,067
Now this could be really useful

9
00:00:37,067 --> 00:00:39,064
but it is specialist too

10
00:00:39,064 --> 00:00:41,136
as you'll see I could think of

11
00:00:41,136 --> 00:00:43,709
no use for it in our practical

12
00:00:43,709 --> 00:00:48,178
so we'll do some simple
hello world type examples.

13
00:00:48,178 --> 00:00:52,345
If you're using auto wiring
you'll find @value useful

14
00:00:53,849 --> 00:00:56,441
so we'll look at that as well.

15
00:00:56,441 --> 00:00:58,343
As this is quite a simple chapter

16
00:00:58,343 --> 00:01:01,426
we won't need a practical afterwards.

17
00:01:03,371 --> 00:01:06,786
This expression language
allows us to execute

18
00:01:06,786 --> 00:01:09,453
so called expressions in our XML

19
00:01:10,999 --> 00:01:14,855
in other words to calculate
values dynamically

20
00:01:14,855 --> 00:01:19,022
instead of having to hard code
static values into the file.

21
00:01:20,185 --> 00:01:23,316
To be honest now that
we are at Spring four

22
00:01:23,316 --> 00:01:26,806
this expression language
sometimes known as SpEL

23
00:01:26,806 --> 00:01:28,723
isn't used a lot often.

24
00:01:29,665 --> 00:01:31,329
At first people thought it was going to

25
00:01:31,329 --> 00:01:33,786
revolutionize Spring programming

26
00:01:33,786 --> 00:01:35,937
and we'd use it everywhere.

27
00:01:35,937 --> 00:01:37,556
But as far as I can tell it's really

28
00:01:37,556 --> 00:01:39,889
just found a few niche uses.

29
00:01:41,795 --> 00:01:46,204
As an example I can't think
of any particular use for SpEL

30
00:01:46,204 --> 00:01:49,482
on the sample project that
we're working with here

31
00:01:49,482 --> 00:01:52,482
on the Bookstore and the CRM system.

32
00:01:53,746 --> 00:01:56,022
In this chapter I'm just going to give you

33
00:01:56,022 --> 00:02:00,352
a basic overview of SpEL so
that you're familiar with it

34
00:02:00,352 --> 00:02:02,879
if you do meet it on a project.

35
00:02:02,879 --> 00:02:05,580
And when you go a bit further with Spring

36
00:02:05,580 --> 00:02:08,832
you might find some of the uses for it

37
00:02:08,832 --> 00:02:11,569
for example on our Spring MVC course

38
00:02:11,569 --> 00:02:14,437
we look at something called WebFlow

39
00:02:14,437 --> 00:02:16,004
and that's good for handling the case

40
00:02:16,004 --> 00:02:20,171
where you have complex multi-screen
processors on a website

41
00:02:21,415 --> 00:02:24,665
and the SpEL is used extensively there.

42
00:02:26,185 --> 00:02:28,056
This is just a basic overview

43
00:02:28,056 --> 00:02:30,580
so you are aware of what it is.

44
00:02:30,580 --> 00:02:33,424
Now I'm here back in our Bookstore

45
00:02:33,424 --> 00:02:38,293
and if you follow the
previous chapter on MyBatis

46
00:02:38,293 --> 00:02:42,460
I've reverted the BookStore
back to the JPA version

47
00:02:43,820 --> 00:02:47,067
notice I have my
EntityManagerFactory here.

48
00:02:47,067 --> 00:02:49,274
I've just done that because I think JPA

49
00:02:49,274 --> 00:02:52,107
is the more common usage of Spring

50
00:02:53,390 --> 00:02:57,556
and I'd rather go forward with
this version of the project.

51
00:02:57,556 --> 00:03:01,488
It's okay if you stick with
the MyBatis version though.

52
00:03:01,488 --> 00:03:04,559
Looking at our existing XML file

53
00:03:04,559 --> 00:03:06,445
you can see that all of the values

54
00:03:06,445 --> 00:03:09,181
that we've been entering so far

55
00:03:09,181 --> 00:03:11,682
have been typed into the XML

56
00:03:11,682 --> 00:03:14,396
in the form of static strings.

57
00:03:14,396 --> 00:03:17,885
Looking at the DataSource here for example

58
00:03:17,885 --> 00:03:21,112
the class name that we've typed in here

59
00:03:21,112 --> 00:03:22,862
is a hardcoded string

60
00:03:23,868 --> 00:03:28,259
and so to derive the class
name, the URL, the password

61
00:03:28,259 --> 00:03:31,879
and so on in fact all of the references

62
00:03:31,879 --> 00:03:35,962
and all of the values in
this file are hardcoded.

63
00:03:37,894 --> 00:03:42,574
Now in the old Spring
Spring one and Spring two

64
00:03:42,574 --> 00:03:45,642
the only way these values could change

65
00:03:45,642 --> 00:03:48,953
would be by changing the values ourselves

66
00:03:48,953 --> 00:03:51,967
and then rerunning the application.

67
00:03:51,967 --> 00:03:55,252
Now I should mention something
that we haven't covered

68
00:03:55,252 --> 00:03:57,967
is that you can put these strings

69
00:03:57,967 --> 00:04:01,185
into a separate properties file

70
00:04:01,185 --> 00:04:03,718
and then pull in those properties.

71
00:04:03,718 --> 00:04:05,688
I haven't covered how to do that

72
00:04:05,688 --> 00:04:08,909
but it's a fairly simple use
and you can find examples

73
00:04:08,909 --> 00:04:12,149
on how to do that in the reference manual.

74
00:04:12,149 --> 00:04:13,854
That would still be hardcoding

75
00:04:13,854 --> 00:04:18,780
we've just moved them one
step away from this file.

76
00:04:18,780 --> 00:04:20,896
From Spring three onwards though

77
00:04:20,896 --> 00:04:23,396
we can use expressions in here

78
00:04:25,101 --> 00:04:28,183
to dynamically calculate values

79
00:04:28,183 --> 00:04:31,770
at the point the beans are created.

80
00:04:31,770 --> 00:04:36,502
As I said our example
application is quite simple

81
00:04:36,502 --> 00:04:38,939
I really can't think of an example

82
00:04:38,939 --> 00:04:43,673
where I would use the
Spring Expression Language.

83
00:04:43,673 --> 00:04:45,200
I'm going to go for a very basic

84
00:04:45,200 --> 00:04:47,210
demonstration of this feature

85
00:04:47,210 --> 00:04:49,635
and then obviously you can use it as

86
00:04:49,635 --> 00:04:51,571
and when you see it fits.

87
00:04:51,571 --> 00:04:54,881
Now because I don't want to
damage any of the existing code

88
00:04:54,881 --> 00:04:56,774
I am going to carry on
working in this project

89
00:04:56,774 --> 00:05:00,245
because I think it's not worth
creating a whole new project

90
00:05:00,245 --> 00:05:01,878
just to demonstrate this.

91
00:05:01,878 --> 00:05:05,295
But I'm going to write a very quick class

92
00:05:06,253 --> 00:05:09,234
and to keep it completely
separated from everything else

93
00:05:09,234 --> 00:05:13,317
I'm going to put it in
package called speltesting

94
00:05:14,200 --> 00:05:15,982
I'm not even putting it under the

95
00:05:15,982 --> 00:05:18,790
com.VirtualPairProgrammers hierarchy.

96
00:05:18,790 --> 00:05:20,743
And because this is a made up example

97
00:05:20,743 --> 00:05:24,576
I'm just going to call
this class simplebeana.

98
00:05:26,189 --> 00:05:27,938
This really is going to be a simple class

99
00:05:27,938 --> 00:05:31,845
it's just going to have
a single String property

100
00:05:31,845 --> 00:05:34,219
I'm going to call it SimpleValue

101
00:05:34,219 --> 00:05:38,303
and we're going to do a dependency
injection into this value

102
00:05:38,303 --> 00:05:41,385
we'll do that the old-fashioned
way without annotations.

103
00:05:41,385 --> 00:05:45,552
I'm going to do a Source,
Generate Getters and Setters

104
00:05:48,389 --> 00:05:50,687
and I'm going to generate a getter

105
00:05:50,687 --> 00:05:53,789
and a setter for that attribute.

106
00:05:53,789 --> 00:05:56,391
Now I can do a regular
dependency injection

107
00:05:56,391 --> 00:06:00,752
into this bean through the
property called SimpleValue.

108
00:06:00,752 --> 00:06:03,427
I'm going to add the
declaration of that bean

109
00:06:03,427 --> 00:06:05,844
to the bottom of my XML file.

110
00:06:06,963 --> 00:06:09,512
I could create a brand
new XML file for this

111
00:06:09,512 --> 00:06:13,015
to keep it completely
separate but just for speed

112
00:06:13,015 --> 00:06:16,108
I'm going to add to my existing one

113
00:06:16,108 --> 00:06:19,525
testing of the Spring Expression Language

114
00:06:20,513 --> 00:06:23,511
and we're going all the
way back to basics here

115
00:06:23,511 --> 00:06:26,308
I'm going to declare this bean

116
00:06:26,308 --> 00:06:29,527
in the old-fashioned manual XML way

117
00:06:29,527 --> 00:06:32,877
and the class name was
I've forgotten already

118
00:06:32,877 --> 00:06:36,044
I think it was speltesting.simplebeana

119
00:06:37,846 --> 00:06:41,429
and we're going to use
dependency injection

120
00:06:43,778 --> 00:06:47,327
into the property called Simplevalue

121
00:06:47,327 --> 00:06:50,680
I use the autocomplete
there and for the value

122
00:06:50,680 --> 00:06:53,073
well as this is a made up example

123
00:06:53,073 --> 00:06:55,845
I'm not gonna do anything
important in there

124
00:06:55,845 --> 00:06:57,459
but just imagine that this is

125
00:06:57,459 --> 00:07:00,626
some kind of IMPORTANT BUSINESS value.

126
00:07:03,299 --> 00:07:06,382
Now I'm going to create a second bean

127
00:07:08,575 --> 00:07:10,558
and I'm not feeling very inspired

128
00:07:10,558 --> 00:07:14,943
so this one is going to
be called simplebeanb

129
00:07:14,943 --> 00:07:19,110
and it similarly is going to
have a very basic property

130
00:07:20,634 --> 00:07:22,884
let's call this SecondValue

131
00:07:25,213 --> 00:07:29,438
and just as before we'll have
a getter and a setter for it.

132
00:07:29,438 --> 00:07:32,411
I'm back to the XML in a very similar way

133
00:07:32,411 --> 00:07:36,244
we're going to declare
an instance of the bean

134
00:07:41,295 --> 00:07:45,191
this time simplebeanb
and I want to configure

135
00:07:45,191 --> 00:07:48,513
the property that I call SecondValue

136
00:07:48,513 --> 00:07:50,553
but now here is my problem.

137
00:07:50,553 --> 00:07:55,174
For some business reason the
value inside this property

138
00:07:55,174 --> 00:07:57,174
must be exactly the same

139
00:07:58,274 --> 00:08:01,240
as the value in the first bean

140
00:08:01,240 --> 00:08:04,407
the value here. Now until Spring three

141
00:08:05,592 --> 00:08:07,443
there are a couple of ways
I could have done this

142
00:08:07,443 --> 00:08:11,671
of course I could have just
copied and pasted the value

143
00:08:11,671 --> 00:08:15,096
which would not be a good idea at all

144
00:08:15,096 --> 00:08:17,216
but I suspect would probably be the way

145
00:08:17,216 --> 00:08:20,767
that most projects would have done it.

146
00:08:20,767 --> 00:08:23,547
Not desirable because it
would change one of the values

147
00:08:23,547 --> 00:08:25,817
we'd have to remember to change the other

148
00:08:25,817 --> 00:08:28,422
and we'd probably forget.

149
00:08:28,422 --> 00:08:30,516
I did mention properties files before

150
00:08:30,516 --> 00:08:32,306
and that would probably have been

151
00:08:32,306 --> 00:08:35,371
the only good way of doing
things before Spring three

152
00:08:35,371 --> 00:08:38,759
I could put the string into
an external properties file

153
00:08:38,759 --> 00:08:41,570
and pull it in from there which is okay

154
00:08:41,570 --> 00:08:44,501
but perhaps properties
files are a bit awkward

155
00:08:44,501 --> 00:08:47,975
to fiddle around with so
that's why we are here.

156
00:08:47,975 --> 00:08:51,642
Thanks to the modern
Spring Expression Language

157
00:08:51,642 --> 00:08:55,612
what we can do inside the quote marks here

158
00:08:55,612 --> 00:08:58,695
is we can essentially write Java code

159
00:09:00,638 --> 00:09:03,270
right here inside the XML

160
00:09:03,270 --> 00:09:06,853
as long as the Java code is evaluating

161
00:09:06,853 --> 00:09:08,936
to a result of some kind.

162
00:09:09,985 --> 00:09:14,429
Inside this value instead
of hardcoding this string

163
00:09:14,429 --> 00:09:16,846
I can write Java code such as

164
00:09:18,468 --> 00:09:20,301
I can call simplebeana

165
00:09:21,916 --> 00:09:24,996
that's just the objects
that we've created here

166
00:09:24,996 --> 00:09:28,413
and I can call the GetSimpleValue method.

167
00:09:30,923 --> 00:09:35,090
That's going to return the
value that we pasted in here

168
00:09:36,163 --> 00:09:37,945
now I can be absolutely sure that

169
00:09:37,945 --> 00:09:42,213
these two values will always be identical.

170
00:09:42,213 --> 00:09:46,934
Well actually I'm lying a
little bit this won't quite work

171
00:09:46,934 --> 00:09:49,629
I'll show you why I don't yet have

172
00:09:49,629 --> 00:09:52,462
a client application to test this.

173
00:09:53,815 --> 00:09:55,977
I don't really want to spoil

174
00:09:55,977 --> 00:09:58,656
my existing client application

175
00:09:58,656 --> 00:10:02,855
so I think what I'll do
inside the speltesting package

176
00:10:02,855 --> 00:10:07,022
I'm going to create a very
quick and dirty SpelClient

177
00:10:09,011 --> 00:10:13,203
I'm going to generate a
public static void main

178
00:10:13,203 --> 00:10:16,407
and I'll do this as quickly as possible

179
00:10:16,407 --> 00:10:20,157
the usual class path
XML application context.

180
00:10:25,456 --> 00:10:27,035
Now what I want to test here is

181
00:10:27,035 --> 00:10:30,868
I'm going to get an
instance of my simplebeanb

182
00:10:36,746 --> 00:10:39,829
and I want to find out what the value

183
00:10:41,316 --> 00:10:43,288
is inside GetSecondValue.

184
00:10:43,288 --> 00:10:45,827
Now although I'm not doing
any database operations

185
00:10:45,827 --> 00:10:48,188
in this client it is going to instantiate

186
00:10:48,188 --> 00:10:50,773
the connection pool
and all the rest of it.

187
00:10:50,773 --> 00:10:53,433
Just to be completely safe I'm going to

188
00:10:53,433 --> 00:10:56,972
close the factory at the end of the run.

189
00:10:56,972 --> 00:10:58,547
Now before I run it looks like

190
00:10:58,547 --> 00:11:01,047
I have an error in my XML file

191
00:11:03,230 --> 00:11:05,356
I probably introduced
the typo at the end here

192
00:11:05,356 --> 00:11:09,273
yes I didn't complete
the property SecondValue.

193
00:11:10,172 --> 00:11:13,288
That's all done now I should
be able to run this client

194
00:11:13,288 --> 00:11:14,673
and I think you can probably guess

195
00:11:14,673 --> 00:11:17,727
what's going to happen here.

196
00:11:17,727 --> 00:11:20,724
Yeah, it doesn't work
it's just printing out

197
00:11:20,724 --> 00:11:24,891
the literal expression of
simplebanda.GetSimpleValue.

198
00:11:26,075 --> 00:11:30,186
And of course Spring has
no way of knowing that

199
00:11:30,186 --> 00:11:34,480
we intended this to be Java
code that we're calling

200
00:11:34,480 --> 00:11:37,137
rather than a hardcoded string.

201
00:11:37,137 --> 00:11:41,485
In order to make the string
become a Spring expression

202
00:11:41,485 --> 00:11:45,652
we need to wrap it using
the symbol you can see here.

203
00:11:46,988 --> 00:11:49,061
Now it depends where you are in the world

204
00:11:49,061 --> 00:11:51,562
as to what you call that symbol

205
00:11:51,562 --> 00:11:54,855
in the U.K. we call it the hash symbol

206
00:11:54,855 --> 00:11:57,723
some people call it the pound symbol

207
00:11:57,723 --> 00:12:01,304
and sometimes it's called the gate symbol.

208
00:12:01,304 --> 00:12:05,018
Whatever you call it you need that symbol

209
00:12:05,018 --> 00:12:09,091
followed by curly brackets
and the curly brackets

210
00:12:09,091 --> 00:12:12,859
are going to wrap around
the entire expression

211
00:12:12,859 --> 00:12:14,739
so whenever you see this stretch here

212
00:12:14,739 --> 00:12:17,772
you'll know that you're working
with a Spring expression.

213
00:12:17,772 --> 00:12:21,362
And by the way I have just remembered

214
00:12:21,362 --> 00:12:25,252
if you did do the MyBatis
part of this course

215
00:12:25,252 --> 00:12:28,344
well I don't have the code for
that in this project anymore

216
00:12:28,344 --> 00:12:30,927
but I'll pull it up from my archive

217
00:12:30,927 --> 00:12:33,174
I just have it in Notepad here.

218
00:12:33,174 --> 00:12:36,454
You may have recognized that the values

219
00:12:36,454 --> 00:12:40,670
the dynamic values that we
were using in the annotations

220
00:12:40,670 --> 00:12:43,847
are in fact spring expressions.

221
00:12:43,847 --> 00:12:46,728
If you did that chapter then unwittingly

222
00:12:46,728 --> 00:12:50,242
you've already used the Spring expression.

223
00:12:50,242 --> 00:12:54,998
But anyway we need to see if
our Spring expression works

224
00:12:54,998 --> 00:12:57,081
or run that client again.

225
00:12:58,954 --> 00:13:01,941
Excellent! We're now seeing
the IMPORTANT BUSINESS value

226
00:13:01,941 --> 00:13:04,674
being reflected in the second bean.

227
00:13:04,674 --> 00:13:07,141
Now that you know that you can invoke

228
00:13:07,141 --> 00:13:10,786
Java expressions from within your XML file

229
00:13:10,786 --> 00:13:14,301
this is one of those things
where the uses of SpEL

230
00:13:14,301 --> 00:13:17,302
are just limited by your imagination.

231
00:13:17,302 --> 00:13:18,975
I'm going to strongly encourage you

232
00:13:18,975 --> 00:13:21,658
to check out the Spring reference manual

233
00:13:21,658 --> 00:13:24,067
at the time of recording at chapter seven

234
00:13:24,067 --> 00:13:26,546
but it's easy to find
there is a whole chapter

235
00:13:26,546 --> 00:13:29,769
devoted to the expression language.

236
00:13:29,769 --> 00:13:32,410
Now one of the problems I
think with the reference manual

237
00:13:32,410 --> 00:13:34,814
as it's currently written is that

238
00:13:34,814 --> 00:13:37,322
the examples that they begin with

239
00:13:37,322 --> 00:13:40,022
are showing you how you can execute

240
00:13:40,022 --> 00:13:44,673
these Spring expressions
from within Java code.

241
00:13:44,673 --> 00:13:46,586
And that's kind of useful it means that

242
00:13:46,586 --> 00:13:48,969
you can do some quite powerful things

243
00:13:48,969 --> 00:13:50,871
and it's a good way of experimenting

244
00:13:50,871 --> 00:13:54,256
inside a stand-alone clients application.

245
00:13:54,256 --> 00:13:56,794
But I'm not so keen on that because

246
00:13:56,794 --> 00:14:00,006
most uses I would say of
the expression language

247
00:14:00,006 --> 00:14:04,173
are in the XML file when you're
working on bean definitions.

248
00:14:05,095 --> 00:14:07,318
I'd probably recommend that you skipped

249
00:14:07,318 --> 00:14:09,957
to the section called expression support

250
00:14:09,957 --> 00:14:12,158
for defining bean definitions

251
00:14:12,158 --> 00:14:16,075
and there are some good examples
of how to use it in there.

252
00:14:16,075 --> 00:14:18,348
But there is one thing
that I'd like to focus on

253
00:14:18,348 --> 00:14:21,126
because it was one of the
things that confused me

254
00:14:21,126 --> 00:14:23,965
it's quite a strange piece of syntax

255
00:14:23,965 --> 00:14:26,959
and the syntax is if you want to

256
00:14:26,959 --> 00:14:29,816
call a static method on a class.

257
00:14:29,816 --> 00:14:31,777
I'm going to show you an example

258
00:14:31,777 --> 00:14:33,333
let's switch to Eclipse.

259
00:14:33,333 --> 00:14:36,878
I'm going to go back to my simplebeanb

260
00:14:36,878 --> 00:14:39,738
where so far I just have this SecondValue

261
00:14:39,738 --> 00:14:42,738
but I'm going to add in a new property now

262
00:14:42,738 --> 00:14:46,905
and this is going to be an
integer called RandomValue

263
00:14:48,257 --> 00:14:51,257
and as before I will set up a getter

264
00:14:52,236 --> 00:14:54,497
and setter for that property

265
00:14:54,497 --> 00:14:56,953
and you can probably guess
now my requirements is

266
00:14:56,953 --> 00:15:00,861
I would like this value
to be a RandomValue

267
00:15:00,861 --> 00:15:04,436
that's different every
time the application runs.

268
00:15:04,436 --> 00:15:08,565
Now I wouldn't be unable to
do that in the old Spring

269
00:15:08,565 --> 00:15:11,800
or at least there probably were techniques

270
00:15:11,800 --> 00:15:13,396
but it would have been relying on

271
00:15:13,396 --> 00:15:16,120
some fairly advanced configuration.

272
00:15:16,120 --> 00:15:19,195
But you know now that I can access

273
00:15:19,195 --> 00:15:22,445
directly from the XML this RandomValue.

274
00:15:23,508 --> 00:15:25,865
And you can probably guess
that there is going to be

275
00:15:25,865 --> 00:15:30,844
some way of executing Java in
here to generate a RandomValue

276
00:15:30,844 --> 00:15:32,554
and I would like that RandomValue

277
00:15:32,554 --> 00:15:35,804
to be between the values of one and 10.

278
00:15:37,041 --> 00:15:39,189
We can use the expression
and so it's going to be

279
00:15:39,189 --> 00:15:41,689
the gate, pound or hash symbol

280
00:15:42,672 --> 00:15:45,391
and I can put some kind
of expression in here.

281
00:15:45,391 --> 00:15:46,444
Now I don't know if you know

282
00:15:46,444 --> 00:15:50,025
but one way of generating
random numbers in standard Java

283
00:15:50,025 --> 00:15:52,858
is to call the Math.random method.

284
00:15:55,540 --> 00:15:59,557
It is in a package but it's
in the java.lang package

285
00:15:59,557 --> 00:16:03,474
so you don't actually
need to have this prefix.

286
00:16:04,381 --> 00:16:06,118
I think I'm just going to leave it in

287
00:16:06,118 --> 00:16:08,689
just to kinda make it
clear what I'm doing here

288
00:16:08,689 --> 00:16:13,093
I'm calling a class from
the standard Java library.

289
00:16:13,093 --> 00:16:17,260
Now that method returns a
number between zero and one

290
00:16:18,154 --> 00:16:20,532
and it's actually a double

291
00:16:20,532 --> 00:16:24,532
so I could take that value
and multiply it by 10

292
00:16:26,582 --> 00:16:31,445
which I think will bring it
into the range of zero to nine.

293
00:16:31,445 --> 00:16:34,088
And now I think I would
have to add a one onto that

294
00:16:34,088 --> 00:16:36,088
and I guess I ought to put round brackets

295
00:16:36,088 --> 00:16:39,120
to make it a little bit clearer

296
00:16:39,120 --> 00:16:42,973
barely routine I promised
you that you'd call Java

297
00:16:42,973 --> 00:16:45,170
inside these expressions.

298
00:16:45,170 --> 00:16:48,236
We go back to the clients this time around

299
00:16:48,236 --> 00:16:51,819
I'm going to call the
GetRandomValue method

300
00:16:53,243 --> 00:16:54,975
and I'm going to give it a run.

301
00:16:54,975 --> 00:16:57,142
Now it's not going to work

302
00:16:58,525 --> 00:17:00,616
and indeed it didn't.

303
00:17:00,616 --> 00:17:05,214
Let's see if we can make
sense of this exception

304
00:17:05,214 --> 00:17:08,248
well it's saying that
field or property Java

305
00:17:08,248 --> 00:17:11,081
cannot be found on objects of type

306
00:17:12,284 --> 00:17:16,216
and then some class name
that we've never seen before.

307
00:17:16,216 --> 00:17:19,507
And to be honest I really
couldn't make any sense

308
00:17:19,507 --> 00:17:23,463
of these exceptions (mumbles) at all.

309
00:17:23,463 --> 00:17:25,796
It does appear to be choking

310
00:17:26,915 --> 00:17:29,748
on my reference here to java.lang.

311
00:17:30,928 --> 00:17:34,530
Now there is a clue here
in the reference manual

312
00:17:34,530 --> 00:17:36,236
and I have to admit here

313
00:17:36,236 --> 00:17:38,274
I don't normally do this on our courses

314
00:17:38,274 --> 00:17:41,305
but the example I've just
been doing in Eclipse

315
00:17:41,305 --> 00:17:43,315
is pretty much the example I have here

316
00:17:43,315 --> 00:17:44,606
in the reference manual.

317
00:17:44,606 --> 00:17:48,490
And the answer can be found right here

318
00:17:48,490 --> 00:17:52,407
at this rather strange
syntax referred to here.

319
00:17:53,874 --> 00:17:57,590
And it's when you call a static method

320
00:17:57,590 --> 00:18:01,882
for some reason you have to
proceed the name of the class

321
00:18:01,882 --> 00:18:06,049
that you're calling from with
the letter T the capital T

322
00:18:07,180 --> 00:18:09,051
followed by in round brackets

323
00:18:09,051 --> 00:18:12,316
the name of the class
that you're working on.

324
00:18:12,316 --> 00:18:15,733
I'm told that that T here stands for type

325
00:18:17,062 --> 00:18:19,932
but and I really can't explain this.

326
00:18:19,932 --> 00:18:21,287
I first covered this back on our

327
00:18:21,287 --> 00:18:23,743
Spring three upgrade course
about three years ago

328
00:18:23,743 --> 00:18:27,406
and I still don't understand
the terminology here

329
00:18:27,406 --> 00:18:30,660
but it's just one of those
things that we have to do.

330
00:18:30,660 --> 00:18:34,913
Let's give that a try
then so it's the capital T

331
00:18:34,913 --> 00:18:37,306
and well it's a little
bit awkward this actually

332
00:18:37,306 --> 00:18:38,669
it needs to be a capital T

333
00:18:38,669 --> 00:18:41,706
I've put that inside my round brackets

334
00:18:41,706 --> 00:18:45,313
but then I know I need
another set of round brackets

335
00:18:45,313 --> 00:18:47,676
just around the class name.

336
00:18:47,676 --> 00:18:51,418
It took me a long time to work that out

337
00:18:51,418 --> 00:18:55,009
it's not the prettiest syntax in the world

338
00:18:55,009 --> 00:18:58,342
but it would be good to see if it works.

339
00:19:00,639 --> 00:19:03,889
Not good an exception and very quickly

340
00:19:03,889 --> 00:19:07,033
I can see by focusing down here

341
00:19:07,033 --> 00:19:09,929
that there is a very strange problem here

342
00:19:09,929 --> 00:19:13,068
because the code that I have just written

343
00:19:13,068 --> 00:19:16,570
works perfectly well on the
first edition of this course

344
00:19:16,570 --> 00:19:19,892
or at least on the Spring
three upgrade module.

345
00:19:19,892 --> 00:19:23,279
On that edition of the
course Spring was able to

346
00:19:23,279 --> 00:19:27,446
kind of silently convert
the double into an integer

347
00:19:30,633 --> 00:19:32,807
and I don't know why but clearly

348
00:19:32,807 --> 00:19:36,477
something has changed between
Spring three and four.

349
00:19:36,477 --> 00:19:39,792
What's effectively happening
if you can't follow this

350
00:19:39,792 --> 00:19:42,209
I'll go back to my expression

351
00:19:44,013 --> 00:19:47,513
the Math.random is creating a double value

352
00:19:49,133 --> 00:19:51,604
and they're multiplying
it by 10 and adding one

353
00:19:51,604 --> 00:19:54,837
of course is keeping it as a double.

354
00:19:54,837 --> 00:19:58,032
But then it can put the
double into the RandomValue

355
00:19:58,032 --> 00:20:02,522
because our RandomValue was
supposed to be an integer.

356
00:20:02,522 --> 00:20:05,572
(mumbles) make sense really
probably should be an error

357
00:20:05,572 --> 00:20:07,934
but certainly in the previous versions

358
00:20:07,934 --> 00:20:10,320
of Spring this did work.

359
00:20:10,320 --> 00:20:12,687
I'm going to need to fix this somehow

360
00:20:12,687 --> 00:20:16,179
and I have spent some time off
camera thinking about this.

361
00:20:16,179 --> 00:20:17,652
I think there are two ways

362
00:20:17,652 --> 00:20:20,168
of solving the problem to be honest

363
00:20:20,168 --> 00:20:23,421
and I think I would probably say

364
00:20:23,421 --> 00:20:26,148
the cleanest way of doing things

365
00:20:26,148 --> 00:20:29,778
is by changing the sentence to a double

366
00:20:29,778 --> 00:20:31,695
and so I could do this.

367
00:20:34,233 --> 00:20:36,310
Now remember we don't want to double

368
00:20:36,310 --> 00:20:39,471
we want some values between one and 10.

369
00:20:39,471 --> 00:20:42,605
Remember Spring is calling the Set method

370
00:20:42,605 --> 00:20:45,258
but it's our client code
that's calling the Get method

371
00:20:45,258 --> 00:20:47,758
so what we could do on the fly

372
00:20:48,602 --> 00:20:50,615
is convert this into an integer.

373
00:20:50,615 --> 00:20:51,917
And there are several ways

374
00:20:51,917 --> 00:20:54,089
of converting this double into an int

375
00:20:54,089 --> 00:20:55,908
but I think this is where we just need

376
00:20:55,908 --> 00:20:58,325
to do a typecast right there.

377
00:20:59,284 --> 00:21:01,987
We're storing the random value as a double

378
00:21:01,987 --> 00:21:03,761
but each time it's returned

379
00:21:03,761 --> 00:21:06,399
it will go back as an integer.

380
00:21:06,399 --> 00:21:09,232
I can check that now on our client

381
00:21:10,581 --> 00:21:13,081
I'll have an eight there

382
00:21:13,081 --> 00:21:14,908
well it run is the important thing

383
00:21:14,908 --> 00:21:17,991
so there was an eight there and a ten

384
00:21:20,682 --> 00:21:24,752
and a three that looks
pretty random to me.

385
00:21:24,752 --> 00:21:28,049
That certainly works but you
might have been disappointed

386
00:21:28,049 --> 00:21:31,976
that we didn't handle it
here in the expression

387
00:21:31,976 --> 00:21:34,127
well we can handle it in the expression

388
00:21:34,127 --> 00:21:36,969
it's just that the only
way I can think of doing it

389
00:21:36,969 --> 00:21:38,958
just looks fairly ugly.

390
00:21:38,958 --> 00:21:41,907
But let's try it I'll
go back into the bean

391
00:21:41,907 --> 00:21:42,961
and return all these back

392
00:21:42,961 --> 00:21:46,264
I'm just using the Undo feature

393
00:21:46,264 --> 00:21:48,308
to return back to where we were

394
00:21:48,308 --> 00:21:51,170
when it was integer-based.

395
00:21:51,170 --> 00:21:54,301
Of course because I can call any Java code

396
00:21:54,301 --> 00:21:58,707
I can do the rounding
off here in the Java code

397
00:21:58,707 --> 00:22:02,040
and one way that I discovered off camera

398
00:22:03,221 --> 00:22:05,041
is to effectively what we want to do is

399
00:22:05,041 --> 00:22:07,958
we want to take the results of this

400
00:22:08,966 --> 00:22:12,466
the whole expression in the round brackets

401
00:22:13,941 --> 00:22:16,924
and remove the decimal places from it.

402
00:22:16,924 --> 00:22:18,582
Well there's several ways of doing this

403
00:22:18,582 --> 00:22:21,306
and I have struggled with this off camera.

404
00:22:21,306 --> 00:22:23,922
But basically you have the same problem

405
00:22:23,922 --> 00:22:25,726
in regular Java anyways

406
00:22:25,726 --> 00:22:28,292
so I'm sure many of
you will have struggled

407
00:22:28,292 --> 00:22:30,591
with this kind of thing in the past.

408
00:22:30,591 --> 00:22:34,207
Now one way of converting
a double into an integer

409
00:22:34,207 --> 00:22:38,207
is to create a new instance
of the double class.

410
00:22:39,122 --> 00:22:42,207
Now that's one of those wrapper classes

411
00:22:42,207 --> 00:22:45,683
and I can pass in the primitive double

412
00:22:45,683 --> 00:22:48,500
that we generated in the round brackets.

413
00:22:48,500 --> 00:22:50,588
And the key thing about that is

414
00:22:50,588 --> 00:22:52,732
and as I say this won't be nice

415
00:22:52,732 --> 00:22:55,407
I'm going to wrap the
whole of the creation

416
00:22:55,407 --> 00:22:58,574
of the new double into round brackets.

417
00:23:00,384 --> 00:23:03,841
Now I've effectively
converted the double primitive

418
00:23:03,841 --> 00:23:07,546
into an object and
therefore I can call methods

419
00:23:07,546 --> 00:23:11,713
and one of the methods on
the double class is intValue.

420
00:23:12,681 --> 00:23:17,123
Now it really isn't a nice
expression I must admit

421
00:23:17,123 --> 00:23:19,542
there are other ways of doing it

422
00:23:19,542 --> 00:23:22,469
but really every way I
found is equally ugly.

423
00:23:22,469 --> 00:23:26,177
It would be interesting to see if it works

424
00:23:26,177 --> 00:23:27,959
well it did run and I got a six

425
00:23:27,959 --> 00:23:29,824
which I'm assuming is a RandomValue

426
00:23:29,824 --> 00:23:32,074
let's try again minus seven

427
00:23:33,562 --> 00:23:35,972
and a two looks random to me.

428
00:23:35,972 --> 00:23:39,229
My worry would be do I need
this plus one on there?

429
00:23:39,229 --> 00:23:40,497
Am I always going to get

430
00:23:40,497 --> 00:23:43,578
an equally distributed
range from one to 10?

431
00:23:43,578 --> 00:23:46,927
Well, I'll leave that up to
you in some kind of a unit test

432
00:23:46,927 --> 00:23:50,145
but I'm reasonably happy
with the expression there

433
00:23:50,145 --> 00:23:53,455
I think possibly if this were real life

434
00:23:53,455 --> 00:23:56,779
I may well have gone for
the previous solution

435
00:23:56,779 --> 00:24:00,434
where I convert the double to
an integer here in the class

436
00:24:00,434 --> 00:24:02,517
but it's entirely up to you.

437
00:24:02,517 --> 00:24:05,261
I know that doesn't look
particularly pleasant

438
00:24:05,261 --> 00:24:08,555
but I hope you at least get
a feel for the kind of power

439
00:24:08,555 --> 00:24:12,222
that you can get out of these expressions.

440
00:24:12,222 --> 00:24:14,270
There is one thing that
I forgot to mention

441
00:24:14,270 --> 00:24:17,937
I'm going to go back
to the SecondValue here

442
00:24:18,863 --> 00:24:22,696
let's rework the client
to call GetSecondValue

443
00:24:25,667 --> 00:24:29,544
remember this is returning the same value

444
00:24:29,544 --> 00:24:32,231
that's in the first bane.

445
00:24:32,231 --> 00:24:34,472
Yeah, that's what we're seeing there.

446
00:24:34,472 --> 00:24:37,181
Now if you're calling a Get method

447
00:24:37,181 --> 00:24:41,399
then you can simplify the
notation a little bit.

448
00:24:41,399 --> 00:24:45,447
You can remove the get
and I'm going to convert

449
00:24:45,447 --> 00:24:48,114
the capital S into a lowercase s

450
00:24:50,371 --> 00:24:53,251
and I can remove the round brackets

451
00:24:53,251 --> 00:24:54,710
I guess you might be familiar

452
00:24:54,710 --> 00:24:57,878
with that kind of notation in Java.

453
00:24:57,878 --> 00:25:00,104
What's going to happen behind the scenes

454
00:25:00,104 --> 00:25:03,223
is Java recognizes this as a property

455
00:25:03,223 --> 00:25:05,697
and it will implicitly convert it

456
00:25:05,697 --> 00:25:07,447
into GetSimpleValue.

457
00:25:08,495 --> 00:25:10,966
This will still be calling the

458
00:25:10,966 --> 00:25:13,633
GetSimpleValue method on bean a.

459
00:25:15,016 --> 00:25:17,120
Although it looks like we're kind of

460
00:25:17,120 --> 00:25:20,874
directly accessing the value we're not

461
00:25:20,874 --> 00:25:22,957
it will call the setter

462
00:25:22,957 --> 00:25:25,624
and I'm just going to prove that

463
00:25:27,821 --> 00:25:29,404
calling the getter.

464
00:25:34,957 --> 00:25:35,969
And there is the proof that

465
00:25:35,969 --> 00:25:38,506
the getter is still being called.

466
00:25:38,506 --> 00:25:41,407
However the syntax for calling the getter

467
00:25:41,407 --> 00:25:44,418
is just a little bit more concise

468
00:25:44,418 --> 00:25:47,835
and it feels a little
bit less like Java code.

469
00:25:47,835 --> 00:25:49,384
I've shown you now how to use

470
00:25:49,384 --> 00:25:53,134
these new Spring
expressions in the XML file.

471
00:25:54,352 --> 00:25:56,460
But of course it might be that you prefer

472
00:25:56,460 --> 00:26:00,169
the auto wiring approach
using the annotations.

473
00:26:00,169 --> 00:26:01,670
Let's assume we're in the situation

474
00:26:01,670 --> 00:26:04,752
where instead of declaring
the beans here in the XML

475
00:26:04,752 --> 00:26:07,028
we'll use the annotations instead.

476
00:26:07,028 --> 00:26:08,923
Now before I do that I want to

477
00:26:08,923 --> 00:26:12,209
preserve this complex expression

478
00:26:12,209 --> 00:26:15,403
so I'm just going to put
that onto the clipboard.

479
00:26:15,403 --> 00:26:16,821
But let's say that we don't want

480
00:26:16,821 --> 00:26:18,893
to create the beans here in the XML

481
00:26:18,893 --> 00:26:22,251
we want them to be
automatically picked up.

482
00:26:22,251 --> 00:26:25,694
You'll know how to do this
now from previous chapters

483
00:26:25,694 --> 00:26:29,861
this is going to become a
component and so is bean b

484
00:26:36,139 --> 00:26:39,980
but the problem is now
going back to bean a

485
00:26:39,980 --> 00:26:42,782
that we can't auto wire this simple value

486
00:26:42,782 --> 00:26:46,600
but we want to provide a
value for this simple value.

487
00:26:46,600 --> 00:26:49,871
And it turns out there is an
annotation called addValue

488
00:26:49,871 --> 00:26:54,038
which allows us to set a
default value for this property

489
00:26:55,264 --> 00:26:56,969
and by the way I could have put that

490
00:26:56,969 --> 00:26:59,302
on the set sir if preferred.

491
00:27:00,582 --> 00:27:04,332
I'm going to leave it
on the attribute itself

492
00:27:05,906 --> 00:27:09,009
and we can provide as a parameter to value

493
00:27:09,009 --> 00:27:12,190
what we want the default value to be.

494
00:27:12,190 --> 00:27:14,721
I think in our original XML it was

495
00:27:14,721 --> 00:27:17,138
SUM IMPORTANT BUSINESS value.

496
00:27:19,606 --> 00:27:22,599
Now that only becomes a default value

497
00:27:22,599 --> 00:27:24,760
if we prefer we could call

498
00:27:24,760 --> 00:27:27,221
the set simple value from the client

499
00:27:27,221 --> 00:27:30,923
or we could overwrite
that value in the XML.

500
00:27:30,923 --> 00:27:33,486
I'll need to import it you can see there

501
00:27:33,486 --> 00:27:37,472
it comes from the annotations
package in Spring.

502
00:27:37,472 --> 00:27:40,220
But the important point and
the reason I'm showing you

503
00:27:40,220 --> 00:27:43,228
this now is that the @value annotation

504
00:27:43,228 --> 00:27:46,395
will take any valid Spring expression.

505
00:27:47,497 --> 00:27:51,664
If I go over to simplebaneb
then for my RandomValue

506
00:27:54,921 --> 00:27:58,086
and I'm going to paste in
here the Spring expression

507
00:27:58,086 --> 00:27:59,653
that I saved from before

508
00:27:59,653 --> 00:28:03,070
it will need to be in double quote marks.

509
00:28:04,533 --> 00:28:07,669
But now when Spring instantiates this bean

510
00:28:07,669 --> 00:28:09,332
it will set the default value

511
00:28:09,332 --> 00:28:13,226
as being whatever this
expression resolves to

512
00:28:13,226 --> 00:28:16,076
of course I'll need to import that.

513
00:28:16,076 --> 00:28:18,436
So similarly for this SecondValue

514
00:28:18,436 --> 00:28:20,877
I think what we wanted in here

515
00:28:20,877 --> 00:28:24,377
was whatever the value of simplebeana was.

516
00:28:26,177 --> 00:28:28,094
I can call simplebeana.

517
00:28:30,353 --> 00:28:34,011
I think the property
was called SimpleValue.

518
00:28:34,011 --> 00:28:36,622
What I've done here is
I've effectively replicated

519
00:28:36,622 --> 00:28:39,700
what I had in the XML previously.

520
00:28:39,700 --> 00:28:44,521
Okay, well I'll try that
for my own simple clients.

521
00:28:44,521 --> 00:28:47,197
Now I have an exception here

522
00:28:47,197 --> 00:28:48,528
and it is quite a silly mistake

523
00:28:48,528 --> 00:28:51,485
that I have made here
but quite the subtle one

524
00:28:51,485 --> 00:28:53,435
and I have decided to
leave it in the course

525
00:28:53,435 --> 00:28:56,864
because it might be a good exercise this.

526
00:28:56,864 --> 00:29:00,688
Just to remind you what
I am doing in the client

527
00:29:00,688 --> 00:29:04,855
very simple I am looking up
the class of type simplebeanb

528
00:29:06,701 --> 00:29:07,534
and we've annotated that

529
00:29:07,534 --> 00:29:09,709
with the components annotation there

530
00:29:09,709 --> 00:29:12,626
full Spring should be instantiating

531
00:29:12,626 --> 00:29:14,352
an instance at this class

532
00:29:14,352 --> 00:29:16,935
and that should be picked up here.

533
00:29:16,935 --> 00:29:18,862
But the exception is telling me that

534
00:29:18,862 --> 00:29:22,195
there is no qualifying bean of that type

535
00:29:23,642 --> 00:29:26,225
defined in my Spring container.

536
00:29:28,064 --> 00:29:30,598
What's going on here?

537
00:29:30,598 --> 00:29:32,811
And I'm gonna pull up the XML file

538
00:29:32,811 --> 00:29:34,326
because there is a clue in here

539
00:29:34,326 --> 00:29:36,803
and you might be able to spot it

540
00:29:36,803 --> 00:29:38,486
and it's something I hadn't thought about

541
00:29:38,486 --> 00:29:40,296
when preparing the session.

542
00:29:40,296 --> 00:29:42,638
It's because my component scan is using

543
00:29:42,638 --> 00:29:47,053
the base package of
com.VirtualPairProgrammers

544
00:29:47,053 --> 00:29:51,608
but because I wanted to
keep the code here separate

545
00:29:51,608 --> 00:29:55,082
the speltesting package
is not a sub-package

546
00:29:55,082 --> 00:29:57,582
of com.VirtualPairProgrammers.

547
00:29:58,958 --> 00:30:01,532
These beans are not being picked up

548
00:30:01,532 --> 00:30:03,200
in the components scanning.

549
00:30:03,200 --> 00:30:05,620
Well there's two ways
of solving this I guess

550
00:30:05,620 --> 00:30:07,627
probably the correct way would be

551
00:30:07,627 --> 00:30:10,420
to make the speltesting b a sub-package

552
00:30:10,420 --> 00:30:13,400
of com.VirtualPairProgrammers

553
00:30:13,400 --> 00:30:16,356
because it is a Virtual
Pair Programmers package.

554
00:30:16,356 --> 00:30:18,952
But one thing that I probably
haven't mentioned so far

555
00:30:18,952 --> 00:30:23,012
is that we can make this
a comma-separated list.

556
00:30:23,012 --> 00:30:27,297
It's a simple case of adding
speltesting to the list

557
00:30:27,297 --> 00:30:31,547
and hopefully now the
code's working as before.

558
00:30:31,547 --> 00:30:34,655
At the moment I'm not
calling the RandomValues

559
00:30:34,655 --> 00:30:38,822
so I do want to also test that
so test the GetRandomValue

560
00:30:44,269 --> 00:30:48,282
and lovely that's still working as before.

561
00:30:48,282 --> 00:30:52,518
The SpEL has potential
uses in lots of areas

562
00:30:52,518 --> 00:30:56,685
WebFlow that we cover on our
Spring MBC curse for example.

563
00:30:57,974 --> 00:31:00,581
It is a bit specialist don't worry

564
00:31:00,581 --> 00:31:03,686
if you are not using it everyday.

565
00:31:03,686 --> 00:31:06,551
Keep it in mind though
you'll be glad of this tool

566
00:31:06,551 --> 00:31:08,130
when you need it.

567
00:31:08,130 --> 00:31:10,128
We've only done basic examples

568
00:31:10,128 --> 00:31:12,234
of writing expressions here

569
00:31:12,234 --> 00:31:16,203
but check the reference
manual for a few more.

570
00:31:16,203 --> 00:31:19,331
You can use the @value annotation

571
00:31:19,331 --> 00:31:21,417
if you are using auto wiring

572
00:31:21,417 --> 00:31:24,273
which gives a default value to a property

573
00:31:24,273 --> 00:31:27,273
and that can be any SpEL expression.

574
00:31:28,961 --> 00:31:30,643
There's no practical for this chapter

575
00:31:30,643 --> 00:31:33,964
but coming up is a really important topic.

576
00:31:33,964 --> 00:31:37,244
Integration tests are far more useful

577
00:31:37,244 --> 00:31:40,253
than the clients we've been writing

578
00:31:40,253 --> 00:31:43,746
and it's the last major
topic on the course.

579
00:31:43,746 --> 00:31:45,579
I'll see you for that.

580
00:31:46,596 --> 00:31:49,096
(theme music)

1
00:00:10,609 --> 00:00:13,403
- [Voiceover] This is the last
major chapter of the course.

2
00:00:13,403 --> 00:00:15,622
Marathons nearly over.

3
00:00:15,622 --> 00:00:19,389
Integration testing is a useful
thing for a project to do.

4
00:00:19,389 --> 00:00:21,382
We'll have a talk about
the difference between

5
00:00:21,382 --> 00:00:24,775
unit test and integration tests.

6
00:00:24,775 --> 00:00:27,740
It's important to distinguish the two.

7
00:00:27,740 --> 00:00:30,977
Largely, unit tests are unaffected

8
00:00:30,977 --> 00:00:31,810
by Spring.

9
00:00:32,670 --> 00:00:34,846
I will give an overview of JUnit

10
00:00:34,846 --> 00:00:37,310
just in case you haven't met it before.

11
00:00:37,310 --> 00:00:38,409
If you already know it,

12
00:00:38,409 --> 00:00:41,609
you can safely skip the
first 15 minutes or so

13
00:00:41,609 --> 00:00:43,646
of this chapter.

14
00:00:43,646 --> 00:00:46,526
If you want to write an integration test,

15
00:00:46,526 --> 00:00:49,311
you'll need some support from Spring.

16
00:00:49,311 --> 00:00:52,628
You get some help to
make writing them easier,

17
00:00:52,628 --> 00:00:54,184
but more importantly,

18
00:00:54,184 --> 00:00:57,149
they will run more efficiently.

19
00:00:57,149 --> 00:00:59,529
A great feature is that you
can make your integration

20
00:00:59,529 --> 00:01:01,946
tests automatically rollback.

21
00:01:02,889 --> 00:01:04,403
That might sound silly,

22
00:01:04,403 --> 00:01:07,389
but it lets you remove tested data

23
00:01:07,389 --> 00:01:10,206
from your database automatically.

24
00:01:10,206 --> 00:01:13,406
Finally, something we haven't
done on the course so far,

25
00:01:13,406 --> 00:01:16,201
is splits of the xml file.

26
00:01:16,201 --> 00:01:17,983
There's plenty of reasons for doing that,

27
00:01:17,983 --> 00:01:20,286
but we'll see that it enables you

28
00:01:20,286 --> 00:01:23,953
to be a bit more
controlled in your testing.

29
00:01:26,004 --> 00:01:28,671
Well the first thing to
say about testing Spring

30
00:01:28,671 --> 00:01:29,671
applications

31
00:01:30,547 --> 00:01:33,427
is because the nature of Spring

32
00:01:33,427 --> 00:01:38,164
is that we're largely working
with plain Java objects.

33
00:01:38,164 --> 00:01:40,403
Spring should not be interfering with our

34
00:01:40,403 --> 00:01:43,188
normal testing strategy.

35
00:01:43,188 --> 00:01:48,126
Now although we only have one
domain class in this project,

36
00:01:48,126 --> 00:01:51,390
that's because I've been
keeping the project simple.

37
00:01:51,390 --> 00:01:52,883
As this application gets bigger,

38
00:01:52,883 --> 00:01:56,467
we'd expect to see a
lot more domain classes.

39
00:01:56,467 --> 00:02:00,494
And those domain classes
should contain testable

40
00:02:00,494 --> 00:02:01,744
business logic.

41
00:02:03,320 --> 00:02:05,711
If you like the higher level classes

42
00:02:05,711 --> 00:02:08,302
such as the service classes

43
00:02:08,302 --> 00:02:10,702
and the data access classes.

44
00:02:10,702 --> 00:02:15,342
They shouldn't really contain
business logic as such.

45
00:02:15,342 --> 00:02:16,707
But even

46
00:02:16,707 --> 00:02:20,089
if we look at the service class,

47
00:02:20,089 --> 00:02:23,472
there's our production
implementation of the service class.

48
00:02:23,472 --> 00:02:24,505
Even then,

49
00:02:24,505 --> 00:02:29,209
there isn't really any
Spring specific code in here.

50
00:02:29,209 --> 00:02:32,142
So we should be able to
unit test our services,

51
00:02:32,142 --> 00:02:35,770
and our domain classes in the usual way.

52
00:02:35,770 --> 00:02:38,103
Using either JUnit or TestNG

53
00:02:40,034 --> 00:02:41,784
or Spock or whatever.

54
00:02:43,522 --> 00:02:45,100
However, there are some areas

55
00:02:45,100 --> 00:02:47,617
where we will need some support

56
00:02:47,617 --> 00:02:49,580
and some help from Spring.

57
00:02:49,580 --> 00:02:52,481
And that's what we're going
to look at in this chapter.

58
00:02:52,481 --> 00:02:54,700
So before we do that then a quick overview

59
00:02:54,700 --> 00:02:57,932
of unit testing just in case
you haven't done it before.

60
00:02:57,932 --> 00:03:00,898
And don't forget we do
cover this in more detail

61
00:03:00,898 --> 00:03:03,565
in the Java Fundamentals course.

62
00:03:04,844 --> 00:03:07,615
Here is our book class
that we've been working

63
00:03:07,615 --> 00:03:09,474
on through the course.

64
00:03:09,474 --> 00:03:12,485
I haven't done any testing on this class

65
00:03:12,485 --> 00:03:13,525
so far,

66
00:03:13,525 --> 00:03:15,765
but what strikes me is there are

67
00:03:15,765 --> 00:03:18,152
a few things I should be thinking about.

68
00:03:18,152 --> 00:03:21,053
For example, what happens if I compare

69
00:03:21,053 --> 00:03:21,886
two books?

70
00:03:23,176 --> 00:03:26,056
Is that going to work successfully?

71
00:03:26,056 --> 00:03:29,937
I'll use that example to show
you how to write a JUnit test.

72
00:03:29,937 --> 00:03:32,051
One of the good things about JUnit is

73
00:03:32,051 --> 00:03:35,650
it's integrated into all of the popular

74
00:03:35,650 --> 00:03:38,203
development environments.

75
00:03:38,203 --> 00:03:40,786
So I can immediately go to new,

76
00:03:41,807 --> 00:03:44,945
and I can find on here somewhere

77
00:03:44,945 --> 00:03:46,278
JUnit test case.

78
00:03:49,230 --> 00:03:50,190
And there it is.

79
00:03:50,190 --> 00:03:52,633
You might have to go
through the other option

80
00:03:52,633 --> 00:03:56,057
if you can't find it in the list.

81
00:03:56,057 --> 00:03:57,294
Now if you're following along with me,

82
00:03:57,294 --> 00:04:00,544
be sure to select the new JUnit 4 test.

83
00:04:01,479 --> 00:04:04,252
One of the things about
Spring 4 is that they don't

84
00:04:04,252 --> 00:04:07,419
support the old JUnit 3 tests anymore.

85
00:04:08,540 --> 00:04:12,423
So we're going to be
writing with JUnit 4 test.

86
00:04:12,423 --> 00:04:16,028
And the idea in JUnit is
we write a separate class

87
00:04:16,028 --> 00:04:19,695
to test some features
of some other classes.

88
00:04:20,710 --> 00:04:22,683
So I want to make sure
that the book class is

89
00:04:22,683 --> 00:04:23,963
operating correctly.

90
00:04:23,963 --> 00:04:28,230
So, I'm going to write
a test class for that.

91
00:04:28,230 --> 00:04:31,143
Now, the level of
granularity is up to you,

92
00:04:31,143 --> 00:04:33,403
but it's quite common
to have something like

93
00:04:33,403 --> 00:04:36,401
we have a class called
book that we want to test,

94
00:04:36,401 --> 00:04:39,984
so we'll have a test
class to do just that.

95
00:04:41,382 --> 00:04:43,643
I don't actually have to
fill in any of the rest

96
00:04:43,643 --> 00:04:45,360
of this stuff here,

97
00:04:45,360 --> 00:04:48,603
it's automatically come up
with a name called book test.

98
00:04:48,603 --> 00:04:50,065
And the package,

99
00:04:50,065 --> 00:04:52,145
well there's a big debate about

100
00:04:52,145 --> 00:04:53,969
what package it should go in.

101
00:04:53,969 --> 00:04:58,150
I'm going to have a subpackage
of my domain package

102
00:04:58,150 --> 00:04:59,483
called dot test.

103
00:05:01,809 --> 00:05:03,877
You don't have to do that, but it's good

104
00:05:03,877 --> 00:05:07,120
to keep these test classes separate.

105
00:05:07,120 --> 00:05:10,160
Now, it creates a little bit
of boilerplate code for us.

106
00:05:10,160 --> 00:05:12,963
But the idea in JUnit 4 is that we have a

107
00:05:12,963 --> 00:05:15,713
series of so-called test methods.

108
00:05:17,060 --> 00:05:18,926
And each of these
methods are going to test

109
00:05:18,926 --> 00:05:22,009
a different aspect of the book class.

110
00:05:22,967 --> 00:05:24,407
So we're going to have several of these,

111
00:05:24,407 --> 00:05:26,690
but it's created the first one for us

112
00:05:26,690 --> 00:05:28,887
as a sort of starter.

113
00:05:28,887 --> 00:05:30,049
What I'd like to do,

114
00:05:30,049 --> 00:05:31,287
is I'd like to test that

115
00:05:31,287 --> 00:05:33,505
if I have two books

116
00:05:33,505 --> 00:05:36,609
and they have the same ISBN number

117
00:05:36,609 --> 00:05:39,359
and I use the Java equals method,

118
00:05:40,268 --> 00:05:43,767
then they're considered to be equal.

119
00:05:43,767 --> 00:05:47,031
So books with the same ISBN number

120
00:05:47,031 --> 00:05:50,124
are considered the same product.

121
00:05:50,124 --> 00:05:51,745
So how can I do that?

122
00:05:51,745 --> 00:05:53,932
Well, I need to write a method

123
00:05:53,932 --> 00:05:55,372
to test that.

124
00:05:55,372 --> 00:05:57,804
And it's very common in JUnit

125
00:05:57,804 --> 00:06:01,868
to write your test methods
with very descriptive names.

126
00:06:01,868 --> 00:06:04,193
So I'm going to write here pretty much

127
00:06:04,193 --> 00:06:05,473
what I just said.

128
00:06:05,473 --> 00:06:07,473
I want to test the books

129
00:06:08,410 --> 00:06:10,493
with the same ISBN number

130
00:06:12,321 --> 00:06:14,988
are considered the same product.

131
00:06:17,268 --> 00:06:19,210
I'm perhaps being a little tongue in cheek

132
00:06:19,210 --> 00:06:21,872
with the length of my method name there,

133
00:06:21,872 --> 00:06:23,341
but you're actually going to find

134
00:06:23,341 --> 00:06:27,508
that people are very verbose
with JUnite method names.

135
00:06:28,515 --> 00:06:30,893
It's almost servers as a documentation

136
00:06:30,893 --> 00:06:33,379
of what the test is going to do.

137
00:06:33,379 --> 00:06:34,893
Perhaps that's a little bit wrong,

138
00:06:34,893 --> 00:06:37,774
but I'm actually quite
comfortable with that.

139
00:06:37,774 --> 00:06:41,462
In Junit 3, you had to
start your test methods

140
00:06:41,462 --> 00:06:43,617
with the word test.

141
00:06:43,617 --> 00:06:47,551
You don't anymore, but it's
still very common to do that.

142
00:06:47,551 --> 00:06:49,906
But what you do have to do,

143
00:06:49,906 --> 00:06:53,106
is you must have the @test annotation

144
00:06:53,106 --> 00:06:55,709
at the top of the method.

145
00:06:55,709 --> 00:06:56,915
Now I'm going to remove this

146
00:06:56,915 --> 00:06:59,508
not yet implemented line.

147
00:06:59,508 --> 00:07:02,313
Now what do I do inside a test?

148
00:07:02,313 --> 00:07:04,969
Well, one of the good
things about testing for me,

149
00:07:04,969 --> 00:07:07,135
is it's a very routine process.

150
00:07:07,135 --> 00:07:10,635
You almost always do the same three steps.

151
00:07:11,636 --> 00:07:14,473
And those three steps are,

152
00:07:14,473 --> 00:07:17,473
to arrange, to act, and then assert.

153
00:07:20,852 --> 00:07:22,729
They all begin with A.

154
00:07:22,729 --> 00:07:26,229
So what do I mean by arrange, act, assert?

155
00:07:27,155 --> 00:07:31,322
Well, arrange is where we're
going to set up our test data.

156
00:07:32,574 --> 00:07:34,974
For me, I'm going to need two books,

157
00:07:34,974 --> 00:07:36,894
so that I can compare them.

158
00:07:36,894 --> 00:07:39,913
So I'm going to create book one

159
00:07:39,913 --> 00:07:40,830
is new book

160
00:07:41,769 --> 00:07:44,372
and I'm going to put in
a random ISBN number,

161
00:07:44,372 --> 00:07:46,867
it really doesn't what it is.

162
00:07:46,867 --> 00:07:50,228
And the books is going
to be called Java Puzzles

163
00:07:50,228 --> 00:07:52,894
and this is by Josh Block.

164
00:07:52,894 --> 00:07:54,835
None of this is actually important,

165
00:07:54,835 --> 00:07:58,409
the only important thing
is the ISBN number.

166
00:07:58,409 --> 00:08:01,993
And to compare that book, I'm
going to need a second book,

167
00:08:01,993 --> 00:08:04,446
which I will call book two.

168
00:08:04,446 --> 00:08:06,068
The important thing is
that it must have the

169
00:08:06,068 --> 00:08:07,485
same ISBN number.

170
00:08:08,530 --> 00:08:11,538
So I'm going to copy that ISBN number,

171
00:08:11,538 --> 00:08:15,250
and then while I'm in it we'll
copy the rest of the data.

172
00:08:15,250 --> 00:08:18,792
It doesn't really matter in this case.

173
00:08:18,792 --> 00:08:20,850
So that's my arranging.

174
00:08:20,850 --> 00:08:24,114
I've set up a testing scenario.

175
00:08:24,114 --> 00:08:27,016
I need to import book class,

176
00:08:27,016 --> 00:08:29,948
that the reason I have the error there.

177
00:08:29,948 --> 00:08:32,050
Then we come on to the act stage,

178
00:08:32,050 --> 00:08:34,930
and this is where we
invoke the business logic

179
00:08:34,930 --> 00:08:37,237
that we're wanting to test.

180
00:08:37,237 --> 00:08:40,395
Now for us we're wanting
to test the equals method.

181
00:08:40,395 --> 00:08:43,220
We want to make sure that book one

182
00:08:43,220 --> 00:08:44,053
dot equals

183
00:08:44,904 --> 00:08:46,394
book two

184
00:08:46,394 --> 00:08:49,456
is returning a Boolean value.

185
00:08:49,456 --> 00:08:52,873
And I'm going to call this are they equal

186
00:08:53,947 --> 00:08:56,891
and we're expecting that
to come back as true,

187
00:08:56,891 --> 00:09:00,634
but this is the process of doing the act.

188
00:09:00,634 --> 00:09:03,487
Now we are expecting that

189
00:09:03,487 --> 00:09:05,613
if everything is coded correctly,

190
00:09:05,613 --> 00:09:07,235
the results of this

191
00:09:07,235 --> 00:09:08,485
should be true.

192
00:09:09,581 --> 00:09:11,181
And that's where the third stage,

193
00:09:11,181 --> 00:09:13,272
the assert comes in.

194
00:09:13,272 --> 00:09:15,896
So we know that that should be true.

195
00:09:15,896 --> 00:09:18,776
So we tell JUnit that that's the case

196
00:09:18,776 --> 00:09:21,193
by coding a so-called assert.

197
00:09:22,339 --> 00:09:25,672
I'm going to use the assert true method.

198
00:09:27,160 --> 00:09:29,933
And by passing in are they equal,

199
00:09:29,933 --> 00:09:33,142
I'm telling JUnit that are they equal

200
00:09:33,142 --> 00:09:34,842
is going to be true

201
00:09:34,842 --> 00:09:38,139
if our code is operating correctly.

202
00:09:38,139 --> 00:09:41,360
Now the assert true is
a method that comes from

203
00:09:41,360 --> 00:09:43,697
the JUnit framework.

204
00:09:43,697 --> 00:09:47,035
In JUnit 3 you used to get that for free

205
00:09:47,035 --> 00:09:49,680
because you extended an existing class,

206
00:09:49,680 --> 00:09:52,836
but it's slightly different in JUnit 4.

207
00:09:52,836 --> 00:09:55,460
In fact if I click the quick fix,

208
00:09:55,460 --> 00:09:57,496
it will give me the first option here

209
00:09:57,496 --> 00:10:00,663
as add static import org.JUnit.assert.

210
00:10:03,080 --> 00:10:04,776
And I'm going to select that.

211
00:10:04,776 --> 00:10:06,121
And I don't know if you've come across

212
00:10:06,121 --> 00:10:08,137
static imports before

213
00:10:08,137 --> 00:10:10,739
they're relatively new in Java.

214
00:10:10,739 --> 00:10:14,580
What this does is it makes
all of the static methods

215
00:10:14,580 --> 00:10:16,595
in this class called assert

216
00:10:16,595 --> 00:10:19,315
become visible to this class.

217
00:10:19,315 --> 00:10:22,238
So assert true is a static method

218
00:10:22,238 --> 00:10:25,939
in a different class, but
I can call it directly

219
00:10:25,939 --> 00:10:28,435
without doing the kind of pain of

220
00:10:28,435 --> 00:10:30,768
org.JUnit.assert.assert true

221
00:10:32,542 --> 00:10:34,398
every time I want to call.

222
00:10:34,398 --> 00:10:36,201
And what will happen is.

223
00:10:36,201 --> 00:10:38,451
If this assertion succeeds.

224
00:10:39,635 --> 00:10:42,803
The code is run successfully
and are they equal

225
00:10:42,803 --> 00:10:45,203
has proved to be true,

226
00:10:45,203 --> 00:10:47,796
then the test will pass.

227
00:10:47,796 --> 00:10:49,796
But if this is not true,

228
00:10:50,761 --> 00:10:53,182
therefore there's something
faulty with our code,

229
00:10:53,182 --> 00:10:55,182
then the test will fail.

230
00:10:56,382 --> 00:10:59,284
The easiest way to run
a JUnit test in Eclipse

231
00:10:59,284 --> 00:11:02,205
is to right-click on the test class.

232
00:11:02,205 --> 00:11:03,870
Select run as,

233
00:11:03,870 --> 00:11:05,120
and JUnit test.

234
00:11:06,067 --> 00:11:08,507
And the nice thing about that is the

235
00:11:08,507 --> 00:11:12,432
integration with JUnit
here will give you either

236
00:11:12,432 --> 00:11:16,155
a green bar if the test have passed,

237
00:11:16,155 --> 00:11:18,630
or a red bar if they failed.

238
00:11:18,630 --> 00:11:21,851
So we can see that the test has failed.

239
00:11:21,851 --> 00:11:24,988
If we have a look down
here on the failure,

240
00:11:24,988 --> 00:11:26,238
it's telling us

241
00:11:28,091 --> 00:11:30,694
the line where the assertion failed.

242
00:11:30,694 --> 00:11:33,202
And of course we only had one assertion,

243
00:11:33,202 --> 00:11:35,285
so it's that one there.

244
00:11:35,285 --> 00:11:37,502
And you can probably
guess why this has failed.

245
00:11:37,502 --> 00:11:40,648
It's just standard Java that
we're talking about here.

246
00:11:40,648 --> 00:11:41,970
And in standard Java,

247
00:11:41,970 --> 00:11:46,590
the default implementation
of the equals method is

248
00:11:46,590 --> 00:11:48,925
are these two objects

249
00:11:48,925 --> 00:11:51,175
the same objects in memory.

250
00:11:52,265 --> 00:11:53,245
But they're not

251
00:11:53,245 --> 00:11:56,989
because I've created two
distinct and separate

252
00:11:56,989 --> 00:11:58,750
objects in memory,

253
00:11:58,750 --> 00:11:59,938
it's just that they happen to

254
00:11:59,938 --> 00:12:02,434
have the same data inside them.

255
00:12:02,434 --> 00:12:05,101
So as you probably know,
if you want to override

256
00:12:05,101 --> 00:12:07,062
that default logic,

257
00:12:07,062 --> 00:12:09,996
you have to provide
your own implementation

258
00:12:09,996 --> 00:12:13,314
of equals here in the book class.

259
00:12:13,314 --> 00:12:15,341
Now it can be quite a complicated job to

260
00:12:15,341 --> 00:12:16,480
implement equals,

261
00:12:16,480 --> 00:12:19,046
and it's not a job for this course.

262
00:12:19,046 --> 00:12:21,648
We do cover it in Java Fundamentals.

263
00:12:21,648 --> 00:12:24,923
But in almost all
developments environments now,

264
00:12:24,923 --> 00:12:29,029
there is an option in
Eclipse it's under source

265
00:12:29,029 --> 00:12:29,946
to generate

266
00:12:31,591 --> 00:12:34,705
the hash code and equals method.

267
00:12:34,705 --> 00:12:38,150
Now I'm not going to talk
about hash code here today,

268
00:12:38,150 --> 00:12:40,911
but I am interested in the equals method

269
00:12:40,911 --> 00:12:42,468
and the

270
00:12:42,468 --> 00:12:44,889
way that the auto generation works is

271
00:12:44,889 --> 00:12:49,647
I can select the fields
that I want to be compared.

272
00:12:49,647 --> 00:12:53,710
Now my business rules
are that it's the ISBN,

273
00:12:53,710 --> 00:12:56,633
that determines a unique book.

274
00:12:56,633 --> 00:12:59,133
So I'm going to tick just ISBN

275
00:13:00,014 --> 00:13:01,689
and I'm clicking okay.

276
00:13:01,689 --> 00:13:05,557
I get a reasonable implementation
of the equals method.

277
00:13:05,557 --> 00:13:07,510
It is a little bit overly complicated,

278
00:13:07,510 --> 00:13:09,898
because there's a lot of ifs and buts

279
00:13:09,898 --> 00:13:12,778
to think about in equals.

280
00:13:12,778 --> 00:13:14,411
I'll leave you to pick through that

281
00:13:14,411 --> 00:13:15,658
if you've not seen it before,

282
00:13:15,658 --> 00:13:17,558
but basically it's saying

283
00:13:17,558 --> 00:13:19,957
if the object is null

284
00:13:19,957 --> 00:13:23,733
and it can't possible be equal and so on.

285
00:13:23,733 --> 00:13:25,717
With those in place,

286
00:13:25,717 --> 00:13:27,690
I can now return to my book test

287
00:13:27,690 --> 00:13:29,607
and rerun the unit test

288
00:13:31,435 --> 00:13:33,864
and great, I now get a green bar.

289
00:13:33,864 --> 00:13:36,659
So I know that that logic was good.

290
00:13:36,659 --> 00:13:39,241
And now on a real project
we continue to add

291
00:13:39,241 --> 00:13:41,427
more and more tests,

292
00:13:41,427 --> 00:13:43,763
and we'd see more and more red bars

293
00:13:43,763 --> 00:13:45,587
followed by green bars,

294
00:13:45,587 --> 00:13:48,004
as the code gets more robust.

295
00:13:49,043 --> 00:13:51,901
I'll do just one more,
just to prove the point.

296
00:13:51,901 --> 00:13:53,128
So another test,

297
00:13:53,128 --> 00:13:57,139
this time I'm going to
test that the format

298
00:13:57,139 --> 00:13:58,472
of the to string

299
00:14:00,318 --> 00:14:01,235
is correct.

300
00:14:02,280 --> 00:14:05,438
So let's say we have a
business rule on this project,

301
00:14:05,438 --> 00:14:08,435
that if we have arranged a book,

302
00:14:08,435 --> 00:14:11,795
I'm going to borrow the one from before.

303
00:14:11,795 --> 00:14:14,258
If I've arranged a book,

304
00:14:14,258 --> 00:14:17,758
and I happen to call the to string method.

305
00:14:20,798 --> 00:14:23,465
I'll call this to string result.

306
00:14:26,462 --> 00:14:29,896
So I'm calling book ones
to string method here.

307
00:14:29,896 --> 00:14:33,097
And my assertion this time is going to be

308
00:14:33,097 --> 00:14:34,792
that the to string result

309
00:14:34,792 --> 00:14:38,152
must match what the business is expecting.

310
00:14:38,152 --> 00:14:40,201
To do that, that gives
me a chance to show you

311
00:14:40,201 --> 00:14:43,240
what's probably the most
common assert method

312
00:14:43,240 --> 00:14:46,078
and that's assert equals.

313
00:14:46,078 --> 00:14:48,702
And what we do in the
assert equals method,

314
00:14:48,702 --> 00:14:51,101
is and it's easy to get
this the wrong way around.

315
00:14:51,101 --> 00:14:55,817
The first parameter is
the value we're expecting,

316
00:14:55,817 --> 00:14:59,998
and the second value is the
actual value that was returned.

317
00:14:59,998 --> 00:15:01,741
Now I don't know what
the business rules for

318
00:15:01,741 --> 00:15:03,403
this project are,

319
00:15:03,403 --> 00:15:06,955
but it could be that
the business wants the

320
00:15:06,955 --> 00:15:08,598
title of the book,

321
00:15:08,598 --> 00:15:11,181
so we're expecting Java Puzzles

322
00:15:12,438 --> 00:15:14,923
followed by the string by,

323
00:15:14,923 --> 00:15:17,462
Followed by the name of the author.

324
00:15:17,462 --> 00:15:18,699
So in this case,

325
00:15:18,699 --> 00:15:22,635
that's the exact string
that we're expecting.

326
00:15:22,635 --> 00:15:25,056
The actual value that we got back was this

327
00:15:25,056 --> 00:15:26,473
to string result.

328
00:15:27,414 --> 00:15:31,179
So I pass that in as the second parameter.

329
00:15:31,179 --> 00:15:32,512
Give that a run.

330
00:15:35,136 --> 00:15:37,942
And this time we have a pass, a green bar.

331
00:15:37,942 --> 00:15:39,435
You might not have expected that,

332
00:15:39,435 --> 00:15:42,017
but that's because throughout this course,

333
00:15:42,017 --> 00:15:45,995
we have had a good
implementation of to string.

334
00:15:45,995 --> 00:15:48,395
Now one of the things
about writing these tests,

335
00:15:48,395 --> 00:15:50,923
is they often seem a
little bit too trivial.

336
00:15:50,923 --> 00:15:53,355
I mean, yeah, we knew the to string method

337
00:15:53,355 --> 00:15:54,976
was going to work.

338
00:15:54,976 --> 00:15:57,163
But really the point of these unit tests

339
00:15:57,163 --> 00:15:59,957
is more of a regression test.

340
00:15:59,957 --> 00:16:01,579
You can imagine the case
where in the future,

341
00:16:01,579 --> 00:16:03,499
a programmer comes along and thinks.

342
00:16:03,499 --> 00:16:05,537
Oh, I don't like this to string.

343
00:16:05,537 --> 00:16:08,181
I'd much prefer it to have a completely

344
00:16:08,181 --> 00:16:09,643
different structure.

345
00:16:09,643 --> 00:16:10,679
Something like this.

346
00:16:10,679 --> 00:16:14,315
And they might not realize
that they're breaking code

347
00:16:14,315 --> 00:16:16,256
elsewhere in the system.

348
00:16:16,256 --> 00:16:17,323
But it's okay,

349
00:16:17,323 --> 00:16:19,979
because as we've got tests in place,

350
00:16:19,979 --> 00:16:22,635
the next time that we run the unit tests,

351
00:16:22,635 --> 00:16:25,056
we get a big alarm sounding.

352
00:16:25,056 --> 00:16:27,573
So we've trapped that problem.

353
00:16:27,573 --> 00:16:29,462
So the real value of these tests,

354
00:16:29,462 --> 00:16:32,045
is often in regression testing.

355
00:16:33,719 --> 00:16:36,822
Now that's all I'm going
to say about the basics

356
00:16:36,822 --> 00:16:37,655
of JUnit.

357
00:16:38,603 --> 00:16:40,459
There are millions of books out there

358
00:16:40,459 --> 00:16:43,136
on out to write effective unit tests

359
00:16:43,136 --> 00:16:46,562
and there is our Java
Fundamentals course as well,

360
00:16:46,562 --> 00:16:50,134
so feel free to read further
if you're interested.

361
00:16:50,134 --> 00:16:53,558
Now, my tests aren't particularly
industrial strength here,

362
00:16:53,558 --> 00:16:55,840
but they are at least
a good flavor of what

363
00:16:55,840 --> 00:16:57,537
tests look like.

364
00:16:57,537 --> 00:17:00,662
And the thing is that even
with Spring in an application,

365
00:17:00,662 --> 00:17:04,277
the unit tests for the
domain classes will be

366
00:17:04,277 --> 00:17:06,315
completely unaffected.

367
00:17:06,315 --> 00:17:09,675
However, throughout this course,

368
00:17:09,675 --> 00:17:13,008
I've been building a client application.

369
00:17:13,878 --> 00:17:15,179
I don't know about you,

370
00:17:15,179 --> 00:17:18,934
but I've been finding that really clunky.

371
00:17:18,934 --> 00:17:23,242
What I'm having to do if I
restore one of my methods,

372
00:17:23,242 --> 00:17:26,909
and I've been having
to refresh the database

373
00:17:27,861 --> 00:17:28,694
each time.

374
00:17:30,359 --> 00:17:34,109
Deleting the database
before running the code

375
00:17:35,979 --> 00:17:37,643
and then when the code is run,

376
00:17:37,643 --> 00:17:40,641
I've had to inspect the output and

377
00:17:40,641 --> 00:17:43,179
use my brains to make sure that everything

378
00:17:43,179 --> 00:17:45,654
has been working okay.

379
00:17:45,654 --> 00:17:48,481
That's dangerous, because it's slow,

380
00:17:48,481 --> 00:17:51,520
it's not repeatable, and
I've might have missed

381
00:17:51,520 --> 00:17:53,920
somethings that have gone wrong in here.

382
00:17:53,920 --> 00:17:56,724
And because I'm checking
by eye every time,

383
00:17:56,724 --> 00:17:59,635
I might miss something important.

384
00:17:59,635 --> 00:18:03,102
So, this client application was okay,

385
00:18:03,102 --> 00:18:04,466
and I wanted to write it,

386
00:18:04,466 --> 00:18:08,882
so I can actually give you
a feel for Spring running.

387
00:18:08,882 --> 00:18:11,005
But it would be nice if
we could have something

388
00:18:11,005 --> 00:18:14,685
repeatable, where we're
testing the whole of Spring's

389
00:18:14,685 --> 00:18:17,352
operation using a single button,

390
00:18:18,609 --> 00:18:22,171
and we can get an immediate pass or fail.

391
00:18:22,171 --> 00:18:26,246
And of course there's nothing
to stop us using JUnit

392
00:18:26,246 --> 00:18:28,246
to test these functions.

393
00:18:29,414 --> 00:18:33,008
Getting books by author and so on.

394
00:18:33,008 --> 00:18:35,035
Now what I've done off camera,

395
00:18:35,035 --> 00:18:39,728
is I have in fact written a
JUnit test to do just that.

396
00:18:39,728 --> 00:18:43,451
Now, I usually type this in on the video

397
00:18:43,451 --> 00:18:47,174
but you can see it's
quite a long class this.

398
00:18:47,174 --> 00:18:49,126
So I did it off camera,

399
00:18:49,126 --> 00:18:51,270
and you will find this
file in your practicals

400
00:18:51,270 --> 00:18:52,806
and code folder.

401
00:18:52,806 --> 00:18:55,089
And if you want to bring
it into your project,

402
00:18:55,089 --> 00:18:59,256
just make sure it's in a package
called Integration tests.

403
00:19:01,308 --> 00:19:04,873
So just create a new package,
and you can drag the file

404
00:19:04,873 --> 00:19:06,423
into there.

405
00:19:06,423 --> 00:19:08,686
Now the thing I want to
point out about this,

406
00:19:08,686 --> 00:19:11,488
is it's a regular JUnit test.

407
00:19:11,488 --> 00:19:12,885
There's nothing different in here.

408
00:19:12,885 --> 00:19:14,890
I have the test annotation,

409
00:19:14,890 --> 00:19:18,325
test finding by ISBN for example,

410
00:19:18,325 --> 00:19:20,608
and in my arrange,

411
00:19:20,608 --> 00:19:23,608
really I ought to move this comment.

412
00:19:25,333 --> 00:19:27,232
All of this is the arranging.

413
00:19:27,232 --> 00:19:29,941
In my arrange, I'm doing
pretty much what I was doing

414
00:19:29,941 --> 00:19:31,560
in the client application.

415
00:19:31,560 --> 00:19:34,068
I am opening up Spring,

416
00:19:34,068 --> 00:19:35,828
the Spring container,

417
00:19:35,828 --> 00:19:39,123
and then getting up the book service bean,

418
00:19:39,123 --> 00:19:42,163
and then adding in a test book

419
00:19:42,163 --> 00:19:44,862
because I'm assuming that
the database is empty

420
00:19:44,862 --> 00:19:47,283
when the test starts.

421
00:19:47,283 --> 00:19:50,068
Then for my act, I'm calling find by

422
00:19:50,068 --> 00:19:53,151
or get book by ISBN and I'm asserting

423
00:19:54,580 --> 00:19:56,497
that the book returned,

424
00:19:58,441 --> 00:19:59,691
the found book,

425
00:20:00,585 --> 00:20:04,752
is equal to the book that
was originally passed in.

426
00:20:06,163 --> 00:20:08,201
By the way, this is a
slightly different version of

427
00:20:08,201 --> 00:20:09,368
assert equals.

428
00:20:10,419 --> 00:20:13,715
There's an extra parameter
here and that's quite useful.

429
00:20:13,715 --> 00:20:17,299
This string will be output to the log,

430
00:20:17,299 --> 00:20:18,750
if the test fails,

431
00:20:18,750 --> 00:20:21,949
and that's really useful for debugging.

432
00:20:21,949 --> 00:20:25,331
But otherwise it's the same
as the assert you saw before.

433
00:20:25,331 --> 00:20:28,798
And then I've gone ahead and
added a couple more tests.

434
00:20:28,798 --> 00:20:31,496
Here I'm testing the adding of books.

435
00:20:31,496 --> 00:20:34,174
So my arrange will be the same as before.

436
00:20:34,174 --> 00:20:38,344
Open up the container, and
get the book service bean.

437
00:20:38,344 --> 00:20:41,677
The acting I'm registering two new books

438
00:20:42,622 --> 00:20:46,579
and for my assertion I'm
expecting that there should be

439
00:20:46,579 --> 00:20:49,224
two books in the database.

440
00:20:49,224 --> 00:20:53,982
And finally, I'm testing
finding a non-existent book.

441
00:20:53,982 --> 00:20:56,520
I've opened up the Spring container

442
00:20:56,520 --> 00:20:59,806
but I'm looking for a book with the ISBN,

443
00:20:59,806 --> 00:21:02,227
which doesn't exist.

444
00:21:02,227 --> 00:21:04,339
Now this is a nice feature of JUnit 4.

445
00:21:04,339 --> 00:21:06,323
I don't need to do anything more

446
00:21:06,323 --> 00:21:08,147
than just trying to find the book.

447
00:21:08,147 --> 00:21:10,643
Now that might throw an exception,

448
00:21:10,643 --> 00:21:12,979
but we want the exception to be found.

449
00:21:12,979 --> 00:21:15,038
If everything's working we should get a

450
00:21:15,038 --> 00:21:17,544
book not found exception.

451
00:21:17,544 --> 00:21:19,582
So I can add into the annotation here

452
00:21:19,582 --> 00:21:22,920
that we are expecting
book not found exception,

453
00:21:22,920 --> 00:21:25,086
and if that doesn't happen,

454
00:21:25,086 --> 00:21:27,058
we'll get a red bar.

455
00:21:27,058 --> 00:21:29,919
So this shows then that
it's perfectly possible

456
00:21:29,919 --> 00:21:33,480
to write a so-called integration test,

457
00:21:33,480 --> 00:21:36,980
even though the framework is called JUnit.

458
00:21:38,301 --> 00:21:41,022
It's really important to
distinguish the difference

459
00:21:41,022 --> 00:21:44,689
between an integration
test and a unit test.

460
00:21:45,544 --> 00:21:47,986
In this integration test,

461
00:21:47,986 --> 00:21:52,102
we're testing multiple
layers in our application.

462
00:21:52,102 --> 00:21:55,665
And we're also going to be
using an external resource.

463
00:21:55,665 --> 00:21:58,811
In this case, that's the database.

464
00:21:58,811 --> 00:22:01,063
Now, it's important to distinguish the two

465
00:22:01,063 --> 00:22:02,630
because integration tests

466
00:22:02,630 --> 00:22:05,880
are a lot more brittle than unit tests.

467
00:22:06,886 --> 00:22:10,406
I could make a very small
change to the application code

468
00:22:10,406 --> 00:22:14,471
and potentially break a
lot of integration tests.

469
00:22:14,471 --> 00:22:17,223
So the best way to work with tests

470
00:22:17,223 --> 00:22:20,188
is to have a lot of unit tests,

471
00:22:20,188 --> 00:22:22,171
and to try to test as much of the code

472
00:22:22,171 --> 00:22:24,763
as possible with unit tests.

473
00:22:24,763 --> 00:22:27,025
And then to have a few

474
00:22:27,025 --> 00:22:28,710
integration tests.

475
00:22:28,710 --> 00:22:31,184
Just sort of making sure really,

476
00:22:31,184 --> 00:22:34,087
that the tiers of your application

477
00:22:34,087 --> 00:22:36,646
are hanging together correctly.

478
00:22:36,646 --> 00:22:37,542
So for example,

479
00:22:37,542 --> 00:22:39,686
if there was a fault with

480
00:22:39,686 --> 00:22:41,703
the database configuration.

481
00:22:41,703 --> 00:22:44,398
Then the unit tests would

482
00:22:44,398 --> 00:22:46,519
show that that's the case.

483
00:22:46,519 --> 00:22:50,060
So this is a perfectly
respectable way of working

484
00:22:50,060 --> 00:22:52,300
as long as you note very clearly

485
00:22:52,300 --> 00:22:54,882
that this integration test,

486
00:22:54,882 --> 00:22:56,882
rather than a unit test.

487
00:22:57,730 --> 00:22:58,892
What I would do on my projects

488
00:22:58,892 --> 00:23:01,345
is make sure that all
the integration tests

489
00:23:01,345 --> 00:23:04,130
are in their own package structure,

490
00:23:04,130 --> 00:23:06,647
and also that every integration test

491
00:23:06,647 --> 00:23:11,447
has the phrase integration
test in the class name.

492
00:23:11,447 --> 00:23:13,111
So this is perfectly reasonable,

493
00:23:13,111 --> 00:23:14,487
but there is

494
00:23:14,487 --> 00:23:17,068
at least one big problem I can see

495
00:23:17,068 --> 00:23:20,183
with the structure of this JUnit test.

496
00:23:20,183 --> 00:23:21,591
I don't know if you've spotted it,

497
00:23:21,591 --> 00:23:24,705
but you'll notice that in my arrange,

498
00:23:24,705 --> 00:23:28,788
I'm always having to open
a new Spring container.

499
00:23:30,210 --> 00:23:33,644
I've got to do that, so I
can get hold of the bean

500
00:23:33,644 --> 00:23:35,169
that I'm wanting to test.

501
00:23:35,169 --> 00:23:38,029
In this case the book service.

502
00:23:38,029 --> 00:23:41,848
So the first obvious problem
is that I'm repeating code.

503
00:23:41,848 --> 00:23:43,810
I'm doing a copy and paste.

504
00:23:43,810 --> 00:23:46,988
These two lines of code are identical to

505
00:23:46,988 --> 00:23:49,325
these two lines of code,

506
00:23:49,325 --> 00:23:51,991
and these two lines of code

507
00:23:51,991 --> 00:23:55,703
and probably I would guess
every single test method

508
00:23:55,703 --> 00:23:58,711
will have those two lines of code.

509
00:23:58,711 --> 00:24:01,325
Now, I don't know how
much you know about JUnit,

510
00:24:01,325 --> 00:24:02,743
but you might be thinking

511
00:24:02,743 --> 00:24:04,471
oh well, we can fix that.

512
00:24:04,471 --> 00:24:08,221
There's special method
in JUnit called setup.

513
00:24:09,367 --> 00:24:10,829
So what I could potentially do

514
00:24:10,829 --> 00:24:13,186
is create a private attribute

515
00:24:13,186 --> 00:24:15,532
holding the book service.

516
00:24:15,532 --> 00:24:18,199
I'll just call the object books.

517
00:24:19,585 --> 00:24:23,585
And then what we could
do in the setup method is

518
00:24:26,210 --> 00:24:29,165
we could take this line of
code where we instantiate

519
00:24:29,165 --> 00:24:31,031
the container

520
00:24:31,031 --> 00:24:34,050
and then we could borrow at least

521
00:24:34,050 --> 00:24:36,727
some of the second line of code.

522
00:24:36,727 --> 00:24:38,008
If you're following along,

523
00:24:38,008 --> 00:24:40,109
you'll want to remove the

524
00:24:40,109 --> 00:24:42,263
declaration of book service there because

525
00:24:42,263 --> 00:24:46,391
we're now working with
an attribute instead.

526
00:24:46,391 --> 00:24:49,463
And then I could go
through the other methods

527
00:24:49,463 --> 00:24:51,880
and remove the repeated lines

528
00:24:55,266 --> 00:24:56,599
there and there.

529
00:24:58,551 --> 00:25:01,548
So it certainly looks a little tidier,

530
00:25:01,548 --> 00:25:04,225
and I should say in JUnit 4,

531
00:25:04,225 --> 00:25:06,690
you had to annotate your setup method

532
00:25:06,690 --> 00:25:09,190
with the at before annotation.

533
00:25:11,148 --> 00:25:11,981
Be careful here,

534
00:25:11,981 --> 00:25:13,143
you've got options.

535
00:25:13,143 --> 00:25:14,391
You're looking for the one from

536
00:25:14,391 --> 00:25:16,724
of course the JUnit package.

537
00:25:17,623 --> 00:25:20,066
So, the deal is then
with the before method

538
00:25:20,066 --> 00:25:24,290
that this code will run
before the tests run.

539
00:25:24,290 --> 00:25:26,530
That's tidied up the code,

540
00:25:26,530 --> 00:25:29,485
but I wonder if you can
see a more subtle problem

541
00:25:29,485 --> 00:25:31,810
with this approach.

542
00:25:31,810 --> 00:25:33,410
I'm going to try to illustrate it

543
00:25:33,410 --> 00:25:35,789
by running the integration test.

544
00:25:35,789 --> 00:25:37,687
Now, I have to warn you before we run,

545
00:25:37,687 --> 00:25:41,272
that I think these
tests are going to fail.

546
00:25:41,272 --> 00:25:44,577
I'll explain the reason
why they're failing shortly

547
00:25:44,577 --> 00:25:47,272
but I want to at least see if they run.

548
00:25:47,272 --> 00:25:50,035
So I'm just going to run as JUnit Test.

549
00:25:50,035 --> 00:25:52,452
Now watch the test carefully.

550
00:26:06,152 --> 00:26:09,853
Now you might want to rewind
and play that back again,

551
00:26:09,853 --> 00:26:12,051
but the point I was
trying to make there was

552
00:26:12,051 --> 00:26:14,078
you could see each of the test methods

553
00:26:14,078 --> 00:26:16,776
running one after the other.

554
00:26:16,776 --> 00:26:18,334
And did you notice in the video

555
00:26:18,334 --> 00:26:21,459
that they were really quite slow to run.

556
00:26:21,459 --> 00:26:24,072
We've even got the timings on there,

557
00:26:24,072 --> 00:26:28,093
the first test method
took about nine seconds.

558
00:26:28,093 --> 00:26:30,557
And then the other two test methods took

559
00:26:30,557 --> 00:26:32,890
one and a half seconds each.

560
00:26:34,750 --> 00:26:37,750
And I want to see if that's a fluke.

561
00:26:45,939 --> 00:26:48,211
Well, slightly faster this time maybe.

562
00:26:48,211 --> 00:26:51,599
Nine seconds and then about
one and a half seconds

563
00:26:51,599 --> 00:26:55,674
and just under a second
for the third test method.

564
00:26:55,674 --> 00:26:57,530
Now I would expect the first

565
00:26:57,530 --> 00:26:59,279
of the test methods to be slow,

566
00:26:59,279 --> 00:27:02,191
that's possibly because
the JUnit framework

567
00:27:02,191 --> 00:27:04,037
is bootstrapping.

568
00:27:04,037 --> 00:27:07,237
But I think, it might
not look significant,

569
00:27:07,237 --> 00:27:11,279
but I think the times we're
seeing for these next two

570
00:27:11,279 --> 00:27:13,231
is really worrying as well.

571
00:27:13,231 --> 00:27:15,631
Let's say on average these tests methods

572
00:27:15,631 --> 00:27:17,881
taking about a second each.

573
00:27:18,799 --> 00:27:21,754
Well of course we've only
got three test methods.

574
00:27:21,754 --> 00:27:23,309
But on a real project,

575
00:27:23,309 --> 00:27:26,135
you might have many more of them.

576
00:27:26,135 --> 00:27:28,013
I don't know what would be a good number

577
00:27:28,013 --> 00:27:30,008
of integration tests on a project,

578
00:27:30,008 --> 00:27:32,355
but you could certainly
see several hundred

579
00:27:32,355 --> 00:27:35,672
integration tests on a big project.

580
00:27:35,672 --> 00:27:37,336
Now the problem that we're seeing here is

581
00:27:37,336 --> 00:27:42,029
that these tests are going
to run really slowly.

582
00:27:42,029 --> 00:27:44,472
And going back to the test code,

583
00:27:44,472 --> 00:27:47,458
the reason is that this setup method

584
00:27:47,458 --> 00:27:50,019
is going to run before

585
00:27:50,019 --> 00:27:52,519
every one of the test methods.

586
00:27:53,517 --> 00:27:56,057
And this line of code here

587
00:27:56,057 --> 00:27:57,307
is really slow.

588
00:27:58,296 --> 00:28:00,418
That line of code is

589
00:28:00,418 --> 00:28:03,751
creating an entire new Spring container.

590
00:28:04,845 --> 00:28:08,024
And in the process it's
going to have to open

591
00:28:08,024 --> 00:28:10,264
the application.xml file,

592
00:28:10,264 --> 00:28:13,240
pause the xml, create the beans,

593
00:28:13,240 --> 00:28:15,576
do all the dependency injections

594
00:28:15,576 --> 00:28:18,824
and that really is going
to take a significat

595
00:28:18,824 --> 00:28:19,796
amount of time.

596
00:28:19,796 --> 00:28:23,060
We've seen it's possibly about a second.

597
00:28:23,060 --> 00:28:25,844
And it's having to do
that before every single

598
00:28:25,844 --> 00:28:28,138
one of these methods.

599
00:28:28,138 --> 00:28:30,100
Now you might think
there's a further solution

600
00:28:30,100 --> 00:28:31,933
which would be just to

601
00:28:32,799 --> 00:28:34,804
instead of doing this in the before,

602
00:28:34,804 --> 00:28:38,878
we could do it in the
constructor of the unit test.

603
00:28:38,878 --> 00:28:40,766
I've seen quite a few projects thinking

604
00:28:40,766 --> 00:28:42,599
that they can do that.

605
00:28:43,646 --> 00:28:45,982
And well, technically you can.

606
00:28:45,982 --> 00:28:48,850
This is now the constructor
so we know that the

607
00:28:48,850 --> 00:28:50,159
container will open,

608
00:28:50,159 --> 00:28:52,933
and we'll get the
attributes set up correctly.

609
00:28:52,933 --> 00:28:54,939
But actually I think we'll see,

610
00:28:54,939 --> 00:28:57,689
now this isn't a scientific test.

611
00:29:03,312 --> 00:29:05,189
Now you might think these

612
00:29:05,189 --> 00:29:07,145
are dramatically improved.

613
00:29:07,145 --> 00:29:10,483
The first test only
took a second this time,

614
00:29:10,483 --> 00:29:13,471
and the subsequent test
apparently are only

615
00:29:13,471 --> 00:29:16,031
taking fractions of a second.

616
00:29:16,031 --> 00:29:17,545
Now the first time that I saw this,

617
00:29:17,545 --> 00:29:19,209
I was absolutely baffled,

618
00:29:19,209 --> 00:29:20,872
because I don't know about you,

619
00:29:20,872 --> 00:29:22,484
if I run these tests again,

620
00:29:22,484 --> 00:29:24,693
just watch carefully and I will make sure

621
00:29:24,693 --> 00:29:27,807
that we don't edit any of
this in post production.

622
00:29:27,807 --> 00:29:30,153
You're seeing this in real time.

623
00:29:30,153 --> 00:29:33,721
We expect a bit of a pause as the

624
00:29:33,721 --> 00:29:36,221
JUnit frameworks starting but.

625
00:29:37,213 --> 00:29:40,659
Yeah, there was kind of a definite pause

626
00:29:40,659 --> 00:29:43,474
on the second and third test run.

627
00:29:43,474 --> 00:29:46,771
I think that the reported times here

628
00:29:46,771 --> 00:29:49,714
are not actually accurate.

629
00:29:49,714 --> 00:29:52,659
And I suspect it's
because that the timings

630
00:29:52,659 --> 00:29:55,218
reported here by Eclipse,

631
00:29:55,218 --> 00:29:59,218
don't include the time
taken by the constructor.

632
00:30:00,413 --> 00:30:01,810
Now that's really significant

633
00:30:01,810 --> 00:30:04,210
because the constructor is still running.

634
00:30:04,210 --> 00:30:07,431
It's just not being
reported in this timing.

635
00:30:07,431 --> 00:30:09,010
Now you might think I just need

636
00:30:09,010 --> 00:30:11,134
a little digression here into JUnit.

637
00:30:11,134 --> 00:30:13,010
You might think well that's not a problem,

638
00:30:13,010 --> 00:30:16,189
because the constructor's
only going to run once.

639
00:30:16,189 --> 00:30:18,855
But that's not correct.

640
00:30:18,855 --> 00:30:21,223
One of the principles of JUnit is

641
00:30:21,223 --> 00:30:23,858
if you have, as we do in our case,

642
00:30:23,858 --> 00:30:26,248
three test methods,

643
00:30:26,248 --> 00:30:28,264
then what JUnit will do is it will create

644
00:30:28,264 --> 00:30:31,931
three separate instances
of this test class.

645
00:30:34,066 --> 00:30:35,688
And in the first instance it will

646
00:30:35,688 --> 00:30:38,320
run the first test method

647
00:30:38,320 --> 00:30:41,339
and then it will stop using that object

648
00:30:41,339 --> 00:30:43,195
and it will use the second object to

649
00:30:43,195 --> 00:30:46,115
run the second test method and so on.

650
00:30:46,115 --> 00:30:49,562
Now JUnit does that as a design feature to

651
00:30:49,562 --> 00:30:53,261
to make sure that at the
end of each test method,

652
00:30:53,261 --> 00:30:55,261
and debris, any garbage,

653
00:30:56,697 --> 00:31:00,397
or any data generated
as a result of the test

654
00:31:00,397 --> 00:31:02,480
is discarded and removed.

655
00:31:03,342 --> 00:31:06,275
And this helps prevent
dependencies happening

656
00:31:06,275 --> 00:31:08,238
between the tests.

657
00:31:08,238 --> 00:31:12,484
The worst thing you can
possibly have with unit testing

658
00:31:12,484 --> 00:31:15,157
is that your test passes

659
00:31:15,157 --> 00:31:17,791
if you run the tests in the order of

660
00:31:17,791 --> 00:31:19,497
one, two, three.

661
00:31:19,497 --> 00:31:21,610
But then for some reason
you change the order of

662
00:31:21,610 --> 00:31:23,252
the tests around,

663
00:31:23,252 --> 00:31:25,172
and then the tests fail.

664
00:31:25,172 --> 00:31:28,436
By having a separate object
for each of these tests,

665
00:31:28,436 --> 00:31:31,871
that kind of helps the tests be insulated

666
00:31:31,871 --> 00:31:33,437
from each other.

667
00:31:33,437 --> 00:31:34,343
It's a good feature,

668
00:31:34,343 --> 00:31:36,498
and if you don't believe
me that that's the case,

669
00:31:36,498 --> 00:31:38,141
I'm going to add in

670
00:31:38,141 --> 00:31:39,974
a system.out.printline

671
00:31:43,698 --> 00:31:45,319
and I'll just put in there, I don't know

672
00:31:45,319 --> 00:31:46,986
running constructor,

673
00:31:48,338 --> 00:31:50,755
and I'll run that test again.

674
00:31:53,138 --> 00:31:54,280
And this time it's the console

675
00:31:54,280 --> 00:31:56,363
that we're interested in.

676
00:31:59,144 --> 00:32:00,743
I'll maximize the console,

677
00:32:00,743 --> 00:32:02,375
and I know it's rather messy,

678
00:32:02,375 --> 00:32:03,975
but the point is can you see there

679
00:32:03,975 --> 00:32:05,224
there's one,

680
00:32:05,224 --> 00:32:06,301
two,

681
00:32:06,301 --> 00:32:07,357
three

682
00:32:07,357 --> 00:32:10,044
separate runs of that constructor.

683
00:32:10,044 --> 00:32:12,338
Which you might not have expected,

684
00:32:12,338 --> 00:32:13,885
and the timings here I believe

685
00:32:13,885 --> 00:32:15,846
are really misleading.

686
00:32:15,846 --> 00:32:18,949
I still think we're experiencing

687
00:32:18,949 --> 00:32:21,968
slowness here because we've run

688
00:32:21,968 --> 00:32:23,771
this line of code

689
00:32:23,771 --> 00:32:24,771
three times.

690
00:32:25,969 --> 00:32:29,883
And I reckon each time
that's taken around a second.

691
00:32:29,883 --> 00:32:33,072
It's just not been
reported in those timings.

692
00:32:33,072 --> 00:32:34,608
So this is really bad.

693
00:32:34,608 --> 00:32:37,125
And this is what we don't
want for integration tests

694
00:32:37,125 --> 00:32:40,958
because they can end up
running really slowly.

695
00:32:42,146 --> 00:32:45,750
Spring features a really nice feature.

696
00:32:45,750 --> 00:32:47,414
It's quite simple,

697
00:32:47,414 --> 00:32:49,729
it's just a pair of annotations

698
00:32:49,729 --> 00:32:52,950
at the top of the integration test.

699
00:32:52,950 --> 00:32:56,283
The first of the annotations is @runwith

700
00:32:58,410 --> 00:33:01,181
and then in round brackets, you specify

701
00:33:01,181 --> 00:33:03,514
Spring JUnit 4 class runner.

702
00:33:06,493 --> 00:33:09,746
And if that was a little
bit tedious typing,

703
00:33:09,746 --> 00:33:11,186
once you've done the at run with,

704
00:33:11,186 --> 00:33:13,991
you can just say Spring command

705
00:33:13,991 --> 00:33:17,554
or control space and
usually the first option

706
00:33:17,554 --> 00:33:20,232
will be the one that you're looking for.

707
00:33:20,232 --> 00:33:24,137
You need to add dot class
on to the end of that.

708
00:33:24,137 --> 00:33:27,122
Now this is one of the features of Spring.

709
00:33:27,122 --> 00:33:31,559
This allows this JUnit
test to be sort of enhanced

710
00:33:31,559 --> 00:33:33,642
with some extra features.

711
00:33:34,484 --> 00:33:37,202
And the biggest of those extra features

712
00:33:37,202 --> 00:33:40,787
is with the second of the annotations.

713
00:33:40,787 --> 00:33:44,204
This annotation is @contextconfiguration,

714
00:33:46,408 --> 00:33:49,405
and in the round brackets,

715
00:33:49,405 --> 00:33:52,488
you specify the name of your xml file

716
00:33:53,522 --> 00:33:57,085
that you're using to
define your application.

717
00:33:57,085 --> 00:33:59,443
You will need to of course import the

718
00:33:59,443 --> 00:34:01,843
context configuration.

719
00:34:01,843 --> 00:34:04,189
And by the way, just a
little digression here.

720
00:34:04,189 --> 00:34:06,856
You can use curly brackets here,

721
00:34:07,848 --> 00:34:10,503
and a comma separated list if you have

722
00:34:10,503 --> 00:34:14,045
more than one xml file
for your application.

723
00:34:14,045 --> 00:34:15,826
I'll be talking a little
bit more about that

724
00:34:15,826 --> 00:34:18,087
in the final chapter of the course,

725
00:34:18,087 --> 00:34:20,104
but we've only got one file

726
00:34:20,104 --> 00:34:23,528
so I don't need to specify an array.

727
00:34:23,528 --> 00:34:25,224
Now what this does,

728
00:34:25,224 --> 00:34:29,141
is it automatically
creates a Spring container.

729
00:34:30,482 --> 00:34:33,821
So we no longer need
to do this line of code

730
00:34:33,821 --> 00:34:36,828
anymore in the constructor.

731
00:34:36,828 --> 00:34:39,549
And I think the most
important thing about this

732
00:34:39,549 --> 00:34:44,348
is Spring will ensure that
this only happens once.

733
00:34:44,348 --> 00:34:47,847
And that container will
be shared by all of these,

734
00:34:47,847 --> 00:34:51,165
in our case, three test methods.

735
00:34:51,165 --> 00:34:55,676
So yes, the first of the tests
might well be quite slow,

736
00:34:55,676 --> 00:34:58,786
but then the rest of them
should run a lot quicker.

737
00:34:58,786 --> 00:35:02,286
And that means in fact we can
get rid of the constructor,

738
00:35:02,286 --> 00:35:04,396
we don't need that anymore

739
00:35:04,396 --> 00:35:06,520
because the final feature is

740
00:35:06,520 --> 00:35:09,923
we don't need to see the
Spring container anymore.

741
00:35:09,923 --> 00:35:12,003
It's going to be automatically created

742
00:35:12,003 --> 00:35:16,482
in the background by the
context configuration.

743
00:35:16,482 --> 00:35:19,438
And then what you can
do on your attributes

744
00:35:19,438 --> 00:35:22,882
is add the autowired annotation.

745
00:35:22,882 --> 00:35:25,219
Now of course we've seen
that earlier in the course

746
00:35:25,219 --> 00:35:27,960
on the chapter on annotations.

747
00:35:27,960 --> 00:35:31,320
The great thing about this feature is,

748
00:35:31,320 --> 00:35:34,550
you don't have to be using
autowiring in the rest

749
00:35:34,550 --> 00:35:36,342
of your application.

750
00:35:36,342 --> 00:35:39,062
Even if you're using manual wiring,

751
00:35:39,062 --> 00:35:41,110
for the integration test,

752
00:35:41,110 --> 00:35:45,252
the autowiring will just silently happen

753
00:35:45,252 --> 00:35:47,537
all because of this annotation.

754
00:35:47,537 --> 00:35:49,724
Now I suspect that some of you might

755
00:35:49,724 --> 00:35:51,024
not be happy about this.

756
00:35:51,024 --> 00:35:55,238
And I know a lot of people
don't like autowiring.

757
00:35:55,238 --> 00:35:58,502
My personal preference
is I do lean towards

758
00:35:58,502 --> 00:36:01,541
using manual wiring where possible.

759
00:36:01,541 --> 00:36:05,243
But I think this area is different.

760
00:36:05,243 --> 00:36:07,782
The argument against autowiring

761
00:36:07,782 --> 00:36:10,299
is that you lose flexibility.

762
00:36:10,299 --> 00:36:12,612
You know it's harder to
do things like changing

763
00:36:12,612 --> 00:36:15,972
the implementation of your beans,

764
00:36:15,972 --> 00:36:19,011
if you don't have an xml file.

765
00:36:19,011 --> 00:36:20,856
But it's different here.

766
00:36:20,856 --> 00:36:22,830
In an integration test,

767
00:36:22,830 --> 00:36:24,898
we don't need any flexibility really,

768
00:36:24,898 --> 00:36:26,670
we just need to get hold

769
00:36:26,670 --> 00:36:29,657
of the book service object
that we're working with

770
00:36:29,657 --> 00:36:31,193
on this system.

771
00:36:31,193 --> 00:36:33,518
Now by the way if we have
multiple implementations

772
00:36:33,518 --> 00:36:34,755
of this book service,

773
00:36:34,755 --> 00:36:36,792
then the one it's going to use

774
00:36:36,792 --> 00:36:39,806
is whichever one we've got configured

775
00:36:39,806 --> 00:36:42,506
in our application.xml file.

776
00:36:42,506 --> 00:36:44,544
So I don't need flexibility here,

777
00:36:44,544 --> 00:36:46,303
I just want to grab hold

778
00:36:46,303 --> 00:36:48,970
of the correct book service.

779
00:36:48,970 --> 00:36:51,231
So to reemphasize then what we've achieved

780
00:36:51,231 --> 00:36:53,555
with these really useful annotations

781
00:36:53,555 --> 00:36:55,710
is that we no longer

782
00:36:55,710 --> 00:36:58,590
have to create a new
container at the start

783
00:36:58,590 --> 00:37:01,918
of every one of the test methods.

784
00:37:01,918 --> 00:37:03,869
So that means that this
integration test is

785
00:37:03,869 --> 00:37:06,402
now going to run, well I
don't know something like

786
00:37:06,402 --> 00:37:08,621
three times better than it did before.

787
00:37:08,621 --> 00:37:10,679
And that's important because we want

788
00:37:10,679 --> 00:37:14,027
to be able to run
integration tests regularly.

789
00:37:14,027 --> 00:37:17,129
We don't want to be sat
around waiting for them.

790
00:37:17,129 --> 00:37:20,296
So I'm going to rerun this JUnit test.

791
00:37:21,950 --> 00:37:23,369
And oh, actually, no.

792
00:37:23,369 --> 00:37:25,364
That was too fast.

793
00:37:25,364 --> 00:37:28,286
I can see all three of
the tests are failing now.

794
00:37:28,286 --> 00:37:31,225
I have an error here
saying failing to load

795
00:37:31,225 --> 00:37:33,563
the application context.

796
00:37:33,563 --> 00:37:36,005
Actually, if I check a little further down

797
00:37:36,005 --> 00:37:39,536
it's telling me it can't find
the application.xml file.

798
00:37:39,536 --> 00:37:42,256
And it's simply because
I've forgotten that

799
00:37:42,256 --> 00:37:44,462
the reference here

800
00:37:44,462 --> 00:37:46,648
works relative to the location

801
00:37:46,648 --> 00:37:48,409
of the test class.

802
00:37:48,409 --> 00:37:51,566
So it's trying to find
that xml file in the

803
00:37:51,566 --> 00:37:53,987
integration test package.

804
00:37:53,987 --> 00:37:56,196
I've forgotten that you
need a forward slash

805
00:37:56,196 --> 00:37:57,559
on the front of that file

806
00:37:57,559 --> 00:38:00,738
to tell it to work from
the top of the class path.

807
00:38:00,738 --> 00:38:02,156
So I'm sorry about that,

808
00:38:02,156 --> 00:38:03,328
but I'll rerun the test,

809
00:38:03,328 --> 00:38:06,578
and again, I won't do any editing here.

810
00:38:19,424 --> 00:38:21,268
And yeah, you can definitely tell there

811
00:38:21,268 --> 00:38:24,020
the first test was really slow.

812
00:38:24,020 --> 00:38:25,756
Of the order of around nine seconds,

813
00:38:25,756 --> 00:38:28,572
but then the other two ran really quickly

814
00:38:28,572 --> 00:38:32,018
and okay, we don't trust these timings,

815
00:38:32,018 --> 00:38:35,959
but just by eye, I certainly
felt that the tests

816
00:38:35,959 --> 00:38:38,769
were running a lot quicker.

817
00:38:38,769 --> 00:38:41,307
Okay so we got the tests
running efficiently now,

818
00:38:41,307 --> 00:38:44,124
but we now need to investigate why are two

819
00:38:44,124 --> 00:38:46,108
of these tests failing.

820
00:38:46,108 --> 00:38:49,212
First off, the test finding by ISBN,

821
00:38:49,212 --> 00:38:51,143
that ones working okay.

822
00:38:51,143 --> 00:38:54,247
But the testing of adding books

823
00:38:54,247 --> 00:38:56,091
is not working.

824
00:38:56,091 --> 00:38:59,185
So let's maximize the results,

825
00:38:59,185 --> 00:39:01,830
and it's actually saying that

826
00:39:01,830 --> 00:39:05,175
there should be two books in the database.

827
00:39:05,175 --> 00:39:07,693
We were expecting two books,

828
00:39:07,693 --> 00:39:11,610
but we actually found 28
books in the database.

829
00:39:12,781 --> 00:39:15,533
Well, this is going to
give me a good opportunity

830
00:39:15,533 --> 00:39:17,261
to solve one of the problems that's been

831
00:39:17,261 --> 00:39:20,972
really annoying me throughout this course.

832
00:39:20,972 --> 00:39:22,274
What's happening here,

833
00:39:22,274 --> 00:39:25,679
is that the test adding books is

834
00:39:25,679 --> 00:39:27,795
of course registering two new books

835
00:39:27,795 --> 00:39:29,128
in the database,

836
00:39:30,035 --> 00:39:32,317
and we're expecting to see therefore

837
00:39:32,317 --> 00:39:34,216
two books in the database.

838
00:39:34,216 --> 00:39:36,840
The test is assuming that we're starting

839
00:39:36,840 --> 00:39:39,154
from a clean database.

840
00:39:39,154 --> 00:39:42,515
But I'll bet, we've got a load of rubbish

841
00:39:42,515 --> 00:39:43,848
in our database,

842
00:39:45,661 --> 00:39:47,161
from earlier runs.

843
00:39:48,840 --> 00:39:51,741
Yeah, and it certainly
looks like something like

844
00:39:51,741 --> 00:39:55,420
well it's now 29 books in the database.

845
00:39:55,420 --> 00:39:57,503
If we run the test again,

846
00:40:04,305 --> 00:40:06,385
then this time around it's different,

847
00:40:06,385 --> 00:40:10,414
it's now moaning there are
31 books in the database.

848
00:40:10,414 --> 00:40:11,694
So what's happening then,

849
00:40:11,694 --> 00:40:14,936
is that each test that we're running

850
00:40:14,936 --> 00:40:17,635
is adding data to the database.

851
00:40:17,635 --> 00:40:20,153
But then when the test is finishing,

852
00:40:20,153 --> 00:40:23,694
that data is not being
removed from the database.

853
00:40:23,694 --> 00:40:26,061
We don't want all of this debris,

854
00:40:26,061 --> 00:40:28,312
all of this garbage to be left behind.

855
00:40:28,312 --> 00:40:31,715
As I mentioned, we really
want each of the tests

856
00:40:31,715 --> 00:40:35,902
to be completely independent
from the previous one.

857
00:40:35,902 --> 00:40:38,155
Now the first solution to this could be

858
00:40:38,155 --> 00:40:41,909
just if we manually refresh the project

859
00:40:41,909 --> 00:40:43,914
and delete the database.

860
00:40:43,914 --> 00:40:45,547
That's the kind of thing I've been doing

861
00:40:45,547 --> 00:40:47,626
through this course.

862
00:40:47,626 --> 00:40:50,043
If I now rerun the unit test,

863
00:40:54,154 --> 00:40:56,106
and it's test adding books method

864
00:40:56,106 --> 00:40:58,439
that I'm trying to fix here.

865
00:41:01,632 --> 00:41:03,616
Yeah, it's now passing.

866
00:41:03,616 --> 00:41:06,848
And it's passing because
we had a clean database

867
00:41:06,848 --> 00:41:08,906
and we were lucky that
at the point that this

868
00:41:08,906 --> 00:41:10,632
test adding books method ran,

869
00:41:10,632 --> 00:41:12,276
there were no books in the database

870
00:41:12,276 --> 00:41:15,341
so we got the right answer.

871
00:41:15,341 --> 00:41:17,223
But I think you can see
the problem with that.

872
00:41:17,223 --> 00:41:19,223
If I run the test again.

873
00:41:21,266 --> 00:41:22,502
Oh, ouch, yep.

874
00:41:22,502 --> 00:41:24,082
It's now failing.

875
00:41:24,082 --> 00:41:26,204
And the worst thing you can possibly have

876
00:41:26,204 --> 00:41:29,746
with JUnit tests, is where
you have the case where

877
00:41:29,746 --> 00:41:31,868
sometimes a test passes,

878
00:41:31,868 --> 00:41:33,905
and sometimes a tests fails.

879
00:41:33,905 --> 00:41:37,660
That always means a badly designed test.

880
00:41:37,660 --> 00:41:40,284
And what we certainly
don't want to have to do

881
00:41:40,284 --> 00:41:44,668
is to have to manually
remember to refresh the project

882
00:41:44,668 --> 00:41:46,727
and delete the database

883
00:41:46,727 --> 00:41:48,209
before we run the test.

884
00:41:48,209 --> 00:41:51,042
That would be absolutely terrible.

885
00:41:52,604 --> 00:41:54,663
But I have seen projects
trying to do that,

886
00:41:54,663 --> 00:41:58,129
and it always leads to
the tests eventually

887
00:41:58,129 --> 00:41:59,900
being abandoned.

888
00:41:59,900 --> 00:42:02,407
So that gives me a chance to show you

889
00:42:02,407 --> 00:42:04,049
a great feature

890
00:42:04,049 --> 00:42:07,505
of the Spring integration test support.

891
00:42:07,505 --> 00:42:09,521
It's going to take me longer to explain it

892
00:42:09,521 --> 00:42:12,028
than to actually do it.

893
00:42:12,028 --> 00:42:15,770
If you add the apps
transactional annotation

894
00:42:15,770 --> 00:42:20,386
to the test, and of course
you will need to import that.

895
00:42:20,386 --> 00:42:23,385
Now we have met transactional
earlier on in the course,

896
00:42:23,385 --> 00:42:25,580
and if you've skipped
straight to this chapter,

897
00:42:25,580 --> 00:42:27,798
I'm afraid you might want
to go back and review

898
00:42:27,798 --> 00:42:29,153
that chapter,

899
00:42:29,153 --> 00:42:31,179
but this annotation is rather different

900
00:42:31,179 --> 00:42:33,302
to what you've seen before.

901
00:42:33,302 --> 00:42:37,196
When we have transactional
on an integration test,

902
00:42:37,196 --> 00:42:39,094
what Spring will do is

903
00:42:39,094 --> 00:42:42,241
it will begin a new
transaction at the beginning

904
00:42:42,241 --> 00:42:44,352
of each test method,

905
00:42:44,352 --> 00:42:47,702
and then at the end of the test method,

906
00:42:47,702 --> 00:42:49,785
it will issue a rollback.

907
00:42:50,956 --> 00:42:54,817
So any data that has
been sent to the database

908
00:42:54,817 --> 00:42:56,981
will be automatically, well,

909
00:42:56,981 --> 00:43:00,641
it just will not be committed
to the database at all.

910
00:43:00,641 --> 00:43:04,236
So that helps us to ensure isolation

911
00:43:04,236 --> 00:43:06,679
from one test method to the other.

912
00:43:06,679 --> 00:43:08,897
So it was very simple to add.

913
00:43:08,897 --> 00:43:10,881
Now I am going to have to

914
00:43:10,881 --> 00:43:11,881
first of all

915
00:43:12,876 --> 00:43:14,720
delete the database.

916
00:43:14,720 --> 00:43:16,396
Now, that's not good,

917
00:43:16,396 --> 00:43:17,900
but that's something we can fix

918
00:43:17,900 --> 00:43:19,574
in a few moments.

919
00:43:19,574 --> 00:43:22,337
But once we've deleted the database.

920
00:43:22,337 --> 00:43:24,670
If I now run the test again.

921
00:43:30,080 --> 00:43:33,281
Now the test adding
books method has passed,

922
00:43:33,281 --> 00:43:37,015
we kind of expected that
'cause we deleted the database.

923
00:43:37,015 --> 00:43:39,734
I'll come back and look at
the failing test in a moment,

924
00:43:39,734 --> 00:43:42,679
but test adding books has worked.

925
00:43:42,679 --> 00:43:45,782
By the way in the IDE, if
I click this button here

926
00:43:45,782 --> 00:43:47,615
it will rerun the test

927
00:43:51,435 --> 00:43:53,301
and yeah, the thing we're looking for

928
00:43:53,301 --> 00:43:56,884
is that test adding
books has passed again.

929
00:43:57,740 --> 00:44:01,654
And if I click the run test button again,

930
00:44:01,654 --> 00:44:05,142
that's great, test adding
books is now running stably.

931
00:44:05,142 --> 00:44:08,481
And that's because now at
the end of every test method,

932
00:44:08,481 --> 00:44:11,979
it's almost as if the changes
that the test has made

933
00:44:11,979 --> 00:44:14,496
are being automatically unwound.

934
00:44:14,496 --> 00:44:16,279
Which means you have a clean sheet

935
00:44:16,279 --> 00:44:18,433
at the start of every test method.

936
00:44:18,433 --> 00:44:20,535
Now that does leave one
remaining problem of course

937
00:44:20,535 --> 00:44:23,713
before I ran the test for the first time,

938
00:44:23,713 --> 00:44:26,433
I had to delete the database.

939
00:44:26,433 --> 00:44:29,462
Now that of course would be nonsensical

940
00:44:29,462 --> 00:44:32,193
on a production project.

941
00:44:32,193 --> 00:44:33,921
But if you think about it,

942
00:44:33,921 --> 00:44:37,281
this database is my production database.

943
00:44:37,281 --> 00:44:40,601
Looking in my application.xml file,

944
00:44:40,601 --> 00:44:42,909
this is my production standard

945
00:44:42,909 --> 00:44:45,147
Spring configuration.

946
00:44:45,147 --> 00:44:48,647
It's pointing at that particular database.

947
00:44:49,573 --> 00:44:51,673
Now don't get hung up on
the fact that this is a file

948
00:44:51,673 --> 00:44:53,433
based database.

949
00:44:53,433 --> 00:44:56,910
That URL could be pointing
to a network database

950
00:44:56,910 --> 00:44:58,910
such as MySQL or Oracle.

951
00:45:00,068 --> 00:45:04,174
Now clearly, we don't
want the integration test

952
00:45:04,174 --> 00:45:07,491
to be talking to our production database.

953
00:45:07,491 --> 00:45:09,934
So, what can we do here?

954
00:45:09,934 --> 00:45:11,694
Well a very common pattern

955
00:45:11,694 --> 00:45:13,944
is to split up the xml file

956
00:45:15,076 --> 00:45:16,743
into multiple parts.

957
00:45:18,030 --> 00:45:20,292
Now the way that you split up the xml file

958
00:45:20,292 --> 00:45:22,713
is entirely up to you.

959
00:45:22,713 --> 00:45:24,953
It's quite a common pattern to have

960
00:45:24,953 --> 00:45:28,537
maybe a separate xml file for each tier

961
00:45:28,537 --> 00:45:30,286
of your application.

962
00:45:30,286 --> 00:45:33,923
So you could have an xml
file for your service beans,

963
00:45:33,923 --> 00:45:36,923
an xml for your data access objects,

964
00:45:37,881 --> 00:45:39,438
and so on.

965
00:45:39,438 --> 00:45:42,222
Now it's just that on this
version of the project,

966
00:45:42,222 --> 00:45:43,982
we've used annotations.

967
00:45:43,982 --> 00:45:46,381
So to be honest there isn't really

968
00:45:46,381 --> 00:45:49,581
very much in this file at all.

969
00:45:49,581 --> 00:45:51,435
But what I could do,

970
00:45:51,435 --> 00:45:54,272
is I could take my data source.

971
00:45:54,272 --> 00:45:56,022
I'm just going to cut

972
00:45:57,372 --> 00:45:59,100
that out of the file,

973
00:45:59,100 --> 00:46:01,907
and I could create a separate xml file

974
00:46:01,907 --> 00:46:03,581
for the data source.

975
00:46:03,581 --> 00:46:06,246
Now because I'm using the Spring IDE here

976
00:46:06,246 --> 00:46:10,413
I can go file, new, Spring
bean configuration file.

977
00:46:11,964 --> 00:46:14,097
You can copy and paste
the schema definition

978
00:46:14,097 --> 00:46:16,261
if you want to do it by hand.

979
00:46:16,261 --> 00:46:18,321
Now I'm going to call this file

980
00:46:18,321 --> 00:46:20,488
data source production.xml

981
00:46:23,343 --> 00:46:24,987
and inside there,

982
00:46:24,987 --> 00:46:29,154
I'm going to add in my
production standard data source.

983
00:46:32,368 --> 00:46:36,229
But I could also create another xml file

984
00:46:36,229 --> 00:46:40,229
and I'm going to call
this one data source test.

985
00:46:44,421 --> 00:46:46,683
Now I've just pasted that data source in,

986
00:46:46,683 --> 00:46:48,924
but I could now make this point to

987
00:46:48,924 --> 00:46:51,591
a completely different database.

988
00:46:52,443 --> 00:46:54,309
So just of the purpose of this course,

989
00:46:54,309 --> 00:46:55,644
I'm going to call this one

990
00:46:55,644 --> 00:46:57,394
database testing.dat.

991
00:47:00,261 --> 00:47:02,085
And the point of doing that is that

992
00:47:02,085 --> 00:47:04,835
I can now in my integration test.

993
00:47:05,829 --> 00:47:08,346
Remember that the parameter here

994
00:47:08,346 --> 00:47:10,929
can take an array of xml files.

995
00:47:11,909 --> 00:47:15,547
So in here I can combine
the applicaion.xml file

996
00:47:15,547 --> 00:47:19,429
which recall has the configuration of

997
00:47:19,429 --> 00:47:22,320
transaction manager, and
all of the other tiers

998
00:47:22,320 --> 00:47:24,388
in the application,

999
00:47:24,388 --> 00:47:26,724
but it doesn't have a data source.

1000
00:47:26,724 --> 00:47:29,945
So I can then add in a reference,

1001
00:47:29,945 --> 00:47:31,769
just a comma separated list

1002
00:47:31,769 --> 00:47:34,352
to the data source for testing.

1003
00:47:36,121 --> 00:47:40,025
Which is going to be just a hsql file.

1004
00:47:40,025 --> 00:47:41,443
And I nearly forgot that I will need

1005
00:47:41,443 --> 00:47:45,610
that forward slash at the
front of file name again.

1006
00:47:46,792 --> 00:47:49,125
Let's check that that works.

1007
00:47:51,837 --> 00:47:52,670
Well the test run okay,

1008
00:47:52,670 --> 00:47:53,981
we still got that failing test

1009
00:47:53,981 --> 00:47:55,880
which I will need to fix.

1010
00:47:55,880 --> 00:47:56,936
But the important thing is

1011
00:47:56,936 --> 00:47:58,641
if I refresh the project now,

1012
00:47:58,641 --> 00:48:00,679
notice we have a new data base

1013
00:48:00,679 --> 00:48:02,179
called testing.dat

1014
00:48:03,207 --> 00:48:04,999
and because everything was rolled back

1015
00:48:04,999 --> 00:48:06,044
at the end of each method,

1016
00:48:06,044 --> 00:48:08,924
there's actually no data inside it.

1017
00:48:08,924 --> 00:48:11,003
And we did all of that without touching

1018
00:48:11,003 --> 00:48:13,927
our production standard database.

1019
00:48:13,927 --> 00:48:17,447
Now there is one problem that
I will have to patch up now.

1020
00:48:17,447 --> 00:48:22,140
Because our application.xml
file now doesn't contain

1021
00:48:22,140 --> 00:48:24,508
a data source reference.

1022
00:48:24,508 --> 00:48:28,625
I think if I run my
client application now,

1023
00:48:28,625 --> 00:48:31,345
this will be my real application I suppose

1024
00:48:31,345 --> 00:48:33,383
rather than a test of course

1025
00:48:33,383 --> 00:48:35,171
it's going to crash because there is now

1026
00:48:35,171 --> 00:48:37,761
no data source defined in there.

1027
00:48:37,761 --> 00:48:40,097
So there are lots of ways
you could handle this

1028
00:48:40,097 --> 00:48:42,476
it's really down to your own strategy

1029
00:48:42,476 --> 00:48:44,844
and down to your own taste.

1030
00:48:44,844 --> 00:48:46,220
But I think what I would do,

1031
00:48:46,220 --> 00:48:49,887
is I would rename this
application.xml file.

1032
00:48:50,881 --> 00:48:53,470
I'll do a refactor rename.

1033
00:48:53,470 --> 00:48:55,720
And I'm going to call this,

1034
00:48:56,649 --> 00:48:58,494
well really this is the configuration

1035
00:48:58,494 --> 00:49:01,340
of all of the tiers in my application

1036
00:49:01,340 --> 00:49:03,857
apart from the data source.

1037
00:49:03,857 --> 00:49:05,297
So I'm just going to call this

1038
00:49:05,297 --> 00:49:06,630
other tiers.xml.

1039
00:49:08,018 --> 00:49:10,278
If you were doing manual wiring,

1040
00:49:10,278 --> 00:49:14,738
you'd probably have a file
for the service beans,

1041
00:49:14,738 --> 00:49:18,140
a separate one for the data
access objects and so on.

1042
00:49:18,140 --> 00:49:20,219
And on the first edition of this course

1043
00:49:20,219 --> 00:49:21,766
that's exactly what I did.

1044
00:49:21,766 --> 00:49:23,078
But because it's not really worth

1045
00:49:23,078 --> 00:49:24,312
breaking down any further,

1046
00:49:24,312 --> 00:49:27,267
I'm just going to call it other tiers.

1047
00:49:27,267 --> 00:49:29,850
That will be entirely up to you.

1048
00:49:29,850 --> 00:49:31,652
Now before I go any further,

1049
00:49:31,652 --> 00:49:33,092
back to the test then.

1050
00:49:33,092 --> 00:49:35,192
What I now want is

1051
00:49:35,192 --> 00:49:36,192
of the tiers

1052
00:49:38,286 --> 00:49:39,119
.xml.

1053
00:49:40,729 --> 00:49:42,393
What I can do now is create

1054
00:49:42,393 --> 00:49:43,976
one final xml file.

1055
00:49:46,744 --> 00:49:49,049
I could call this application.xml,

1056
00:49:49,049 --> 00:49:51,427
but I'm going to be a little clearer.

1057
00:49:51,427 --> 00:49:54,177
I'm going to call this production

1058
00:49:56,155 --> 00:49:57,488
application.xml.

1059
00:50:01,840 --> 00:50:03,771
And you might be worrying that we've

1060
00:50:03,771 --> 00:50:05,275
got lots of work to do here,

1061
00:50:05,275 --> 00:50:07,131
but actually this is
going to be quite simple.

1062
00:50:07,131 --> 00:50:09,457
What we can do in this file

1063
00:50:09,457 --> 00:50:10,540
is import the

1064
00:50:12,656 --> 00:50:14,323
other tiers.xml file

1065
00:50:16,016 --> 00:50:17,433
and we can import

1066
00:50:20,912 --> 00:50:21,745
the

1067
00:50:22,672 --> 00:50:23,589
data source

1068
00:50:27,675 --> 00:50:29,059
production.xml file.

1069
00:50:29,059 --> 00:50:30,798
So using these imports

1070
00:50:30,798 --> 00:50:32,142
is a really neat way

1071
00:50:32,142 --> 00:50:33,997
of just gathering together

1072
00:50:33,997 --> 00:50:36,579
all of the xml files that you want

1073
00:50:36,579 --> 00:50:40,003
for in this case, a
production standard run.

1074
00:50:40,003 --> 00:50:42,654
And because I decided to
change the file name there,

1075
00:50:42,654 --> 00:50:45,822
I am going to have to go
back to my client application

1076
00:50:45,822 --> 00:50:49,076
and make sure that we're
opening up the correct file now,

1077
00:50:49,076 --> 00:50:52,076
which is production application.xml.

1078
00:50:53,374 --> 00:50:54,643
If you didn't want to make the change

1079
00:50:54,643 --> 00:50:56,177
in the client application,

1080
00:50:56,177 --> 00:50:58,417
I could perfectly of easily called this

1081
00:50:58,417 --> 00:51:02,396
grand xml file that's
pulling everything together.

1082
00:51:02,396 --> 00:51:04,646
Just regular applicaion.xml

1083
00:51:05,863 --> 00:51:08,280
So if I run this client then,

1084
00:51:09,340 --> 00:51:10,737
I just want to check that that's working

1085
00:51:10,737 --> 00:51:13,154
with the production database.

1086
00:51:14,962 --> 00:51:16,498
And it's certainly
running, and we're seeing

1087
00:51:16,498 --> 00:51:19,385
the Java Programming by Gary Cornell

1088
00:51:19,385 --> 00:51:23,218
which I believe is in
our production database.

1089
00:51:24,068 --> 00:51:25,401
But if I run the

1090
00:51:27,833 --> 00:51:29,166
integration test

1091
00:51:31,652 --> 00:51:32,826
then this time we're working

1092
00:51:32,826 --> 00:51:34,957
with the testing version

1093
00:51:34,957 --> 00:51:37,901
which has no data inside it.

1094
00:51:37,901 --> 00:51:40,621
So we've got quite close now to what

1095
00:51:40,621 --> 00:51:44,107
you might see on a
production standard project.

1096
00:51:44,107 --> 00:51:46,465
The only difference you would probably see

1097
00:51:46,465 --> 00:51:48,544
is that the production database would be

1098
00:51:48,544 --> 00:51:50,966
a proper network database,

1099
00:51:50,966 --> 00:51:54,763
Oracle, MySQL, SQL Server or whatever.

1100
00:51:54,763 --> 00:51:57,163
But actually, it's quite a common thing

1101
00:51:57,163 --> 00:51:59,318
for your testing database to be

1102
00:51:59,318 --> 00:52:02,678
a hsql or similar type database

1103
00:52:02,678 --> 00:52:04,459
because all of that can be done

1104
00:52:04,459 --> 00:52:06,241
with a simple file.

1105
00:52:06,241 --> 00:52:07,958
There is just one last thing I want to do

1106
00:52:07,958 --> 00:52:09,259
before I finish the chapter,

1107
00:52:09,259 --> 00:52:12,822
and that is we have had a
failing test throughout.

1108
00:52:12,822 --> 00:52:15,979
Now, in fact this isn't
relevant to Spring,

1109
00:52:15,979 --> 00:52:17,878
it's just that there is a little bit

1110
00:52:17,878 --> 00:52:19,467
of a fault in our logic.

1111
00:52:19,467 --> 00:52:21,462
And I've left this in
because it illustrates

1112
00:52:21,462 --> 00:52:24,482
the purpose of an integration test.

1113
00:52:24,482 --> 00:52:26,886
The error that I'm seeing here,

1114
00:52:26,886 --> 00:52:29,403
if I maximize the window,

1115
00:52:29,403 --> 00:52:32,529
it's saying that the test was expecting

1116
00:52:32,529 --> 00:52:35,089
a book not found exception,

1117
00:52:35,089 --> 00:52:37,723
but the actual exception thrown was

1118
00:52:37,723 --> 00:52:39,556
a no result exception.

1119
00:52:40,465 --> 00:52:42,149
So let's see if we can investigate

1120
00:52:42,149 --> 00:52:43,643
what's happening there or,

1121
00:52:43,643 --> 00:52:45,632
of course you can pause the video

1122
00:52:45,632 --> 00:52:48,822
and try to work it out for yourself.

1123
00:52:48,822 --> 00:52:52,054
We want to see a book not found exception

1124
00:52:52,054 --> 00:52:55,115
if you call get book by ISBN

1125
00:52:55,115 --> 00:52:57,696
with a garbage ISBN number.

1126
00:52:57,696 --> 00:52:59,958
Well I think the cause is going to be

1127
00:52:59,958 --> 00:53:03,659
a result of our data access object.

1128
00:53:03,659 --> 00:53:07,072
We're using the JPA implementation

1129
00:53:07,072 --> 00:53:09,099
for this recording.

1130
00:53:09,099 --> 00:53:10,752
And it's this method here,

1131
00:53:10,752 --> 00:53:11,835
find by ISBN.

1132
00:53:13,153 --> 00:53:17,312
Now I'm just calling, let
me tidy this up a bit.

1133
00:53:17,312 --> 00:53:20,438
If you did the chapter on JPA,

1134
00:53:20,438 --> 00:53:24,821
then I'm calling the get
single result method.

1135
00:53:24,821 --> 00:53:27,738
Now that's going to return no rows.

1136
00:53:28,715 --> 00:53:31,364
That's of course the book doesn't exist.

1137
00:53:31,364 --> 00:53:34,350
Now the JPA exception
that's thrown from here

1138
00:53:34,350 --> 00:53:37,006
is the no results exception.

1139
00:53:37,006 --> 00:53:37,839
But we don't want that,

1140
00:53:37,839 --> 00:53:39,844
we want the book not found exception.

1141
00:53:39,844 --> 00:53:43,705
And so I actually think
it's a simple case of

1142
00:53:43,705 --> 00:53:44,872
catching that.

1143
00:53:46,884 --> 00:53:49,231
So I'll add in a try catch block

1144
00:53:49,231 --> 00:53:51,247
and the exception is going to be from the

1145
00:53:51,247 --> 00:53:52,997
Java persistence API,

1146
00:53:54,426 --> 00:53:55,524
and there it is.

1147
00:53:55,524 --> 00:53:57,988
No results exception.

1148
00:53:57,988 --> 00:53:59,268
If there are no results,

1149
00:53:59,268 --> 00:54:00,346
then we want to throw

1150
00:54:00,346 --> 00:54:03,311
a more specific business exception

1151
00:54:03,311 --> 00:54:05,764
that means something to us

1152
00:54:05,764 --> 00:54:08,440
which is book not found exception.

1153
00:54:08,440 --> 00:54:10,573
So that was a genuine
case of where I'd simply

1154
00:54:10,573 --> 00:54:12,323
forgotten to do that.

1155
00:54:13,218 --> 00:54:15,757
But luckily the integration test was able

1156
00:54:15,757 --> 00:54:17,090
to pick that up.

1157
00:54:18,082 --> 00:54:19,842
So that wasn't related to Spring,

1158
00:54:19,842 --> 00:54:22,200
but it was certainly worth fixing.

1159
00:54:22,200 --> 00:54:23,950
I'll rerun that test.

1160
00:54:26,317 --> 00:54:29,734
And the wonderful feeling of a green bar.

1161
00:54:30,957 --> 00:54:32,376
Well, we're finally there.

1162
00:54:32,376 --> 00:54:35,821
That was the last major theory chapter.

1163
00:54:35,821 --> 00:54:39,938
Integration tests in Spring
are pretty easy to write

1164
00:54:39,938 --> 00:54:42,572
using a pair of annotations.

1165
00:54:42,572 --> 00:54:44,418
Just be careful not to write too many

1166
00:54:44,418 --> 00:54:46,402
integration tests.

1167
00:54:46,402 --> 00:54:50,637
It's the unit tests
that are more valuable.

1168
00:54:50,637 --> 00:54:53,336
With Spring, you can get
your integration tests

1169
00:54:53,336 --> 00:54:56,002
to automatically rollback,

1170
00:54:56,002 --> 00:54:58,914
so you keep your test database clean

1171
00:54:58,914 --> 00:55:01,336
after each test method.

1172
00:55:01,336 --> 00:55:03,836
And by splitting the xml files

1173
00:55:04,739 --> 00:55:07,298
you can use one data source for testing,

1174
00:55:07,298 --> 00:55:10,318
and another for production.

1175
00:55:10,318 --> 00:55:12,767
Well, there's just one
final practical session

1176
00:55:12,767 --> 00:55:15,092
where you can try this yourself

1177
00:55:15,092 --> 00:55:18,292
and then all that remains
is the close of the course.

1178
00:55:18,292 --> 00:55:20,542
Where I'll show you where to go next,

1179
00:55:20,542 --> 00:55:23,542
plus a brief overview of Spring MVC.

1
00:00:00,286 --> 00:00:05,256
(fun music)

2
00:00:10,323 --> 00:00:12,926
- [Voiceover] Welcome back to
your final practical session

3
00:00:12,926 --> 00:00:16,552
on this Spring Framework
Fundamentals course.

4
00:00:16,552 --> 00:00:20,936
The requirement for this
practical is really easy to state.

5
00:00:20,936 --> 00:00:24,510
Your job is to write a
set of integration tests

6
00:00:24,510 --> 00:00:28,670
that test the functionality
of your three services

7
00:00:28,670 --> 00:00:32,339
in your customer relation
management system.

8
00:00:32,339 --> 00:00:34,291
Now because this is a training course,

9
00:00:34,291 --> 00:00:35,987
you don't really need
to worry about writing

10
00:00:35,987 --> 00:00:40,488
very extensive tests;
the important thing is to

11
00:00:40,488 --> 00:00:43,934
identify any major problems and of course

12
00:00:43,934 --> 00:00:48,229
to have a good practice using
a Spring integration test.

13
00:00:48,229 --> 00:00:50,416
My suggestion would be that you

14
00:00:50,416 --> 00:00:53,296
test the customer management service,

15
00:00:53,296 --> 00:00:56,379
maybe test creating a new customer

16
00:00:56,379 --> 00:00:58,907
and finding an existing customer,

17
00:00:58,907 --> 00:01:01,563
something like that.

18
00:01:01,563 --> 00:01:04,368
Now it's entirely up
to you whether you use

19
00:01:04,368 --> 00:01:07,248
manual or automatic wiring,
I think you will have

20
00:01:07,248 --> 00:01:10,267
probably made that decision
earlier on in the course

21
00:01:10,267 --> 00:01:11,920
and which ever one you've gone for,

22
00:01:11,920 --> 00:01:13,637
it doesn't really make a difference

23
00:01:13,637 --> 00:01:15,888
to your integration tests.

24
00:01:15,888 --> 00:01:20,176
Either way, you will be using
that auto-wired annotation

25
00:01:20,176 --> 00:01:22,992
in your integration test.

26
00:01:22,992 --> 00:01:25,456
Make sure that you have your data source

27
00:01:25,456 --> 00:01:29,968
in it's own XML file so that
you can have a special one

28
00:01:29,968 --> 00:01:32,688
just for integration testing.

29
00:01:32,688 --> 00:01:35,525
If you're using manual
wiring, then you might want

30
00:01:35,525 --> 00:01:40,240
to split your XML file into
separate tiers as well.

31
00:01:40,240 --> 00:01:43,696
I didn't get the chance
to do that in the video,

32
00:01:43,696 --> 00:01:47,248
so I will do this on the walk through.

33
00:01:47,248 --> 00:01:49,829
So yep, as always there
will be a walk through,

34
00:01:49,829 --> 00:01:52,059
but try it for yourself first.

35
00:01:52,059 --> 00:01:54,768
In the walk through I
won't do extensive tests,

36
00:01:54,768 --> 00:01:57,072
I'll show you how to
get started and how to

37
00:01:57,072 --> 00:01:59,739
split the XML file into multiple tiers

38
00:01:59,739 --> 00:02:03,344
and then I'll just do two
or three test methods.

39
00:02:03,344 --> 00:02:05,733
So good luck with that and if you need it,

40
00:02:05,733 --> 00:02:08,816
I'll see you in the walk through.

41
00:02:08,816 --> 00:02:11,589
Ok then, here's the final
walk through for the course

42
00:02:11,589 --> 00:02:15,440
and I've off camera
opened up the CRM System

43
00:02:15,440 --> 00:02:16,880
and I've been looking forward to this

44
00:02:16,880 --> 00:02:21,474
because it's going to be
good to get rid of this

45
00:02:21,474 --> 00:02:24,258
test application that we've
writing through the course,

46
00:02:24,258 --> 00:02:26,968
which is effectively an integration test,

47
00:02:26,968 --> 00:02:29,410
but it's not an automatic one.

48
00:02:29,410 --> 00:02:33,912
We have to inspect the
console every time we run

49
00:02:33,912 --> 00:02:36,536
and I don't even know if
this is a good thing or not

50
00:02:36,536 --> 00:02:38,999
with the customer not existing.

51
00:02:38,999 --> 00:02:41,581
So let's write a proper
integration test then,

52
00:02:41,581 --> 00:02:45,824
so as on the video, it's
just a regular new class,

53
00:02:45,824 --> 00:02:50,288
the package is going to
be the same root name,

54
00:02:50,288 --> 00:02:55,288
but we'll have a package
just for integration tests,

55
00:02:55,351 --> 00:02:59,394
and I'm going to call
this customer management

56
00:02:59,394 --> 00:03:02,662
integration tests.

57
00:03:04,034 --> 00:03:07,820
Ok that's great and the
annotations we'll need

58
00:03:07,820 --> 00:03:12,820
is the at run with, I'm
looking for Spring JUnit

59
00:03:13,149 --> 00:03:16,417
for class runner

60
00:03:18,194 --> 00:03:22,279
and don't forget .class on the end of that

61
00:03:22,279 --> 00:03:27,268
and we also have the at
context configuration.

62
00:03:27,268 --> 00:03:29,434
Well I'm going to be doing some splitting

63
00:03:29,434 --> 00:03:34,434
of the XML file, but for now
it's just application.xml.

64
00:03:35,407 --> 00:03:37,871
All of that will need to be imported

65
00:03:37,871 --> 00:03:41,327
and that looks like it's
compiling just fine.

66
00:03:41,327 --> 00:03:45,004
I think I'll write the
stretcher of my first test

67
00:03:45,004 --> 00:03:47,689
and I'm going to be testing

68
00:03:47,689 --> 00:03:52,689
let's say creating a customer record

69
00:03:56,959 --> 00:03:59,913
and also don't forget the void on there.

70
00:03:59,913 --> 00:04:04,571
I will need the at test
annotation at the front of there

71
00:04:04,571 --> 00:04:08,411
and it's the usual arrange at and assert.

72
00:04:08,411 --> 00:04:10,822
So for the arrange, I'm probably going to

73
00:04:10,822 --> 00:04:13,744
want to create a new customer,

74
00:04:13,744 --> 00:04:15,952
which I'll call test customer

75
00:04:15,952 --> 00:04:19,227
and for the data, well I
can put, that's going to be

76
00:04:19,227 --> 00:04:23,408
new customer and for the data,

77
00:04:23,408 --> 00:04:27,653
well I need a customer ID,
that's just a business ID

78
00:04:27,653 --> 00:04:30,864
so I'll use anything there, 9191,

79
00:04:30,864 --> 00:04:34,235
The customer name can be vpp

80
00:04:34,235 --> 00:04:36,443
and I'm just going to
put in test data here,

81
00:04:36,443 --> 00:04:39,643
I think it's email and then

82
00:04:39,643 --> 00:04:44,588
telephone and notes, so I'll
just put some rubbish in there.

83
00:04:49,104 --> 00:04:52,749
The data really doesn't matter in a test,

84
00:04:52,749 --> 00:04:55,394
customer will need to be imported

85
00:04:55,394 --> 00:04:57,112
and there it is.

86
00:04:57,112 --> 00:04:58,509
So what I want to do then, is I want to

87
00:04:58,509 --> 00:05:02,264
pass this to the customer service object.

88
00:05:02,264 --> 00:05:04,269
Well I haven't declared
that so that's going

89
00:05:04,269 --> 00:05:07,029
to become an attribute of this class.

90
00:05:07,029 --> 00:05:11,487
So that's the customer and
I'll use the suggestion there

91
00:05:11,487 --> 00:05:15,808
it's the customer management service

92
00:05:15,808 --> 00:05:20,504
and I'll call that, I don't
know, customer service

93
00:05:21,920 --> 00:05:24,960
and as I mentioned even
though I'm using manual wiring

94
00:05:24,960 --> 00:05:28,512
for this project, in the
case of an integration test,

95
00:05:28,512 --> 00:05:31,349
I'm going use auto-wired.

96
00:05:31,349 --> 00:05:34,208
There's absolutely no
purpose in using manual

97
00:05:34,208 --> 00:05:37,969
wiring for integration tests.

98
00:05:37,969 --> 00:05:40,988
I think I have an error
compiler on that line just

99
00:05:40,988 --> 00:05:43,815
because I have a stray
round bracket there.

100
00:05:43,815 --> 00:05:48,787
Ok so I'm going to pass
onto my customer service,

101
00:05:50,151 --> 00:05:54,191
I'm going to call the new customer method,

102
00:05:54,191 --> 00:05:56,836
passing in this test customer.

103
00:05:56,836 --> 00:06:00,804
So that's my arrange and act,

104
00:06:00,804 --> 00:06:02,948
and now I want to do an assert,

105
00:06:02,948 --> 00:06:05,455
and it's also sometimes a
little difficult to work out.

106
00:06:05,455 --> 00:06:08,260
Well how do we know that that worked?

107
00:06:08,260 --> 00:06:12,004
Well what I could do
is I could call on the

108
00:06:12,004 --> 00:06:16,945
customer service, I could call
the get old customers method,

109
00:06:18,240 --> 00:06:22,955
and that's going to return
a list of customers.

110
00:06:22,955 --> 00:06:26,486
I'll need to import the list,

111
00:06:26,486 --> 00:06:31,200
if the first part of this
works then we would expect

112
00:06:31,200 --> 00:06:36,152
that the number of
customers returned back from

113
00:06:36,152 --> 00:06:41,152
all customers, I could call
the size method on that.

114
00:06:41,208 --> 00:06:43,426
I would expect that that's going to be

115
00:06:43,426 --> 00:06:48,348
equal to one, so I can
do an assert equals here

116
00:06:49,943 --> 00:06:52,397
and I always get this
the wrong way around,

117
00:06:52,397 --> 00:06:54,904
it's the expected value first.

118
00:06:54,904 --> 00:06:59,869
We're expecting one, the actual
value is number of customers

119
00:07:01,293 --> 00:07:03,960
and by the way it's quite
a common concern here

120
00:07:03,960 --> 00:07:08,653
that well hang on what if
get all customers is faulty

121
00:07:08,653 --> 00:07:11,447
and accidentally returns one

122
00:07:11,447 --> 00:07:16,002
even though the first part is faulty.

123
00:07:16,002 --> 00:07:17,421
Well that's not a problem as long as we

124
00:07:17,421 --> 00:07:20,514
have a separate test
for get all customers.

125
00:07:20,514 --> 00:07:23,693
Now assert equals will need to be imported

126
00:07:23,693 --> 00:07:27,360
and luckily Eclipse gives
you a quick fix here.

127
00:07:27,360 --> 00:07:30,912
So the first of the quick
fixes is the one you want,

128
00:07:30,912 --> 00:07:35,912
it will add in this static
import of org.junit.assert.star

129
00:07:36,274 --> 00:07:40,136
and that brings in all
of the assert methods.

130
00:07:40,136 --> 00:07:42,173
I can never remember how to do that line,

131
00:07:42,173 --> 00:07:45,010
so it's good that Eclipse does it for us.

132
00:07:45,010 --> 00:07:48,189
So that's it we have
our first test in place,

133
00:07:48,189 --> 00:07:50,184
but one thing I mustn't forget,

134
00:07:50,184 --> 00:07:52,189
when I was setting up the annotations,

135
00:07:52,189 --> 00:07:56,980
is I am going to need the at transactional

136
00:07:58,864 --> 00:08:01,701
to ensure that the changes
made in this method

137
00:08:01,701 --> 00:08:04,762
will then be rolled back
and we've got a clean

138
00:08:04,762 --> 00:08:08,460
sheet to start the next test with.

139
00:08:08,460 --> 00:08:10,391
I also realize as I've come up to here,

140
00:08:10,391 --> 00:08:12,338
I've made the same
mistake I did on the video

141
00:08:12,338 --> 00:08:14,450
when I forgot the forward slash

142
00:08:14,450 --> 00:08:17,031
at the front of the XML file.

143
00:08:17,031 --> 00:08:20,413
Ok, so that's a reasonable looking test.

144
00:08:20,413 --> 00:08:22,621
Now at the moment that's
going to talk to the

145
00:08:22,621 --> 00:08:26,642
production database, so I
think before I go any further

146
00:08:26,642 --> 00:08:29,437
I better do some splitting up.

147
00:08:29,437 --> 00:08:33,565
So here is the XML file and
remember I've been working

148
00:08:33,565 --> 00:08:38,565
with manual wiring for
the practical sessions.

149
00:08:39,229 --> 00:08:41,650
So I think what I'm going to
do, it might be a little bit

150
00:08:41,650 --> 00:08:45,394
tedious for you to watch
this, but I'm going to split

151
00:08:45,394 --> 00:08:50,109
this file into services,
data access objects,

152
00:08:50,109 --> 00:08:53,341
and data sources.

153
00:08:53,341 --> 00:08:55,922
It's probably not going to
be a lot of fun to be honest,

154
00:08:55,922 --> 00:08:59,143
but I may as well

155
00:08:59,143 --> 00:09:03,400
do it for illustration, so
I'm going to start with,

156
00:09:03,400 --> 00:09:07,346
I'll call my first file
services.xml, it doesn't matter

157
00:09:07,346 --> 00:09:10,130
if you didn't do this by the way.

158
00:09:10,130 --> 00:09:15,130
I'm going to copy across
all of the service beans,

159
00:09:15,560 --> 00:09:18,109
so that's the customer
service, diary service,

160
00:09:18,109 --> 00:09:23,039
and call service and they're
all going to go into here.

161
00:09:26,877 --> 00:09:29,800
Now notice I will get the
warning and the warning is

162
00:09:29,800 --> 00:09:33,095
because now it can't see the DAOs anymore,

163
00:09:33,095 --> 00:09:34,578
well of course it can't see the DAOs

164
00:09:34,578 --> 00:09:37,224
because they're in another file.

165
00:09:37,224 --> 00:09:39,290
It can be a bit annoying,
but I'll show you

166
00:09:39,290 --> 00:09:42,895
what we can do with this
Spring IDE in a short while

167
00:09:42,895 --> 00:09:45,178
and then I'm going to
create a separate one

168
00:09:45,178 --> 00:09:49,753
for the data access objects

169
00:09:49,753 --> 00:09:54,372
daos.xml and in this one
it's just going to be

170
00:09:54,372 --> 00:09:59,346
two beans and they can go in there

171
00:10:04,091 --> 00:10:08,079
and then I'm going to need one for the,

172
00:10:08,079 --> 00:10:10,799
I'll start with the
production data source.

173
00:10:10,799 --> 00:10:14,394
So this is going to be data source

174
00:10:14,394 --> 00:10:17,033
production.xml.

175
00:10:19,151 --> 00:10:21,295
This is entirely up to you,
but I think I'm going to

176
00:10:21,295 --> 00:10:23,887
take into the data
sources, I'm going to take

177
00:10:23,887 --> 00:10:28,463
both the data source and
the entity manager factory

178
00:10:28,463 --> 00:10:30,425
and if you think about it, the data source

179
00:10:30,425 --> 00:10:34,255
and entity manager factory are
very tightly related together

180
00:10:34,255 --> 00:10:36,089
and you're going to see that
will give us a little bit

181
00:10:36,089 --> 00:10:38,628
of benefit in a moment.

182
00:10:38,628 --> 00:10:41,871
So I'll cut both of those out

183
00:10:41,871 --> 00:10:45,892
and put those into the
data source production.

184
00:10:45,892 --> 00:10:50,054
Ok now that does leave a
couple of beans left behind,

185
00:10:50,054 --> 00:10:54,631
we've got the transaction
manager and these two tags here

186
00:10:54,631 --> 00:10:58,194
and those tags are, remember
the ones that set off the

187
00:10:58,194 --> 00:11:02,279
transaction management and
I also, and I need this tag

188
00:11:02,279 --> 00:11:05,298
to make sure that the
entity manager is injected

189
00:11:05,298 --> 00:11:07,741
into the data access objects.

190
00:11:07,741 --> 00:11:12,741
So we've got here a kind
of miscellaneous XML file.

191
00:11:12,871 --> 00:11:16,061
Now we need the TX and
the context name spaces

192
00:11:16,061 --> 00:11:17,682
so I think rather than creating a new one

193
00:11:17,682 --> 00:11:20,701
and copying those in, I'm going to rename

194
00:11:20,701 --> 00:11:24,737
my application.xml file,

195
00:11:25,853 --> 00:11:27,527
lots of different ways you could do this,

196
00:11:27,527 --> 00:11:31,916
but I'm going to call
this miscellaneous beans.

197
00:11:33,245 --> 00:11:37,191
Now that's just saved me having
to recreate the contexts,

198
00:11:37,191 --> 00:11:40,327
if I'd gone and created a new XML file.

199
00:11:40,327 --> 00:11:42,525
Now what I want to be able to
do is I still want to be able

200
00:11:42,525 --> 00:11:45,802
to run my client's application,
the test times we've been

201
00:11:45,802 --> 00:11:47,956
working with through the course.

202
00:11:47,956 --> 00:11:52,956
So the way I'll do that is by
creating one final XML file

203
00:11:53,701 --> 00:11:56,209
and this is going to be
back to the original name

204
00:11:56,209 --> 00:12:01,209
of application.xml and I think
you know what's coming here

205
00:12:01,479 --> 00:12:06,012
now I can do that import directive

206
00:12:06,012 --> 00:12:08,146
and I can import each of the

207
00:12:08,146 --> 00:12:11,260
production standard XML files.

208
00:12:11,260 --> 00:12:14,369
So that's going to be DAOs,

209
00:12:15,814 --> 00:12:20,744
I'm also going to want
to import the services

210
00:12:29,607 --> 00:12:33,724
and the crucial thing here is

211
00:12:33,724 --> 00:12:38,724
I want the data source,
production XML file,

212
00:12:41,532 --> 00:12:46,532
and finally we will need
the miscellaneous beans.

213
00:12:53,127 --> 00:12:56,636
So I always call this the grand XML file,

214
00:12:56,636 --> 00:12:58,823
it's pulling everything together for a

215
00:12:58,823 --> 00:13:01,141
production standard run.

216
00:13:01,141 --> 00:13:03,829
Now it's something I didn't
mention on the videos,

217
00:13:03,829 --> 00:13:05,948
and that's because I was
working with auto-wiring,

218
00:13:05,948 --> 00:13:08,615
is that if I look at the beans graph,

219
00:13:08,615 --> 00:13:10,493
the beans graph should still work,

220
00:13:10,493 --> 00:13:15,493
it does pull together those
fragments into a proper graph.

221
00:13:15,719 --> 00:13:19,325
Now remember that we have
two halves of the graph

222
00:13:19,325 --> 00:13:22,834
because we're using that
annotation to connect

223
00:13:22,834 --> 00:13:26,845
the data access object to
the entity manager factories.

224
00:13:26,845 --> 00:13:29,682
So the important bean graph is here

225
00:13:29,682 --> 00:13:32,284
and I want you to notice that the services

226
00:13:32,284 --> 00:13:35,303
are still connected together
and are still talking to

227
00:13:35,303 --> 00:13:37,511
the data access objects.

228
00:13:37,511 --> 00:13:41,477
So that's looking good
and I'm hoping therefore,

229
00:13:41,477 --> 00:13:45,434
that I haven't broken
anything with my clients,

230
00:13:45,434 --> 00:13:49,125
we'll come back to the
integration test in a moment,

231
00:13:49,125 --> 00:13:52,772
but the client should still run.

232
00:13:52,772 --> 00:13:55,023
I don't think I'm doing
anything exciting at the moment

233
00:13:55,023 --> 00:14:00,023
in the client's app, but the
key thing is it isn't crashing.

234
00:14:00,265 --> 00:14:04,212
So that's it for the rather
tedious job of splitting up

235
00:14:04,212 --> 00:14:07,839
the XML files, but the point
of doing that was so that

236
00:14:07,839 --> 00:14:11,487
I could have an alternative
version for testing.

237
00:14:11,487 --> 00:14:13,599
So I think I'll do this in a clunky way,

238
00:14:13,599 --> 00:14:16,596
I'm just going to copy all of the lines

239
00:14:16,596 --> 00:14:19,956
in the data source production XML file

240
00:14:19,956 --> 00:14:23,604
and I'll create another one

241
00:14:23,604 --> 00:14:28,590
for data source testing
or data source test.xml

242
00:14:32,777 --> 00:14:36,937
and I can paste in what's
initially going to be

243
00:14:36,937 --> 00:14:40,393
a copy of the previous
one, but this time around

244
00:14:40,393 --> 00:14:44,414
the URL is going to point
to a different database,

245
00:14:44,414 --> 00:14:47,476
this time testing database, by the way

246
00:14:47,476 --> 00:14:50,217
one reason why I took the
entity manager factory

247
00:14:50,217 --> 00:14:53,769
as well is that yeah for
testing we might not want

248
00:14:53,769 --> 00:14:56,201
the SQL to be logged.

249
00:14:56,201 --> 00:14:59,046
So I'm going to set that to false,

250
00:14:59,046 --> 00:15:00,305
you might be surprised at that,

251
00:15:00,305 --> 00:15:02,118
but the reason is because we want

252
00:15:02,118 --> 00:15:05,595
the integration tests
to run automatically,

253
00:15:05,595 --> 00:15:08,251
if something goes wrong
we'll get a red bar.

254
00:15:08,251 --> 00:15:11,014
We don't want the console to be written to

255
00:15:11,014 --> 00:15:14,171
because that's going
to slow the test down.

256
00:15:14,171 --> 00:15:19,171
So you might want to set false
for your testing version,

257
00:15:19,366 --> 00:15:23,736
but we do want the tables to be generated,

258
00:15:23,736 --> 00:15:26,008
whereas on the production version

259
00:15:26,008 --> 00:15:28,589
we might want the SQL to be logged so that

260
00:15:28,589 --> 00:15:31,768
a maintenance programmer can see the logs

261
00:15:31,768 --> 00:15:36,183
or we might want to switch
the generate DDL to false

262
00:15:36,183 --> 00:15:38,637
because talking to an existing database

263
00:15:38,637 --> 00:15:42,104
which has a scheme already
and the database administrator

264
00:15:42,104 --> 00:15:46,445
certainly doesn't want us
creating new tables on the fly.

265
00:15:46,445 --> 00:15:49,442
I will switch that back
to true just for us

266
00:15:49,442 --> 00:15:51,757
because we're not in that situation,

267
00:15:51,757 --> 00:15:53,944
but I did want to mention
that's why you might need

268
00:15:53,944 --> 00:15:57,986
different versions of the
entity manager factory.

269
00:15:57,986 --> 00:16:00,930
So before I run my integration test,

270
00:16:00,930 --> 00:16:03,160
now I'm going to need to reflect that

271
00:16:03,160 --> 00:16:05,389
in my configuration here.

272
00:16:05,389 --> 00:16:09,197
Now it might seem tedious,
having to specify this

273
00:16:09,197 --> 00:16:13,101
array of different fragments,
but if you think about it

274
00:16:13,101 --> 00:16:17,368
this is really quite powerful
that because I'm going to

275
00:16:17,368 --> 00:16:22,368
combine together the
DAO's with the services

276
00:16:25,645 --> 00:16:29,980
and the miscellaneous beans

277
00:16:29,980 --> 00:16:34,220
and the data source test

278
00:16:36,114 --> 00:16:38,129
and this is really useful because

279
00:16:38,129 --> 00:16:40,007
if you get more sophisticated with your

280
00:16:40,007 --> 00:16:43,591
integration tests, it
might be that you need

281
00:16:43,591 --> 00:16:46,542
a testing version of your DAO layer,

282
00:16:46,542 --> 00:16:47,982
and you might need that because you

283
00:16:47,982 --> 00:16:50,980
want to use some mocks instead of using

284
00:16:50,980 --> 00:16:54,596
the real database and you
could very easily do that

285
00:16:54,596 --> 00:16:59,508
by having a, I don't
know, DAOs mocks XML file,

286
00:17:00,590 --> 00:17:03,865
but in production you
use a different version.

287
00:17:03,865 --> 00:17:05,369
We won't be doing that on the course,

288
00:17:05,369 --> 00:17:08,419
but I hope you can see
the power and flexibility

289
00:17:08,419 --> 00:17:10,926
that that can give you.

290
00:17:10,926 --> 00:17:13,593
So that was quite a lot of
engineering work and I know

291
00:17:13,593 --> 00:17:17,177
that wasn't very exciting,
but we should be ready now

292
00:17:17,177 --> 00:17:20,488
to run this test for the first time

293
00:17:21,860 --> 00:17:23,908
and of course I have a red bar

294
00:17:23,908 --> 00:17:26,905
and I think I've done
the same thing as usual,

295
00:17:26,905 --> 00:17:31,310
failed to load the application context,

296
00:17:31,310 --> 00:17:35,353
yeah because it can't find the file.

297
00:17:35,353 --> 00:17:38,135
It's getting late in the course,

298
00:17:38,135 --> 00:17:40,683
I forgot to put the forward slashes

299
00:17:40,683 --> 00:17:43,517
in front of all of the file names.

300
00:17:43,517 --> 00:17:48,517
Hmm, ok well that's done
I can rerun the test,

301
00:17:51,709 --> 00:17:54,173
a satisfying green bar.

302
00:17:54,173 --> 00:17:56,190
Well that's pretty much it
for the walk through really,

303
00:17:56,190 --> 00:17:59,325
it's now just a case of writing
a few more test methods.

304
00:17:59,325 --> 00:18:02,205
So just to make sure that
there's nothing nasty

305
00:18:02,205 --> 00:18:06,067
lurking in the application,
I'll write a few more tests.

306
00:18:06,067 --> 00:18:09,128
So this next one can be,

307
00:18:09,128 --> 00:18:11,795
let's test retrieving a customer.

308
00:18:11,795 --> 00:18:16,782
So I'll call this test finding a customer.

309
00:18:18,451 --> 00:18:20,424
So remember we're going
to have a completely clean

310
00:18:20,424 --> 00:18:23,560
database when this test starts.

311
00:18:23,560 --> 00:18:25,875
So I'm going to beed to
create a new customer

312
00:18:25,875 --> 00:18:29,128
and it's quite common to
need to copy and paste code

313
00:18:29,128 --> 00:18:30,845
from one test to another.

314
00:18:30,845 --> 00:18:32,957
I know that copying and
pasting is not necessarily

315
00:18:32,957 --> 00:18:36,445
good style, but in tests
it's usually the easiest way

316
00:18:36,445 --> 00:18:39,389
or it's sometimes the
easiest way of doing things.

317
00:18:39,389 --> 00:18:43,059
I could make this test customer
be an attribute of the class

318
00:18:43,059 --> 00:18:46,472
if you prefer, but this is
now seed of the database.

319
00:18:46,472 --> 00:18:50,195
So we've got a single
customer ready to be found.

320
00:18:50,195 --> 00:18:54,391
So I can now call the customer service

321
00:18:55,742 --> 00:18:59,133
find customer by ID method
I think I'll go for,

322
00:18:59,133 --> 00:19:02,920
and this one is going to be 9191,

323
00:19:02,920 --> 00:19:05,474
and I'm expecting

324
00:19:06,515 --> 00:19:09,960
a single customer back from that.

325
00:19:09,960 --> 00:19:11,741
Now I have an error there
because I think that might

326
00:19:11,741 --> 00:19:14,045
throw an exception, yes
it's the customer not

327
00:19:14,045 --> 00:19:16,040
found exception.

328
00:19:16,040 --> 00:19:18,248
So I'll use the quick fix there to

329
00:19:18,248 --> 00:19:20,637
add in the try catch block.

330
00:19:20,637 --> 00:19:23,027
Now this is an important one,

331
00:19:23,027 --> 00:19:27,048
if that exception is thrown
then we've definitely failed,

332
00:19:27,048 --> 00:19:30,664
we're completely expecting
this customer to be found.

333
00:19:30,664 --> 00:19:35,503
So what I will do in here is
I will invoke the fail method

334
00:19:39,343 --> 00:19:42,091
which will immediately cause fail.

335
00:19:42,091 --> 00:19:43,861
Now that will need to be imported,

336
00:19:43,861 --> 00:19:48,107
now I know earlier on I added
that static import with .star,

337
00:19:48,107 --> 00:19:51,509
but because I've called
the control shift o,

338
00:19:51,509 --> 00:19:55,243
when you do control shift
o it optimizes the import

339
00:19:55,243 --> 00:19:59,797
so it removed the .star
and replaced it with the

340
00:19:59,797 --> 00:20:04,797
explicit assert equals so
I had to do that again.

341
00:20:05,216 --> 00:20:06,666
It's up to you whether you do anything

342
00:20:06,666 --> 00:20:10,635
with the found customer,
that method is returned

343
00:20:10,635 --> 00:20:12,843
kind of suggests that
the customer was found,

344
00:20:12,843 --> 00:20:16,651
but I guess we could do
a quick assert equals

345
00:20:16,651 --> 00:20:18,709
and we want to make sure that the customer

346
00:20:18,709 --> 00:20:22,965
that was found matches
the customer that we

347
00:20:22,965 --> 00:20:25,216
originally sent in.

348
00:20:25,216 --> 00:20:29,632
So we're expecting to get back the same

349
00:20:29,632 --> 00:20:33,611
object as the original test customer,

350
00:20:33,611 --> 00:20:38,537
the actual value was the found customer.

351
00:20:42,506 --> 00:20:47,002
So I hope that's ok,
let's run that test again,

352
00:20:49,557 --> 00:20:52,373
and good that's run through ok.

353
00:20:52,373 --> 00:20:55,232
I kind of fancy going a
little further with tests,

354
00:20:55,232 --> 00:20:58,475
so I'm going to write
another test that will

355
00:20:58,475 --> 00:21:01,387
test adding a call to a
customer because I think

356
00:21:01,387 --> 00:21:03,723
that's one of the richer
features on our system.

357
00:21:03,723 --> 00:21:08,723
So I'll do test adding
a call to a customer,

358
00:21:09,663 --> 00:21:10,887
now if you remember it's quite a long way

359
00:21:10,887 --> 00:21:12,722
back in the course, that's where we have

360
00:21:12,722 --> 00:21:16,764
a separate service, the
call handling service

361
00:21:16,764 --> 00:21:19,826
that works with the diary and the customer

362
00:21:19,826 --> 00:21:21,874
management service.

363
00:21:21,874 --> 00:21:23,399
So what I'm going to be doing here

364
00:21:23,399 --> 00:21:27,421
is once again I'll be
creating a test customer

365
00:21:27,421 --> 00:21:29,949
and adding it to the system,

366
00:21:29,949 --> 00:21:33,341
so I'll repeat that code there,

367
00:21:33,341 --> 00:21:35,783
it might well be worth moving that into

368
00:21:35,783 --> 00:21:38,567
a set up method, I won't do that here,

369
00:21:38,567 --> 00:21:42,514
but probably in real life I would,

370
00:21:42,514 --> 00:21:44,957
but then I want to call
the call handling service

371
00:21:44,957 --> 00:21:47,090
which we haven't yet used here

372
00:21:47,090 --> 00:21:50,482
and it's absolutely find to auto-wire in

373
00:21:50,482 --> 00:21:53,927
as many of the Spring objects as you need.

374
00:21:53,927 --> 00:21:57,377
So this is the call handling service

375
00:21:59,378 --> 00:22:02,956
and I'll call it calls service.

376
00:22:05,906 --> 00:22:08,690
I realize it's quite a
long time since we used

377
00:22:08,690 --> 00:22:11,453
the call handling service,
so you might not remember.

378
00:22:11,453 --> 00:22:15,356
It has a single method in
there called record call

379
00:22:15,356 --> 00:22:18,813
and it's looking for a customer ID

380
00:22:18,813 --> 00:22:21,255
so that will be 9191.

381
00:22:21,255 --> 00:22:25,479
We need a new call, so
we'll need to create that,

382
00:22:25,479 --> 00:22:28,359
I'll call it test call

383
00:22:31,219 --> 00:22:34,194
I think parameters into
this are quite simple,

384
00:22:34,194 --> 00:22:38,578
yes so I just need to send in some notes,

385
00:22:38,578 --> 00:22:41,852
this is just a test call

386
00:22:41,852 --> 00:22:44,936
and I'm not interested in
the actions for this test,

387
00:22:44,936 --> 00:22:48,466
so I'm just going to create a blank array,

388
00:22:48,466 --> 00:22:51,090
or an array list I should say

389
00:22:51,090 --> 00:22:54,103
that I'm going to call actions.

390
00:23:00,636 --> 00:23:03,926
I'll need some imports

391
00:23:06,023 --> 00:23:10,695
and it's our virtual pair
programmers action class.

392
00:23:10,695 --> 00:23:15,499
Ok and I think I called
it test call there.

393
00:23:17,063 --> 00:23:19,687
Now that might throw an exception again,

394
00:23:19,687 --> 00:23:24,242
that will be the customer
not found exception

395
00:23:24,242 --> 00:23:28,985
that will be if the 9191
customer doesn't exist

396
00:23:28,985 --> 00:23:31,865
so I need to handle that
and again it's going to be

397
00:23:31,865 --> 00:23:36,740
if this exception is thrown
then we've definitely failed.

398
00:23:36,740 --> 00:23:40,271
That customer was not found

399
00:23:40,271 --> 00:23:44,079
when it certainly should have been found,

400
00:23:44,079 --> 00:23:47,258
but what am I going to assert in here?

401
00:23:47,258 --> 00:23:50,511
Well what I could do here
is, I could from the,

402
00:23:50,511 --> 00:23:53,785
rather from the customer service,

403
00:23:53,785 --> 00:23:57,156
I can bind that customer,
I could get in fact

404
00:23:57,156 --> 00:24:02,156
the full customer detail for customer 9191

405
00:24:02,382 --> 00:24:05,380
and you might remember that
get full customer detail

406
00:24:05,380 --> 00:24:07,961
will return not just the customer,

407
00:24:07,961 --> 00:24:12,121
but all of the associated
calls for that customer

408
00:24:12,121 --> 00:24:15,514
and the Java doc's even
telling me that right there.

409
00:24:15,514 --> 00:24:20,514
So I'll call that the found customer

410
00:24:21,295 --> 00:24:26,159
and that means I should be able to

411
00:24:26,159 --> 00:24:29,177
get the calls for that customer,

412
00:24:29,177 --> 00:24:33,705
I could then get the first
element from that list

413
00:24:34,542 --> 00:24:38,515
and that's going to be a call

414
00:24:41,989 --> 00:24:45,441
and then I could do an assert equals

415
00:24:45,441 --> 00:24:48,065
and again I'm expecting
that the value will

416
00:24:48,065 --> 00:24:52,161
be the same as the original
test call I passed in there

417
00:24:52,161 --> 00:24:56,198
and the actual value was found call.

418
00:24:57,686 --> 00:25:00,129
Quite a complex integration test that one

419
00:25:00,129 --> 00:25:02,262
and if you didn't quite
follow the details then

420
00:25:02,262 --> 00:25:06,145
don't worry too much because
it's not Spring specific

421
00:25:06,145 --> 00:25:09,889
it's specific to the problem domain,

422
00:25:09,889 --> 00:25:12,492
but hopefully you get the general idea.

423
00:25:12,492 --> 00:25:17,490
Now we haven't had any
failing tests so far so,

424
00:25:18,849 --> 00:25:22,540
well yeah I might've known
that that was going to give

425
00:25:22,540 --> 00:25:26,187
an exception, let's maximize the JUnit

426
00:25:26,187 --> 00:25:28,556
so the whole point of integration tests

427
00:25:28,556 --> 00:25:30,785
is to identify where you have problems

428
00:25:30,785 --> 00:25:34,252
in the integration between your tiers

429
00:25:34,252 --> 00:25:38,888
and looking at the error here
it's clearly some kind of

430
00:25:38,888 --> 00:25:43,888
query problem, could not
locate named parameter

431
00:25:44,261 --> 00:25:49,261
customer ID, so this is
about named parameters

432
00:25:50,011 --> 00:25:53,456
which if you recall,
we're having to go back

433
00:25:53,456 --> 00:25:55,685
quite a long way in the course now.

434
00:25:55,685 --> 00:26:00,685
That's specific to, we're using JPA here

435
00:26:01,936 --> 00:26:06,811
so if I look in the JPA
implementation of the DAO

436
00:26:06,811 --> 00:26:08,432
I'm guessing the problem is with that

437
00:26:08,432 --> 00:26:11,056
get full customer detail method.

438
00:26:11,056 --> 00:26:16,000
So I'll scroll down and there's
get full customer detail

439
00:26:17,552 --> 00:26:19,312
and it's a little bit
hard to read because it

440
00:26:19,312 --> 00:26:20,912
doesn't quite fit on the screen,

441
00:26:20,912 --> 00:26:25,912
but I'm creating a
query and oh right well,

442
00:26:27,515 --> 00:26:29,584
it's quite easy really,
I mean I've used the

443
00:26:29,584 --> 00:26:32,581
question mark there, but
then I've referred to the

444
00:26:32,581 --> 00:26:36,197
parameter as customer ID.

445
00:26:36,197 --> 00:26:41,197
I should have used customer
ID preceded by a colon.

446
00:26:43,888 --> 00:26:47,611
Now that's just JPA specific
and I actually gave you

447
00:26:47,611 --> 00:26:51,675
that query in the handout,
but I deliberately left

448
00:26:51,675 --> 00:26:53,552
that error in.

449
00:26:53,552 --> 00:26:56,869
On my version so that
it would be exposed by

450
00:26:56,869 --> 00:26:59,035
an integration test.

451
00:26:59,035 --> 00:27:01,285
So you probably didn't have that problem,

452
00:27:01,285 --> 00:27:05,840
but I wanted to have at least something

453
00:27:05,840 --> 00:27:10,759
trip up an integration
test, so let's rerun

454
00:27:12,272 --> 00:27:15,333
and it's wonderful to
see the green bar again.

455
00:27:15,333 --> 00:27:16,955
So of course I could go further now

456
00:27:16,955 --> 00:27:19,579
and keep adding more and more tests

457
00:27:19,579 --> 00:27:21,648
and certainly on a real
project you would expect

458
00:27:21,648 --> 00:27:24,037
to see a lot more than this.

459
00:27:24,037 --> 00:27:26,800
It's really a discussion
for another course,

460
00:27:26,800 --> 00:27:31,800
but you don't necessarily
need extensive or

461
00:27:31,999 --> 00:27:36,101
complete integration tests,
it's really impossible to get

462
00:27:36,101 --> 00:27:38,352
complete coverage with integration tests

463
00:27:38,352 --> 00:27:40,773
because there are too many combinations

464
00:27:40,773 --> 00:27:44,688
in the interactions between
the tiers of your application,

465
00:27:44,688 --> 00:27:48,645
but I tend to think of them
as tests to sort of exercise

466
00:27:48,645 --> 00:27:52,517
the architecture and give all
of the layers a good kicking

467
00:27:52,517 --> 00:27:56,165
to see if there are any
obvious problems in our layers.

468
00:27:56,165 --> 00:27:59,483
For example, even though
we've only got three tests,

469
00:27:59,483 --> 00:28:04,037
imagine if a few weeks later
a maintenance programmer

470
00:28:04,037 --> 00:28:07,152
or a new joiner to the project comes along

471
00:28:07,152 --> 00:28:11,163
and sees in our misc beans.xml file

472
00:28:11,163 --> 00:28:14,277
that we're using the
JPA transaction manager

473
00:28:14,277 --> 00:28:15,909
and for some reason they decided

474
00:28:15,909 --> 00:28:18,949
no that's the wrong transaction manager

475
00:28:18,949 --> 00:28:22,107
we should be using the
hibernate transaction manager,

476
00:28:22,107 --> 00:28:25,429
so they go in and make a change

477
00:28:28,475 --> 00:28:31,557
like this thinking they're
doing the right thing,

478
00:28:31,557 --> 00:28:35,162
but they're not, well ok
to be fair in this case

479
00:28:35,162 --> 00:28:38,064
that's quite a big mistake to make,

480
00:28:38,064 --> 00:28:39,568
it's going to break a lot of code

481
00:28:39,568 --> 00:28:42,344
and then the code would never run anyway,

482
00:28:42,344 --> 00:28:45,518
the property names are
different for one thing,

483
00:28:45,518 --> 00:28:49,347
but the point is that the
mistake they've made there

484
00:28:49,347 --> 00:28:53,390
will if you run your
integration tests regularly,

485
00:28:53,390 --> 00:28:56,600
will be immediately
detected by the fact that

486
00:28:56,600 --> 00:28:59,310
you're going to see red
bars all over the place

487
00:28:59,310 --> 00:29:02,243
just like this, so we caused this sort of

488
00:29:02,243 --> 00:29:06,488
architectural problem here
and it was very easily

489
00:29:06,488 --> 00:29:09,315
discovered by the integration tests.

490
00:29:09,315 --> 00:29:12,037
I better undo that
change or the practicals

491
00:29:12,037 --> 00:29:16,449
and code folder will be rather ruined

492
00:29:16,449 --> 00:29:18,751
and I'll make sure that
that's still running.

493
00:29:18,751 --> 00:29:20,756
I don't think integration
tests are good for

494
00:29:20,756 --> 00:29:25,727
finding logic problems, unit
tests are the right thing

495
00:29:25,727 --> 00:29:27,882
for logic problems.

496
00:29:27,882 --> 00:29:30,420
So that's why it's important
to have as much of your

497
00:29:30,420 --> 00:29:34,644
logic as possible inside
your domain classes,

498
00:29:34,644 --> 00:29:37,780
which as you know are
not effected by spring.

499
00:29:37,780 --> 00:29:40,959
So I won't go any further with
adding any more test methods

500
00:29:40,959 --> 00:29:43,188
because that would get really boring,

501
00:29:43,188 --> 00:29:45,162
I'm sure if you go ahead and add more

502
00:29:45,162 --> 00:29:48,532
you will find there
are several subtle bugs

503
00:29:48,532 --> 00:29:50,751
like the one we just found,

504
00:29:50,751 --> 00:29:52,980
but hope you did ok with that

505
00:29:52,980 --> 00:29:56,095
and as usual do send us contact message

506
00:29:56,095 --> 00:29:59,743
if you had any problems not
covered by the walk through.

507
00:29:59,743 --> 00:30:01,578
We've got just one chapter to go,

508
00:30:01,578 --> 00:30:03,135
I'm going to be showing
you some of the best

509
00:30:03,135 --> 00:30:05,642
books on the market, where to go next,

510
00:30:05,642 --> 00:30:09,151
and also give you an
overview of the more advanced

511
00:30:09,151 --> 00:30:12,788
Spring MVC which enables
you to put a web front end

512
00:30:12,788 --> 00:30:16,197
onto the front of your application.

1
00:00:00,150 --> 00:00:02,733
(upbeat music)

2
00:00:10,605 --> 00:00:13,302
- [Voiceover] So congratulations
on successfully completing

3
00:00:13,302 --> 00:00:17,313
the Spring Framework
Fundamentals training course.

4
00:00:17,313 --> 00:00:19,026
I hope you float through
all of the Pratt school

5
00:00:19,026 --> 00:00:21,712
sessions successfully as well.

6
00:00:21,712 --> 00:00:24,357
In this closing chapter, we're
going to have a look back

7
00:00:24,357 --> 00:00:25,943
at what we've done.

8
00:00:25,943 --> 00:00:27,727
And I'm also going to give you some clues

9
00:00:27,727 --> 00:00:30,443
as to where to go from here.

10
00:00:30,443 --> 00:00:33,924
I'm also going to do a short overview

11
00:00:33,924 --> 00:00:36,919
of the Spring MVC framework.

12
00:00:36,919 --> 00:00:39,017
Spring MVC is a massive topic

13
00:00:39,017 --> 00:00:41,041
so I can't go into great detail

14
00:00:41,041 --> 00:00:43,870
but I'd like to at
least give you a feeling

15
00:00:43,870 --> 00:00:45,316
for what it's going to feel like

16
00:00:45,316 --> 00:00:49,847
to plug on a web front-end
onto your application.

17
00:00:49,847 --> 00:00:52,343
Let's have a look back at what we've done.

18
00:00:52,343 --> 00:00:56,519
We saw that EJBs, or
Enterprise Java Beans,

19
00:00:56,519 --> 00:00:59,184
were an early attempt to make accessing

20
00:00:59,184 --> 00:01:02,184
the Enterprise Java library simpler.

21
00:01:03,230 --> 00:01:05,647
EJB2 was not a great success.

22
00:01:07,928 --> 00:01:10,812
Spring attempted to do the same thing

23
00:01:10,812 --> 00:01:13,062
but it did it a lot better.

24
00:01:14,453 --> 00:01:16,286
EJB3 is now available,

25
00:01:17,166 --> 00:01:20,481
and that's a vast improvement on EJB2.

26
00:01:20,481 --> 00:01:22,401
And projects face a choice

27
00:01:22,401 --> 00:01:26,568
to use either the official
EJB standard or Spring.

28
00:01:27,509 --> 00:01:30,414
And there are pros and cons to each.

29
00:01:30,414 --> 00:01:34,310
EJB's a standard and
it's now well-respected

30
00:01:34,310 --> 00:01:37,477
despite the earlier terrible versions.

31
00:01:38,474 --> 00:01:41,930
But it does need an
application server to work with

32
00:01:41,930 --> 00:01:44,965
and these are quite heavy and complex.

33
00:01:44,965 --> 00:01:46,377
I should say that you can work

34
00:01:46,377 --> 00:01:48,810
without an application server in EJB,

35
00:01:48,810 --> 00:01:50,080
there are ways to do it,

36
00:01:50,080 --> 00:01:53,192
but I think they're a bit complex as well.

37
00:01:53,192 --> 00:01:57,359
Spring is not a standard,
which some projects won't like.

38
00:01:58,415 --> 00:01:59,735
What's on the plus side,

39
00:01:59,735 --> 00:02:02,162
Spring is quite simple to work with

40
00:02:02,162 --> 00:02:06,417
as long as you're okay
with dependency injection.

41
00:02:06,417 --> 00:02:07,375
And the way you work

42
00:02:07,375 --> 00:02:12,159
is by pulling in the pieces
that you need as you go along.

43
00:02:12,159 --> 00:02:15,513
And only if you need some
kind of complex feature

44
00:02:15,513 --> 00:02:19,689
from an application server
do you need to bring one in.

45
00:02:19,689 --> 00:02:21,787
Most projects probably don't need

46
00:02:21,787 --> 00:02:24,731
any of these complex features.

47
00:02:24,731 --> 00:02:26,644
I never said what kind of feature

48
00:02:26,644 --> 00:02:28,808
you might get from an application server

49
00:02:28,808 --> 00:02:31,268
that you couldn't get elsewhere.

50
00:02:31,268 --> 00:02:35,393
Well, one big example would
possibly be clustering.

51
00:02:35,393 --> 00:02:37,482
That's where you can run your application

52
00:02:37,482 --> 00:02:40,815
on more than one server at the same time

53
00:02:41,695 --> 00:02:45,036
for various reasons,
possibly to boost performance

54
00:02:45,036 --> 00:02:48,389
or maybe to improve reliability.

55
00:02:48,389 --> 00:02:50,475
Application servers are really good

56
00:02:50,475 --> 00:02:52,947
at that kind of thing.

57
00:02:52,947 --> 00:02:55,246
So we said right at
the start of the course

58
00:02:55,246 --> 00:02:56,623
that Spring aims to make

59
00:02:56,623 --> 00:02:59,978
Java Enterprise Development simpler.

60
00:02:59,978 --> 00:03:00,989
So how did it do it?

61
00:03:00,989 --> 00:03:03,949
Well, we saw that the
fundamental principle in Spring

62
00:03:03,949 --> 00:03:06,758
was dependency injection.

63
00:03:06,758 --> 00:03:09,221
This technique allowed us to decouple

64
00:03:09,221 --> 00:03:12,166
the major tiers of our application,

65
00:03:12,166 --> 00:03:15,430
and in doing so, we have
the power to control

66
00:03:15,430 --> 00:03:17,430
each tier independently.

67
00:03:18,387 --> 00:03:22,752
This makes for easier
development and easier testing.

68
00:03:22,752 --> 00:03:26,168
We then moved on to look at
how to access a database.

69
00:03:26,168 --> 00:03:28,708
Possibly one of the most important areas

70
00:03:28,708 --> 00:03:31,154
of server-side development.

71
00:03:31,154 --> 00:03:35,780
JDBC on its own does work,
but it's difficult to use.

72
00:03:35,780 --> 00:03:39,145
I would never want to use
it on a project directly,

73
00:03:39,145 --> 00:03:43,312
but the JDBC template from
Spring made life a lot easier.

74
00:03:44,180 --> 00:03:46,266
If on the other hand, you decided to use

75
00:03:46,266 --> 00:03:48,429
one of the leading ORMs,

76
00:03:48,429 --> 00:03:51,223
that's an object-relational
mapping framework,

77
00:03:51,223 --> 00:03:53,723
instead of JDBC, then you can.

78
00:03:54,606 --> 00:03:58,613
We work with Spring
simplification of Hibernate,

79
00:03:58,613 --> 00:04:00,030
JPA, and MyBatis.

80
00:04:02,340 --> 00:04:04,371
We also had a good look at

81
00:04:04,371 --> 00:04:07,371
aspect-oriented programming, or AOP.

82
00:04:08,448 --> 00:04:12,607
Now, you might not need
to write aspects yourself,

83
00:04:12,607 --> 00:04:15,334
maybe you do have a requirement fallen,

84
00:04:15,334 --> 00:04:19,034
but even if you don't
need to use it directly,

85
00:04:19,034 --> 00:04:23,836
many of the useful features
of Spring depend upon AOP.

86
00:04:23,836 --> 00:04:26,357
And for this course, the big one was

87
00:04:26,357 --> 00:04:28,738
application transactions

88
00:04:28,738 --> 00:04:31,976
being managed automatically by Spring.

89
00:04:31,976 --> 00:04:35,291
So Spring's using AOP to do that.

90
00:04:35,291 --> 00:04:37,276
When you go a bit further with Spring,

91
00:04:37,276 --> 00:04:40,450
you'll find that there
are more uses for AOP,

92
00:04:40,450 --> 00:04:42,533
such as remoting and JMX.

93
00:04:44,405 --> 00:04:47,045
We saw that without
writing any code at all,

94
00:04:47,045 --> 00:04:48,719
Spring can start a transaction

95
00:04:48,719 --> 00:04:50,857
at the beginning of a service method

96
00:04:50,857 --> 00:04:54,505
and will commit at the
end of the service method.

97
00:04:54,505 --> 00:04:58,672
And using exceptions, we
can also control rollbacks.

98
00:04:59,765 --> 00:05:03,605
In the final chapter, we
looked at integration testing.

99
00:05:03,605 --> 00:05:07,202
Because Spring is based
around plain old Java objects,

100
00:05:07,202 --> 00:05:10,133
units testing should not be affected.

101
00:05:10,133 --> 00:05:11,238
But for integration test,

102
00:05:11,238 --> 00:05:14,929
there's some really
smart support in Spring.

103
00:05:14,929 --> 00:05:16,407
So where do you go next?

104
00:05:16,407 --> 00:05:19,754
Well, there are some topics
that we haven't covered

105
00:05:19,754 --> 00:05:22,337
on this fundamental course.

106
00:05:22,337 --> 00:05:25,143
Now, let's start with the web tier.

107
00:05:25,143 --> 00:05:27,062
If you're writing a web application

108
00:05:27,062 --> 00:05:31,229
and want a web front-end, then
you really have two choices.

109
00:05:32,440 --> 00:05:35,706
You might decide to
use one of the existing

110
00:05:35,706 --> 00:05:39,954
web development frameworks
from the open source world.

111
00:05:39,954 --> 00:05:42,565
Now, fortunately there
are hundreds of these

112
00:05:42,565 --> 00:05:46,431
in the Java world, so we
certainly can't list them here.

113
00:05:46,431 --> 00:05:49,235
But most of them usually Spring

114
00:05:49,235 --> 00:05:51,818
can integrate with them easily.

115
00:05:52,693 --> 00:05:56,609
It's really just a case of
making the web framework

116
00:05:56,609 --> 00:06:00,919
be able to see and access
the Spring container.

117
00:06:00,919 --> 00:06:03,504
And that's usually a simple process

118
00:06:03,504 --> 00:06:07,180
and many web frameworks
feature Spring integration

119
00:06:07,180 --> 00:06:08,908
out of the box.

120
00:06:08,908 --> 00:06:11,658
Struts 2 would be a good example.

121
00:06:12,556 --> 00:06:16,569
Now importantly, the code you
have developed on this course

122
00:06:16,569 --> 00:06:19,051
would not need to change.

123
00:06:19,051 --> 00:06:21,498
Alternatively, you or your project

124
00:06:21,498 --> 00:06:24,081
might choose to use Spring MVC.

125
00:06:25,643 --> 00:06:26,950
Now this is a web framework

126
00:06:26,950 --> 00:06:29,971
that was developed by the Spring team

127
00:06:29,971 --> 00:06:32,200
and is in fact part of the JAR files

128
00:06:32,200 --> 00:06:35,708
that you've been using
throughout this course.

129
00:06:35,708 --> 00:06:39,420
It is considered a core part of Spring.

130
00:06:39,420 --> 00:06:42,901
Now, Spring MVC is a
traditional web framework

131
00:06:42,901 --> 00:06:46,000
and it's very similar to most of the other

132
00:06:46,000 --> 00:06:48,789
web frameworks available in Java,

133
00:06:48,789 --> 00:06:52,054
but the big feature of Spring MVC

134
00:06:52,054 --> 00:06:56,221
is that it will integrate with
your container really easily.

135
00:06:57,788 --> 00:07:02,511
Also, part of Spring MVC is a
side project called WebFlow,

136
00:07:02,511 --> 00:07:06,244
and that's good for handling
really complex websites

137
00:07:06,244 --> 00:07:10,661
where you have complex
flows, you have lots of pages

138
00:07:10,661 --> 00:07:12,685
with lots of business rules governing

139
00:07:12,685 --> 00:07:15,185
which page you go to and from.

140
00:07:16,177 --> 00:07:20,344
Now, these are two really big
subjects in their own right.

141
00:07:21,297 --> 00:07:25,464
And many projects who use
Spring don't use Spring MVC,

142
00:07:26,737 --> 00:07:30,743
so that's why we made this
course a course in its own right,

143
00:07:30,743 --> 00:07:33,192
separate from the Fundamentals course.

144
00:07:33,192 --> 00:07:36,486
This is the page for
the Spring MVC course,

145
00:07:36,486 --> 00:07:39,650
you can find it through
our Browse Courses link.

146
00:07:39,650 --> 00:07:41,534
And if you have a look at
the contents page there

147
00:07:41,534 --> 00:07:45,355
you can see that we have
16 chapters on that course

148
00:07:45,355 --> 00:07:49,595
so there is quite a
lot of detail in there.

149
00:07:49,595 --> 00:07:51,208
I don't have accurate figures,

150
00:07:51,208 --> 00:07:53,367
but off the projects I've worked with

151
00:07:53,367 --> 00:07:57,826
that we use in Spring, I
would say a lot less than half

152
00:07:57,826 --> 00:08:00,266
were using Spring MVC.

153
00:08:00,266 --> 00:08:01,395
But it is a good framework

154
00:08:01,395 --> 00:08:05,348
and it integrates with
Spring really cleanly.

155
00:08:05,348 --> 00:08:07,126
Now, while we're here, we don't have time

156
00:08:07,126 --> 00:08:08,853
to cover it on this course,

157
00:08:08,853 --> 00:08:11,144
but I would like to give
you a quick overview

158
00:08:11,144 --> 00:08:13,144
of how Spring MVC works.

159
00:08:14,074 --> 00:08:15,777
And the point I want to get across

160
00:08:15,777 --> 00:08:18,621
is that code you've
developed on this course

161
00:08:18,621 --> 00:08:21,079
would not need to change.

162
00:08:21,079 --> 00:08:23,882
Now, back to your
Starting Workspaces folder

163
00:08:23,882 --> 00:08:26,356
that we began the course with,

164
00:08:26,356 --> 00:08:28,967
there is a third workspace
that we haven't yet used

165
00:08:28,967 --> 00:08:32,300
and that's the one called MVC Workspace.

166
00:08:33,321 --> 00:08:37,632
So if you want to follow along
with this part of the course,

167
00:08:37,632 --> 00:08:40,430
what you can do is go into that folder

168
00:08:40,430 --> 00:08:43,554
and we have a folder
in there called Tomcat.

169
00:08:43,554 --> 00:08:47,721
Now, Tomcat is a very well
respected Java web server.

170
00:08:49,288 --> 00:08:53,409
You can almost think of this
as being an application server

171
00:08:53,409 --> 00:08:56,481
but with heavily cut-down features.

172
00:08:56,481 --> 00:09:00,949
You can't run an EJB
on Tomcat, for example,

173
00:09:00,949 --> 00:09:04,789
but you can certainly run a
Spring application on Tomcat,

174
00:09:04,789 --> 00:09:07,364
and that's what we're
going to do right now.

175
00:09:07,364 --> 00:09:09,348
Now, if you're running on Windows,

176
00:09:09,348 --> 00:09:13,072
I'll come back to Unix
and Mac in a moment.

177
00:09:13,072 --> 00:09:17,122
You need to run these
"start tomcat.bat" file.

178
00:09:17,122 --> 00:09:20,260
And what we're expecting
to see in the popup window

179
00:09:20,260 --> 00:09:22,069
is something like you can see here.

180
00:09:22,069 --> 00:09:24,912
It's slightly scary-looking logging.

181
00:09:24,912 --> 00:09:27,446
You don't want to see any exceptions there

182
00:09:27,446 --> 00:09:29,609
and you want to see info

183
00:09:29,609 --> 00:09:33,534
and something saying the
server has started up.

184
00:09:33,534 --> 00:09:35,903
If you can see that,
that means you now have

185
00:09:35,903 --> 00:09:40,050
a very lightweight application
server up and running.

186
00:09:40,050 --> 00:09:41,369
If you got an exception here,

187
00:09:41,369 --> 00:09:44,788
it might be because you already
have a web server running

188
00:09:44,788 --> 00:09:46,042
somewhere else.

189
00:09:46,042 --> 00:09:48,668
Make sure you don't
have Apache or GlassFish

190
00:09:48,668 --> 00:09:51,806
or anything like that
running on your machine.

191
00:09:51,806 --> 00:09:53,752
You might possibly want to try a reboot

192
00:09:53,752 --> 00:09:56,724
before trying this if that's the case.

193
00:09:56,724 --> 00:09:59,437
Now, if you're running
on a Mac or on Linux,

194
00:09:59,437 --> 00:10:01,762
then of course you won't be
able to run this bat file,

195
00:10:01,762 --> 00:10:05,776
but in a terminal window,
you can change directories

196
00:10:05,776 --> 00:10:08,966
into the Tomcat bin directory,

197
00:10:08,966 --> 00:10:12,423
and there is a startup shell script

198
00:10:12,423 --> 00:10:15,246
that you can run from your terminal.

199
00:10:15,246 --> 00:10:17,399
Now, once you've run that shell script,

200
00:10:17,399 --> 00:10:20,714
you will probably want to change directory

201
00:10:20,714 --> 00:10:23,018
into the logs directory

202
00:10:23,018 --> 00:10:25,755
and then you want to look at whatever log

203
00:10:25,755 --> 00:10:28,407
is being written to by Tomcat.

204
00:10:28,407 --> 00:10:31,967
Now, that might be "tomcat.log"
as you can see here.

205
00:10:31,967 --> 00:10:33,527
I think on a Mac and on Linux,

206
00:10:33,527 --> 00:10:37,868
you might see a file
called "catalina.out".

207
00:10:37,868 --> 00:10:39,789
And what you want to do on the console

208
00:10:39,789 --> 00:10:41,706
is "tail -f" that file.

209
00:10:44,669 --> 00:10:46,424
And that will do the equivalent

210
00:10:46,424 --> 00:10:48,110
of what we have here on Windows.

211
00:10:48,110 --> 00:10:51,212
It will show you that log
and it will keep updating it

212
00:10:51,212 --> 00:10:53,400
as it gets written to.

213
00:10:53,400 --> 00:10:55,333
Anyway, this isn't a
web development course,

214
00:10:55,333 --> 00:10:56,411
so what I've tried to do here

215
00:10:56,411 --> 00:10:58,683
is just give you a kind
of closed environment

216
00:10:58,683 --> 00:11:01,050
where you can just run this script

217
00:11:01,050 --> 00:11:03,270
without even thinking about it

218
00:11:03,270 --> 00:11:07,010
and then you can concentrate
on the Spring MVC.

219
00:11:07,010 --> 00:11:09,058
Now, once you've started up Tomcat,

220
00:11:09,058 --> 00:11:11,810
you can test that it's running
successfully by firing up

221
00:11:11,810 --> 00:11:15,977
a web browser and visiting
the URL of "localhost:8080"

222
00:11:19,021 --> 00:11:21,651
and if you see a page something like this

223
00:11:21,651 --> 00:11:24,275
then it's up and running.

224
00:11:24,275 --> 00:11:26,024
If you're not getting this working

225
00:11:26,024 --> 00:11:27,467
then you've got two choices.

226
00:11:27,467 --> 00:11:29,899
Of course, you can send us a support call,

227
00:11:29,899 --> 00:11:34,089
but really, I'm only doing
a basic demonstration here,

228
00:11:34,089 --> 00:11:36,099
so if you'd rather just watch the video

229
00:11:36,099 --> 00:11:39,435
then that will work just fine as well.

230
00:11:39,435 --> 00:11:42,612
If you open the workspace in Eclipse,

231
00:11:42,612 --> 00:11:44,365
if you've already got a workspace open

232
00:11:44,365 --> 00:11:47,954
then you can go to File, Switch Workspace.

233
00:11:47,954 --> 00:11:51,243
Then we'll need to open up the
project that's inside there.

234
00:11:51,243 --> 00:11:53,957
So File, New Java Project,

235
00:11:53,957 --> 00:11:55,800
and it's the usual pattern,

236
00:11:55,800 --> 00:11:59,499
we need exactly the correct
name of the project.

237
00:11:59,499 --> 00:12:01,320
I'm sorry I gave this
a slightly silly name,

238
00:12:01,320 --> 00:12:05,487
it's "BookStore", all one
word, and then "MVC Version".

239
00:12:06,646 --> 00:12:08,951
And you need to get
the case correct there.

240
00:12:08,951 --> 00:12:10,822
So as always, if you've
spelled that correctly,

241
00:12:10,822 --> 00:12:12,279
it will say, the Wizard will

242
00:12:12,279 --> 00:12:14,958
automatically configure the JRE.

243
00:12:14,958 --> 00:12:18,041
If all is well, you can click Finish.

244
00:12:18,900 --> 00:12:22,650
Now, all I have here is
exactly the same code

245
00:12:23,547 --> 00:12:26,422
that we had at the end of the videos.

246
00:12:26,422 --> 00:12:30,257
It's the BookStore with the services,

247
00:12:30,257 --> 00:12:32,880
the AccountService and BookService,

248
00:12:32,880 --> 00:12:35,537
and all the stuff that
you're really familiar with.

249
00:12:35,537 --> 00:12:37,305
But I have done in this project though,

250
00:12:37,305 --> 00:12:41,472
is I've added a few extra
files the Spring MVC needs,

251
00:12:42,326 --> 00:12:46,089
such as this one called
"Dispatcher-servlet.xml"

252
00:12:46,089 --> 00:12:49,238
and this one here called "web.xml".

253
00:12:49,238 --> 00:12:51,061
Now, this is not an MVC course,

254
00:12:51,061 --> 00:12:54,158
I can't go into detail about
what they are or how they work

255
00:12:54,158 --> 00:12:56,741
but they just need to be there.

256
00:12:57,664 --> 00:12:59,965
Now, the message I want to get across

257
00:12:59,965 --> 00:13:03,161
from this demonstration
is that the code we wrote

258
00:13:03,161 --> 00:13:05,494
in the previous 31 chapters,

259
00:13:06,351 --> 00:13:09,768
such as the BookService,
production implementation,

260
00:13:09,768 --> 00:13:11,268
remains unaltered.

261
00:13:12,328 --> 00:13:15,720
We wrote that code to
professional standards.

262
00:13:15,720 --> 00:13:17,154
It's just that because we were running

263
00:13:17,154 --> 00:13:19,625
that client application to the console,

264
00:13:19,625 --> 00:13:22,632
it'd feel a little bit
sort of not professional,

265
00:13:22,632 --> 00:13:26,154
but I want to really make it clear that

266
00:13:26,154 --> 00:13:29,544
the clients application
was just a test front-end

267
00:13:29,544 --> 00:13:32,208
and we can effectively
throw that front-end away

268
00:13:32,208 --> 00:13:34,485
and bolt on a web front-end.

269
00:13:34,485 --> 00:13:37,839
Now, the way that Spring
MVC works is it divides

270
00:13:37,839 --> 00:13:41,376
the application into three logical tiers.

271
00:13:41,376 --> 00:13:42,709
The M for Model,

272
00:13:43,821 --> 00:13:45,459
I would think of this as just being

273
00:13:45,459 --> 00:13:48,138
all of the work we've
done on the work so far,

274
00:13:48,138 --> 00:13:51,888
our services, our domain,
our DAOs and so on,

275
00:13:52,771 --> 00:13:53,938
are all Model.

276
00:13:54,837 --> 00:13:58,002
And because that's completely
separate from everything else,

277
00:13:58,002 --> 00:14:00,139
we don't need to change it.

278
00:14:00,139 --> 00:14:05,080
The V is for View and for
this very basic demonstration,

279
00:14:05,080 --> 00:14:07,896
I just have a webpage here,

280
00:14:07,896 --> 00:14:11,037
which really is a basic webpage.

281
00:14:11,037 --> 00:14:14,175
It's just going to display
all of the books in the system

282
00:14:14,175 --> 00:14:16,656
with a title and an author.

283
00:14:16,656 --> 00:14:18,706
Now, it's called the View because in here

284
00:14:18,706 --> 00:14:22,740
we don't expect any logic,
any code, any processing.

285
00:14:22,740 --> 00:14:25,573
It's just displaying some results.

286
00:14:26,439 --> 00:14:29,575
But perhaps the most
interesting, one of the three,

287
00:14:29,575 --> 00:14:30,825
is the Control.

288
00:14:31,738 --> 00:14:33,927
Now, what I've done is
I've written a new class

289
00:14:33,927 --> 00:14:36,988
called "ManageBooksController".

290
00:14:36,988 --> 00:14:38,988
Now, a controller in MVC

291
00:14:40,226 --> 00:14:44,233
is sort of designed to glue
the two layers together.

292
00:14:44,233 --> 00:14:48,482
It's the bridge between
the View and the Model.

293
00:14:48,482 --> 00:14:49,764
Now, without this layer,

294
00:14:49,764 --> 00:14:51,952
you'd either have to into your model

295
00:14:51,952 --> 00:14:54,692
and put some web-type code

296
00:14:54,692 --> 00:14:58,084
or you'd have to do something
complicated in your View.

297
00:14:58,084 --> 00:15:00,018
Now, what you're looking at here

298
00:15:00,018 --> 00:15:04,101
is almost production
standard Spring MVC control.

299
00:15:05,239 --> 00:15:08,656
Very simple code, very, very clean class.

300
00:15:09,682 --> 00:15:13,637
But the wonderful thing
about working in Spring MVC

301
00:15:13,637 --> 00:15:18,271
is you don't have to open
an application context.

302
00:15:18,271 --> 00:15:22,380
You do not have to start up the container.

303
00:15:22,380 --> 00:15:24,673
That's done for you at the point

304
00:15:24,673 --> 00:15:27,913
you send your application to Tomcat.

305
00:15:27,913 --> 00:15:29,770
And what you get in these controllers,

306
00:15:29,770 --> 00:15:32,640
notice this class here is annotated.

307
00:15:32,640 --> 00:15:35,837
It's a little bit like
the service, components

308
00:15:35,837 --> 00:15:38,216
and repository annotations.

309
00:15:38,216 --> 00:15:41,596
If we annotate this class with Controller,

310
00:15:41,596 --> 00:15:45,982
this class will automatically
be instantiated at startup

311
00:15:45,982 --> 00:15:50,133
and the best bit here
is that we can easily

312
00:15:50,133 --> 00:15:53,320
get access to any of the
beans that we've configured

313
00:15:53,320 --> 00:15:56,061
in our XML wiring file.

314
00:15:56,061 --> 00:15:59,223
So our book service
implementation, in this case,

315
00:15:59,223 --> 00:16:03,473
is going to be injected
straight into this controller.

316
00:16:03,473 --> 00:16:06,570
And then what we do is we write a method

317
00:16:06,570 --> 00:16:08,273
to perform some business logic.

318
00:16:08,273 --> 00:16:09,965
Now, the business logic I want

319
00:16:09,965 --> 00:16:13,820
is to display all books on a webpage.

320
00:16:13,820 --> 00:16:18,336
Now notice this annotation
here, this "/all-books",

321
00:16:18,336 --> 00:16:21,817
that's how we tell Spring MVC what URL

322
00:16:21,817 --> 00:16:25,607
we want to associate with
this business process.

323
00:16:25,607 --> 00:16:28,012
So we're going to visit all books

324
00:16:28,012 --> 00:16:30,316
on the browser in a few moments.

325
00:16:30,316 --> 00:16:35,257
And Spring MVC will know we
need to run this logic in here.

326
00:16:35,257 --> 00:16:37,011
Now, what is the logic in here?

327
00:16:37,011 --> 00:16:39,891
Well, it's just a case
of calling our model,

328
00:16:39,891 --> 00:16:41,875
that's our service class,

329
00:16:41,875 --> 00:16:44,256
and we can call the method
that we've been working with

330
00:16:44,256 --> 00:16:46,229
throughout this course.

331
00:16:46,229 --> 00:16:48,786
I've just noticed I have a
system out print line in there

332
00:16:48,786 --> 00:16:50,961
which must have been some
debugging from earlier,

333
00:16:50,961 --> 00:16:52,765
we really don't need that.

334
00:16:52,765 --> 00:16:54,853
And the return new model and view,

335
00:16:54,853 --> 00:16:58,766
it's a simple case of telling Spring MVC

336
00:16:58,766 --> 00:17:01,140
which webpage we want it to use

337
00:17:01,140 --> 00:17:03,331
to display the results.

338
00:17:03,331 --> 00:17:05,415
Now this is quite a basic controller,

339
00:17:05,415 --> 00:17:08,669
but it's possible that we
could expand the controller,

340
00:17:08,669 --> 00:17:11,434
maybe call two or three different services

341
00:17:11,434 --> 00:17:13,778
and then combine the results together

342
00:17:13,778 --> 00:17:16,518
before sending across to a webpage,

343
00:17:16,518 --> 00:17:19,641
but that's it for the controller.

344
00:17:19,641 --> 00:17:20,919
Now, one of the reasons that we can't go

345
00:17:20,919 --> 00:17:23,666
into too much detail on
Spring MVC on this course

346
00:17:23,666 --> 00:17:26,023
is that a problem with web applications

347
00:17:26,023 --> 00:17:28,678
is you do have to deploy them to a server.

348
00:17:28,678 --> 00:17:30,216
Now, what we've done on this course,

349
00:17:30,216 --> 00:17:32,749
it's the same as we do on
the Spring MVC courses.

350
00:17:32,749 --> 00:17:35,296
We've provided an Ant script

351
00:17:35,296 --> 00:17:38,176
which you can run and that should make

352
00:17:38,176 --> 00:17:40,727
your web application become live.

353
00:17:40,727 --> 00:17:43,082
Now, you don't need to
understand this Ant script,

354
00:17:43,082 --> 00:17:45,911
you don't need to change
anything inside there.

355
00:17:45,911 --> 00:17:47,549
If you want to run this application,

356
00:17:47,549 --> 00:17:52,132
then just right-click
on the XML, "build.xml",

357
00:17:52,132 --> 00:17:54,549
select Run As, and Ant Build.

358
00:17:58,956 --> 00:18:02,623
And all being well, the
code should compile,

359
00:18:03,732 --> 00:18:06,821
and you should see a build complete.

360
00:18:06,821 --> 00:18:10,034
I'm going to quickly switch
cross to the Tomcat console,

361
00:18:10,034 --> 00:18:12,066
and watch this console
re-correct carefully.

362
00:18:12,066 --> 00:18:15,108
What happens is every two
seconds, Tomcat checks to see

363
00:18:15,108 --> 00:18:17,324
if there's a new deployment.

364
00:18:17,324 --> 00:18:19,914
We're getting logging appearing on there,

365
00:18:19,914 --> 00:18:24,081
it's saying "Initializing Spring
root WebApplicationContext"

366
00:18:25,105 --> 00:18:27,609
and then some other stuff is happening.

367
00:18:27,609 --> 00:18:30,132
Now, what's happening
here is that Spring MVC

368
00:18:30,132 --> 00:18:34,023
is automatically opening our container.

369
00:18:34,023 --> 00:18:35,802
So now at this point,

370
00:18:35,802 --> 00:18:38,636
the book service
production implementation,

371
00:18:38,636 --> 00:18:41,324
the DAOs, and all of the advice

372
00:18:41,324 --> 00:18:42,980
and all of the other beans
that we've configured

373
00:18:42,980 --> 00:18:46,576
this week have all now
automatically been created

374
00:18:46,576 --> 00:18:49,993
and will now be available
to the controller

375
00:18:49,993 --> 00:18:52,245
which means I can now go to the webpage,

376
00:18:52,245 --> 00:18:55,077
remember the URL we want is the one here,

377
00:18:55,077 --> 00:18:56,660
which is all books.

378
00:18:57,728 --> 00:19:01,632
Now, before we do that,
I just need to tell you

379
00:19:01,632 --> 00:19:04,205
that the name of the whole application

380
00:19:04,205 --> 00:19:06,955
is called MyWebApp, all one word.

381
00:19:08,534 --> 00:19:11,198
And that's not really anything clever,

382
00:19:11,198 --> 00:19:14,134
it's just that we've built
a file called MyWebApp

383
00:19:14,134 --> 00:19:16,271
in the build script.

384
00:19:16,271 --> 00:19:19,457
So, back to the console then.

385
00:19:19,457 --> 00:19:23,624
If I visit "localhost:8080/mywebapp/all",

386
00:19:28,512 --> 00:19:31,493
you can see that I've
rehearsed this earlier,

387
00:19:31,493 --> 00:19:34,993
"all-books" and you need .html on the end.

388
00:19:36,829 --> 00:19:38,746
Then when I hit Return,

389
00:19:40,410 --> 00:19:43,010
all being well, we have a webpage.

390
00:19:43,010 --> 00:19:45,350
Yeah, I know it's not a
very good-looking webpage,

391
00:19:45,350 --> 00:19:47,090
but of course, it would now be a job

392
00:19:47,090 --> 00:19:49,540
for a professional CSS designer

393
00:19:49,540 --> 00:19:52,160
or whatever to make this look nice.

394
00:19:52,160 --> 00:19:55,036
Now, we're seeing two books
here from the database.

395
00:19:55,036 --> 00:19:56,312
Now, I just want to point out

396
00:19:56,312 --> 00:19:59,512
that if you go into this workspace

397
00:19:59,512 --> 00:20:02,914
and into the Tomcat web apps directory,

398
00:20:02,914 --> 00:20:05,656
there will now be a folder for mywebapp,

399
00:20:05,656 --> 00:20:09,383
and what's happening is the database

400
00:20:09,383 --> 00:20:12,212
that was in Eclipse is being deployed

401
00:20:12,212 --> 00:20:13,508
with this application.

402
00:20:13,508 --> 00:20:16,632
And that's where it's
getting the data from.

403
00:20:16,632 --> 00:20:21,025
So it really is getting
data from a live database.

404
00:20:21,025 --> 00:20:23,137
Now, by the way, if you
followed along with me

405
00:20:23,137 --> 00:20:26,184
and you've opened up
this web app directory,

406
00:20:26,184 --> 00:20:29,563
please make sure that
you leave this directory.

407
00:20:29,563 --> 00:20:33,313
You need to go all the way
back up to the Tomcat directory

408
00:20:33,313 --> 00:20:36,863
because if you then try to
redeploy your web application,

409
00:20:36,863 --> 00:20:39,308
it won't be able to delete the old one

410
00:20:39,308 --> 00:20:41,830
and you'll get a horrible
file-locking problem,

411
00:20:41,830 --> 00:20:44,300
you really don't want that so be careful

412
00:20:44,300 --> 00:20:48,473
not to leave the Tomcat webapps directory

413
00:20:48,473 --> 00:20:50,636
open in Explorer.

414
00:20:50,636 --> 00:20:53,107
Now, just to go back to
Eclipse for a moment,

415
00:20:53,107 --> 00:20:57,274
I have to tell you in my
data source configuration,

416
00:20:58,208 --> 00:21:03,092
I maximize that, I did have to
bodge this a little bit too,

417
00:21:03,092 --> 00:21:07,043
I kind of hard coded the path
the database.dot file there.

418
00:21:07,043 --> 00:21:10,053
Now, of course in a real
application you wouldn't do that,

419
00:21:10,053 --> 00:21:12,292
this will be pointing to a proper database

420
00:21:12,292 --> 00:21:14,042
like Oracle or MySQL.

421
00:21:15,748 --> 00:21:19,387
That's just a minor concession
I had to make for this demo.

422
00:21:19,387 --> 00:21:22,151
If I have a look on the
Tomcat console by the way,

423
00:21:22,151 --> 00:21:24,332
we're seeing the logging
from our application,

424
00:21:24,332 --> 00:21:27,749
this is what we used to
have in the clips console

425
00:21:27,749 --> 00:21:30,154
and I still have the timing advice on

426
00:21:30,154 --> 00:21:31,647
which is quite interesting,

427
00:21:31,647 --> 00:21:34,171
so everything we've done this week

428
00:21:34,171 --> 00:21:38,030
is now running right there
inside the web application.

429
00:21:38,030 --> 00:21:39,120
So I'm sorry that I can't go

430
00:21:39,120 --> 00:21:41,359
into any more detail on Spring MVC,

431
00:21:41,359 --> 00:21:46,241
I really wanted to show you
that it's relatively easy

432
00:21:46,241 --> 00:21:48,558
to plug on a web front-end

433
00:21:48,558 --> 00:21:52,283
without having to change
any business code.

434
00:21:52,283 --> 00:21:54,948
So Spring MVC is quite
a big complex framework

435
00:21:54,948 --> 00:21:59,101
and do check out or separate
course if you're interested.

436
00:21:59,101 --> 00:22:02,304
Now, there's no doubt that
Spring is a huge framework,

437
00:22:02,304 --> 00:22:04,851
there is no one developer
on the planet, probably,

438
00:22:04,851 --> 00:22:07,206
who knows everything in Spring.

439
00:22:07,206 --> 00:22:09,537
Maybe Rod Johnson might
have done in the old days,

440
00:22:09,537 --> 00:22:13,918
but he's left Spring
since the VMware buyout.

441
00:22:13,918 --> 00:22:15,729
Our aim on this course was to give you

442
00:22:15,729 --> 00:22:18,756
the fundamental concepts
so that you can work

443
00:22:18,756 --> 00:22:22,404
on professional projects
anywhere in the world.

444
00:22:22,404 --> 00:22:24,273
Once you know the fundamentals,

445
00:22:24,273 --> 00:22:26,218
you'll find it much easier to understand

446
00:22:26,218 --> 00:22:29,022
the advanced features because most of them

447
00:22:29,022 --> 00:22:31,484
are based on these principles,

448
00:22:31,484 --> 00:22:34,484
mainly dependency injection and AOP.

449
00:22:35,656 --> 00:22:38,371
Some of the more advanced
features in Spring

450
00:22:38,371 --> 00:22:42,535
include Remoting, and that's
where you can call methods

451
00:22:42,535 --> 00:22:45,715
on objects from remote computers,

452
00:22:45,715 --> 00:22:49,299
possibly even from non-Java clients,

453
00:22:49,299 --> 00:22:52,034
Visual Basic for example.

454
00:22:52,034 --> 00:22:54,766
Webservices, that's where we can transform

455
00:22:54,766 --> 00:22:58,840
our service classes into
standard webservices

456
00:22:58,840 --> 00:23:00,464
and there are two ways of doing that,

457
00:23:00,464 --> 00:23:03,375
two big ways of doing that,
they're called SOAP and REST

458
00:23:03,375 --> 00:23:06,079
and they're both supported by Spring.

459
00:23:06,079 --> 00:23:09,208
We also have general JavaEE services,

460
00:23:09,208 --> 00:23:11,895
these are JavaEE libraries that enable you

461
00:23:11,895 --> 00:23:15,812
to do things such as
timing and sending emails.

462
00:23:17,241 --> 00:23:20,834
There's also a messaging library in JavaEE

463
00:23:20,834 --> 00:23:24,372
and Spring can integrate with that.

464
00:23:24,372 --> 00:23:25,366
There's also a library

465
00:23:25,366 --> 00:23:28,276
called the Java Management eXtensions.

466
00:23:28,276 --> 00:23:31,517
That enables you to monitor an application

467
00:23:31,517 --> 00:23:33,234
whilst it's running.

468
00:23:33,234 --> 00:23:35,152
And of course, Security,

469
00:23:35,152 --> 00:23:38,891
to control access to your application.

470
00:23:38,891 --> 00:23:42,283
Now, we are planning to
cover all of these topics

471
00:23:42,283 --> 00:23:45,950
and a few more in an
advanced Spring course.

472
00:23:46,943 --> 00:23:49,540
Now, back in the first
edition of this course

473
00:23:49,540 --> 00:23:52,591
I made exactly the same promise

474
00:23:52,591 --> 00:23:55,736
and then a Virtual Pair
program as we were deluged

475
00:23:55,736 --> 00:24:00,087
with requests to do courses
on JavaEE and build tools,

476
00:24:00,087 --> 00:24:04,030
and Java fundamentals
and Hibernate and JPA.

477
00:24:04,030 --> 00:24:06,042
So I've spent the last four years

478
00:24:06,042 --> 00:24:08,112
working on all of those courses

479
00:24:08,112 --> 00:24:10,984
and unfortunately, the
Spring Advanced course

480
00:24:10,984 --> 00:24:12,868
fell by the wayside.

481
00:24:12,868 --> 00:24:16,550
Well, one of the reasons why
we've updated this course

482
00:24:16,550 --> 00:24:18,172
and released a second edition

483
00:24:18,172 --> 00:24:22,298
is to prepare the ground for
a full Spring Advanced course.

484
00:24:22,298 --> 00:24:25,576
I promise you now that on Monday morning

485
00:24:25,576 --> 00:24:27,575
after finish this course,

486
00:24:27,575 --> 00:24:29,702
I'm moving straight onto recording

487
00:24:29,702 --> 00:24:32,111
the Spring Advanced course.

488
00:24:32,111 --> 00:24:34,481
Now I can't give a release
date for the course,

489
00:24:34,481 --> 00:24:37,092
we always take a long time
to record our courses.

490
00:24:37,092 --> 00:24:39,364
We want to get them right.

491
00:24:39,364 --> 00:24:40,950
By the time you watch this video,

492
00:24:40,950 --> 00:24:42,629
the course may have been released.

493
00:24:42,629 --> 00:24:44,600
You can always check our websites

494
00:24:44,600 --> 00:24:46,718
for a current list of courses.

495
00:24:46,718 --> 00:24:49,018
And if you've bought one
of our courses before

496
00:24:49,018 --> 00:24:50,918
and you're on our mailing list,

497
00:24:50,918 --> 00:24:53,222
then of course you'll get a notification

498
00:24:53,222 --> 00:24:56,360
as soon as that course is ready.

499
00:24:56,360 --> 00:24:59,793
Now, as Spring is so
big, no one expects you

500
00:24:59,793 --> 00:25:01,565
to remember all of the features

501
00:25:01,565 --> 00:25:04,390
and definitely not all of the details

502
00:25:04,390 --> 00:25:06,810
such as all of the class and package names

503
00:25:06,810 --> 00:25:09,686
and I hope I've got that
across on this course.

504
00:25:09,686 --> 00:25:13,251
And I also encourage you
to use the reference manual

505
00:25:13,251 --> 00:25:17,656
and the Java docs on the
Spring Framework website.

506
00:25:17,656 --> 00:25:19,581
Now I'mma say that the reference manual

507
00:25:19,581 --> 00:25:22,441
can be a little bit difficult
to understand in places.

508
00:25:22,441 --> 00:25:24,505
Sometimes they go into too much detail

509
00:25:24,505 --> 00:25:27,146
and sometimes not enough detail.

510
00:25:27,146 --> 00:25:29,469
Hey, that's to be expected after 10 years

511
00:25:29,469 --> 00:25:32,837
of so many people
working on this document.

512
00:25:32,837 --> 00:25:35,563
But often times you can
find exactly what you need

513
00:25:35,563 --> 00:25:37,808
in the documentation.

514
00:25:37,808 --> 00:25:39,356
But you might prefer to have

515
00:25:39,356 --> 00:25:42,024
a good paper book to hand though,

516
00:25:42,024 --> 00:25:43,765
and there are dozens if not hundreds

517
00:25:43,765 --> 00:25:46,242
of books available on Spring.

518
00:25:46,242 --> 00:25:48,892
Some of them are good, some
of them are bad, of course,

519
00:25:48,892 --> 00:25:50,659
but whichever one you buy,

520
00:25:50,659 --> 00:25:52,748
I would probably
recommend that you get one

521
00:25:52,748 --> 00:25:56,081
that covers either Spring 3 or Spring 4.

522
00:25:57,057 --> 00:25:58,686
Now, we don't have any connection

523
00:25:58,686 --> 00:26:00,183
with any publishing companies,

524
00:26:00,183 --> 00:26:02,642
so this is my personal preference,

525
00:26:02,642 --> 00:26:05,970
but I've always found since
I started with Spring,

526
00:26:05,970 --> 00:26:09,836
the book called Spring
in Action by Craig Walls

527
00:26:09,836 --> 00:26:11,559
to be absolutely the best.

528
00:26:11,559 --> 00:26:14,176
It's a lovely, friendly book,

529
00:26:14,176 --> 00:26:17,822
it's comprehensive, it
covers both fundamentals

530
00:26:17,822 --> 00:26:21,898
and advanced topics, and it's
quite entertaining to read.

531
00:26:21,898 --> 00:26:25,414
I personally think this
book was one of the reasons

532
00:26:25,414 --> 00:26:27,603
that Spring became so successful,

533
00:26:27,603 --> 00:26:30,697
it gave developers a
great way into Spring.

534
00:26:30,697 --> 00:26:31,976
And there is one slight problem in

535
00:26:31,976 --> 00:26:34,978
that they are currently
updating this book,

536
00:26:34,978 --> 00:26:38,298
they are currently writing
the fourth edition,

537
00:26:38,298 --> 00:26:42,080
but if you go to the manning.com website,

538
00:26:42,080 --> 00:26:45,821
you can buy an early
access version of that book

539
00:26:45,821 --> 00:26:47,026
and they give you a free copy

540
00:26:47,026 --> 00:26:48,811
of the previous edition as well,

541
00:26:48,811 --> 00:26:51,026
so that's a pretty good deal.

542
00:26:51,026 --> 00:26:53,051
I notice that the fourth edition

543
00:26:53,051 --> 00:26:56,322
seems to be covering Spring 3.2,

544
00:26:56,322 --> 00:26:59,200
I wouldn't be surprised if
they update that for Spring 4

545
00:26:59,200 --> 00:27:01,988
by the time they release the paper book,

546
00:27:01,988 --> 00:27:03,923
but to be honest, if it covers 3.2

547
00:27:03,923 --> 00:27:07,101
that's fine because as I said earlier,

548
00:27:07,101 --> 00:27:10,748
Spring 4 didn't really change very much.

549
00:27:10,748 --> 00:27:14,391
So I'm now off to start recording
the Spring Advanced course

550
00:27:14,391 --> 00:27:18,500
and this time, I promise
I won't get sidetracked.

551
00:27:18,500 --> 00:27:20,446
So it's been great fun revisiting

552
00:27:20,446 --> 00:27:24,183
the Spring Fundamentals
course for the second edition.

553
00:27:24,183 --> 00:27:26,591
It's been great to see Spring do so well

554
00:27:26,591 --> 00:27:29,386
in the last four or five years.

555
00:27:29,386 --> 00:27:31,271
So all that remains for me

556
00:27:31,271 --> 00:27:33,495
is to wish you the very best of luck

557
00:27:33,495 --> 00:27:36,309
and I hope you enjoy
your career in Spring.

558
00:27:36,309 --> 00:27:38,097
I've been Richard Chesterwood,

559
00:27:38,097 --> 00:27:41,499
and from me and everyone at
Virtual Pair Programmers,

560
00:27:41,499 --> 00:27:45,499
goodbye and I'll see you
on another course soon.

561
00:27:46,397 --> 00:27:48,980
(upbeat music)

1
00:00:01,413 --> 00:00:02,887
- [Voiceover] Hello and
welcome to this module

2
00:00:02,887 --> 00:00:06,370
where we will be looking
at how to use JavaConfig

3
00:00:06,370 --> 00:00:09,470
in your Spring applications.

4
00:00:09,470 --> 00:00:12,210
I'm sure you know me by
now, Richard Chesterwood.

5
00:00:12,210 --> 00:00:15,530
I'm the trainer of all of
the Virtual Pair Programmers'

6
00:00:15,530 --> 00:00:17,530
previous Spring courses.

7
00:00:18,618 --> 00:00:21,010
And of course, I will
be assuming that you are

8
00:00:21,010 --> 00:00:24,273
already knowledgeable
about the Spring framework,

9
00:00:24,273 --> 00:00:28,755
but you want to know what
JavaConfig is all about.

10
00:00:28,755 --> 00:00:31,830
And it all comes down to xml.

11
00:00:31,830 --> 00:00:35,719
Which it is fair to say, I think today,

12
00:00:35,719 --> 00:00:37,802
hated by many developers.

13
00:00:38,972 --> 00:00:42,360
Not all developers, for
sure, but a simple search

14
00:00:42,360 --> 00:00:46,193
of the phrase, "xml
hell," gives many results.

15
00:00:49,293 --> 00:00:53,612
And even though I didn't
mention Spring in the search

16
00:00:53,612 --> 00:00:57,112
Spring is very prominent in these results.

17
00:00:58,313 --> 00:01:01,896
And there's a reference
here to JavaConfig.

18
00:01:02,794 --> 00:01:06,220
And anyway, you're a Spring
developer yourself so

19
00:01:06,220 --> 00:01:09,052
I guess you already know for yourself

20
00:01:09,052 --> 00:01:13,002
some of the problems with xml in Spring.

21
00:01:13,002 --> 00:01:15,997
Before we start coding,
a quick history lesson.

22
00:01:15,997 --> 00:01:19,884
When Spring was first devised,
it's aim was to replace

23
00:01:19,884 --> 00:01:21,634
the need to use EJBs.

24
00:01:23,172 --> 00:01:26,505
Now this was around the year 2003, 2004.

25
00:01:28,871 --> 00:01:33,037
And one of the problems
at the time with EJBs

26
00:01:33,037 --> 00:01:36,537
was that you needed to write a mass of xml

27
00:01:37,452 --> 00:01:41,785
in the form of so-called
deployment descriptors.

28
00:01:41,785 --> 00:01:44,169
Now what you're seeing on
screen now is a screenshot

29
00:01:44,169 --> 00:01:48,086
from my live EJB course
that I was forced to do

30
00:01:49,085 --> 00:01:50,980
around that time.

31
00:01:50,980 --> 00:01:53,962
And it was, indeed, hellish.

32
00:01:53,962 --> 00:01:55,953
The documents were massive,

33
00:01:55,953 --> 00:01:59,256
many of the fields were
mandatory even though

34
00:01:59,256 --> 00:02:01,903
they were really dull and routine,

35
00:02:01,903 --> 00:02:04,397
there were no good defaults.

36
00:02:04,397 --> 00:02:07,127
And the schema of these documents were

37
00:02:07,127 --> 00:02:09,343
really poorly designed.

38
00:02:09,343 --> 00:02:13,801
So you had nested tags where
they weren't necessary,

39
00:02:13,801 --> 00:02:16,824
and you had to reverse,
you had related data

40
00:02:16,824 --> 00:02:19,318
that was scattered across the document

41
00:02:19,318 --> 00:02:22,494
rather than being grouped together.

42
00:02:22,494 --> 00:02:25,712
Now we often used to resort to using tools

43
00:02:25,712 --> 00:02:28,248
to generate this xml.

44
00:02:28,248 --> 00:02:32,303
Which at the time many people
thought was a good solution.

45
00:02:32,303 --> 00:02:34,894
But, I find usually,
that when you're forced

46
00:02:34,894 --> 00:02:38,237
to use a tool to generate something,

47
00:02:38,237 --> 00:02:40,968
there's usually something
fundamentally wrong

48
00:02:40,968 --> 00:02:45,050
with the underlying development process.

49
00:02:45,050 --> 00:02:48,143
So all of that is ancient history now.

50
00:02:48,143 --> 00:02:51,055
I'm sure you don't care
about this today but,

51
00:02:51,055 --> 00:02:53,285
it is worth understanding, why?

52
00:02:53,285 --> 00:02:57,798
In Java circles in
particular, xml has always had

53
00:02:57,798 --> 00:03:00,946
this kind of hatred and I
don't think it's ever going

54
00:03:00,946 --> 00:03:04,638
to recover from the bad
feeling that first set in

55
00:03:04,638 --> 00:03:06,221
back in those days.

56
00:03:07,398 --> 00:03:10,330
So when Spring was
invented they decided that

57
00:03:10,330 --> 00:03:14,409
xml was still valuable
because configuration details

58
00:03:14,409 --> 00:03:17,028
should be separated from the code

59
00:03:17,028 --> 00:03:20,176
in order to reduce coupling.

60
00:03:20,176 --> 00:03:24,343
But the xml that Spring worked
with was really simplified.

61
00:03:26,464 --> 00:03:29,348
So back in Spring 1, and
again I'm showing you

62
00:03:29,348 --> 00:03:32,636
a screenshot here from one
of my very early versions

63
00:03:32,636 --> 00:03:35,283
of the Spring Framework course,

64
00:03:35,283 --> 00:03:37,554
at first the xml looked really lovely.

65
00:03:37,554 --> 00:03:40,730
There were only really
three tags to understand.

66
00:03:40,730 --> 00:03:44,380
You had beans, bean, and property,

67
00:03:44,380 --> 00:03:47,320
and everything that you
needed to do in Spring

68
00:03:47,320 --> 00:03:51,570
could be achieved with
just those three tags.

69
00:03:51,570 --> 00:03:53,924
While I say at first it looked lovely

70
00:03:53,924 --> 00:03:58,298
the trouble was, in order to
do anything useful in Spring,

71
00:03:58,298 --> 00:04:02,048
such as declaring
transactions, or doing AOP,

72
00:04:03,509 --> 00:04:06,676
well, you needed a lot of these beans.

73
00:04:07,870 --> 00:04:10,620
And the xml got far too unwieldy.

74
00:04:12,411 --> 00:04:16,328
So in Spring 2, they
decided to add extra tags.

75
00:04:18,570 --> 00:04:22,737
And by sometimes, unofficially
called these the macro tags.

76
00:04:23,571 --> 00:04:27,305
For example, here in this Spring project

77
00:04:27,305 --> 00:04:30,138
we have the tag annotation driven.

78
00:04:31,345 --> 00:04:33,797
You probably know that
this tells Spring that we

79
00:04:33,797 --> 00:04:37,531
want to use transactions and
that it should automatically

80
00:04:37,531 --> 00:04:41,198
search what annotated
transactional classes.

81
00:04:42,216 --> 00:04:46,383
In Spring 1, this would have
been a massive pile of xml.

82
00:04:48,499 --> 00:04:51,745
We would have to configure
transaction proxies,

83
00:04:51,745 --> 00:04:54,476
we had to configure lots of properties,

84
00:04:54,476 --> 00:04:58,224
and we had to wire it all together.

85
00:04:58,224 --> 00:05:01,247
But from Spring 2
onwards, it turned into a

86
00:05:01,247 --> 00:05:03,497
very concise configuration.

87
00:05:04,757 --> 00:05:07,322
But there is a problem
with these macro tags,

88
00:05:07,322 --> 00:05:11,489
I have to admit, I think
Spring here made a mistake.

89
00:05:13,368 --> 00:05:17,380
They were, at the time
of Spring 2 and Spring 3,

90
00:05:17,380 --> 00:05:20,765
completely obsessed with modularity,

91
00:05:20,765 --> 00:05:24,360
I think to the point where
they went way over the top.

92
00:05:24,360 --> 00:05:28,122
And they decided that instead
of making these macro tags

93
00:05:28,122 --> 00:05:31,939
just freely available,
and we could just use them

94
00:05:31,939 --> 00:05:35,450
without thinking about
it, they decided that

95
00:05:35,450 --> 00:05:39,978
they should be optional
additions to our projects

96
00:05:39,978 --> 00:05:43,697
and that we should have
to import these macros

97
00:05:43,697 --> 00:05:45,197
into our projects.

98
00:05:46,331 --> 00:05:49,117
And to do that they used the standard xml

99
00:05:49,117 --> 00:05:50,950
concept of namespaces.

100
00:05:52,307 --> 00:05:55,762
And for this reason you
do usually hear of these

101
00:05:55,762 --> 00:05:59,929
macro tags, as I call them,
referred to as the namespaces.

102
00:06:02,137 --> 00:06:05,494
So for example we would
say here on line 19,

103
00:06:05,494 --> 00:06:08,327
that we're using the tx namespace.

104
00:06:09,451 --> 00:06:12,280
And what they did unfortunately,

105
00:06:12,280 --> 00:06:15,930
is they made all of these
namespaces really tiny.

106
00:06:15,930 --> 00:06:19,078
So the tx namespace for
example, and I'm using the

107
00:06:19,078 --> 00:06:22,381
IntelliSense here to tell
me there are only three tags

108
00:06:22,381 --> 00:06:25,055
in that entire namespace.

109
00:06:25,055 --> 00:06:27,089
We've got advice, sanitation-driven,

110
00:06:27,089 --> 00:06:29,422
and JTA transaction manager.

111
00:06:30,335 --> 00:06:33,882
So that means that in
Spring in there are lots of

112
00:06:33,882 --> 00:06:38,033
these namespaces, and on a typical project

113
00:06:38,033 --> 00:06:41,447
you're going to need to
import a lot of them.

114
00:06:41,447 --> 00:06:43,983
And you probably know
by now that the process

115
00:06:43,983 --> 00:06:47,229
of doing this is a right pain in the neck.

116
00:06:47,229 --> 00:06:50,562
Because you've got to add this line here

117
00:06:51,408 --> 00:06:53,741
to declare the tx namespace,

118
00:06:55,107 --> 00:06:59,274
and you also have to include
the line that you can see here.

119
00:07:00,446 --> 00:07:04,667
This is in fact often split
into two separate lines.

120
00:07:04,667 --> 00:07:07,621
And that's declaring the location of where

121
00:07:07,621 --> 00:07:10,239
this namespace is declared.

122
00:07:10,239 --> 00:07:11,870
I think on the Spring fundamentals course

123
00:07:11,870 --> 00:07:13,959
I went into a bit of depth
here and I showed you

124
00:07:13,959 --> 00:07:17,959
where to find this file
here, this Springtx.xsd,

125
00:07:20,020 --> 00:07:24,228
actually that's buried
in one of your jar files.

126
00:07:24,228 --> 00:07:27,418
So you end up with this
block here which is really

127
00:07:27,418 --> 00:07:30,539
ugly and difficult to deal with.

128
00:07:30,539 --> 00:07:33,228
And I have seen many of the
Spring framework teams say,

129
00:07:33,228 --> 00:07:35,846
"well, this isn't a problem
because you can use the

130
00:07:35,846 --> 00:07:39,846
"Spring IDE to automatically
add these lines."

131
00:07:39,846 --> 00:07:44,749
But there we go again with using
tools to simplify processes

132
00:07:44,749 --> 00:07:48,734
that should have been
simple in the first place.

133
00:07:48,734 --> 00:07:52,858
So to summarize that then,
if you can kind of ignore

134
00:07:52,858 --> 00:07:55,812
the misery that's going up here,

135
00:07:55,812 --> 00:07:59,239
then you should find
that the xml down here

136
00:07:59,239 --> 00:08:01,217
is pretty tolerable.

137
00:08:01,217 --> 00:08:04,352
Now you'll probably know
that on real projects,

138
00:08:04,352 --> 00:08:06,877
still these xml documents,
that even using these

139
00:08:06,877 --> 00:08:11,044
namespaces can get too big,
and that's definitely true.

140
00:08:11,956 --> 00:08:14,896
You can split them down using import,

141
00:08:14,896 --> 00:08:18,532
which is actually what I've
done on this project here,

142
00:08:18,532 --> 00:08:21,123
and we did that on the
fundamentals course as well,

143
00:08:21,123 --> 00:08:25,052
and you can also use annotations for some

144
00:08:25,052 --> 00:08:27,379
or all of your classes.

145
00:08:27,379 --> 00:08:31,057
Personally, in real life,
I always use annotations

146
00:08:31,057 --> 00:08:33,557
for my Spring mvc controllers.

147
00:08:34,610 --> 00:08:38,762
Because frankly, I don't
find controllers interesting,

148
00:08:38,762 --> 00:08:41,854
they shouldn't contain
any interesting logic.

149
00:08:41,854 --> 00:08:44,710
They are important cogs
in the architecture,

150
00:08:44,710 --> 00:08:47,441
but I don't want to by
wiring them up all the time

151
00:08:47,441 --> 00:08:50,464
because I never, or at least rarely,

152
00:08:50,464 --> 00:08:54,365
want to rewire them or change them around

153
00:08:54,365 --> 00:08:56,664
in any kind of intelligent way.

154
00:08:56,664 --> 00:08:59,520
So that was a quick review
of the wiring options

155
00:08:59,520 --> 00:09:03,100
that you had available until Spring 3.

156
00:09:03,100 --> 00:09:08,088
But Spring 3 introduced the
concepts of Java Configuration.

157
00:09:08,088 --> 00:09:11,976
And I'm going to call it from
this point onwards JavaConfig.

158
00:09:11,976 --> 00:09:14,622
Now it didn't immediately become popular,

159
00:09:14,622 --> 00:09:17,576
but it has over the
last two or three years

160
00:09:17,576 --> 00:09:20,349
really, suddenly become very popular.

161
00:09:20,349 --> 00:09:22,703
And it does now seem to be the preferred

162
00:09:22,703 --> 00:09:26,703
configuration choice for
probably most projects.

163
00:09:27,719 --> 00:09:30,547
The reference manuals
of Spring have started

164
00:09:30,547 --> 00:09:34,100
to use it heavily and I
think most significantly,

165
00:09:34,100 --> 00:09:36,774
the book Spring in Action,
which for many years

166
00:09:36,774 --> 00:09:40,856
was my favorite book on
Spring, in the latest edition,

167
00:09:40,856 --> 00:09:44,439
they now use JavaConfig
almost exclusively.

168
00:09:45,315 --> 00:09:48,937
And the author constantly
makes references to xml

169
00:09:48,937 --> 00:09:50,901
in a very disparaging way.

170
00:09:50,901 --> 00:09:54,148
I'm here on their free
sample of Chapter 12,

171
00:09:54,148 --> 00:09:57,672
which is the Working with
NoSQL databases chapter,

172
00:09:57,672 --> 00:09:59,330
and there's a very good example.

173
00:09:59,330 --> 00:10:01,128
This paragraph here where he's saying,

174
00:10:01,128 --> 00:10:05,432
well for what it's worth,
you can do this in xml,

175
00:10:05,432 --> 00:10:08,497
but, well really you
don't want to do that.

176
00:10:08,497 --> 00:10:11,381
If you have a fondness for xml,

177
00:10:11,381 --> 00:10:14,864
and I infer from that he
thinks that anyone who does

178
00:10:14,864 --> 00:10:17,930
is probably mad, then
he does reluctantly give

179
00:10:17,930 --> 00:10:19,097
an xml sample.

180
00:10:20,228 --> 00:10:22,555
Now I'm not criticizing
Craig Walls's book here,

181
00:10:22,555 --> 00:10:25,871
I still think it's the best
book on the Spring framework,

182
00:10:25,871 --> 00:10:29,354
I'm really trying to illustrate
that the current climate

183
00:10:29,354 --> 00:10:31,847
in the Spring framework community

184
00:10:31,847 --> 00:10:35,790
is very much against xml configuration.

185
00:10:35,790 --> 00:10:38,576
Also there is a project called Spring Boot

186
00:10:38,576 --> 00:10:41,404
which is a way of getting
your Spring project

187
00:10:41,404 --> 00:10:44,428
up and running really quickly.

188
00:10:44,428 --> 00:10:46,448
We will be producing a module on this

189
00:10:46,448 --> 00:10:48,622
at some point in the future.

190
00:10:48,622 --> 00:10:51,700
It is on my massive to-do list.

191
00:10:51,700 --> 00:10:56,047
But this project uses
JavaConfig, and you'll see here

192
00:10:56,047 --> 00:10:57,691
that they're both saying that there is

193
00:10:57,691 --> 00:11:00,524
absolutely no requirement for xml,

194
00:11:01,801 --> 00:11:04,560
and since many projects
these days are initiating

195
00:11:04,560 --> 00:11:07,151
their project using this boot,

196
00:11:07,151 --> 00:11:09,630
we are seeing more and more JavaConfig

197
00:11:09,630 --> 00:11:12,124
out there in the real world.

198
00:11:12,124 --> 00:11:14,089
Now I'm going to be honest at this stage,

199
00:11:14,089 --> 00:11:16,485
and I will admit that I am not personally

200
00:11:16,485 --> 00:11:19,926
a fan of JavaConfig,
and that's probably why

201
00:11:19,926 --> 00:11:23,980
I've really delayed covering
this course until now.

202
00:11:23,980 --> 00:11:26,451
I personally don't think it's any clearer

203
00:11:26,451 --> 00:11:28,429
to work with than xml.

204
00:11:28,429 --> 00:11:32,609
In fact I think it's a very
ugly solution to the problem.

205
00:11:32,609 --> 00:11:35,536
A better solution would
have been to, maybe,

206
00:11:35,536 --> 00:11:39,436
just use a better format
than xml such as YAML,

207
00:11:39,436 --> 00:11:43,239
or even better, they could
have used a dynamic language

208
00:11:43,239 --> 00:11:46,944
like Scala or Groovy,
to allow us to configure

209
00:11:46,944 --> 00:11:50,177
the Spring container using program code

210
00:11:50,177 --> 00:11:53,855
that has been made to look
like simple configuration.

211
00:11:53,855 --> 00:11:58,481
In other words, a DSL or
domain-specific language.

212
00:11:58,481 --> 00:12:01,702
I think one of the reasons
that I've always enjoyed

213
00:12:01,702 --> 00:12:05,269
working with Spring is
Spring, traditionally,

214
00:12:05,269 --> 00:12:08,947
enforced a separation between
the deployment aspects

215
00:12:08,947 --> 00:12:12,430
of your architecture, in
other words, how your system

216
00:12:12,430 --> 00:12:15,180
is wired up, and the actual code.

217
00:12:16,318 --> 00:12:20,469
And when you start to do
the configuration in Java,

218
00:12:20,469 --> 00:12:23,520
I think you lose some of that separation.

219
00:12:23,520 --> 00:12:26,028
The separation is still there, to be fair,

220
00:12:26,028 --> 00:12:28,200
and you're going to see on
this module that there are ways

221
00:12:28,200 --> 00:12:31,434
that we can achieve if
you like dynamic wiring

222
00:12:31,434 --> 00:12:33,063
using JavaConfig.

223
00:12:33,063 --> 00:12:36,156
So it's not all bad, and
certainly many of you

224
00:12:36,156 --> 00:12:38,970
are using it on projects.

225
00:12:38,970 --> 00:12:41,701
It's my job to help you to
understand these frameworks,

226
00:12:41,701 --> 00:12:44,684
so I'm going to put my
grumpiness to one side,

227
00:12:44,684 --> 00:12:47,567
I'll pretend I like JavaConfig,
and I'm going to give you

228
00:12:47,567 --> 00:12:51,118
what I hope will be a really
good guide through it.

229
00:12:51,118 --> 00:12:53,375
We're going to start with a basic project,

230
00:12:53,375 --> 00:12:56,580
just to establish the
fundamentals of JavaConfig

231
00:12:56,580 --> 00:12:58,768
and then we're going to
take one of the projects

232
00:12:58,768 --> 00:13:01,749
that we've built on one
of the earlier courses

233
00:13:01,749 --> 00:13:04,020
and I'll show you how to convert it into

234
00:13:04,020 --> 00:13:06,959
a full JavaConfig project.

235
00:13:06,959 --> 00:13:09,733
Along the way, we'll be
configuring the business tiers.

236
00:13:09,733 --> 00:13:12,686
So we'll be doing things
like connection pools.

237
00:13:12,686 --> 00:13:15,305
And then we'll do the
web tier with JavaConfig,

238
00:13:15,305 --> 00:13:17,352
the Spring mvc.

239
00:13:17,352 --> 00:13:21,239
And finally, and this is
being very heavily requested,

240
00:13:21,239 --> 00:13:24,403
we will look at how to do Spring Security

241
00:13:24,403 --> 00:13:27,997
and Spring OAuth using JavaConfig.

242
00:13:27,997 --> 00:13:30,741
So we're now going to
start with a very basic

243
00:13:30,741 --> 00:13:33,491
overview of how JavaConfig works.

244
00:13:34,433 --> 00:13:37,457
And to do that, I have prepared for you

245
00:13:37,457 --> 00:13:41,624
what is probably the most
simple Spring project possible.

246
00:13:42,667 --> 00:13:45,788
And it's currently configured using xml.

247
00:13:45,788 --> 00:13:47,586
And of course the job is going to be

248
00:13:47,586 --> 00:13:51,472
for us to convert that
into a JavaConfig version.

249
00:13:51,472 --> 00:13:53,102
If you want to follow along with me

250
00:13:53,102 --> 00:13:56,112
than you will find a folder
in your Starting Workspace

251
00:13:56,112 --> 00:13:59,112
folder called Basic Spring Projects.

252
00:14:00,571 --> 00:14:02,966
As usual on Virtual Pair Programs courses,

253
00:14:02,966 --> 00:14:05,627
I have switched the workspace to be

254
00:14:05,627 --> 00:14:08,372
that Starting Workspace folder,

255
00:14:08,372 --> 00:14:10,197
and I'm going to open the project by going

256
00:14:10,197 --> 00:14:14,364
File, New, Java Projects,
and then for project name

257
00:14:15,741 --> 00:14:18,878
exactly the same name as the folder name

258
00:14:18,878 --> 00:14:21,461
which is Basic Spring Projects.

259
00:14:25,913 --> 00:14:28,671
And we should see the
message you can see here.

260
00:14:28,671 --> 00:14:30,691
Let me take you through what we have here.

261
00:14:30,691 --> 00:14:32,753
Very similar to the kinds
of code we would have had

262
00:14:32,753 --> 00:14:34,605
in the very early stages of the

263
00:14:34,605 --> 00:14:38,088
Spring Framework Fundamentals course.

264
00:14:38,088 --> 00:14:42,255
We have two classes here inside
the package called Beans.

265
00:14:43,368 --> 00:14:46,963
I couldn't think of very
interesting names for these classes

266
00:14:46,963 --> 00:14:50,463
so I've just gone for Class A and Class B.

267
00:14:52,216 --> 00:14:56,383
The idea is that Class A
contains a reference to Class B,

268
00:14:58,360 --> 00:15:01,621
and I've called that reference dependency.

269
00:15:01,621 --> 00:15:03,934
I have a pair of get and
set methods so that we

270
00:15:03,934 --> 00:15:07,917
can configure it using
dependency injection.

271
00:15:07,917 --> 00:15:10,983
I have here a business method,
and that business method

272
00:15:10,983 --> 00:15:15,384
is going to delegate that
dependent class to get a

273
00:15:15,384 --> 00:15:19,285
value out of it which it will
just print to the console.

274
00:15:19,285 --> 00:15:22,337
We also have a method
here called Create Bean A,

275
00:15:22,337 --> 00:15:24,566
I'll show you what that's
for a little bit later

276
00:15:24,566 --> 00:15:26,977
on in this demonstration.

277
00:15:26,977 --> 00:15:31,144
For Class B, similarly simple,
this one has a string value,

278
00:15:32,605 --> 00:15:35,014
which we can get and set.

279
00:15:35,014 --> 00:15:36,854
And again this destroyed Bean B

280
00:15:36,854 --> 00:15:39,765
will be useful a little later on.

281
00:15:39,765 --> 00:15:42,022
Course the interesting
aspects of this is that

282
00:15:42,022 --> 00:15:46,648
we're wiring these beans together
using standard Spring xml.

283
00:15:46,648 --> 00:15:50,075
We have here the definition
of Bean A, and its property

284
00:15:50,075 --> 00:15:54,575
which is the dependency,
which is referring to Bean B,

285
00:15:54,575 --> 00:15:57,236
which Spring will instantiate
and we'll set the value

286
00:15:57,236 --> 00:16:01,624
to some string, we don't
really care what that is.

287
00:16:01,624 --> 00:16:05,776
And to tie it all together we
have a main test harness here

288
00:16:05,776 --> 00:16:08,800
which is going to open
the standard class path

289
00:16:08,800 --> 00:16:10,800
xml application context.

290
00:16:11,949 --> 00:16:16,073
Which you know is the implementation
of the Spring container

291
00:16:16,073 --> 00:16:18,525
or the Spring factory which reads

292
00:16:18,525 --> 00:16:21,423
an xml file from the class path.

293
00:16:21,423 --> 00:16:24,781
And then I'm going to get
one of the beans from Class A

294
00:16:24,781 --> 00:16:27,302
and then I'm going to
call the business method.

295
00:16:27,302 --> 00:16:30,020
All very simple, all very dull.

296
00:16:30,020 --> 00:16:32,103
Let's check that it runs.

297
00:16:34,268 --> 00:16:35,606
And it does.

298
00:16:35,606 --> 00:16:38,030
Don't worry about the red
text, that's because we

299
00:16:38,030 --> 00:16:42,237
have not configured a logging
system yet for this project.

300
00:16:42,237 --> 00:16:46,960
So we need to get this converted
to use JavaConfig instead,

301
00:16:46,960 --> 00:16:49,789
but before we start, a word of warning.

302
00:16:49,789 --> 00:16:53,956
If you go to a search engine
and search for JavaConfig,

303
00:16:54,999 --> 00:16:57,925
you're very likely to find the top result

304
00:16:57,925 --> 00:16:59,805
is the one that you can see here,

305
00:16:59,805 --> 00:17:01,672
which looks just about perfect.

306
00:17:01,672 --> 00:17:04,725
The Spring JavaConfig Reference Guide.

307
00:17:04,725 --> 00:17:07,008
And you might be very
tempted to start studying

308
00:17:07,008 --> 00:17:09,377
what you find in here.

309
00:17:09,377 --> 00:17:13,794
But if you check out the
dates that you can see here,

310
00:17:13,794 --> 00:17:17,011
course this is a very old document.

311
00:17:17,011 --> 00:17:19,965
And what we're in fact
seeing here is the manual

312
00:17:19,965 --> 00:17:23,392
for the very final version
of Spring JavaConfig

313
00:17:23,392 --> 00:17:26,475
when it was a side project to Spring.

314
00:17:28,213 --> 00:17:32,366
It was until 2008 an experimental project

315
00:17:32,366 --> 00:17:36,084
that you could download
as an optional extra.

316
00:17:36,084 --> 00:17:40,194
But from November,
2008, it became absorbed

317
00:17:40,194 --> 00:17:41,944
into the core Spring.

318
00:17:43,385 --> 00:17:46,868
So it no longer has its
own reference manual,

319
00:17:46,868 --> 00:17:49,389
and that's why web searches for JavaConfig

320
00:17:49,389 --> 00:17:51,743
can be very confusing.

321
00:17:51,743 --> 00:17:54,307
So make sure that
whatever you're looking at

322
00:17:54,307 --> 00:17:56,676
it's always up to date

323
00:17:56,676 --> 00:18:00,381
and part of the standard Spring reference.

324
00:18:00,381 --> 00:18:02,583
I've now switched to the standard page

325
00:18:02,583 --> 00:18:05,592
for the core Spring Framework,

326
00:18:05,592 --> 00:18:08,421
and I'm going to find
the reference manual for,

327
00:18:08,421 --> 00:18:12,588
I'll go for the 4.2.2 which
is currently the live version,

328
00:18:13,812 --> 00:18:17,350
and it's not that easy to find but,

329
00:18:17,350 --> 00:18:19,850
if you go down to section six,

330
00:18:21,377 --> 00:18:23,369
this is the details on how to configure

331
00:18:23,369 --> 00:18:27,758
what they used to call the
inversion of control container.

332
00:18:27,758 --> 00:18:31,004
The first few sections in this section

333
00:18:31,004 --> 00:18:34,222
are dealing with the xml version,

334
00:18:34,222 --> 00:18:37,845
but eventually you will
find a section called

335
00:18:37,845 --> 00:18:41,509
Java-based container configuration.

336
00:18:41,509 --> 00:18:45,479
At the time of recording
it was section 6.12,

337
00:18:45,479 --> 00:18:50,008
and this really is the
reference manual for JavaConfig.

338
00:18:50,008 --> 00:18:52,988
So do check out that
manual for full details,

339
00:18:52,988 --> 00:18:56,054
but I'm going to be showing
you over the next few moments

340
00:18:56,054 --> 00:18:59,370
the main aspects of Java configuration.

341
00:18:59,370 --> 00:19:02,964
The main idea behind Spring
Java configuration is that

342
00:19:02,964 --> 00:19:06,140
instead of writing an xml file,

343
00:19:06,140 --> 00:19:10,961
we're going to express exactly
the same configuration,

344
00:19:10,961 --> 00:19:15,071
the fact we have two objects
called Bean A and Bean B

345
00:19:15,071 --> 00:19:19,892
and that they're connected
together using Java code instead.

346
00:19:19,892 --> 00:19:22,357
And I suppose there are
two promised advantages

347
00:19:22,357 --> 00:19:23,653
of doing that.

348
00:19:23,653 --> 00:19:27,429
As a Java programmer you might
just find it more readable,

349
00:19:27,429 --> 00:19:30,117
and more understandable
to look at Java code

350
00:19:30,117 --> 00:19:31,367
instead of xml.

351
00:19:32,848 --> 00:19:34,705
And the second reason is that because

352
00:19:34,705 --> 00:19:36,878
it's going to be Java code

353
00:19:36,878 --> 00:19:40,919
typing mistakes are going to
be picked up by the compiler.

354
00:19:40,919 --> 00:19:45,086
Let's say for example, I
change Bean B to just Bean.

355
00:19:46,798 --> 00:19:48,693
Now it's not going to cause any problems

356
00:19:48,693 --> 00:19:51,856
because I don't have any
special plugin installed,

357
00:19:51,856 --> 00:19:56,023
this is just an xml file, so
the built-in Eclipse compiler

358
00:19:57,094 --> 00:20:00,117
isn't going to see
anything bad about that.

359
00:20:00,117 --> 00:20:03,405
But of course we now have an
unsatisfied dependency here,

360
00:20:03,405 --> 00:20:06,386
there is no bean called Bean B,

361
00:20:06,386 --> 00:20:09,636
so we will see at runtime an exception.

362
00:20:12,043 --> 00:20:13,965
So where to start then?

363
00:20:13,965 --> 00:20:18,507
Well, all we need to do
is to define a new class.

364
00:20:18,507 --> 00:20:21,558
This class can be called
anything you like,

365
00:20:21,558 --> 00:20:25,391
I'm going to go for
Application Configuration.

366
00:20:27,786 --> 00:20:31,171
And it can be in any package you like.

367
00:20:31,171 --> 00:20:33,596
I think I'm going to create a new package

368
00:20:33,596 --> 00:20:37,013
called com.virtualpairprogrammers.config.

369
00:20:38,374 --> 00:20:41,258
And the idea is that what
we do inside this class

370
00:20:41,258 --> 00:20:43,752
is we first of all annotate it with the

371
00:20:43,752 --> 00:20:47,669
standard Spring annotation
of at configuration.

372
00:20:49,032 --> 00:20:51,387
Which will of course need to be imported,

373
00:20:51,387 --> 00:20:53,811
and you can see that it comes right from

374
00:20:53,811 --> 00:20:56,277
the standard Spring framework.

375
00:20:56,277 --> 00:20:59,230
And inside this configuration
class we're really

376
00:20:59,230 --> 00:21:04,204
just going to do exactly what
we were doing in the xml.

377
00:21:04,204 --> 00:21:06,907
And on the occasions
where I've had to convert

378
00:21:06,907 --> 00:21:10,390
an application from xml to JavaConfig,

379
00:21:10,390 --> 00:21:13,390
what I generally do, is cut the xml,

380
00:21:14,946 --> 00:21:19,850
and I'm going to delete the
application.xml file altogether.

381
00:21:19,850 --> 00:21:23,263
And then in our new file
I'm going to paste this in,

382
00:21:23,263 --> 00:21:26,036
and make it be a comment.

383
00:21:26,036 --> 00:21:27,986
And that gives me a really handy reference

384
00:21:27,986 --> 00:21:30,354
because, and I've said
this a couple of times,

385
00:21:30,354 --> 00:21:32,834
what we're doing in
this configuration class

386
00:21:32,834 --> 00:21:37,001
is going to be identical to
what we were doing in the xml.

387
00:21:37,976 --> 00:21:41,598
To tell Spring that we want
it to instantiate a bean

388
00:21:41,598 --> 00:21:44,454
and we want it to have the name of Bean A,

389
00:21:44,454 --> 00:21:47,268
and we want it to be of
this particular class,

390
00:21:47,268 --> 00:21:50,528
we simply write a Java method.

391
00:21:50,528 --> 00:21:54,278
And the method is going
to return an instance

392
00:21:55,711 --> 00:21:59,821
of the class that we want
to bring to instantiate.

393
00:21:59,821 --> 00:22:03,387
So in this case it's going to be Class A.

394
00:22:03,387 --> 00:22:07,357
As with all methods the
method needs to have a name.

395
00:22:07,357 --> 00:22:10,980
We can technically call this
method anything we want.

396
00:22:10,980 --> 00:22:14,574
What will happen is whatever
object that we will return

397
00:22:14,574 --> 00:22:18,614
from this method, Spring is
going to catch that object,

398
00:22:18,614 --> 00:22:20,872
it will put it into the Spring container,

399
00:22:20,872 --> 00:22:22,933
and it will give it the ID

400
00:22:22,933 --> 00:22:26,319
of whatever we called this method.

401
00:22:26,319 --> 00:22:30,150
So if we want to copy
exactly what we had before,

402
00:22:30,150 --> 00:22:33,733
then this method needs
to be called Bean A.

403
00:22:34,957 --> 00:22:37,353
Now for the method
implementation we're going to do

404
00:22:37,353 --> 00:22:40,377
what the Spring container used to do,

405
00:22:40,377 --> 00:22:43,039
and that is we are going to do the work

406
00:22:43,039 --> 00:22:47,206
of instantiating an instance
of the Class A class.

407
00:22:49,182 --> 00:22:52,099
So I could do a return new Class A.

408
00:22:55,521 --> 00:22:57,346
And none of this is compiling because

409
00:22:57,346 --> 00:22:59,846
I will need to import Class A.

410
00:23:00,926 --> 00:23:03,783
So that's compiling, I clearly
haven't done all of the work

411
00:23:03,783 --> 00:23:05,677
that was in the xml.

412
00:23:05,677 --> 00:23:07,739
I think just to get things started,

413
00:23:07,739 --> 00:23:10,401
I'm going to go ahead now
and do exactly the same work

414
00:23:10,401 --> 00:23:11,651
for our Bean B.

415
00:23:12,727 --> 00:23:14,956
This is going to be very routine,

416
00:23:14,956 --> 00:23:18,373
really just changing the A's for the B's.

417
00:23:19,623 --> 00:23:23,790
And in here we will return
a new instance of Class B.

418
00:23:24,917 --> 00:23:28,401
Which itself will need to be imported.

419
00:23:28,401 --> 00:23:32,412
So that Spring knows that we
are intending these methods

420
00:23:32,412 --> 00:23:37,358
to be bean definitions,
we have another annotation

421
00:23:37,358 --> 00:23:40,284
that we need to add on
each of these methods,

422
00:23:40,284 --> 00:23:42,284
and that is the at bean.

423
00:23:43,182 --> 00:23:45,174
Which of course will need to be imported,

424
00:23:45,174 --> 00:23:49,214
comes from the same package as
the configuration annotation.

425
00:23:49,214 --> 00:23:53,478
So we'll need to do that for
both of these new methods.

426
00:23:53,478 --> 00:23:54,856
We're about halfway there now.

427
00:23:54,856 --> 00:23:57,824
Spring will be able to parse this class,

428
00:23:57,824 --> 00:23:59,259
and it will understand that we want to

429
00:23:59,259 --> 00:24:03,035
instantiate an instance
of each of these classes.

430
00:24:03,035 --> 00:24:05,167
But we haven't done
any of the dependencies

431
00:24:05,167 --> 00:24:07,159
or the values.

432
00:24:07,159 --> 00:24:08,218
So how do we do that?

433
00:24:08,218 --> 00:24:10,712
Well I'm going to start with Bean B.

434
00:24:10,712 --> 00:24:13,358
We need to pass into Bean B, somehow,

435
00:24:13,358 --> 00:24:16,108
this value of some amazing value.

436
00:24:17,245 --> 00:24:19,614
And really there's no
complexity behind this,

437
00:24:19,614 --> 00:24:23,542
other than that we manually
code the setter method.

438
00:24:23,542 --> 00:24:25,451
So I'll do a refactor here.

439
00:24:25,451 --> 00:24:28,461
Instead of instantiating
returning in one go,

440
00:24:28,461 --> 00:24:30,982
I'm going to create an instance,

441
00:24:30,982 --> 00:24:33,838
which I'm going to call Bean B,

442
00:24:33,838 --> 00:24:38,005
and then I can call the setter
method the set value method

443
00:24:40,261 --> 00:24:43,048
and let's make it something
slightly different,

444
00:24:43,048 --> 00:24:46,798
this is going to be the
second amazing value.

445
00:24:48,904 --> 00:24:51,717
And we'll return that Bean B back.

446
00:24:51,717 --> 00:24:52,986
So I hope you're getting the flavor

447
00:24:52,986 --> 00:24:55,117
for how this JavaConfig works.

448
00:24:55,117 --> 00:24:58,475
You're really doing the work
that the container used to do.

449
00:24:58,475 --> 00:25:01,846
Now for the first slightly
complex piece of work.

450
00:25:01,846 --> 00:25:06,013
Our Bean A, here, needs to
have a reference to Bean B.

451
00:25:07,475 --> 00:25:09,286
So how do we do that?

452
00:25:09,286 --> 00:25:13,453
Well I'll do a similar job
to before, first of all.

453
00:25:17,060 --> 00:25:19,429
And create a variable for the bean.

454
00:25:19,429 --> 00:25:22,508
And there are two ways
that we can do this.

455
00:25:22,508 --> 00:25:24,667
The general answer is
we're going to call the

456
00:25:24,667 --> 00:25:28,359
setter method of Bean A,
and the setter is called

457
00:25:28,359 --> 00:25:29,609
set dependency.

458
00:25:30,783 --> 00:25:34,531
And we need somehow to get
this instance of Bean B.

459
00:25:34,531 --> 00:25:36,732
The first way of doing it, I think is the,

460
00:25:36,732 --> 00:25:38,780
I suppose the obvious way.

461
00:25:38,780 --> 00:25:40,981
We can just call this method.

462
00:25:40,981 --> 00:25:43,481
So we can say in here, Bean B.

463
00:25:44,520 --> 00:25:47,989
And I'm really trying to elaborate
things here a little bit,

464
00:25:47,989 --> 00:25:51,737
but I realize that I
hope this all should feel

465
00:25:51,737 --> 00:25:53,631
fairly natural to you because it is

466
00:25:53,631 --> 00:25:55,964
just standard, regular Java.

467
00:25:56,947 --> 00:25:59,706
There is a second way of
doing this dependency,

468
00:25:59,706 --> 00:26:01,893
I'll show you that in a few moments

469
00:26:01,893 --> 00:26:03,858
when we have this working.

470
00:26:03,858 --> 00:26:07,048
But I think we've now reached
the point in our configuration

471
00:26:07,048 --> 00:26:09,904
where we have reflected
exactly what we had

472
00:26:09,904 --> 00:26:14,071
in the xml previously, with
Java configuration instead.

473
00:26:15,324 --> 00:26:17,845
So that's okay, only if it works.

474
00:26:17,845 --> 00:26:20,269
So we'll need to go to our main class now,

475
00:26:20,269 --> 00:26:22,052
and we're going to need
to make a change here.

476
00:26:22,052 --> 00:26:25,452
Because of course, currently
we're reading the xml file.

477
00:26:25,452 --> 00:26:27,347
Somehow we need to read this

478
00:26:27,347 --> 00:26:31,164
application configuration class instead.

479
00:26:31,164 --> 00:26:32,850
Now I think I will have covered this

480
00:26:32,850 --> 00:26:34,772
on the Java Fundamentals Course,

481
00:26:34,772 --> 00:26:38,005
but if you're not using xml
then there is an alternative

482
00:26:38,005 --> 00:26:41,126
version of the application context,

483
00:26:41,126 --> 00:26:45,293
and it's called the annotation
config application context.

484
00:26:46,267 --> 00:26:50,850
So I'll need to change that on
both sides of the assignment.

485
00:26:50,850 --> 00:26:53,289
Of course that's not right,
we need to replace this

486
00:26:53,289 --> 00:26:57,008
file name and instead we
pass in a reference to the

487
00:26:57,008 --> 00:26:58,750
configuration class which is

488
00:26:58,750 --> 00:27:01,750
application configuration dot class.

489
00:27:03,390 --> 00:27:07,012
And I hope that wasn't too
difficult but we should now have

490
00:27:07,012 --> 00:27:10,512
a working version of a JavaConfig project.

491
00:27:11,526 --> 00:27:15,274
And there you are, it's
working exactly as before.

492
00:27:15,274 --> 00:27:18,603
I did say there's a second
way of supplying dependencies,

493
00:27:18,603 --> 00:27:21,223
and, I must admit, I don't
know why, but I think this

494
00:27:21,223 --> 00:27:24,051
is my preferred way of
passing the dependency

495
00:27:24,051 --> 00:27:26,168
from one bean to another.

496
00:27:26,168 --> 00:27:30,655
We can instead declare as a
parameter into this class,

497
00:27:30,655 --> 00:27:32,572
an instance of Class B.

498
00:27:34,137 --> 00:27:36,534
And I can call this anything I like,

499
00:27:36,534 --> 00:27:40,198
I'm just going to go for dependency.

500
00:27:40,198 --> 00:27:43,806
And the Spring container just knows that

501
00:27:43,806 --> 00:27:46,662
if we've declared a
parameter in one of these,

502
00:27:46,662 --> 00:27:51,213
at bean methods, then
we must be referring to

503
00:27:51,213 --> 00:27:55,894
another bean that we created
elsewhere in the configuration.

504
00:27:55,894 --> 00:27:57,607
It doesn't matter if that bean's declared

505
00:27:57,607 --> 00:28:00,940
after or before, that's absolutely fine.

506
00:28:02,261 --> 00:28:03,836
It will know to automatically search for

507
00:28:03,836 --> 00:28:08,085
wherever we've declared
this instance of Class B.

508
00:28:08,085 --> 00:28:10,035
So, that's slightly different.

509
00:28:10,035 --> 00:28:14,549
It means we don't have
to call a method in here.

510
00:28:14,549 --> 00:28:18,716
Instead now we can just refer
to this dependency objects.

511
00:28:20,164 --> 00:28:23,355
And I could have supplied
a comma-separated list

512
00:28:23,355 --> 00:28:26,600
of arbitrarily many dependencies,

513
00:28:26,600 --> 00:28:30,627
assuming that I have that many
bean definitions elsewhere.

514
00:28:30,627 --> 00:28:33,413
So let's check that that's working,

515
00:28:33,413 --> 00:28:35,071
and it is.

516
00:28:35,071 --> 00:28:37,997
So it's entirely up to you
which of those versions you use,

517
00:28:37,997 --> 00:28:41,409
it's really dependent on your own taste,

518
00:28:41,409 --> 00:28:42,845
and you're going to find
that as we go further

519
00:28:42,845 --> 00:28:46,607
with JavaConfig that there
are often several ways

520
00:28:46,607 --> 00:28:48,696
of achieving the same goal.

521
00:28:48,696 --> 00:28:50,647
Now I do want to point
out that if you compare

522
00:28:50,647 --> 00:28:53,141
the Java with the xml you'll see that

523
00:28:53,141 --> 00:28:56,067
it isn't really any shorter.

524
00:28:56,067 --> 00:28:59,409
In fact, we've ended up
with more lines of code

525
00:28:59,409 --> 00:29:02,475
than we had in the original xml.

526
00:29:02,475 --> 00:29:06,417
So you are going to find
that it's usually impractical

527
00:29:06,417 --> 00:29:10,584
to keep your entire configuration
in a single Java file.

528
00:29:11,614 --> 00:29:12,631
So you're going to want to

529
00:29:12,631 --> 00:29:16,616
break these files up on a real project.

530
00:29:16,616 --> 00:29:18,343
And we're going to be doing
a real project shortly,

531
00:29:18,343 --> 00:29:20,614
where we will definitely want to do that.

532
00:29:20,614 --> 00:29:23,024
Of course for this project
it's not really necessary,

533
00:29:23,024 --> 00:29:25,560
but I'd like to show you
how we could separate

534
00:29:25,560 --> 00:29:27,678
these two bean definitions into

535
00:29:27,678 --> 00:29:30,428
two separate configuration files.

536
00:29:31,440 --> 00:29:33,752
And the first part of it
is quite simple really,

537
00:29:33,752 --> 00:29:38,238
we can just declare multiple
configuration classes.

538
00:29:38,238 --> 00:29:42,752
So I might call this one,
second configuration.

539
00:29:42,752 --> 00:29:46,350
And as previously, we will need
the configuration annotation

540
00:29:46,350 --> 00:29:49,338
on the top and I think for this project

541
00:29:49,338 --> 00:29:54,274
I'm going to take the second
bean and I'm going to move it

542
00:29:54,274 --> 00:29:58,485
across into this second
configuration class.

543
00:29:58,485 --> 00:30:01,443
To keep things consistent for
the practicals of code folder

544
00:30:01,443 --> 00:30:03,556
I'm also going to take the comment

545
00:30:03,556 --> 00:30:06,288
where I'm got the corresponding xml,

546
00:30:06,288 --> 00:30:07,797
I think I'm going to preserve that

547
00:30:07,797 --> 00:30:11,435
because it's probably quite useful.

548
00:30:11,435 --> 00:30:13,276
Okay while this is still compiling

549
00:30:13,276 --> 00:30:15,962
and it's compiling because
in the Java there are

550
00:30:15,962 --> 00:30:19,389
no dependencies between these two classes.

551
00:30:19,389 --> 00:30:22,226
I should mention that if I'd
gone for the previous version

552
00:30:22,226 --> 00:30:25,290
of declaring these dependencies,

553
00:30:25,290 --> 00:30:28,882
you'll remember previously I had a call

554
00:30:28,882 --> 00:30:31,132
to the Bean B method, well,

555
00:30:32,187 --> 00:30:34,648
that version wouldn't work
here because of course,

556
00:30:34,648 --> 00:30:39,492
we don't have visibility of the
Bean B method in this class.

557
00:30:39,492 --> 00:30:42,813
So that's one good use of this
parameter-based technique,

558
00:30:42,813 --> 00:30:46,737
it means it's easier to separate
the configuration classes.

559
00:30:46,737 --> 00:30:49,831
But the problem is, in our
main class at the minute,

560
00:30:49,831 --> 00:30:53,288
we're only pointing to one
of those configurations.

561
00:30:53,288 --> 00:30:56,109
So I think if we give this a run,

562
00:30:56,109 --> 00:30:58,449
yeah we have an exception,

563
00:30:58,449 --> 00:31:02,343
And the exception is
it can't create Bean A

564
00:31:02,343 --> 00:31:05,760
because it has an unsatisfied dependency,

565
00:31:07,098 --> 00:31:10,431
it can't find any declaration of Bean B.

566
00:31:11,369 --> 00:31:12,561
There are two ways we can fix this.

567
00:31:12,561 --> 00:31:15,625
The first way, and
probably the simplest way,

568
00:31:15,625 --> 00:31:18,206
is we could have here in our main method

569
00:31:18,206 --> 00:31:20,862
we could provide a comma-separated list

570
00:31:20,862 --> 00:31:24,786
of all of the configuration
classes in our system.

571
00:31:24,786 --> 00:31:28,953
So we could have added second
configuration dot class,

572
00:31:32,424 --> 00:31:34,431
and now these two configurations are

573
00:31:34,431 --> 00:31:35,835
going to be combined together.

574
00:31:35,835 --> 00:31:38,068
Let's check if that's working,

575
00:31:38,068 --> 00:31:40,121
and it is back to working now.

576
00:31:40,121 --> 00:31:42,702
So that is quite tedious to do but,

577
00:31:42,702 --> 00:31:45,509
it's actually very useful
when you're doing things like

578
00:31:45,509 --> 00:31:49,426
testing systems, and
you're wanting to assemble

579
00:31:50,807 --> 00:31:53,901
a collection of different configurations.

580
00:31:53,901 --> 00:31:57,130
And we will be doing that
later on in this course,

581
00:31:57,130 --> 00:31:59,304
when we build an integration text.

582
00:31:59,304 --> 00:32:02,972
But in general, if this
is your production run,

583
00:32:02,972 --> 00:32:05,161
it's pretty tedious having to list

584
00:32:05,161 --> 00:32:07,560
all of the configurations here.

585
00:32:07,560 --> 00:32:10,262
So the alternative and really, once again,

586
00:32:10,262 --> 00:32:14,200
this is identical to what
you could do in the xml.

587
00:32:14,200 --> 00:32:17,264
You'll recall that in your
xml config you are able to

588
00:32:17,264 --> 00:32:21,181
use the import tag, well
we have direct analogy

589
00:32:22,079 --> 00:32:24,540
here on the configurations.

590
00:32:24,540 --> 00:32:28,707
There is an at import
annotation, again from exactly

591
00:32:29,611 --> 00:32:32,569
the same package, and
in here I can specify

592
00:32:32,569 --> 00:32:34,817
the name of another configuration class

593
00:32:34,817 --> 00:32:37,671
that I want to combine with this one.

594
00:32:37,671 --> 00:32:41,754
So this would be, second
configuration dot class.

595
00:32:44,762 --> 00:32:47,345
Now we're back to working again.

596
00:32:47,345 --> 00:32:49,779
So the import annotation is identical

597
00:32:49,779 --> 00:32:52,557
to the xml version of
import, which I'm sure

598
00:32:52,557 --> 00:32:55,440
you're very familiar with already.

599
00:32:55,440 --> 00:32:58,066
You're probably familiar with the concept

600
00:32:58,066 --> 00:33:01,649
in the xml of the init
and destroy-methods.

601
00:33:02,910 --> 00:33:05,295
The idea of the init
and destroy-methods is

602
00:33:05,295 --> 00:33:07,981
that we can specify in the
xml that when the container

603
00:33:07,981 --> 00:33:11,665
creates an instance of a
bean, we also want it to

604
00:33:11,665 --> 00:33:14,832
automatically run a particular method.

605
00:33:15,906 --> 00:33:19,135
And the destroy-methods is
the same in reverse, really,

606
00:33:19,135 --> 00:33:22,245
when we close the Spring
container, we might sometimes

607
00:33:22,245 --> 00:33:25,188
want Spring to make sure that it calls

608
00:33:25,188 --> 00:33:29,972
a special destroy method
before the container is closed.

609
00:33:29,972 --> 00:33:32,538
We had a use for both
of those requirements

610
00:33:32,538 --> 00:33:35,451
on our Spring Fundamentals projects.

611
00:33:35,451 --> 00:33:38,938
When we start up our database connections,

612
00:33:38,938 --> 00:33:41,126
we want to run an initialize method

613
00:33:41,126 --> 00:33:44,794
that will make sure that the
tables have been created.

614
00:33:44,794 --> 00:33:47,888
But more importantly,
for the destroy-method,

615
00:33:47,888 --> 00:33:49,578
we always want to make sure
that when we're closing

616
00:33:49,578 --> 00:33:52,128
our system, any database connections

617
00:33:52,128 --> 00:33:55,374
have been successfully closed.

618
00:33:55,374 --> 00:33:57,663
Well we'll be talking about all of that

619
00:33:57,663 --> 00:33:59,821
when we get to our real
projects a little bit

620
00:33:59,821 --> 00:34:01,830
later on in this module.

621
00:34:01,830 --> 00:34:05,284
But I'd like to show you
the theory behind that,

622
00:34:05,284 --> 00:34:07,805
and it's actually quite simple.

623
00:34:07,805 --> 00:34:10,402
Now you might have noticed
when I was introducing

624
00:34:10,402 --> 00:34:13,527
the project that here in
Class A, I've put in there

625
00:34:13,527 --> 00:34:16,110
a method called created bean A.

626
00:34:17,238 --> 00:34:19,623
It's not currently being
called, but let's say,

627
00:34:19,623 --> 00:34:23,154
I would like that method
to be automatically called

628
00:34:23,154 --> 00:34:25,918
when this bean is created.

629
00:34:25,918 --> 00:34:27,532
How can I do that?

630
00:34:27,532 --> 00:34:30,914
Well the answer is we simply
have to supply a parameter

631
00:34:30,914 --> 00:34:33,404
into the at bean annotation.

632
00:34:33,404 --> 00:34:35,441
I'll use IntelliSense here to show

633
00:34:35,441 --> 00:34:39,394
that there is a parameter
here called init-method.

634
00:34:39,394 --> 00:34:43,499
And it's a little bit odd
because it's just a string

635
00:34:43,499 --> 00:34:45,734
so we've got to be careful with this.

636
00:34:45,734 --> 00:34:47,997
And of course it's going
to be just the name

637
00:34:47,997 --> 00:34:51,061
of the method that we want to be called.

638
00:34:51,061 --> 00:34:54,561
And similarly, in Class B, I have a method

639
00:34:55,589 --> 00:34:57,582
that I would like to be called

640
00:34:57,582 --> 00:35:00,841
when the container is being closed down.

641
00:35:00,841 --> 00:35:02,924
So that's going to be
through an attribute here

642
00:35:02,924 --> 00:35:06,486
on the at bean annotation,
this time for Class B,

643
00:35:06,486 --> 00:35:08,357
so I'm in the other configuration file

644
00:35:08,357 --> 00:35:11,274
and this one is the destroy-method.

645
00:35:13,036 --> 00:35:17,203
And that's going to be, in
this case, destroy bean B.

646
00:35:19,224 --> 00:35:22,545
So if I run the code this time,

647
00:35:22,545 --> 00:35:26,651
you can see the points in the
application's lifetime where,

648
00:35:26,651 --> 00:35:29,277
this is where Bean A was created,

649
00:35:29,277 --> 00:35:33,594
and this is the end of the run
where Bean B was destroyed.

650
00:35:33,594 --> 00:35:36,688
If you're running this
on your own project then

651
00:35:36,688 --> 00:35:40,325
you will only see the destroying
if in your main method

652
00:35:40,325 --> 00:35:43,222
you have explicitly
called the close method

653
00:35:43,222 --> 00:35:45,245
on the container.

654
00:35:45,245 --> 00:35:49,351
Now in the reference manual here at 6.12.3

655
00:35:49,351 --> 00:35:53,335
where they're talking about
how to use this bean annotation

656
00:35:53,335 --> 00:35:55,826
and they're confirming
there that we can use

657
00:35:55,826 --> 00:35:59,131
init-method and destroy-method.

658
00:35:59,131 --> 00:36:00,685
Just going a little further down though,

659
00:36:00,685 --> 00:36:02,980
there's something that I
would like you to remember

660
00:36:02,980 --> 00:36:05,862
for a little later on in the course

661
00:36:05,862 --> 00:36:09,424
when we are setting up a full project.

662
00:36:09,424 --> 00:36:13,514
It's telling us that, by
default, beans using JavaConfig

663
00:36:13,514 --> 00:36:17,755
that have either a public
close or shut down method

664
00:36:17,755 --> 00:36:22,449
will be automatically enlisted
with a destruction callback.

665
00:36:22,449 --> 00:36:24,532
So that's going to mean
that if we have an object

666
00:36:24,532 --> 00:36:27,913
in the Spring container,
we've closed all shut down,

667
00:36:27,913 --> 00:36:30,131
then we don't have to explicitly

668
00:36:30,131 --> 00:36:32,395
register that destroy-method.

669
00:36:32,395 --> 00:36:35,867
I have to say I hate this
because it's very magic,

670
00:36:35,867 --> 00:36:39,565
and you have to kind of know
that that's going to happen.

671
00:36:39,565 --> 00:36:41,119
And we're going to find as we go

672
00:36:41,119 --> 00:36:42,946
a little further through this course

673
00:36:42,946 --> 00:36:45,753
that there's quite a lot of this where,

674
00:36:45,753 --> 00:36:49,164
they're doing things for
you to try to help you

675
00:36:49,164 --> 00:36:51,790
but it's not much help,
really, because you

676
00:36:51,790 --> 00:36:54,854
have to know that it's doing this anyway.

677
00:36:54,854 --> 00:36:58,310
So I'd like you to bear this
in mind for a little later on

678
00:36:58,310 --> 00:37:00,152
when it will become relevant to us.

679
00:37:00,152 --> 00:37:01,661
Don't worry if you forget
it though because of course

680
00:37:01,661 --> 00:37:05,117
I will be highlighting
this when we get there.

681
00:37:05,117 --> 00:37:07,381
But for this basic overview of JavaConfig

682
00:37:07,381 --> 00:37:10,400
there's really just one
last thing I want to cover.

683
00:37:10,400 --> 00:37:12,331
And I'm going to cover
it here because we won't

684
00:37:12,331 --> 00:37:15,471
be using this again when
we go ahead and build

685
00:37:15,471 --> 00:37:17,765
a more complicated project.

686
00:37:17,765 --> 00:37:20,358
And that's related to the scope

687
00:37:20,358 --> 00:37:23,136
of the beans that we're creating.

688
00:37:23,136 --> 00:37:25,581
Now you probably know, or you should know,

689
00:37:25,581 --> 00:37:27,845
that when you're working with xml,

690
00:37:27,845 --> 00:37:32,012
the default is that Spring
always creates singletons.

691
00:37:33,671 --> 00:37:35,904
Which really just means
that each of the beans

692
00:37:35,904 --> 00:37:38,821
is instantiated once and once only.

693
00:37:40,794 --> 00:37:42,711
And we need to know if that's true

694
00:37:42,711 --> 00:37:44,658
in JavaConfig as well.

695
00:37:44,658 --> 00:37:46,379
And I'm not going to
tease this out, really,

696
00:37:46,379 --> 00:37:48,824
because I hope you're
getting the flavor by now

697
00:37:48,824 --> 00:37:51,344
that everything that
we're doing in JavaConfig

698
00:37:51,344 --> 00:37:54,438
is just a replacement for the xml.

699
00:37:54,438 --> 00:37:58,106
It's not in any way changing
the underlying model

700
00:37:58,106 --> 00:38:00,023
about how Spring works.

701
00:38:01,064 --> 00:38:04,897
So, therefore, exactly as in the xml

702
00:38:04,897 --> 00:38:07,282
what we're seeing with
these configurations

703
00:38:07,282 --> 00:38:09,909
is that we're always going
to be getting, by default,

704
00:38:09,909 --> 00:38:11,242
singleton beans.

705
00:38:12,565 --> 00:38:15,131
Which you should know
from Java Fundamentals

706
00:38:15,131 --> 00:38:19,010
means that, by default,
Spring is only going to

707
00:38:19,010 --> 00:38:23,177
instantiate one of these
beans, no matter what we do.

708
00:38:24,443 --> 00:38:26,918
So if I go back into the main,

709
00:38:26,918 --> 00:38:31,235
we've already got one
reference here to Class A,

710
00:38:31,235 --> 00:38:35,402
but if I were to declare
another instance of Class A,

711
00:38:36,970 --> 00:38:41,136
and I'm going to call this,
let's call it, second bean,

712
00:38:41,136 --> 00:38:43,886
if I do a container dot get bean,

713
00:38:49,744 --> 00:38:51,077
of type Class A,

714
00:38:52,430 --> 00:38:55,763
and I can call it business method again,

715
00:38:57,230 --> 00:39:01,064
exactly as in standard
Spring xml configuration,

716
00:39:01,064 --> 00:39:05,351
the container will not create
a second instance of this bean

717
00:39:05,351 --> 00:39:08,128
instead it's going to
hand us a reference to the

718
00:39:08,128 --> 00:39:11,711
same bean that was
created here on line 15.

719
00:39:13,199 --> 00:39:17,288
And we can verify that
by running the code.

720
00:39:17,288 --> 00:39:21,047
And our init-method, I hope you can see,

721
00:39:21,047 --> 00:39:22,964
is only being run once.

722
00:39:24,609 --> 00:39:26,481
If you're in any way confused about this

723
00:39:26,481 --> 00:39:29,454
terminology of singletons
then do check out

724
00:39:29,454 --> 00:39:32,488
the Spring Framework Fundamentals course,

725
00:39:32,488 --> 00:39:34,284
but it means that exactly what I've said,

726
00:39:34,284 --> 00:39:35,944
there's only going to be one instance

727
00:39:35,944 --> 00:39:38,660
of that being created
no matter how many times

728
00:39:38,660 --> 00:39:41,513
we try to access that bean.

729
00:39:41,513 --> 00:39:42,888
But as with standard Spring

730
00:39:42,888 --> 00:39:45,695
we can switch that
configuration and we can tell it

731
00:39:45,695 --> 00:39:48,772
that each time we try
to access an instance

732
00:39:48,772 --> 00:39:52,515
of Class A, we want a
brand new fresh instance

733
00:39:52,515 --> 00:39:53,995
to be created.

734
00:39:53,995 --> 00:39:56,697
You don't do that very often in Spring,

735
00:39:56,697 --> 00:40:00,682
because the kind of use cases
that Spring is designed for

736
00:40:00,682 --> 00:40:03,926
is for configuring things
like service classes,

737
00:40:03,926 --> 00:40:08,093
DAO's, and connection pools,
and those kinds of things.

738
00:40:09,027 --> 00:40:12,696
And very, very often you
want those to be singletons

739
00:40:12,696 --> 00:40:15,473
because they don't contain any state

740
00:40:15,473 --> 00:40:16,951
and it's just more efficient to

741
00:40:16,951 --> 00:40:20,438
keep re-using a single instance.

742
00:40:20,438 --> 00:40:22,566
So it's not very often that you do it,

743
00:40:22,566 --> 00:40:25,585
but Spring calls a bean
that you want to be created

744
00:40:25,585 --> 00:40:27,835
each time a prototype bean.

745
00:40:29,691 --> 00:40:31,802
And it's very easy to
specify that we want it

746
00:40:31,802 --> 00:40:33,206
to be a prototype.

747
00:40:33,206 --> 00:40:37,373
We use the at scope annotation
here in the JavaConfig.

748
00:40:39,259 --> 00:40:41,856
It will take a single parameter,

749
00:40:41,856 --> 00:40:45,085
and that's going to be prototype.

750
00:40:45,085 --> 00:40:46,956
When you're importing this make sure

751
00:40:46,956 --> 00:40:51,243
you choose the Spring
Framework version of scope.

752
00:40:51,243 --> 00:40:52,632
And you can probably guess that when we

753
00:40:52,632 --> 00:40:55,197
go into the web tier
we can also use session

754
00:40:55,197 --> 00:40:58,005
as a scope in here as well.

755
00:40:58,005 --> 00:41:01,129
So the difference this time will be

756
00:41:01,129 --> 00:41:04,071
that now you can see that the init-method

757
00:41:04,071 --> 00:41:06,321
is being called twice because we're now

758
00:41:06,321 --> 00:41:09,807
having two instances
of that being created.

759
00:41:09,807 --> 00:41:12,509
Even though this bean
here is configured as a

760
00:41:12,509 --> 00:41:16,592
prototype scope the
dependency bean, the Class B,

761
00:41:18,366 --> 00:41:22,533
is still going to be the
default scope of singleton.

762
00:41:23,768 --> 00:41:27,286
So these two beans that we've created

763
00:41:27,286 --> 00:41:31,029
are sharing a reference
to the same objects.

764
00:41:31,029 --> 00:41:33,608
Now although this second
configuration was useful

765
00:41:33,608 --> 00:41:36,386
to show you how you can
split your configuration

766
00:41:36,386 --> 00:41:40,884
into multiple files, for
this final demonstration

767
00:41:40,884 --> 00:41:43,872
it's going to be clearer if
I merge the configurations

768
00:41:43,872 --> 00:41:45,487
back together again.

769
00:41:45,487 --> 00:41:48,987
So I'm going to take the code out of here,

770
00:41:50,166 --> 00:41:51,817
and for the practicals in code folder

771
00:41:51,817 --> 00:41:54,276
the final solution for this chapter

772
00:41:54,276 --> 00:41:56,857
will not have the second
configuration file,

773
00:41:56,857 --> 00:41:59,876
but I'm sure that's no great loss really.

774
00:41:59,876 --> 00:42:04,043
So I think I will even delete
the second configuration

775
00:42:05,641 --> 00:42:10,033
from the project and I don't
need this import anymore.

776
00:42:10,033 --> 00:42:13,218
And the reason I've done
that is I want to use

777
00:42:13,218 --> 00:42:17,112
the alternative version of
passing in this dependency.

778
00:42:17,112 --> 00:42:18,697
You'll remember from not very long ago

779
00:42:18,697 --> 00:42:21,942
that there's two ways of
passing this dependency.

780
00:42:21,942 --> 00:42:24,734
We can either make it
a parameter into here

781
00:42:24,734 --> 00:42:28,901
or we can just go ahead
and call the bean B method

782
00:42:31,073 --> 00:42:32,323
just like that.

783
00:42:33,653 --> 00:42:35,903
The reason that I'm doing
that is I want to illustrate

784
00:42:35,903 --> 00:42:37,577
that if we take a step back a moment

785
00:42:37,577 --> 00:42:40,672
and remind ourselves what's
going to happen here,

786
00:42:40,672 --> 00:42:45,094
because Bean A we've
declared to be a prototype,

787
00:42:45,094 --> 00:42:48,702
when we run our main
method you might think that

788
00:42:48,702 --> 00:42:52,702
that means it's going to
call this method twice.

789
00:42:55,674 --> 00:42:59,841
And therefore you check out
the call to Bean B there,

790
00:43:00,716 --> 00:43:03,961
you might expect this Bean B method

791
00:43:03,961 --> 00:43:06,557
to be called twice as well.

792
00:43:06,557 --> 00:43:10,149
But remember that Bean
B is the default scope,

793
00:43:10,149 --> 00:43:12,816
this is going to be a singleton.

794
00:43:13,680 --> 00:43:17,847
So actually we only want this
method to be called once.

795
00:43:18,888 --> 00:43:22,011
But I want to make a really
important point here,

796
00:43:22,011 --> 00:43:23,959
that when we run our application

797
00:43:23,959 --> 00:43:27,415
Spring isn't simply executing this Java

798
00:43:27,415 --> 00:43:30,405
as if it were standard Java.

799
00:43:30,405 --> 00:43:33,822
Spring is, if you like, parsing this Java

800
00:43:34,690 --> 00:43:39,037
to understand what the
structure of our bean should be.

801
00:43:39,037 --> 00:43:42,961
Again, as I've said many
times in this chapter,

802
00:43:42,961 --> 00:43:45,285
the Java that we're seeing here is just

803
00:43:45,285 --> 00:43:49,452
an alternative representation
of the xml that we had before.

804
00:43:50,870 --> 00:43:55,291
And even though this looks
like a method call here,

805
00:43:55,291 --> 00:43:57,842
I would advise that you
don't think of it as being

806
00:43:57,842 --> 00:44:02,310
a method call, it's more of a
kind of a static declaration,

807
00:44:02,310 --> 00:44:05,479
exactly as you would have done in the xml.

808
00:44:05,479 --> 00:44:07,970
If you really want to
know what's going on here

809
00:44:07,970 --> 00:44:10,158
you can check out the reference manual,

810
00:44:10,158 --> 00:44:12,392
and you might even want
to hunt through the

811
00:44:12,392 --> 00:44:15,019
Spring Framework source code.

812
00:44:15,019 --> 00:44:18,746
In fact it's using a
clever system of proxies.

813
00:44:18,746 --> 00:44:22,716
So, what it means in
practice is that at runtime,

814
00:44:22,716 --> 00:44:25,115
when it comes to create this second bean,

815
00:44:25,115 --> 00:44:27,938
it will know that it
does not have to execute

816
00:44:27,938 --> 00:44:31,303
this method here because
this bean is a singleton

817
00:44:31,303 --> 00:44:33,749
and it has already been created.

818
00:44:33,749 --> 00:44:37,431
Now don't take my word for it,
we can prove this very easily

819
00:44:37,431 --> 00:44:40,014
by adding in a print line here.

820
00:44:41,627 --> 00:44:45,794
Called the creation of Bean
B, we expect to see that

821
00:44:48,042 --> 00:44:50,459
code run once, and once only.

822
00:44:51,754 --> 00:44:53,671
However, the code here,

823
00:45:00,524 --> 00:45:03,255
we expect to be run twice.

824
00:45:03,255 --> 00:45:06,787
Even though that doesn't look
right according to the Java,

825
00:45:06,787 --> 00:45:10,213
Spring is doing some clever
tricks with Java here.

826
00:45:10,213 --> 00:45:13,489
I seem to have an error in my main class,

827
00:45:13,489 --> 00:45:16,386
and I think it's just an abandoned import

828
00:45:16,386 --> 00:45:19,707
so control or command shift
over to clean those up,

829
00:45:19,707 --> 00:45:23,207
everything's clean, let's give this a run.

830
00:45:25,502 --> 00:45:27,464
And we can now verify that we are indeed

831
00:45:27,464 --> 00:45:30,997
seeing two calls to
the creation of Bean A,

832
00:45:30,997 --> 00:45:34,195
but only one to the creation of Bean B.

833
00:45:34,195 --> 00:45:37,441
And you might be surprised
to see the ordering

834
00:45:37,441 --> 00:45:40,460
of these bean creations,
but again we can appeal

835
00:45:40,460 --> 00:45:43,267
to our standard Spring knowledge,

836
00:45:43,267 --> 00:45:45,682
if we have a singleton
then it's going to be

837
00:45:45,682 --> 00:45:47,849
created eagerly on startup

838
00:45:49,032 --> 00:45:52,157
so that's why Bean B is
being created immediately.

839
00:45:52,157 --> 00:45:56,324
But a prototype bean only gets
created when it is needed.

840
00:45:57,333 --> 00:46:02,299
So that means that Bean A is
being created after Bean B.

841
00:46:02,299 --> 00:46:05,107
It's a relatively minor point, really,

842
00:46:05,107 --> 00:46:08,095
the important point is
that scopes are respected

843
00:46:08,095 --> 00:46:12,079
in exactly the same way as in the xml.

844
00:46:12,079 --> 00:46:14,570
So in this chapter we've
had a run-through really

845
00:46:14,570 --> 00:46:17,800
most of the features
of Java configuration.

846
00:46:17,800 --> 00:46:20,154
The trick is to be able to apply this

847
00:46:20,154 --> 00:46:22,402
to a production environment.

848
00:46:22,402 --> 00:46:23,897
So in the next chapter
we'll be switching to

849
00:46:23,897 --> 00:46:28,682
one of the projects from a
previous Spring training course

850
00:46:28,682 --> 00:46:30,643
and we're going to convert the whole

851
00:46:30,643 --> 00:46:34,810
of a much more complicated
xml file into JavaConfig.

852
00:46:35,971 --> 00:46:37,888
So there's still a long way to go,

853
00:46:37,888 --> 00:46:40,471
I'll see you for the next part.

1
00:00:00,000 --> 00:00:02,059
(funky music)

2
00:00:02,059 --> 00:00:04,542
- [Voiceover] Welcome back
to this second chapter

3
00:00:04,542 --> 00:00:05,709
of JavaConfig.

4
00:00:06,635 --> 00:00:10,365
We're now going to work on
porting a full Spring application

5
00:00:10,365 --> 00:00:12,282
from XML to JavaConfig.

6
00:00:13,825 --> 00:00:15,871
Much of what we need to do will just be

7
00:00:15,871 --> 00:00:18,124
putting into practice what we learnt

8
00:00:18,124 --> 00:00:21,724
in the previous chapter, but
there will be some new features

9
00:00:21,724 --> 00:00:23,821
to learn along the way.

10
00:00:23,821 --> 00:00:27,788
In particular, I think the most
useful aspect of JavaConfig

11
00:00:27,788 --> 00:00:32,435
is profiles, so I'll make
sure that we include that

12
00:00:32,435 --> 00:00:34,482
somewhere along the way.

13
00:00:34,482 --> 00:00:38,622
So the plan, then, is to work
on a full Spring project,

14
00:00:38,622 --> 00:00:41,706
and the project that I've
decided to use for this course

15
00:00:41,706 --> 00:00:44,872
is the CRM system that we've worked with

16
00:00:44,872 --> 00:00:47,955
on previous Spring Framework courses.

17
00:00:48,830 --> 00:00:51,844
We used this on the Spring
Fundamentals course,

18
00:00:51,844 --> 00:00:54,813
and we also used it on the Spring Security

19
00:00:54,813 --> 00:00:56,896
and Spring OAuth courses.

20
00:00:57,750 --> 00:01:01,350
If you're interested in porting
your own Spring projects,

21
00:01:01,350 --> 00:01:04,616
then really any Spring project will do.

22
00:01:04,616 --> 00:01:08,617
You should be able to follow
along with your own projects.

23
00:01:08,617 --> 00:01:13,582
But if you're wanting to do
Spring Security and Oauth,

24
00:01:13,582 --> 00:01:16,953
then you will be wanting
to work with the CRM system

25
00:01:16,953 --> 00:01:21,005
and also this associated
project called Male Monkey,

26
00:01:21,005 --> 00:01:25,428
which was developed as
part of the OAuth course.

27
00:01:25,428 --> 00:01:28,033
Now I do have a slight problem,

28
00:01:28,033 --> 00:01:32,544
and that is that I have had
to update the lib folder

29
00:01:32,544 --> 00:01:34,127
for the CRM system.

30
00:01:35,911 --> 00:01:40,448
Sp perhaps you've just done
our Spring Security course

31
00:01:40,448 --> 00:01:43,370
and you're wanting to
switch across to JavaConfig.

32
00:01:43,370 --> 00:01:45,858
If that's the case then
you might want to take

33
00:01:45,858 --> 00:01:50,638
all of the JAR files from
my Starting Workspace,

34
00:01:50,638 --> 00:01:52,471
and in your workspace,

35
00:01:53,590 --> 00:01:55,552
empty your lib folder

36
00:01:55,552 --> 00:01:58,724
and transfer my JAR files across.

37
00:01:58,724 --> 00:02:03,031
Now, the reason I've done this
is a very, very minor point

38
00:02:03,031 --> 00:02:05,512
is that a little later
on in this demonstration

39
00:02:05,512 --> 00:02:08,996
I am going to be relying on
a feature that was only added

40
00:02:08,996 --> 00:02:10,329
in Spring 4.1.6,

41
00:02:13,590 --> 00:02:15,492
and, unfortunately, the JAR files

42
00:02:15,492 --> 00:02:18,790
that I was using for the
Spring Security course

43
00:02:18,790 --> 00:02:20,373
was 4.1.3, I think.

44
00:02:22,855 --> 00:02:25,922
Now, if you find all that a big pain,

45
00:02:25,922 --> 00:02:28,504
then you don't really
need to worry about it

46
00:02:28,504 --> 00:02:32,224
because the feature is
a very, very small one,

47
00:02:32,224 --> 00:02:36,117
and you can very easily
avoid using that feature.

48
00:02:36,117 --> 00:02:39,365
So all of that will be explained later.

49
00:02:39,365 --> 00:02:41,855
You could, of course, use
the full Starting Workspace

50
00:02:41,855 --> 00:02:44,021
from the practicals and code folder

51
00:02:44,021 --> 00:02:46,123
for this JavaConfig module,

52
00:02:46,123 --> 00:02:49,625
and you're working with exactly
the same code that I have.

53
00:02:49,625 --> 00:02:51,796
So you might already
have this project open,

54
00:02:51,796 --> 00:02:55,637
but I need to get it up and
running for the recording.

55
00:02:55,637 --> 00:02:57,546
I'll start by closing the project

56
00:02:57,546 --> 00:03:00,478
that we were using as a warm-up.

57
00:03:00,478 --> 00:03:02,689
We won't be needing that again.

58
00:03:02,689 --> 00:03:04,298
And the usual technique,

59
00:03:04,298 --> 00:03:08,381
I'll create a new Java
project called CRM System,

60
00:03:09,698 --> 00:03:13,455
and that's exactly the same
name as the folder name.

61
00:03:13,455 --> 00:03:14,949
We don't need the Mail Monkey project

62
00:03:14,949 --> 00:03:16,651
until much later in this course,

63
00:03:16,651 --> 00:03:20,084
so I'll just stick with the CRM System.

64
00:03:20,084 --> 00:03:21,509
Now, before we go any further,

65
00:03:21,509 --> 00:03:25,174
there is one other change
that we will need to make.

66
00:03:25,174 --> 00:03:26,605
What we're going to be
doing on this course

67
00:03:26,605 --> 00:03:29,597
is we're going to migrating this XML

68
00:03:29,597 --> 00:03:31,845
across the JavaConfig, of course,

69
00:03:31,845 --> 00:03:34,360
but all along the way,
I would like to check

70
00:03:34,360 --> 00:03:37,527
that the integration tests still work.

71
00:03:39,645 --> 00:03:42,462
Now, unfortunately, and this is my bad,

72
00:03:42,462 --> 00:03:46,312
I didn't notice when I was
doing the Spring Security course

73
00:03:46,312 --> 00:03:50,708
that I had broken all of
the integration tests.

74
00:03:50,708 --> 00:03:52,946
We can verify this by right-clicking

75
00:03:52,946 --> 00:03:56,943
on the CustomerManagementIntegrationTests.

76
00:03:56,943 --> 00:03:59,443
You can do Run As, JUnit Test,

77
00:04:01,420 --> 00:04:04,636
and you get a great big red bar.

78
00:04:04,636 --> 00:04:08,282
Now, if you're working with
your own workspace that you had

79
00:04:08,282 --> 00:04:12,780
at the end of the Spring
Security and OAuth modules,

80
00:04:12,780 --> 00:04:15,613
you will probably see an exception

81
00:04:16,879 --> 00:04:19,851
that say something like
"datasource-test.xml

82
00:04:19,851 --> 00:04:23,960
"cannot be opened because
it does not exist."

83
00:04:23,960 --> 00:04:25,604
So I'm sorry about that

84
00:04:25,604 --> 00:04:28,409
the reason for that is
when I set up the workspace

85
00:04:28,409 --> 00:04:31,099
for the Spring Security course,

86
00:04:31,099 --> 00:04:33,172
I just thought I really need to

87
00:04:33,172 --> 00:04:36,690
clear away everything that
isn't relevant to that course,

88
00:04:36,690 --> 00:04:39,770
and in doing so, I swept
away this test file

89
00:04:39,770 --> 00:04:42,912
that really is needed for
the integration tests.

90
00:04:42,912 --> 00:04:44,707
So if that's happening for you,

91
00:04:44,707 --> 00:04:48,540
then you can find the
datasource-test.xml file

92
00:04:50,225 --> 00:04:52,636
under the src folder

93
00:04:52,636 --> 00:04:55,469
for the workspace for this course,

94
00:04:56,595 --> 00:04:58,901
so feel free to download that.

95
00:04:58,901 --> 00:05:02,044
Copy it into your src folder,

96
00:05:02,044 --> 00:05:03,843
and then once you have that,

97
00:05:03,843 --> 00:05:05,349
we can run the integration test again

98
00:05:05,349 --> 00:05:08,092
by right-licking on src,

99
00:05:08,092 --> 00:05:09,675
Run As, JUnit Test.

100
00:05:11,682 --> 00:05:13,519
I did see a little bit of green there,

101
00:05:13,519 --> 00:05:15,868
but I've got lots more red.

102
00:05:15,868 --> 00:05:17,733
You won't see this problem
if you're working with

103
00:05:17,733 --> 00:05:20,797
the workspace that was
supplied with this module,

104
00:05:20,797 --> 00:05:22,290
but if you're using your module

105
00:05:22,290 --> 00:05:24,422
from the end of the
Spring Security course,

106
00:05:24,422 --> 00:05:26,431
then you will see this problem.

107
00:05:26,431 --> 00:05:28,284
And this problem is happening

108
00:05:28,284 --> 00:05:31,496
simply because we're missing a JAR file.

109
00:05:31,496 --> 00:05:34,127
You'll find that missing JAR file again

110
00:05:34,127 --> 00:05:37,207
if you download the
practicals and code folder,

111
00:05:37,207 --> 00:05:39,816
the zip file for this module.

112
00:05:39,816 --> 00:05:42,606
Check in the Starting Workspace folder

113
00:05:42,606 --> 00:05:45,277
and the CRM System and lib.

114
00:05:45,277 --> 00:05:46,872
The JAR file that we need

115
00:05:46,872 --> 00:05:48,205
is javax.el-api.

116
00:05:50,706 --> 00:05:55,416
This is the standard Java
Expression Language API,

117
00:05:55,416 --> 00:05:59,533
and Spring needs that to
run integration tests.

118
00:05:59,533 --> 00:06:03,124
So it's a simple case of copying
that into your lib folder,

119
00:06:03,124 --> 00:06:07,086
and right-click there and select Refresh,

120
00:06:07,086 --> 00:06:10,211
and then find your new JAR file.

121
00:06:10,211 --> 00:06:14,476
Right-click Build Path, Add to Build Path,

122
00:06:14,476 --> 00:06:16,916
and now you should find,

123
00:06:16,916 --> 00:06:19,207
you right-click on src,

124
00:06:19,207 --> 00:06:20,790
Run As, JUnit Test.

125
00:06:23,535 --> 00:06:26,419
We should now have a green bar.

126
00:06:26,419 --> 00:06:28,493
The reason that JAR file was missing

127
00:06:28,493 --> 00:06:30,439
is that it will cause a problem

128
00:06:30,439 --> 00:06:33,024
when we try to run this
as a web application,

129
00:06:33,024 --> 00:06:35,348
which we'll be doing later in the course,

130
00:06:35,348 --> 00:06:37,476
but we'll deal with that
problem when we get to it.

131
00:06:37,476 --> 00:06:39,415
It's really not very serious.

132
00:06:39,415 --> 00:06:42,695
So what we're seeing
here is a web project,

133
00:06:42,695 --> 00:06:46,487
but the integration tests are
testing the business layers,

134
00:06:46,487 --> 00:06:48,273
and it's the exact integration test

135
00:06:48,273 --> 00:06:50,792
from our Spring Fundamentals course.

136
00:06:50,792 --> 00:06:53,632
It does things like reading in some data

137
00:06:53,632 --> 00:06:57,777
and manipulating some
of the data and so on.

138
00:06:57,777 --> 00:07:00,354
So that's really useful
because as we make changes

139
00:07:00,354 --> 00:07:02,960
to the XML, once we've
done all of our changes,

140
00:07:02,960 --> 00:07:07,867
we can check that the
integration tests still run.

141
00:07:07,867 --> 00:07:10,083
Another useful test is that

142
00:07:10,083 --> 00:07:12,614
back when the business
tiers of this were built,

143
00:07:12,614 --> 00:07:15,133
back on the Springs Fundamentals course,

144
00:07:15,133 --> 00:07:19,133
we built a, what we call
the Simple Client Test.

145
00:07:20,094 --> 00:07:21,836
This was a very basic class

146
00:07:21,836 --> 00:07:24,517
that we just used for developments.

147
00:07:24,517 --> 00:07:26,762
It's bootstrapping a container,

148
00:07:26,762 --> 00:07:28,784
it's setting up some services,

149
00:07:28,784 --> 00:07:32,082
and then it's calling some of
the methods on the services.

150
00:07:32,082 --> 00:07:33,919
You'd be familiar with this if you did the

151
00:07:33,919 --> 00:07:36,137
Spring fundamentals course.

152
00:07:36,137 --> 00:07:40,129
Now, the state that this
class is currently in is

153
00:07:40,129 --> 00:07:42,467
doesn't look like a
very good state, really.

154
00:07:42,467 --> 00:07:43,742
It looks like at the time

155
00:07:43,742 --> 00:07:46,756
we were testing deleting customers.

156
00:07:46,756 --> 00:07:49,100
But then for some reason,
I don't remember why,

157
00:07:49,100 --> 00:07:52,189
we've commented out a huge block here

158
00:07:52,189 --> 00:07:55,672
where we appear to be
creating a new customer record

159
00:07:55,672 --> 00:08:00,040
and then doing a few
operations against that record.

160
00:08:00,040 --> 00:08:02,433
I want to suggest this,
we take all of those lines

161
00:08:02,433 --> 00:08:04,367
and uncomment them.

162
00:08:04,367 --> 00:08:07,424
I just did a control, forward slash there.

163
00:08:07,424 --> 00:08:08,827
I don't really remember, to be honest,

164
00:08:08,827 --> 00:08:10,467
whats going on in this method,

165
00:08:10,467 --> 00:08:13,429
but it does look like a very useful way

166
00:08:13,429 --> 00:08:15,726
of making sure we give that a run.

167
00:08:15,726 --> 00:08:17,810
Lots of logging there.

168
00:08:17,810 --> 00:08:19,389
Various things are happening.

169
00:08:19,389 --> 00:08:21,869
We can see some inserts

170
00:08:21,869 --> 00:08:25,560
and a few bits of system out print lines.

171
00:08:25,560 --> 00:08:28,923
The point is there's no
crashes going on in there,

172
00:08:28,923 --> 00:08:31,867
and that will be another
good way of sanity testing

173
00:08:31,867 --> 00:08:35,151
that the changes we've made
aren't breaking anything.

174
00:08:35,151 --> 00:08:38,354
We'll run the integration tests
at the end of this chapter,

175
00:08:38,354 --> 00:08:40,637
but I'm going to use
the Simple Client Test

176
00:08:40,637 --> 00:08:43,238
as we go through the entire chapter.

177
00:08:43,238 --> 00:08:45,010
As things stand at the moment,

178
00:08:45,010 --> 00:08:48,549
we're using the
ClassPathXmLApplicationContext

179
00:08:48,549 --> 00:08:53,382
with the single XML file
called application.xml.

180
00:08:53,382 --> 00:08:55,597
Let's have a look what's in there.

181
00:08:55,597 --> 00:08:58,475
Well, it's just a set of imports,

182
00:08:58,475 --> 00:09:00,320
and we've got four of them.

183
00:09:00,320 --> 00:09:04,942
we've got the daos, the services,
one for the data source,

184
00:09:04,942 --> 00:09:08,315
which will be the configuration
of the connection pool,

185
00:09:08,315 --> 00:09:12,017
and we have one for any
miscellaneous beans,

186
00:09:12,017 --> 00:09:14,620
which I think is going to
be, yeah, that's going to be

187
00:09:14,620 --> 00:09:18,440
setting up the transaction
management by the look of it.

188
00:09:18,440 --> 00:09:21,981
The plan is I'm going to
do this piece by piece,

189
00:09:21,981 --> 00:09:23,365
and that's something I didn't tell you

190
00:09:23,365 --> 00:09:24,990
in the previous chapter.

191
00:09:24,990 --> 00:09:27,240
It's absolutely fine to mix

192
00:09:28,755 --> 00:09:32,005
XML and JavaConfig in the same project.

193
00:09:33,271 --> 00:09:35,403
I'm guessing that not many projects

194
00:09:35,403 --> 00:09:38,151
in the real world do that.

195
00:09:38,151 --> 00:09:39,904
You'll chose one or the other,

196
00:09:39,904 --> 00:09:44,429
but there's no problem with
mixing the two approaches.

197
00:09:44,429 --> 00:09:46,380
Perhaps the main use for that

198
00:09:46,380 --> 00:09:48,847
is exactly as we're doing here.

199
00:09:48,847 --> 00:09:53,231
If you're wanting to port from
one approach to the other,

200
00:09:53,231 --> 00:09:56,353
you might do it in a
piece-by-piece fashion.

201
00:09:56,353 --> 00:09:57,683
I reckon the hardest thing here

202
00:09:57,683 --> 00:10:01,183
is just knowing where to start, so I think

203
00:10:02,874 --> 00:10:04,874
we'll take the daos.xml,

204
00:10:06,648 --> 00:10:10,815
and we'll convert that entirely
into JavaConfig instead.

205
00:10:11,879 --> 00:10:15,258
In case you're not
familiar with the daos.xml,

206
00:10:15,258 --> 00:10:18,096
this is the configuration
of the data access objects

207
00:10:18,096 --> 00:10:21,192
for the system, very simple configuration,

208
00:10:21,192 --> 00:10:25,151
so, actually, this looks like
a really good place to start.

209
00:10:25,151 --> 00:10:27,805
Just as I did in the previous chapter,

210
00:10:27,805 --> 00:10:31,722
I'm going to take the
XML here and cut that out

211
00:10:32,692 --> 00:10:36,859
and then delete the file
entirely from our projects.

212
00:10:38,078 --> 00:10:40,025
And I'm deleting it just to make sure

213
00:10:40,025 --> 00:10:43,814
that I don't accidentally pick
it up somehow in the future

214
00:10:43,814 --> 00:10:45,877
and think that all the
work I've done is working

215
00:10:45,877 --> 00:10:49,266
when actually I haven't changed anything.

216
00:10:49,266 --> 00:10:53,273
Clearly, this import line
here is now going to fail,

217
00:10:53,273 --> 00:10:55,953
so I may as well delete it.

218
00:10:55,953 --> 00:10:59,084
So I'm going to replace it,
then, with a config class,

219
00:10:59,084 --> 00:11:01,157
and the details should be exactly the same

220
00:11:01,157 --> 00:11:03,300
as in the previous chapter.

221
00:11:03,300 --> 00:11:05,075
We'll have a new class.

222
00:11:05,075 --> 00:11:07,599
It needs to go in a sensible package,

223
00:11:07,599 --> 00:11:09,781
and we will need a new package for that,

224
00:11:09,781 --> 00:11:12,764
so we'll call this the config package.

225
00:11:12,764 --> 00:11:15,483
And I'm not sure what to do here,

226
00:11:15,483 --> 00:11:19,650
but I think I'm going to go
for one single config file.

227
00:11:20,874 --> 00:11:23,714
Of course, we could break the config up

228
00:11:23,714 --> 00:11:26,970
exactly as we did in the previous chapter,

229
00:11:26,970 --> 00:11:28,694
but I reckon just for simplicity

230
00:11:28,694 --> 00:11:33,290
it's worthwhile doing all of
this in one single config file,

231
00:11:33,290 --> 00:11:37,169
so I'm going to call
this ApplicationConfig.

232
00:11:37,169 --> 00:11:41,336
We will need the @Configuration
annotation at the top,

233
00:11:42,571 --> 00:11:45,642
and, at least for the short-term,

234
00:11:45,642 --> 00:11:49,382
I'm going to paste in the
XML that we had before

235
00:11:49,382 --> 00:11:51,038
and leave that there as
a comment to guide us

236
00:11:51,038 --> 00:11:52,454
through the next steps,

237
00:11:52,454 --> 00:11:54,532
which should be really simple, really.

238
00:11:54,532 --> 00:11:57,138
We're going to need an @Bean,

239
00:11:57,138 --> 00:12:00,503
which is going to return an instance of,

240
00:12:00,503 --> 00:12:02,757
now the class that we're creating

241
00:12:02,757 --> 00:12:04,590
is CustomerDaoJpaImpl,

242
00:12:06,995 --> 00:12:09,281
but, as you can guess from the class name,

243
00:12:09,281 --> 00:12:11,981
that's an implementation of an interface,

244
00:12:11,981 --> 00:12:15,750
and we may as well use the
interface as the return type.

245
00:12:15,750 --> 00:12:18,325
So that is going to be,

246
00:12:18,325 --> 00:12:22,619
I think CustomerDao was
the name of the interface.

247
00:12:22,619 --> 00:12:25,122
The method name becomes
the ID of the bean,

248
00:12:25,122 --> 00:12:29,289
so to remain consistent, we'll
use CustomerDao from there.

249
00:12:32,005 --> 00:12:35,142
And because this is a
very simple object here,

250
00:12:35,142 --> 00:12:38,475
we just need to return a new instance of

251
00:12:40,135 --> 00:12:42,052
the CustomerDaoJpaImpl.

252
00:12:44,513 --> 00:12:46,563
It has no parameters, so we don't need to

253
00:12:46,563 --> 00:12:49,141
do anything very complicated.

254
00:12:49,141 --> 00:12:50,767
We just need to complete the imports.

255
00:12:50,767 --> 00:12:53,566
Control or Command + Shift + O,

256
00:12:53,566 --> 00:12:55,609
and everything is compiling.

257
00:12:55,609 --> 00:12:59,227
So now we'll do the second of the beans.

258
00:12:59,227 --> 00:13:01,810
This time this is an ActionDao.

259
00:13:03,337 --> 00:13:06,489
Method will be ActionDao as well.

260
00:13:06,489 --> 00:13:09,431
I'll return a new instance of the

261
00:13:09,431 --> 00:13:10,848
ActionDaoJpaImpl.

262
00:13:13,941 --> 00:13:15,937
Fix up the imports.

263
00:13:15,937 --> 00:13:17,658
Well, that was suspiciously easy,

264
00:13:17,658 --> 00:13:20,143
but I think we are now done.

265
00:13:20,143 --> 00:13:23,691
Now, the integration
tests will be broken now,

266
00:13:23,691 --> 00:13:25,868
and I will return to the integration tests

267
00:13:25,868 --> 00:13:27,969
at the end of the chapter,

268
00:13:27,969 --> 00:13:30,608
but it would be nice if
we could in the interim,

269
00:13:30,608 --> 00:13:32,270
I know we haven't finished
yet, but it would be nice

270
00:13:32,270 --> 00:13:35,520
if we could run the Simple Client Test.

271
00:13:36,722 --> 00:13:38,359
Well, it is going to break, of course,

272
00:13:38,359 --> 00:13:41,721
because at the moment
it's reading the XML file,

273
00:13:41,721 --> 00:13:43,888
which is missing the daos.

274
00:13:44,829 --> 00:13:46,329
Let's verify that.

275
00:13:48,208 --> 00:13:51,699
Yeah, plenty of logging, but
plenty of red text as well.

276
00:13:51,699 --> 00:13:53,741
I'm not even going to
bother looking at the

277
00:13:53,741 --> 00:13:55,834
stack traces for that.

278
00:13:55,834 --> 00:13:59,618
So I promise you that
it's possible to mix XML

279
00:13:59,618 --> 00:14:01,525
and JavaConfig.

280
00:14:01,525 --> 00:14:02,531
How do we do that?

281
00:14:02,531 --> 00:14:04,303
Well the reference manual

282
00:14:04,303 --> 00:14:08,211
in the section on Java-based
container configuration,

283
00:14:08,211 --> 00:14:10,517
at the time of recording,
it's right at the end here.

284
00:14:10,517 --> 00:14:13,185
Has a rather nice
section on how to combine

285
00:14:13,185 --> 00:14:15,435
Java and XML configuration.

286
00:14:16,993 --> 00:14:21,160
And it covers here what they
call the XML-centric use

287
00:14:22,162 --> 00:14:25,425
versus, if I go a little further down,

288
00:14:25,425 --> 00:14:28,425
the configuration class-centric use.

289
00:14:29,329 --> 00:14:33,996
Now, all it means is, really,
what are you starting from.

290
00:14:33,996 --> 00:14:36,464
If we have a look in our project,

291
00:14:36,464 --> 00:14:39,297
our client is loading an XML file.

292
00:14:41,014 --> 00:14:43,892
At the moment, we will be changing that,

293
00:14:43,892 --> 00:14:45,426
but at the moment it's XML,

294
00:14:45,426 --> 00:14:48,759
and that means that this is XML-centric.

295
00:14:49,860 --> 00:14:53,110
So if we check the XML-centric section,

296
00:14:54,153 --> 00:14:55,821
you'll find that this information here

297
00:14:55,821 --> 00:14:57,539
is basically just saying

298
00:14:57,539 --> 00:15:00,206
that we need to include in the XML

299
00:15:00,206 --> 00:15:04,090
a reference to our configuration class.

300
00:15:04,090 --> 00:15:07,325
And, really, that's just
going to be a simple case of

301
00:15:07,325 --> 00:15:09,742
if I go into application.xml,

302
00:15:10,937 --> 00:15:12,437
if we declare bean

303
00:15:14,515 --> 00:15:17,070
from the class that we've
just written, which was

304
00:15:17,070 --> 00:15:21,070
virtualpairprogrammers.config.ApplicationConfig,

305
00:15:24,306 --> 00:15:27,103
and make sure you type
all of that correctly.

306
00:15:27,103 --> 00:15:29,142
But this means that
Spring will instantiate

307
00:15:29,142 --> 00:15:32,911
our configuration class,
and it will start processing

308
00:15:32,911 --> 00:15:36,095
the annotations that it finds inside.

309
00:15:36,095 --> 00:15:38,923
By the way, it's only going
to process the annotations

310
00:15:38,923 --> 00:15:41,476
because we also have this

311
00:15:41,476 --> 00:15:43,559
misc-beans.xml file here,

312
00:15:45,412 --> 00:15:49,579
which has the context
annotation-config annotation inside.

313
00:15:50,551 --> 00:15:52,811
Well, actually we're going to be deleting

314
00:15:52,811 --> 00:15:57,095
this XML file quite soon, so
I don't want this to break.

315
00:15:57,095 --> 00:15:59,219
So an alternative way of doing this,

316
00:15:59,219 --> 00:16:02,310
again I'm just using standard Spring here,

317
00:16:02,310 --> 00:16:04,698
is I can use the macro tag in here,

318
00:16:04,698 --> 00:16:08,305
which is from the context namespace,

319
00:16:08,305 --> 00:16:11,555
and it's the component-scan annotation.

320
00:16:13,466 --> 00:16:15,255
Now, you might remember this.

321
00:16:15,255 --> 00:16:18,570
This tells Spring to look
in a particular package

322
00:16:18,570 --> 00:16:21,346
and to find any classes in there

323
00:16:21,346 --> 00:16:23,829
with any Spring annotations.

324
00:16:23,829 --> 00:16:27,157
It will automatically
instantiate those classes

325
00:16:27,157 --> 00:16:30,373
and process their annotations.

326
00:16:30,373 --> 00:16:34,122
So if we tell it that the
base package for this scan

327
00:16:34,122 --> 00:16:38,205
is going to be
com.virtualpairprogrammers.config,

328
00:16:42,274 --> 00:16:43,888
and Spring will automatically find this

329
00:16:43,888 --> 00:16:47,796
ApplicationConfig file,
and it will process it.

330
00:16:47,796 --> 00:16:49,615
And I think that's the
best way of combining

331
00:16:49,615 --> 00:16:52,747
the XML with the annotations.

332
00:16:52,747 --> 00:16:54,802
If you're finding all of this
a little bit heavyweight,

333
00:16:54,802 --> 00:16:56,527
remember I am only doing this

334
00:16:56,527 --> 00:16:59,170
because I want to temporarily

335
00:16:59,170 --> 00:17:02,278
combine the XML and the annotations.

336
00:17:02,278 --> 00:17:04,622
When we get to the end of this process,

337
00:17:04,622 --> 00:17:08,122
we'll be deleting all of the XML entirely.

338
00:17:09,734 --> 00:17:11,339
But before we get there,

339
00:17:11,339 --> 00:17:15,127
I'm afraid, of course, to make
the context namespace work.

340
00:17:15,127 --> 00:17:19,740
We've got to upgrade the schema
declaration here at the top.

341
00:17:19,740 --> 00:17:21,635
I think the simplest way of doing that

342
00:17:21,635 --> 00:17:25,218
is if you can find the
misc-beans.xml file.

343
00:17:26,090 --> 00:17:30,506
You can simply copy
lines one through to 12

344
00:17:30,506 --> 00:17:35,211
because that file already
has the context namespacing

345
00:17:35,211 --> 00:17:38,231
plus a few others we
don't need, but who cares.

346
00:17:38,231 --> 00:17:42,717
So I'm going to replace
lines two through to four

347
00:17:42,717 --> 00:17:44,745
with what I just copied,

348
00:17:44,745 --> 00:17:48,086
and now that macro tag is enabled.

349
00:17:48,086 --> 00:17:50,032
Well, I hope that's the last piece of XML

350
00:17:50,032 --> 00:17:51,281
we're going to have to work with

351
00:17:51,281 --> 00:17:54,778
because by the end of this
chapter, it will all be gone.

352
00:17:54,778 --> 00:17:58,809
But let's see now if the
client's application is running,

353
00:17:58,809 --> 00:18:00,983
and we're back to that
long list of logging.

354
00:18:00,983 --> 00:18:03,311
No exceptions, and you can definitely see

355
00:18:03,311 --> 00:18:05,327
some system out print lines

356
00:18:05,327 --> 00:18:08,236
happily working away right there.

357
00:18:08,236 --> 00:18:09,485
So that's a great start.

358
00:18:09,485 --> 00:18:12,568
We've got our first piece
of JavaConfig in place,

359
00:18:12,568 --> 00:18:15,889
and now we can go ahead
and just do the rest.

360
00:18:15,889 --> 00:18:19,565
Let's work on this services.xml next,

361
00:18:19,565 --> 00:18:21,665
so we'll delete the imports

362
00:18:21,665 --> 00:18:23,998
and then find that XML file.

363
00:18:26,534 --> 00:18:28,034
I'll copy the tags

364
00:18:29,429 --> 00:18:31,429
and then delete the XML.

365
00:18:32,624 --> 00:18:35,527
Of course, now everything
should be broken.

366
00:18:35,527 --> 00:18:39,340
Let's run the client test harness again,

367
00:18:39,340 --> 00:18:41,766
and there we are, we have an exception.

368
00:18:41,766 --> 00:18:45,345
No qualifying bean of type
CustomerManagementService

369
00:18:45,345 --> 00:18:47,489
because we're no longer declaring it,

370
00:18:47,489 --> 00:18:51,656
and I'm going to place this
in the ApplicationConfig.

371
00:18:54,280 --> 00:18:57,370
So just for the purposes of documentation

372
00:18:57,370 --> 00:18:58,645
and for practicals and code,

373
00:18:58,645 --> 00:19:00,193
you wouldn't do this on a real project.

374
00:19:00,193 --> 00:19:02,491
I include the XML in there,

375
00:19:02,491 --> 00:19:04,154
and I think this should be routine.

376
00:19:04,154 --> 00:19:06,820
We, first of all, need a bean

377
00:19:06,820 --> 00:19:09,653
of type CustomerManagementService,

378
00:19:13,754 --> 00:19:15,924
which is going to be
called customerService now.

379
00:19:15,924 --> 00:19:18,892
I reckon you could probably
do this work for yourself,

380
00:19:18,892 --> 00:19:21,225
so if you want to
forward, rewind the video

381
00:19:21,225 --> 00:19:24,788
and just do this for
yourself, do feel free.

382
00:19:24,788 --> 00:19:27,345
I guess the difference
here is for the first time

383
00:19:27,345 --> 00:19:31,159
we have a constructor
argument going into this bean.

384
00:19:31,159 --> 00:19:32,893
Well, there's nothing scary there.

385
00:19:32,893 --> 00:19:36,480
Its customerDao is a dependency,
so my preferred approach

386
00:19:36,480 --> 00:19:39,458
is to declare it as a perimeter into here.

387
00:19:39,458 --> 00:19:41,291
I'll just call it dao.

388
00:19:42,692 --> 00:19:46,025
And we can return a new instance of the,

389
00:19:46,930 --> 00:19:48,662
checking the concrete class here.

390
00:19:48,662 --> 00:19:51,223
This is the customer management

391
00:19:51,223 --> 00:19:54,823
service production implementation,

392
00:19:54,823 --> 00:19:57,635
and we're passing in the
dependency that we received.

393
00:19:57,635 --> 00:20:01,419
So very easy, and then this
one called diaryService,

394
00:20:01,419 --> 00:20:05,252
which its interface is
DiaryManagementService.

395
00:20:08,630 --> 00:20:11,830
And beans like the diaryService,

396
00:20:11,830 --> 00:20:15,663
each receiving a dependency
of type ActionDao.

397
00:20:19,848 --> 00:20:24,673
And that's the concrete class
diary management service

398
00:20:24,673 --> 00:20:26,141
production implementation.

399
00:20:26,141 --> 00:20:27,641
Passing in the dao

400
00:20:28,816 --> 00:20:30,316
and one final one,

401
00:20:31,156 --> 00:20:34,995
which I think we are
using in the test harness.

402
00:20:34,995 --> 00:20:38,245
This one is a type CallHandlingService,

403
00:20:39,866 --> 00:20:42,283
the beans called callService,

404
00:20:44,206 --> 00:20:48,039
and there are two
dependencies into this bean,

405
00:20:50,336 --> 00:20:52,975
one of type customer service,

406
00:20:52,975 --> 00:20:55,975
or rather CustomerManagementService.

407
00:20:57,521 --> 00:21:00,910
I'll call it customers and one of type

408
00:21:00,910 --> 00:21:02,827
DiaryManagementService.

409
00:21:07,338 --> 00:21:09,423
And they're both constructor arguments,

410
00:21:09,423 --> 00:21:12,226
so we'll be returning
a new instance of the

411
00:21:12,226 --> 00:21:14,226
CallHandlingServiceImpl.

412
00:21:18,841 --> 00:21:21,235
It must take two parameters
into the constructor,

413
00:21:21,235 --> 00:21:22,555
and it does.

414
00:21:22,555 --> 00:21:25,638
The first one is the customerService,

415
00:21:26,875 --> 00:21:29,624
and the second one is the diaryService.

416
00:21:29,624 --> 00:21:33,326
And my compiler there is just
because I haven't imported

417
00:21:33,326 --> 00:21:36,476
the call handling service implementation.

418
00:21:36,476 --> 00:21:40,314
Now before I run this, I do
have a glaring omission here.

419
00:21:40,314 --> 00:21:43,846
I forgot to include the @Bean annotation

420
00:21:43,846 --> 00:21:46,771
on the top of the methods,
and that is important

421
00:21:46,771 --> 00:21:49,553
because otherwise these
methods will be ignored.

422
00:21:49,553 --> 00:21:53,720
I'll just prove that, in fact,
if I run the client test now,

423
00:21:55,189 --> 00:21:57,317
yeah, there's an exception there.

424
00:21:57,317 --> 00:21:59,147
No such bean definition.

425
00:21:59,147 --> 00:22:03,305
No qualifying bean of type
CustomerManagementService,

426
00:22:03,305 --> 00:22:06,388
but if I now go in and add my bean...

427
00:22:17,034 --> 00:22:18,784
Now we should find...

428
00:22:20,550 --> 00:22:23,847
Yeah, we're back to a running application.

429
00:22:23,847 --> 00:22:27,367
Okay, back to our main XML file then,

430
00:22:27,367 --> 00:22:30,015
and we've got two more to go.

431
00:22:30,015 --> 00:22:34,196
The next one is the datasource-webapp.xml.

432
00:22:34,196 --> 00:22:35,682
I'll follow the same process.

433
00:22:35,682 --> 00:22:37,765
We'll delete the imports.

434
00:22:39,516 --> 00:22:41,034
Find the file.

435
00:22:41,034 --> 00:22:43,605
It's in the src folder.

436
00:22:43,605 --> 00:22:46,272
We'll take the bean definitions,

437
00:22:47,257 --> 00:22:49,229
cut those out,

438
00:22:49,229 --> 00:22:51,562
and then trash the XML file.

439
00:22:55,496 --> 00:22:59,663
And then we'll migrate this
across to the ApplicationConfig.

440
00:23:00,992 --> 00:23:04,086
So these beans are for the
database connection pool,

441
00:23:04,086 --> 00:23:07,614
and this project happens to
use the Java Persistence API

442
00:23:07,614 --> 00:23:09,957
to make calls to the database.

443
00:23:09,957 --> 00:23:13,446
I assume you're familiar with
this entityManagerFactory.

444
00:23:13,446 --> 00:23:15,481
If not, you could check
out the Spring Framework

445
00:23:15,481 --> 00:23:17,728
Fundamentals course, but even then,

446
00:23:17,728 --> 00:23:19,756
you don't necessarily
need to check that course.

447
00:23:19,756 --> 00:23:23,039
It's just a bean that
we need to configure.

448
00:23:23,039 --> 00:23:25,563
So the both of these beans
look a bit more complicated

449
00:23:25,563 --> 00:23:27,292
than the ones we've had before.

450
00:23:27,292 --> 00:23:28,967
They're just Java objects.

451
00:23:28,967 --> 00:23:32,790
They should be fairly simple
and routine to instantiate.

452
00:23:32,790 --> 00:23:35,964
So I better not forget @Bean this time,

453
00:23:35,964 --> 00:23:37,942
so we'll start with the first one now.

454
00:23:37,942 --> 00:23:40,917
This is creating bean of type

455
00:23:40,917 --> 00:23:42,250
BasicDataSource,

456
00:23:43,768 --> 00:23:45,333
and I have a choice here.

457
00:23:45,333 --> 00:23:47,236
It's up to you.

458
00:23:47,236 --> 00:23:50,736
I could configure this as BasicDataSource.

459
00:23:52,489 --> 00:23:54,420
Probably better engineering is to use

460
00:23:54,420 --> 00:23:57,312
the interface BasicDataSource,

461
00:23:57,312 --> 00:23:58,861
which you probably know

462
00:23:58,861 --> 00:24:01,778
is the interface called DataSource.

463
00:24:02,619 --> 00:24:06,697
The bean's ID is going to be DataSource,

464
00:24:06,697 --> 00:24:10,692
and there's no dependencies
coming in here,

465
00:24:10,692 --> 00:24:13,664
so we don't need any parameters.

466
00:24:13,664 --> 00:24:17,158
But what we do have in
here are four properties,

467
00:24:17,158 --> 00:24:19,325
each of which are strings,

468
00:24:20,188 --> 00:24:22,754
and if you've got the
flavor of JavaConfig now,

469
00:24:22,754 --> 00:24:25,793
you'll know exactly what
you have to do here.

470
00:24:25,793 --> 00:24:27,054
We're going to have to instantiate

471
00:24:27,054 --> 00:24:29,387
this BaiscDataSource object.

472
00:24:32,055 --> 00:24:33,388
I'll call it ds.

473
00:24:37,156 --> 00:24:39,906
This must be new BasicDataSource.

474
00:24:41,283 --> 00:24:43,812
There's going to be no
parameters into the constructor

475
00:24:43,812 --> 00:24:47,243
because there's constructor args in here.

476
00:24:47,243 --> 00:24:48,854
These will need to be imported,

477
00:24:48,854 --> 00:24:52,271
and the data source comes from javax.sql.

478
00:24:55,179 --> 00:24:57,044
But the BasicDataSource you probably know

479
00:24:57,044 --> 00:25:00,429
comes from the Apache Commons library.

480
00:25:00,429 --> 00:25:01,784
And now what do we do?

481
00:25:01,784 --> 00:25:05,125
Well, for the properties, we
just call the set methods.

482
00:25:05,125 --> 00:25:08,458
So we need to set the driver class name,

483
00:25:09,907 --> 00:25:11,818
and be careful here.

484
00:25:11,818 --> 00:25:16,109
In rehearsals, I copied the wrong strings,

485
00:25:16,109 --> 00:25:18,757
and I lost quite a lot of time over that.

486
00:25:18,757 --> 00:25:22,924
So that's going to be the
one beginning org.hsqldb,

487
00:25:23,775 --> 00:25:26,942
and then we have the set URL property,

488
00:25:30,256 --> 00:25:32,423
this big ugly string here.

489
00:25:33,503 --> 00:25:36,019
And just in case this is the first

490
00:25:36,019 --> 00:25:38,900
Virtual Pair Programmers
course you've watched,

491
00:25:38,900 --> 00:25:41,459
I have to apologies
for this very ugly hack

492
00:25:41,459 --> 00:25:44,703
that we did on the Java
Fundamentals course.

493
00:25:44,703 --> 00:25:46,280
I wanted to keep everything simple

494
00:25:46,280 --> 00:25:48,098
when we deploy this to Tomcat.

495
00:25:48,098 --> 00:25:51,410
So I've hard-coded in a file name here,

496
00:25:51,410 --> 00:25:54,864
and it has actually caused
all sorts of problem

497
00:25:54,864 --> 00:25:58,020
and support calls, but I
hope it shouldn't cause us

498
00:25:58,020 --> 00:26:00,462
any problem on this course.

499
00:26:00,462 --> 00:26:03,294
Anyway, two to go, we've got
to set the property called

500
00:26:03,294 --> 00:26:07,127
username which is sa for
system administrator,

501
00:26:08,194 --> 00:26:10,631
and find that we have a
password property now.

502
00:26:10,631 --> 00:26:12,308
We do need to set that property

503
00:26:12,308 --> 00:26:15,759
even though it's going
to be a blank string.

504
00:26:15,759 --> 00:26:19,050
So set password to be empty string,

505
00:26:19,050 --> 00:26:21,717
and then we just return that ds.

506
00:26:22,856 --> 00:26:26,597
Now, although I've called
bean EntityManagerFactory,

507
00:26:26,597 --> 00:26:28,631
EntityManagerFacotry is an interface

508
00:26:28,631 --> 00:26:31,409
from the Java Persistance API.

509
00:26:31,409 --> 00:26:34,404
But, actually, this bean is a wrapper bean

510
00:26:34,404 --> 00:26:38,118
for an EntityManagerFactory,
and it's from the class

511
00:26:38,118 --> 00:26:41,368
LocalContainerEntityManagerFactoryBean.

512
00:26:43,086 --> 00:26:45,621
Now, I'm not planning on
changing the implementation

513
00:26:45,621 --> 00:26:47,892
of this class anytime soon,

514
00:26:47,892 --> 00:26:50,713
so as we're between frames here,

515
00:26:50,713 --> 00:26:52,446
I'm not even going to bother looking at

516
00:26:52,446 --> 00:26:54,938
what the parent interface of that is.

517
00:26:54,938 --> 00:26:57,896
I'm just going to make
that be the return type

518
00:26:57,896 --> 00:26:59,146
of this method.

519
00:27:00,028 --> 00:27:03,945
The method will be called
EntityManagerFactory.

520
00:27:05,122 --> 00:27:08,430
And this one does have a dependency.

521
00:27:08,430 --> 00:27:11,612
It has a dependency on the data source,

522
00:27:11,612 --> 00:27:14,612
so I'll declare that as a parameter.

523
00:27:16,731 --> 00:27:18,029
We can call it anything we like,

524
00:27:18,029 --> 00:27:19,529
but why not go for

525
00:27:22,301 --> 00:27:23,218
dataSource?

526
00:27:25,540 --> 00:27:27,516
Okay, I will need to import this

527
00:27:27,516 --> 00:27:30,290
LocalContainerEntityManagerFactoryBean,

528
00:27:30,290 --> 00:27:32,981
which I'll do with a quick fix.

529
00:27:32,981 --> 00:27:34,916
Well, although this is a big block of XML,

530
00:27:34,916 --> 00:27:37,164
there are actually only two properties

531
00:27:37,164 --> 00:27:38,801
that we need to configure here.

532
00:27:38,801 --> 00:27:40,741
We've got the dataSource,

533
00:27:40,741 --> 00:27:44,015
and we've got the jpaVendorAdapter.

534
00:27:44,015 --> 00:27:46,381
And so this is going to
be a very simple case

535
00:27:46,381 --> 00:27:47,947
of just creating an object

536
00:27:47,947 --> 00:27:51,530
for this jpaVendorAdapter
and wiring it in.

537
00:27:52,390 --> 00:27:54,764
So, again, if you want
to try this for yourself

538
00:27:54,764 --> 00:27:56,516
and if you have any problems,

539
00:27:56,516 --> 00:27:59,352
you can jsut follow the
few minutes of video.

540
00:27:59,352 --> 00:28:01,464
I'm hoping it's going to be routine.

541
00:28:01,464 --> 00:28:03,643
We'll need to create an instance of this

542
00:28:03,643 --> 00:28:06,893
LocalContainerEntityManagerFactoryBean.

543
00:28:07,786 --> 00:28:09,786
I'll just call that EMF.

544
00:28:15,395 --> 00:28:17,853
And we got two properties,

545
00:28:17,853 --> 00:28:19,773
so I'll do the easy one first.

546
00:28:19,773 --> 00:28:21,168
We can set the data source

547
00:28:21,168 --> 00:28:23,994
to be the dependency that was passed in.

548
00:28:23,994 --> 00:28:25,304
That's easy.

549
00:28:25,304 --> 00:28:29,207
Slightly more complicated
is this property called

550
00:28:29,207 --> 00:28:30,790
setJpaVendorAdapter

551
00:28:32,269 --> 00:28:34,519
because it needs an object,

552
00:28:35,656 --> 00:28:37,568
but all the details we need are here.

553
00:28:37,568 --> 00:28:39,731
The object is of type

554
00:28:39,731 --> 00:28:41,898
HibernateJpaVendorAdapter.

555
00:28:48,107 --> 00:28:50,357
Called it jpaVendorAdapter.

556
00:28:52,662 --> 00:28:53,579
And that...

557
00:28:56,541 --> 00:28:58,624
No constructor arguments.

558
00:29:02,385 --> 00:29:06,044
So we have a proxy called ShowSQL,

559
00:29:06,044 --> 00:29:08,377
which we're setting to true.

560
00:29:11,791 --> 00:29:15,458
And they have a property
called generateDdl,

561
00:29:16,781 --> 00:29:19,531
which we're also setting to true.

562
00:29:21,697 --> 00:29:22,864
And that's it!

563
00:29:24,507 --> 00:29:27,295
We can now return the object at the end.

564
00:29:27,295 --> 00:29:29,193
So I'm trying to make this interesting,

565
00:29:29,193 --> 00:29:31,639
but really apart from creating objects

566
00:29:31,639 --> 00:29:35,385
and passing in properties,
it's very routine.

567
00:29:35,385 --> 00:29:39,052
Let's check that
everything's still running.

568
00:29:40,054 --> 00:29:41,600
And all good for me.

569
00:29:41,600 --> 00:29:42,671
Now we've got through that,

570
00:29:42,671 --> 00:29:46,187
there are a few interesting
pieces of theory coming up

571
00:29:46,187 --> 00:29:49,349
when we work on our final import,

572
00:29:49,349 --> 00:29:52,099
which was the misc-beans.xml file

573
00:29:53,452 --> 00:29:57,415
Follow the same routine
get rid of the imports,

574
00:29:57,415 --> 00:29:59,390
find the file,

575
00:29:59,390 --> 00:30:02,909
we'll rescue the XML
from there with a cut,

576
00:30:02,909 --> 00:30:05,826
and then we'll delete the XML file.

577
00:30:07,433 --> 00:30:11,600
Now I suspect this is going to
be a little more complicated.

578
00:30:13,257 --> 00:30:15,939
Just review what we had in that XML file.

579
00:30:15,939 --> 00:30:18,340
This is where we're setting
transaction management.

580
00:30:18,340 --> 00:30:20,572
We have to declare a transaction manager

581
00:30:20,572 --> 00:30:22,687
for our chosen database strategy,

582
00:30:22,687 --> 00:30:25,764
which is JPA for this project.

583
00:30:25,764 --> 00:30:29,551
And then I'm using the
tx annotation-driven tag,

584
00:30:29,551 --> 00:30:33,424
which, of course, scans all of
the classes in our container

585
00:30:33,424 --> 00:30:36,271
for any transaction annotations.

586
00:30:36,271 --> 00:30:39,276
We're going to need to work
out how to make that work

587
00:30:39,276 --> 00:30:40,340
in just a few moments,

588
00:30:40,340 --> 00:30:43,141
but we can certainly do
the first of the tags.

589
00:30:43,141 --> 00:30:45,724
That's going to be easy enough.

590
00:30:47,342 --> 00:30:49,725
We need an @Bean method.

591
00:30:49,725 --> 00:30:50,865
Now be careful here.

592
00:30:50,865 --> 00:30:53,180
You might think, "Oh,
yeah the parent interface

593
00:30:53,180 --> 00:30:56,312
"is going to be transactionManager,"

594
00:30:56,312 --> 00:30:59,712
and I have done that before
on a previous project.

595
00:30:59,712 --> 00:31:02,669
I've got transactionManager in here

596
00:31:02,669 --> 00:31:05,169
and then completed the method.

597
00:31:06,105 --> 00:31:08,752
But if you check the import there,

598
00:31:08,752 --> 00:31:13,125
the import is from the
standard Java package.

599
00:31:13,125 --> 00:31:16,010
Actually, this comes from Java EE,

600
00:31:16,010 --> 00:31:18,160
so you have to be very
careful when you're doing this

601
00:31:18,160 --> 00:31:20,267
if your not really thinking.

602
00:31:20,267 --> 00:31:24,189
The parent interface for
JpaTransactionManager,

603
00:31:24,189 --> 00:31:27,100
well, we should be using
the Javadocs really,

604
00:31:27,100 --> 00:31:29,237
and the important interface is the

605
00:31:29,237 --> 00:31:32,320
PlatformTransactionManager interface,

606
00:31:33,385 --> 00:31:37,662
the central interface in Spring's
transaction infrastructure

607
00:31:37,662 --> 00:31:39,329
so be careful there.

608
00:31:41,952 --> 00:31:44,656
PlatformTransactionManager.

609
00:31:44,656 --> 00:31:46,997
Now, when you're
instantiating this object,

610
00:31:46,997 --> 00:31:49,963
you are going to have to
use the concrete class name

611
00:31:49,963 --> 00:31:54,287
on the left-hand side as well
as on the right-hand side.

612
00:31:54,287 --> 00:31:56,296
Let me demonstrate why.

613
00:31:56,296 --> 00:31:58,678
If you use the interface here,

614
00:31:58,678 --> 00:32:00,928
PlatformTransactionManager,

615
00:32:02,207 --> 00:32:04,213
I'll call the object tx.

616
00:32:04,213 --> 00:32:08,479
There's a new instance
of JpaTransactionManager.

617
00:32:08,479 --> 00:32:11,358
Then your problem is, unfortunately,

618
00:32:11,358 --> 00:32:14,130
want to import that, first of all.

619
00:32:14,130 --> 00:32:17,164
But, unfortunately, the interface here

620
00:32:17,164 --> 00:32:20,011
doesn't have any of the set methods.

621
00:32:20,011 --> 00:32:22,683
You can see that from the IntelliSense.

622
00:32:22,683 --> 00:32:26,475
So I can't set the EntityManagerFacotry.

623
00:32:26,475 --> 00:32:30,559
So you're going to need concrete
class name on both sides,

624
00:32:30,559 --> 00:32:35,136
and then you can call
setEntityManagerFactory,

625
00:32:35,136 --> 00:32:37,861
and, of course, this EntityManagerFactory

626
00:32:37,861 --> 00:32:40,778
is a dependency that we can pass in

627
00:32:42,702 --> 00:32:43,952
as a dependency

628
00:32:47,715 --> 00:32:49,238
just like so.

629
00:32:49,238 --> 00:32:51,560
Notice the type here does need to be

630
00:32:51,560 --> 00:32:53,429
EntityManagerFactory,

631
00:32:53,429 --> 00:32:55,994
which is one the parent
interfaces of this.

632
00:32:55,994 --> 00:32:58,900
That's because setEntityManagerFactory

633
00:32:58,900 --> 00:33:02,840
will insist on an instance
of EntityManagerFactory

634
00:33:02,840 --> 00:33:04,478
to be passed in.

635
00:33:04,478 --> 00:33:06,950
All that remains, then, is to return

636
00:33:06,950 --> 00:33:09,033
our new object called tx,

637
00:33:09,894 --> 00:33:12,874
and now everything is compiling.

638
00:33:12,874 --> 00:33:16,716
So that's, but that was only
one of the beans in this XML.

639
00:33:16,716 --> 00:33:20,287
The important one really
was the macro tag here,

640
00:33:20,287 --> 00:33:22,954
which was tx: annotation-driven.

641
00:33:24,726 --> 00:33:27,977
Now, this is something
that we haven't met so far.

642
00:33:27,977 --> 00:33:29,568
All we've been doing with JavaConfig

643
00:33:29,568 --> 00:33:33,401
is configuring beans and
wiring in properties.

644
00:33:34,323 --> 00:33:38,490
How on Earth are we going
to replace this macro tag?

645
00:33:39,627 --> 00:33:41,558
As you know, a macro tag

646
00:33:41,558 --> 00:33:43,350
does a lot of stuff behind the scenes.

647
00:33:43,350 --> 00:33:46,106
it will create a lot of beans

648
00:33:46,106 --> 00:33:49,636
and will do all kinds of magic for us.

649
00:33:49,636 --> 00:33:51,258
Well, the answer's really easy,

650
00:33:51,258 --> 00:33:55,017
and I'm really just working
from the reference manual here.

651
00:33:55,017 --> 00:33:56,350
You should find,

652
00:33:57,186 --> 00:34:00,436
with at least most of these macro tags,

653
00:34:01,273 --> 00:34:03,533
there will be an
alternative way of doing it

654
00:34:03,533 --> 00:34:07,700
in the JavaConfig, and in the
case of tx annotation-driven,

655
00:34:09,067 --> 00:34:10,855
it's a simple case

656
00:34:10,855 --> 00:34:14,188
of going to the top of your config class

657
00:34:15,360 --> 00:34:19,570
and adding in, yeah, it's
gonna be an annotation.

658
00:34:19,570 --> 00:34:23,737
It is the the
@EnableTransactionManagement annotation.

659
00:34:26,540 --> 00:34:28,735
Nothing complicated about this.

660
00:34:28,735 --> 00:34:32,735
The presence of annotation
does exactly the same

661
00:34:33,836 --> 00:34:37,169
as the presence of this tag in your XML.

662
00:34:38,082 --> 00:34:41,419
I think for the AnnotationConfig tag

663
00:34:41,419 --> 00:34:44,918
I'm not actually sure
that we're using that tag.

664
00:34:44,918 --> 00:34:46,265
I think that was just there

665
00:34:46,265 --> 00:34:48,500
as part of the fundamentals course

666
00:34:48,500 --> 00:34:53,169
when we were experimenting
with annotation-based config.

667
00:34:53,169 --> 00:34:54,243
And as far as I can tell,

668
00:34:54,243 --> 00:34:57,192
we're not actually using
that at the moment at least,

669
00:34:57,192 --> 00:35:00,172
so I'll just remove that tag.

670
00:35:00,172 --> 00:35:04,170
So I think we've now reached
a really good position.

671
00:35:04,170 --> 00:35:07,348
If we check in the application.xml,

672
00:35:07,348 --> 00:35:09,523
we're actually doing nothing in there

673
00:35:09,523 --> 00:35:12,500
other than reading the config class.

674
00:35:12,500 --> 00:35:13,917
And I reckon that

675
00:35:15,908 --> 00:35:17,491
we run the clients.

676
00:35:19,085 --> 00:35:23,316
Yeah, everything is running
through absolutely fine.

677
00:35:23,316 --> 00:35:25,111
So we've now reached a really good point

678
00:35:25,111 --> 00:35:27,554
where we can get rid of the XML entirely

679
00:35:27,554 --> 00:35:30,338
because, after all, this
isn't really doing anything

680
00:35:30,338 --> 00:35:33,526
other than setting off the JavaConfig.

681
00:35:33,526 --> 00:35:37,026
So I will delete the application.xml file.

682
00:35:41,533 --> 00:35:43,177
That feels good.

683
00:35:43,177 --> 00:35:45,866
And in our Simple Client Test,

684
00:35:45,866 --> 00:35:49,056
exactly as in the previous
chapter, we can now switch the

685
00:35:49,056 --> 00:35:51,556
ClassPathXMLApplicationContext

686
00:35:52,517 --> 00:35:55,934
to the AnnotationConfigApplicationContext

687
00:35:59,075 --> 00:36:00,658
and point it at our

688
00:36:01,708 --> 00:36:03,708
ApplicationConfig.class.

689
00:36:08,598 --> 00:36:10,908
We do still have a few other XML files

690
00:36:10,908 --> 00:36:13,151
for other parts of the architecture

691
00:36:13,151 --> 00:36:16,210
but for the business tiers,

692
00:36:16,210 --> 00:36:17,922
let's check that's working.

693
00:36:17,922 --> 00:36:19,235
For the business tiers,

694
00:36:19,235 --> 00:36:22,568
we are now running with pure JavaConfig.

695
00:36:24,446 --> 00:36:26,582
So that's good, but I have been neglecting

696
00:36:26,582 --> 00:36:30,476
the integration tests that we saw earlier.

697
00:36:30,476 --> 00:36:34,252
Now I recKon that these are
going to be completely wrecked

698
00:36:34,252 --> 00:36:36,169
if I run as JUnit Test.

699
00:36:38,227 --> 00:36:41,241
Yeah, a red bar, and all three of these

700
00:36:41,241 --> 00:36:44,144
integration test methods are failing.

701
00:36:44,144 --> 00:36:46,830
Should be fairly obvious
why that's happening

702
00:36:46,830 --> 00:36:50,572
because previously we were
telling the intergration test

703
00:36:50,572 --> 00:36:52,905
to use these four XML files.

704
00:36:54,581 --> 00:36:57,391
And I've gone and deleted,

705
00:36:57,391 --> 00:36:59,907
I've actually deleted three of them.

706
00:36:59,907 --> 00:37:04,268
There is one here, which
is datasource-test.xml,

707
00:37:04,268 --> 00:37:07,133
which we haven't currently touched.

708
00:37:07,133 --> 00:37:09,890
Now, again, you'll only know
this if you've been on the

709
00:37:09,890 --> 00:37:12,164
Spring Fundamentals course,

710
00:37:12,164 --> 00:37:14,718
but the idea here is
that the integration test

711
00:37:14,718 --> 00:37:18,255
is going to use an alternative database,

712
00:37:18,255 --> 00:37:21,882
a database purely for testing purposes,

713
00:37:21,882 --> 00:37:24,852
and you probably know all
the reasons for doing that.

714
00:37:24,852 --> 00:37:26,872
It means that we can
run our integration test

715
00:37:26,872 --> 00:37:30,173
without the integration test interfering

716
00:37:30,173 --> 00:37:32,590
with any production data.

717
00:37:32,590 --> 00:37:34,082
So I'd like to be able to do that,

718
00:37:34,082 --> 00:37:37,784
and there are two ways
that you can do this.

719
00:37:37,784 --> 00:37:40,378
The easy way is to do things

720
00:37:40,378 --> 00:37:43,113
really pretty much in exactly the same way

721
00:37:43,113 --> 00:37:45,345
as we did with the XML.

722
00:37:45,345 --> 00:37:49,959
We would split the configuration
into multiple classes.

723
00:37:49,959 --> 00:37:53,147
And what we can do here in
the ContextConfiguration

724
00:37:53,147 --> 00:37:55,564
is, instead of the XML files,

725
00:37:58,092 --> 00:38:01,425
we can supply a property called classes.

726
00:38:02,669 --> 00:38:04,366
And this property takes an array,

727
00:38:04,366 --> 00:38:08,581
so that's the curly brackets,
and it's just an array

728
00:38:08,581 --> 00:38:11,866
of config classes that we want to use.

729
00:38:11,866 --> 00:38:14,783
So we have ApplicationConfig.class,

730
00:38:16,719 --> 00:38:19,136
which will need to be imported,

731
00:38:19,136 --> 00:38:21,633
and then we could go ahead and create some

732
00:38:21,633 --> 00:38:23,216
other config files.

733
00:38:25,628 --> 00:38:28,583
For example, DataSourceTest.class.

734
00:38:28,583 --> 00:38:31,534
And this will work in exactly
the same way as the XML.

735
00:38:31,534 --> 00:38:36,191
These configs will be combined
together for this test.

736
00:38:36,191 --> 00:38:38,790
That would work, and feel
free to try that for yourself

737
00:38:38,790 --> 00:38:40,770
if you want to do that.

738
00:38:40,770 --> 00:38:42,655
It's a perfectly good way of doing things.

739
00:38:42,655 --> 00:38:46,071
It's the same as we did on
the Spring Fundamentals course

740
00:38:46,071 --> 00:38:48,744
but using classes instead of XML.

741
00:38:48,744 --> 00:38:50,347
But the problem is at the moment

742
00:38:50,347 --> 00:38:52,931
I have everything in this big monolithic

743
00:38:52,931 --> 00:38:56,581
ApplicationConfig file, and
it's going to take at least

744
00:38:56,581 --> 00:38:59,408
five minutes for me to
separate everything up

745
00:38:59,408 --> 00:39:01,749
into separate files.

746
00:39:01,749 --> 00:39:04,111
So that would be a bit boring,

747
00:39:04,111 --> 00:39:06,047
and it gives me a chance to
show you the alternative,

748
00:39:06,047 --> 00:39:09,218
which I think is really wonderful,

749
00:39:09,218 --> 00:39:13,135
and the alternative is
to use profiles instead.

750
00:39:14,697 --> 00:39:16,300
Let me explain how this works.

751
00:39:16,300 --> 00:39:19,126
So we're here in the ApplicationConfig,

752
00:39:19,126 --> 00:39:23,266
and here's where we've
declared the data source bean,

753
00:39:23,266 --> 00:39:26,437
and this is the bean
we want to be different

754
00:39:26,437 --> 00:39:28,684
if we're running in production

755
00:39:28,684 --> 00:39:31,723
as opposed to be running in testing.

756
00:39:31,723 --> 00:39:36,168
And this is where the
profile annotation comes in.

757
00:39:36,168 --> 00:39:39,819
We can say that this data source bean

758
00:39:39,819 --> 00:39:43,902
is only going to be active
if the profile called,

759
00:39:45,302 --> 00:39:48,246
and we can use any label we like here.

760
00:39:48,246 --> 00:39:49,901
These are arbitrary.

761
00:39:49,901 --> 00:39:53,152
They will be defined by your projects,

762
00:39:53,152 --> 00:39:54,765
but I'll go for the obvious one,

763
00:39:54,765 --> 00:39:57,432
which is going to be production.

764
00:39:58,813 --> 00:40:01,996
And we will need to import profile tag,

765
00:40:01,996 --> 00:40:03,388
but that means now we can go ahead

766
00:40:03,388 --> 00:40:07,257
and create a second
definition of this bean

767
00:40:07,257 --> 00:40:10,482
that we want to run in other environments.

768
00:40:10,482 --> 00:40:12,086
Now, for this definition of the bean,

769
00:40:12,086 --> 00:40:16,086
I'll need to go to the
datasource-test.xml file.

770
00:40:17,304 --> 00:40:21,053
Oh, and it turns out that from
the Java Fundamentals course

771
00:40:21,053 --> 00:40:23,581
the test configuration also contained

772
00:40:23,581 --> 00:40:25,517
the EntityManagerFactory

773
00:40:25,517 --> 00:40:27,877
with a slightly different setting.

774
00:40:27,877 --> 00:40:30,969
The showSQL was set to false.

775
00:40:30,969 --> 00:40:32,199
You can do that if you want.

776
00:40:32,199 --> 00:40:34,808
I'm not going to providing
an alternative profile

777
00:40:34,808 --> 00:40:36,578
for the EntityManagerFactory.

778
00:40:36,578 --> 00:40:39,923
It's very simple to do
if you want to do it.

779
00:40:39,923 --> 00:40:43,673
So I'll delete that,
but this definition here

780
00:40:44,589 --> 00:40:47,839
is the XML for our testing data source,

781
00:40:49,672 --> 00:40:51,370
so I've cut that out.

782
00:40:51,370 --> 00:40:55,537
And now I'm going to delete
the datasource-test.xml file,

783
00:40:56,754 --> 00:41:00,171
and I'm going to transfer that into here.

784
00:41:01,518 --> 00:41:04,510
So this is going to be
my bean definition that

785
00:41:04,510 --> 00:41:08,677
I only want to be active
when the profile is set to,

786
00:41:09,678 --> 00:41:13,375
again we can call this anything we want.

787
00:41:13,375 --> 00:41:15,458
Let's go for integration,

788
00:41:17,732 --> 00:41:19,649
and it's going to be...

789
00:41:24,842 --> 00:41:26,875
It's going to be very routine,
very similar, in fact,

790
00:41:26,875 --> 00:41:29,606
to the configuration that
we had in production.

791
00:41:29,606 --> 00:41:32,977
I was really doing this on
the Spring Fundamentals course

792
00:41:32,977 --> 00:41:35,090
to prove a point, to prove that

793
00:41:35,090 --> 00:41:37,324
you can very easily
change bean definitions

794
00:41:37,324 --> 00:41:41,444
at run time by changing XML files around.

795
00:41:41,444 --> 00:41:44,105
But really the difference
isn't that interesting.

796
00:41:44,105 --> 00:41:46,791
The difference is the URL's different

797
00:41:46,791 --> 00:41:49,691
The path here is only necessary

798
00:41:49,691 --> 00:41:52,281
when we're running on Tomcat.

799
00:41:52,281 --> 00:41:55,373
We've changed that to file:database.

800
00:41:55,373 --> 00:41:58,373
Then we have the string testing.dat,

801
00:41:59,391 --> 00:42:00,572
so it's not really exiting,

802
00:42:00,572 --> 00:42:02,483
but the point is we're pointing that

803
00:42:02,483 --> 00:42:05,092
at a completely different database.

804
00:42:05,092 --> 00:42:07,248
Now we have a problem, which
isn't a Spring problem.

805
00:42:07,248 --> 00:42:09,354
Now we're in a regular Java

806
00:42:09,354 --> 00:42:13,175
Of course, this is going
to become the bean ID

807
00:42:13,175 --> 00:42:16,730
in the container, and we
cant usually duplicate

808
00:42:16,730 --> 00:42:19,592
an ID in the Spring
container, but we can now

809
00:42:19,592 --> 00:42:22,416
because we're using the profile tag,

810
00:42:22,416 --> 00:42:25,766
so Spring will only read one
of these bean definitions

811
00:42:25,766 --> 00:42:27,766
when it starts up.

812
00:42:27,766 --> 00:42:30,310
But, of course, that's no good for Java.

813
00:42:30,310 --> 00:42:32,471
Because we're in a single Java class,

814
00:42:32,471 --> 00:42:35,489
the method names need to be unique.

815
00:42:35,489 --> 00:42:40,109
So the solution to this
problem would be to either

816
00:42:40,109 --> 00:42:43,692
put this configuration
in a different class

817
00:42:44,559 --> 00:42:48,267
as long the class is annotated
with that configuration,

818
00:42:48,267 --> 00:42:52,189
or, actually, we're never
referring to this ID

819
00:42:52,189 --> 00:42:56,356
anywhere in our code because
we're using the type here

820
00:42:57,697 --> 00:43:00,684
to do the dependency injection.

821
00:43:00,684 --> 00:43:03,620
So in this example, there's
absolutely no problem

822
00:43:03,620 --> 00:43:05,834
with renaming the ID of these beans

823
00:43:05,834 --> 00:43:07,751
to dataSourceProduction

824
00:43:10,240 --> 00:43:12,073
and dataSourceTesting,

825
00:43:13,356 --> 00:43:15,475
but don't forget we're
only doing that to make

826
00:43:15,475 --> 00:43:17,682
the Java compiler happy.

827
00:43:17,682 --> 00:43:21,051
If you wanted to, you could
have separated these out

828
00:43:21,051 --> 00:43:23,422
into two separate classes.

829
00:43:23,422 --> 00:43:26,035
Normally, having two
beans with the same ID

830
00:43:26,035 --> 00:43:27,672
would be a problem

831
00:43:27,672 --> 00:43:30,959
but not now because
we're using this profile.

832
00:43:30,959 --> 00:43:32,412
So that's all very well,

833
00:43:32,412 --> 00:43:35,513
but, of course, that means at run time

834
00:43:35,513 --> 00:43:39,329
we need some way of telling
Spring which of the two profiles

835
00:43:39,329 --> 00:43:40,951
we're working with.

836
00:43:40,951 --> 00:43:44,201
And the way we do that, at
the start of our application,

837
00:43:44,201 --> 00:43:47,151
we set an environment variable.

838
00:43:47,151 --> 00:43:49,822
Now, there lots of different
ways of doing that.

839
00:43:49,822 --> 00:43:51,977
With the Simple Client
Test, I suggest we just use

840
00:43:51,977 --> 00:43:56,569
the standard Java API for
setting environment variables.

841
00:43:56,569 --> 00:43:57,776
You probably know how to do this.

842
00:43:57,776 --> 00:44:00,193
It's just System.setProperty,

843
00:44:02,176 --> 00:44:05,388
and it's a key value pair, and the key,

844
00:44:05,388 --> 00:44:08,732
well, it is going to be a
string, but we don't need to

845
00:44:08,732 --> 00:44:12,180
remember what the name of this string is.

846
00:44:12,180 --> 00:44:13,572
If you pick up the

847
00:44:13,572 --> 00:44:15,655
AbstractEnvironment class

848
00:44:17,772 --> 00:44:20,660
from the Spring Framework,

849
00:44:20,660 --> 00:44:23,277
there is property in there called

850
00:44:23,277 --> 00:44:25,777
Active Profiles Property Name.

851
00:44:27,502 --> 00:44:30,986
And if I hover over that and
get the Javadocs up for it,

852
00:44:30,986 --> 00:44:35,153
that resolves to the string,
spring.profiles.active.

853
00:44:36,052 --> 00:44:37,829
So you can use that string if you prefer.

854
00:44:37,829 --> 00:44:39,438
They're certainly never going to change

855
00:44:39,438 --> 00:44:41,474
the value of that string,

856
00:44:41,474 --> 00:44:44,714
so you're quite safe to
use that it's a hard code.

857
00:44:44,714 --> 00:44:46,429
And then the value,

858
00:44:46,429 --> 00:44:48,653
well, here you're going to
say whether it's production

859
00:44:48,653 --> 00:44:51,104
or integration or any other profile

860
00:44:51,104 --> 00:44:53,310
that you might invent later.

861
00:44:53,310 --> 00:44:56,212
So the idea is for this client test,

862
00:44:56,212 --> 00:45:00,045
we're going to use the
production environment.

863
00:45:01,136 --> 00:45:03,553
And now, if we run this code,

864
00:45:06,027 --> 00:45:08,505
everything's working exactly as before.

865
00:45:08,505 --> 00:45:10,582
And just to really test that
that did make a difference,

866
00:45:10,582 --> 00:45:13,837
if I comment out the
setting of that property,

867
00:45:13,837 --> 00:45:15,503
well, it's not going to know now

868
00:45:15,503 --> 00:45:18,502
which of the data sources to use.

869
00:45:18,502 --> 00:45:21,324
So we're going to get a nice exception,

870
00:45:21,324 --> 00:45:23,698
and it's actually saying
there's no qualifying bean

871
00:45:23,698 --> 00:45:26,024
of type DataSource,

872
00:45:26,024 --> 00:45:28,060
and that's because it's going to ignore

873
00:45:28,060 --> 00:45:29,435
our two beans definitions

874
00:45:29,435 --> 00:45:31,840
because the profile doesn't match

875
00:45:31,840 --> 00:45:34,107
what we've currently set.

876
00:45:34,107 --> 00:45:37,384
So let's get that line of
code of line back in place,

877
00:45:37,384 --> 00:45:40,214
and where that leaves us
now is that if we go to

878
00:45:40,214 --> 00:45:42,398
our integration test now,

879
00:45:42,398 --> 00:45:44,088
all we need is a way of saying that, yeah,

880
00:45:44,088 --> 00:45:46,829
we want to use the
ApplicationConfig class,

881
00:45:46,829 --> 00:45:49,851
but we want to use the testing profile

882
00:45:49,851 --> 00:45:52,165
or the integration profile.

883
00:45:52,165 --> 00:45:53,900
Well, you could in the constructor

884
00:45:53,900 --> 00:45:56,690
of this integration test class.

885
00:45:56,690 --> 00:45:59,480
Set the environment
property like we just did.

886
00:45:59,480 --> 00:46:01,713
There's a much neater way of doing that.

887
00:46:01,713 --> 00:46:04,172
There's an annotation,

888
00:46:04,172 --> 00:46:06,875
the last annotation from
this chapter, I think.

889
00:46:06,875 --> 00:46:11,004
The annotation is called ActiveProfiles.

890
00:46:11,004 --> 00:46:14,600
And so in here, we can
specify that we want to run

891
00:46:14,600 --> 00:46:16,683
with an integration test.

892
00:46:17,649 --> 00:46:20,312
So just to prove that that's
working, I'm going to,

893
00:46:20,312 --> 00:46:23,480
before I try it I will comment it out,

894
00:46:23,480 --> 00:46:26,572
and we'll run that as a JUnit Test.

895
00:46:26,572 --> 00:46:30,191
We should get a red bar here, and we do,

896
00:46:30,191 --> 00:46:33,398
and the red bar will be very similar.

897
00:46:33,398 --> 00:46:36,784
It will be saying it can't
find a qualifying bean

898
00:46:36,784 --> 00:46:38,446
for the data source,

899
00:46:38,446 --> 00:46:41,363
but if I now take that comment out,

900
00:46:42,369 --> 00:46:44,078
so Spring will now know the profile

901
00:46:44,078 --> 00:46:46,161
that we're running under.

902
00:46:47,031 --> 00:46:50,713
Rerun the test, and that's fantastic.

903
00:46:50,713 --> 00:46:53,761
We are back to a green bar.

904
00:46:53,761 --> 00:46:56,353
So these profiles are a
really wonderful feature.

905
00:46:56,353 --> 00:47:00,191
It gives you a way of creating
very dynamic environments

906
00:47:00,191 --> 00:47:02,774
where you have multiple wirings

907
00:47:03,712 --> 00:47:05,748
for different environments,

908
00:47:05,748 --> 00:47:08,771
and you can change the way
your application is running

909
00:47:08,771 --> 00:47:10,229
based on these profiles

910
00:47:10,229 --> 00:47:13,441
rather than having to
change the XML files,

911
00:47:13,441 --> 00:47:16,440
which is what we would
have traditionally done.

912
00:47:16,440 --> 00:47:18,329
So that's it for the business tier.

913
00:47:18,329 --> 00:47:21,563
We now need to look at how
to configure the web tier

914
00:47:21,563 --> 00:47:23,741
and optionally, if you're interested,

915
00:47:23,741 --> 00:47:25,908
how to configure security.

